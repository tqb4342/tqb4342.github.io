[{"title":"科学上网（翻墙）软件之---VPN篇","url":"https://tanqingbo.cn/科学上网之VPN篇/","content":"前言　　科学上网，又叫翻墙。说到这，问题就来了，既然要翻墙，那么什么是墙呢？great firewall, 就是对网络进行封锁。想要看看墙外面的世界，就得翻墙。　　之前我有提到过用hosts翻墙，但是不太稳定，经常得更换源，还上不了youtubu，所以干脆就放弃了。我比较提倡用钱能解决的问题，尽量还是花些钱吧。方便、稳定、一劳永逸。所以今天给大家介绍花钱的翻墙办法。\n一枝红杏\n先摆一下一枝红杏的介绍：一支红杏网络加速器是銘佑科技（香港）有限公司，（也是老薛主机，不会跑路型）推出的网络加速器服务，基于 Trojan 协议的科学上网方式，该协议会将您需要代理的网络数据伪装成 HTTPS 协议的正常网络数据，以通过防火墙的检测和封锁。连接速度快，它会帮助你在互联网上冲浪时保护你的隐私和安全。\n支持 Windows、MAC OS X、cross platform、Android、IOS、openwrt等系统，是非常实用的网络代理软件。\n我买的就是一枝红杏的VPN，亲测真的很好用，网速很快，Google、youtubu、Facebook啥的都能上。下面就教大家怎么用起来。\n打开一枝红杏官网。\n官网：https://order.yizhihongxing.club/aff.php?aff=4818\n翻到下面会有两种VPN的购买方式，如果是个人用的话，选择入门版就可以了，一个月100G足够用了。\n跳转到订购页面后可以先在右上角点击注册，注册一个新账号，然后再根据提示购买你的产品。\n购买之后依次点击上方导航栏中的 服务-&gt;产品/服务，就能看到你购买的节点信息。\n\n\n\n\n\n好了，别着急。接下来需要下载一个软件Trojan来辅助科学上网。\n\nTrojan或者Clash先放一个下载链接: https://order.yizhihongxing.club/index.php?rp=/knowledgebase/13/\n下载安装好之后登入后前往  产品/服务 ，点击有效的服务，打开产品详情页面，向下滑动。\n点击 Clash 配置右侧的获得地址，在弹出的窗口中，选择 复制地址 或是 下载配置。\n\n如果点击获得地址没有反应，请更换使用 Chrome 、Firefox 或是 EDGE 浏览器访问客户中心。\n注1. 订阅链接与你的密码一样重要，请不要分享给他人，如不慎泄露，请在产品详情页面重置链接并提交工单申请重置服务密码。\n注2. 如果使用链接添加时报错，可以点击 下载配置 ，手动添加 \n4. 添加配置打开客户端后，使用上一步的订阅链接添加配置：\n\n首先点击左侧 订阅(Profiles) ，粘贴订阅链接后点击 导入\n添加成功后点击左侧 代理(Proxies) 选择节点使用 \n\n\n5. 客户端使用介绍正常在添加配置后，前往设置，开启 系统代理 后即可正常使用\n\n客户端模式（在 代理 (Proxies) 界面右上角切换）介绍：\n规则模式：自动区分是否代理大陆网站的流量，日常情况推荐使用这个模式\n全局模式：所有转发给客户端的流量都会经过代理，切换到全局模式后请选择节点，不需要选择 DIRECT \n直连模式：不使用代理\n最后再放一个一枝红杏的官网：https://order.yizhihongxing.club/aff.php?aff=4818\n我觉得还是蛮好用的\n","categories":["科学上网"],"tags":[]},{"title":"2025主流科学上网工具推荐-支持Windows/Android/macOS/iOS/Linux","url":"https://tanqingbo.cn/2026-best-vpn/","content":"以下是2026年主流科学上网工具推荐，均附带对应官方下载或权威下载链接，并特别推荐支持多协议且性能优异的一支红杏。\n\nWindows平台\nClash for Windows\n支持V2Ray、Trojan、Shadowsocks等多协议，分流规则强大，界面友好，适合新手和进阶用户。\n\nV2rayN\n基于Xray和v2fly内核，支持多种代理协议，配置灵活，适合技术用户。\n\nNekoray\n支持绝大多数代理协议，支持链式代理，适合高级用户。\n\nClashN\n基于Clash Meta内核，支持多协议，界面简洁易用。\n\n\n\nmacOS平台\nClashX\nmacOS上最流行的Clash客户端，支持多协议，分流强大，界面简洁。\n\nV2rayU\n支持V2Ray和Shadowsocks协议，高度可定制。\n\nSurge（付费）\n功能强大，适合开发者和专业用户，支持多协议和复杂规则。\n\n\n\nLinux平台\nClash\n命令行工具，支持多协议，适合服务器和高级用户。\n\nSing-box\n多协议支持，灵活配置，适合技术用户。\n\n\n\nAndroid平台\nClash for Android\n支持多协议，分流规则强大，界面友好。\n\nV2rayNG\n支持V2Ray订阅和二维码导入，轻量易用。\n\nNekobox\n支持多协议和链式代理，用户体验良好。\n\n\n\niOS平台\nSpectre（免费）\n支持多协议，功能强大，适合大多数iOS用户。\n\nShadowrocket（付费）\n支持多协议，规则管理强，适合高级用户。\n\nSurge（付费）\n功能强大，适合专业用户。\n\n\n\n推荐科学上网工具：一支红杏\n一支红杏\n支持Windows、macOS、Linux、Android、iOS全平台，采用先进的Hysteria协议，具备极强的抗封锁能力和高速稳定的连接体验。适合所有用户群体，是当前中国网络环境下高性价比的科学上网解决方案。\n\n\n\n选择科学上网工具建议\n根据设备平台选择对应客户端\n优先选择支持多协议（V2Ray、Trojan、Shadowsocks等）的工具\n关注工具的分流规则和易用性\n推荐付费服务保障稳定和安全，一支红杏为优选之一\n\n\n注册教程iOS/MAC 端注册教程：iphone如何用外网/苹果手机搭梯子-翻墙VPN软件工具 | IT码农\nWindows 端这里推荐 clash for Windows\n注册教程：Windows 翻墙教程：从零开始科学上网（最稳定的科学上网方案） | IT码农\nAndroid 端注册教程：安卓/Android系统手机实现科学上网教程-翻墙VPN软件工具 | IT码农\n\n以上工具均为当前主流且活跃维护的科学上网客户端，点击对应链接即可获取最新版本，助你畅游全球互联网。\n","categories":["科学上网"],"tags":[]},{"title":"从小白到高手，你需要理解同步与异步（ Vert.x 与 Java 对比）","url":"https://tanqingbo.cn/Vertx-Java/","content":"一、异步与同步核心定义（生活化类比）先通过「餐厅点餐」这个场景理解核心区别，这是新手最易接受的方式：\n\n\n\n模式\n核心特征（生活例子）\n编程中的对应逻辑\n\n\n\n同步（同步）\n点餐后站在柜台等餐，直到拿到餐才能做其他事（期间啥也干不了）\n代码按顺序执行，前一个任务没完成，后一个任务阻塞等待，线程被占用直到任务结束\n\n\n异步（异步）\n点餐后拿取餐号，去旁边玩手机/聊天（做其他事），餐好了服务员喊号再取\n发起任务后，代码继续执行后续逻辑，任务在后台完成，完成后通过「回调/通知」处理结果，线程不阻塞\n\n\n二、编程场景举例（HTTP 服务器对比） Vert.x 异步代码对比传统同步 HTTP 服务器，能最直观看到差异：\n场景：实现一个监听 8888 端口的 HTTP 服务器，处理 ?name=xxx 请求并返回响应\n示例 1：同步代码（传统 Java ServerSocket）同步模式下，服务器一次只能处理一个请求，第二个请求必须等第一个处理完才能被响应（阻塞）：\nimport java.io.BufferedWriter;import java.io.IOException;import java.io.OutputStreamWriter;import java.net.ServerSocket;import java.net.Socket;import java.util.Scanner;public class SyncHttpServer {    public static void main(String[] args) throws IOException {        // 启动同步服务器，监听8888端口        ServerSocket server = new ServerSocket(8888);        System.out.println(\"同步HTTP服务器启动在端口：8888\");        // 死循环等待请求（同步阻塞）        while (true) {            // 核心阻塞点1：accept() 会阻塞，直到有客户端连接            Socket socket = server.accept();            System.out.println(\"新客户端连接：\" + socket.getRemoteSocketAddress());            // 处理这个请求（全程阻塞，直到响应发送完成）            handleRequest(socket);        }    }    // 同步处理请求（一个请求处理完，才能处理下一个）    private static void handleRequest(Socket socket) throws IOException {        // 核心阻塞点2：读取请求数据，阻塞直到读完        Scanner scanner = new Scanner(socket.getInputStream());        String requestLine = scanner.nextLine(); // 读取请求行（如 GET /?name=Francesco HTTP/1.1）                // 解析name参数        String name = \"unknown\";        if (requestLine.contains(\"name=\")) {            String[] parts = requestLine.split(\"name=\");            name = parts[1].split(\" \")[0]; // 截取name的值        }        // 模拟「耗时操作」（比如数据库查询）—— 同步模式下，整个服务器会卡住        try {            Thread.sleep(3000); // 阻塞3秒，期间服务器无法处理任何新请求        } catch (InterruptedException e) {            e.printStackTrace();        }        // 核心阻塞点3：发送响应，阻塞直到发送完成        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));        writer.write(\"HTTP/1.1 200 OK\\r\\n\");        writer.write(\"Content-Type: application/json\\r\\n\\r\\n\");        writer.write(\"{\\\"name\\\":\\\"\" + name + \"\\\",\\\"message\\\":\\\"Hello \" + name + \"\\\"}\");        writer.flush();        writer.close();        socket.close(); // 关闭连接        System.out.println(\"请求处理完成，释放连接\");    }}\n\n同步代码的问题：\n\n你打开 2 个浏览器标签页访问 http://localhost:8888?name=A 和 http://localhost:8888?name=B，第二个请求会等待3秒（第一个请求的sleep时间） 才开始处理；\n\n线程全程被占用，一个线程只能处理一个请求，高并发下会瞬间耗尽服务器线程资源。\n\n\n\n示例 2：异步代码（你之前写的 Vert.x 版本）异步模式下，服务器无需等待请求处理完成，一个线程就能处理成百上千个请求（非阻塞）：\nimport io.vertx.core.Future;import io.vertx.core.Vertx;import io.vertx.core.json.JsonObject;import io.vertx.ext.web.Router;import io.vertx.ext.web.RoutingContext;public class AsyncHttpServer {    private final Vertx vertx = Vertx.vertx();    public Future&lt;?&gt; start() {        Router router = Router.router(vertx);        // 异步处理所有请求（非阻塞）        router.route().handler(this::handleRequestAsync);        // 异步启动服务器，监听8888端口        return vertx.createHttpServer()                .requestHandler(router)                .listen(8888)                .onSuccess(server -&gt; System.out.println(\"异步HTTP服务器启动在端口：\" + server.actualPort()))                .onFailure(throwable -&gt; throwable.printStackTrace());    }    // 异步处理请求（无阻塞）    private void handleRequestAsync(RoutingContext context) {        // 获取name参数（非阻塞操作）        String name = context.queryParams().getOrDefault(\"name\", \"unknown\");        String address = context.request().connection().remoteAddress().toString();        // 模拟「耗时操作」（比如数据库查询）—— 异步执行，不阻塞事件循环        vertx.setTimer(3000, id -&gt; { // 3秒后执行回调，期间线程可处理其他请求            // 异步返回响应            context.json(new JsonObject()                    .put(\"name\", name)                    .put(\"address\", address)                    .put(\"message\", \"Hello \" + name + \" connected from \" + address));        });    }    public static void main(String[] args) {        new AsyncHttpServer().start();    }}\n\n异步代码的优势：\n\n你打开 10 个浏览器标签页访问 http://localhost:8888?name=xxx，所有请求会同时被接收，3 秒后同时返回响应；\n\n处理耗时操作（vertx.setTimer 模拟）时，线程不会被阻塞，而是去处理其他请求，直到耗时操作完成后，通过「回调（timer的lambda）」返回响应。\n\n\n三、同步 vs 异步 核心区别总结\n\n\n维度\n同步（Sync）\n异步（Async）\n\n\n\n执行顺序\n代码按「从上到下」顺序执行，前一个任务没完成，后一个不执行\n发起任务后，代码继续执行后续逻辑，任务后台运行，完成后回调处理\n\n\n线程状态\n任务执行期间，线程阻塞等待（闲置但占用资源）\n任务执行期间，线程非阻塞（可处理其他任务，资源利用率高）\n\n\n资源消耗\n高（一个请求占用一个线程，高并发下线程耗尽）\n低（少量线程处理大量请求，如 Vert.x 用 4-8 个线程就能支撑万级并发）\n\n\n编程复杂度\n低（逻辑线性，易理解）\n稍高（需处理回调/异步结果，Vert.x 已封装得很友好）\n\n\n适用场景\n简单场景、低并发、耗时短的操作（如本地文件读取、简单计算）\n高并发、耗时操作（如 HTTP 服务器、数据库查询、网络请求）\n\n\n总结\n核心差异：同步是「阻塞等待」，异步是「非阻塞+回调通知」，核心是线程是否被闲置占用；\n\n资源利用：异步用少量线程处理大量任务，适合高并发（如你的 Vert.x 服务器）；同步逻辑简单，但高并发下性能差；\n\n实战选择：简单工具/低并发场景用同步（易开发），后端接口/高并发服务用异步（如 Vert.x、Netty、Spring WebFlux）。\n\n\n","categories":["Java"],"tags":["Vertx"]},{"title":"2025年终总结","url":"https://tanqingbo.cn/2025年终总结/","content":"时间过得真快，又一年过去了。\n2025，三十而立，心态更加稳定了。\n体重也很稳定，主要得益于运动习惯没有丢掉，有时候下班之后会纠结 是出去打球还是躺家里休息，多数情况下还是选择了去打球，运动习惯养成不易，丢掉却很容易，要坚持。\n今年对我帮助最大的一句话是：多做自己擅长的事情，少做或者不做自己不擅长的事情。\n在大环境不好的情况下，做的多可能错的也就越多，基于此我重新梳理了一下自己的情况：\n在资金管理方面，10月份清空了自己几乎所有的股票和基金，最近几年账户一直都是亏损状态，承认自己不擅长，接受亏损。\n全面拥抱确定性更高的港股打新和二级市场套利，这些在之前都是实实在在取得过好结果的，在转变投资方向之后，虽然也有过不少拍断大腿的时刻，但也真真切切给我带来了不少收益。\n副业方面，我擅长什么？\n公众号、知乎以及个人网站的运营，前面很多年的收入来源都是靠公众号和知乎，但随着短视频时代的到来，知乎几乎停摆，公众号收入也大幅下降，\n但此前一直被忽视的个人网站却意外焕发第二春，正好网站运营也是我擅长的领域，于是重新认真给网站做SEO以及增加内容的垂直度，现在网站的回报已经是以上三者中最高的了。\n公众号也还在定期更新，主要是为了保持更新的惯性，因为一旦停止更新就很难再启动起来了，知乎就随缘了！\n多做自己擅长的事情，少多或者不做自己不擅长的事情，再知行合一，真的让我受益良多。\n再聊一下2025年看过的书以及去过的地方\n2025年读过的书：\n1、《大唐气象》三部曲，最近几年看的最多的就是历史书，三部曲从隋末天下大乱到安史之乱结束，开篇以物质的惯性揭示历史发展的规律我很喜欢。\n2、《我们生活在巨大的差距里》余华老师的杂文集，“这个世界上有一种人，毛病数不清，可是他给人们带来了快乐，这个世界上还有一种人，没有什么毛病，可是从来未给人们带来快乐，我觉得和没什么毛病的人交往是一件可怕的事情。”、“少数中国人赚钱太容易，不知道钱是怎么赚来的，多数中国人赚钱太难，不知道怎么可以赚到钱。”\n3、《太白金星有点烦》，马伯庸老师的书，原本以为这本书只是以太白金星的视角重新解读了西游的九九八十一难，没想到越读到后面后劲越大，心疼被偷命的六耳，也心疼替罪的悟空，混到中层的太白金星和观音表面上是取经的导演和顾问，其实妥妥是牛马工具人！这本书看似讲天界，实则演人间！\n4、《一句顶一万句》刘震云老师的书，看到一半还没看完，看似是讲延津县的故事，其实是在讲我们身边的故事。\n5、《反本能》，公司要求看的书，里面对我们一些行为习惯的剖析，以及方式方法确实很受用。\n6、《遮天》三部曲，打发时间看的。。。\n7、《主角模式》，樊登老师的书，正在看。。\n2025年去过的地方：\n3月份的时候去了趟大理，其实在我本科毕业那年就去过一次大理，当时我就想着这个地方我以后肯定还会再来，今年去的时候依然还是这个感觉：我还要再来，苍山洱海，太美了！\n此外还去了趟泰国的曼谷和芭提雅，猎奇的话可以去看一下芭提雅的成人秀，如果是想去泰国看海的话不建议去芭提雅，可以去普吉岛，位置在太平洋的中间，水质要好很多，曼谷有点像中国的三四线城市，没啥好玩的。\n2026年，有时间的话还想再去趟东南亚，此外还想去趟哈尔滨，在哈尔滨待了这么多年，想回去看看了。\n感情方面也要做一个总结\n和我的队友在一起快三年了，从最开始矛盾不断，到现在矛盾的次数越来越少，一起搭档的日子越来越开心，但仍需要检讨，有时候说话表达方式不对，有时候也会忽视队友的情绪，这些都是需要改进的地方，希望2026年能改掉这些坏的毛病，同时花更多的时间来陪我的队友，一起去见识世界的美好。\n2025年大体如此，\n2026年，继续保持心态和体重的稳定，不要心存执念，多做擅长的事，少做不擅长的事，就这样吧！\n","categories":["技术以外"],"tags":[]},{"title":"2026 保姆级科学上网/魔法上网教程：Clash机场 / VPN / 自建 VPS 全面解析","url":"https://tanqingbo.cn/VPN2026/","content":"引言：什么是“科学上网”？“科学上网”是中文互联网社区对通过技术手段访问被限制或屏蔽的国外互联网内容的通俗称谓，也被称为“翻墙”。这一术语并不意味着从事违法活动，而是强调以技术方式突破网络封锁，实现对信息的自由访问。\n在全球信息高度互联的时代，科学上网不仅关乎网络自由，也关乎学术、工作与生活的全面发展。本文将以科普角度，系统介绍中国用户为什么需要科学上网、突破网络封锁之后能做什么，以及三种主流方式（自建 VPS、Clash 机场、VPN）的区别与选择建议。\n\n为什么在中国需要科学上网？1. 互联网信息访问限制现状在中国，互联网实行严格的网络审查制度，许多国际主流网站和服务在境内无法直接访问。这种限制不仅影响用户获取全球信息的能力，也在一定程度上阻碍了技术学习、跨境交流和商业拓展。\n以下是常见受限平台的分类列表：\n\n搜索引擎：Google、Bing、DuckDuckGo、Yahoo、Startpage\n\n视频平台：YouTube、Twitch、Vimeo、Dailymotion\n\n社交媒体：Twitter、Facebook、Instagram、Reddit、LinkedIn\n\n学术资源：Wikipedia、Google Scholar、Archive.org、JSTOR、ResearchGate\n\nAI 工具：ChatGPT、Gemini（原 Bard）、Copilot、Claude、Perplexity AI\n\n流媒体服务：Netflix、Disney+、Max（HBO Max）、Amazon Prime Video、Hulu\n\n\n\n⚠️ 这些平台涵盖了学习、工作、研究、娱乐等多个领域，对于现代数字生活极为重要。\n\n因此，越来越多用户会选择使用科学上网工具（如 VPN、代理或机场服务）来突破限制，恢复自由、开放的互联网访问环境。\n\n2. 获取多维度的信息来源在信息碎片化与同质化严重的背景下，获取来自不同国家、不同文化背景的信息显得尤为重要，不同信息来源有助于用户对事物有更客观的判断。科学上网可以帮助用户：\n\n了解不同政治、经济、科技、文化观点\n验证事件真相，打破信息孤岛\n查阅国际研究、科学论文与数据库\n提高外语阅读与批判性思维能力\n\n特别是对于学术研究者、媒体从业者和科技开发人员，多维信息的输入几乎是必需的。\n\n3. 社交与工作需求在全球化背景下，与国外的亲友、客户或合作方保持联系已成为常态。科学上网可以帮助用户：\n\n使用 WhatsApp、Telegram、Signal 等通讯工具保持跨境沟通\n登录 Gmail、Zoom、Slack 等远程办公平台\n访问 GitHub、Notion、Trello 等团队协作服务\n管理海外业务后台，如 Amazon、Shopify、PayPal 等\n\n对于从事跨境电商、远程编程、内容创作、自媒体和数字游民群体而言，稳定可控的“出海”通道至关重要。\n\n科学上网之后可以做什么？4. 访问全球互联网服务一旦成功突破网络封锁，用户便可无障碍访问全球互联网中的各种服务与平台，包括但不限于：\n\n通信与办公：Gmail、Outlook、Slack、Zoom、Google Docs、Dropbox\nAI 工具：ChatGPT、Gemini（原 Bard）、Claude、Midjourney、Notion AI\n云服务与开发平台：GitHub、AWS、Google Cloud、Heroku\n学术研究：Google Scholar、arXiv、JSTOR、SpringerLink\n媒体与资讯：BBC、纽约时报、华盛顿邮报、The Verge、NPR\n支付平台：PayPal、Stripe、Wise（TransferWise）\n\n这些平台构建了全球知识流动和科技发展的主干线，对从业者与学习者而言意义重大。\n\n5. 自主选择信息渠道科学上网的核心价值之一在于用户可以“自主选择”所接收的信息源，而不是被动接受过滤后的内容。通过科学上网，用户可以：\n\n跟踪全球多个视角下的新闻与时政分析\n订阅自己信赖的海外播客、YouTube 频道或博客\n参与 Reddit、Quora 等全球社区的讨论\n使用 RSS 服务自主聚合资讯\n\n这种信息“自由组合”的能力，是现代公民素养的重要体现，也是构建知识体系的基础之一。\n\n6. 技术学习与成长对于程序员、设计师、研究者、创作者和学生来说，科学上网能极大拓宽学习资源：\n\n开发平台：访问 Stack Overflow、GitHub、CodePen、Hacker News\n在线课程：Coursera、edX、Udemy、Khan Academy、freeCodeCamp\n开源工具与文档：Node.js、Python、React、TensorFlow 等\nAI 与前沿技术动态：订阅 MIT Technology Review、TechCrunch、IEEE Spectrum\n\n这些资源的获取，为技术成长提供了重要土壤。\n7. 娱乐对于游戏玩家和视频爱好者，科学上网可以帮助他们：\n\n访问海外原版高清电影、游戏、音乐等\n观看海外电影、电视节目、播客\n参与全球在线社区，分享想法和经验\n\n\n快速开始（3分钟）如果你只想尽快“能用起来”，按下面流程做就够了（细节看文末延伸阅读）。\n\n明确你的主要用途：AI（ChatGPT/Claude）、学术资料、远程办公、流媒体、游戏。用途会决定你更需要“地区/IP/线路/延迟/稳定性”里的哪一项。\n新手首选 Clash（规则分流）+ 机场订阅：一个客户端 + 一条订阅链接，通常比自建 VPS 更省心。\n直接看入口与折扣：#快速注册入口\n\n\n按图文教程完成配置：导入订阅 → 选 Rule 模式 → 开启系统代理或 TUN → 测速选节点 → 访问测试网站。\n图文教程（含各平台客户端）：Clash 机场使用图文教程：订阅导入到测速\n\n\n选购前先把关键概念搞懂（能少踩一半坑）：\n如何挑选优质机场（避坑指南）\nVmess/Vless/Trojan/Reality/Hysteria 等协议科普\nClash 机场常用名称解释（名词科普大全）\n\n\n做好备份与冗余：保存订阅链接（不要外泄）、准备至少 2 个可用地区/线路，出问题先按“排障清单”排查。\n\n\n科学上网的主要方式对比下面按“新手优先 → 进阶 → 折腾党”的思路介绍，便于你快速做选择。\n方式一：自建 VPS（适合技术用户/备援/学习）VPS（Virtual Private Server） 即虚拟专用服务器。通过部署代理程序（如 V2Ray、Xray、Shadowsocks 等）并结合 TLS、WebSocket 等方式，可实现自主科学上网方案。\n\n推荐配置：Linux + Nginx + TLS + V2Ray/Xray\n适用平台：DigitalOcean、Vultr、Oracle Cloud、HostHatch、Linode 等\n\n✅ 优点\n完全可控：节点配置、加密方式、协议选择自由度高\n安全性强：结合 TLS+WebSocket 可高度伪装流量，减少被识别概率\n长期成本低：按月计费，一台服务器可多人使用或自搭多节点\n适合技术型用户：具备一定动手能力者可持续优化性能和稳定性\n\n❌ 缺点与风险（2026 年更新）\n可用性不稳定：网络环境与服务商风控变化会影响可用性，可能出现需要换 IP 或重建实例的情况\nIP 质量不可控：部分云厂商分配到的 IP 可能存在可用性问题，部署后仍可能无法正常使用\n配置门槛高：需要掌握 Linux、证书、域名、端口与防火墙等基础运维\n维护负担重：更新、监控、备份、安全加固都需要自己负责\n\n\n💸 IP 被封后如何处理？是否要花钱？是的，IP 被封后更换 IP 或实例通常会产生额外费用，以下是常见平台的对比：\n\n\n\n平台\n更换 IP 成本\n说明\n\n\n\nDigitalOcean\n✅ 需删除实例重建\n不支持单独换 IP，重建浪费配额\n\n\nVultr\n✅ 工单更换或重建\n新建实例分配新 IP 但可能仍被封\n\n\nOracle Cloud\n❌ 免费但不支持换 IP\n免费额度资源易被回收，风控强\n\n\nHostHatch / RackNerd\n✅/❌ 有时不给换\n多为年付套餐，被封 IP 无法恢复\n\n\n\n🔁 更换 IP = 额外支出 + 运维复杂 + 时间浪费尤其是做多地区部署时，每换一个节点，成本都要叠加。\n\n\n✅ 建议策略（面向 2026）\n✅ 优先月付/按量测试，确认可用后再长期投入\n✅ 优先选择支持更换 IP / 重装实例 / 工单响应快的服务商\n✅ 把自建当“备援/学习”而不是唯一通道，日常优先用机场省心\n✅ 做好最基本的安全：更新系统、限制管理端口、开启防火墙与日志审计\n\n\n方式二：Clash（规则分流）+ 机场订阅（最推荐新手）Clash（规则分流客户端） 是基于规则引擎的跨平台代理客户端（不同客户端可能内置不同 Clash 系内核/维护分支）。配合订阅型“机场”节点服务，可以做到：一键导入、多端通用、规则分流、自动更新。\n购买机场服务地址：https://order.yizhihongxing.club/aff.php?aff=4818\n\n操作流程：购买服务→ 获取订阅链接 → 导入客户端 → 选择策略组/节点 → 开启系统代理 → 测速与日常使用\n客户端选择：不同平台推荐见图文教程（含下载地址与配置截图），#图文教程\n\n优点：\n\n使用便捷，适合小白用户\n自动更新节点，支持规则分流\n支持多端（Windows、Mac、iOS、Android、Apple TV）\n\n缺点：\n\n依赖第三方服务：服务商质量参差，需要花时间做功课与试用\n节点体验波动：晚高峰拥堵、地区/线路质量差异会影响速度与稳定性\n订阅链接是“账号密钥”：一旦泄露可能被他人盗用流量或滥用你的账号\n\n\n🔝 快速注册入口（图文教程）点击下方表格中的链接即可查看详细的图文教程：\n\n\n\n平台\n推荐客户端\n主要特点\n\n\n\nWindows\nClash for Windows\n功能丰富，订阅管理优秀\n\n\nmacOS\nSpectre\n适配良好，支持 Clash 订阅\n\n\nAndroid\nClash for Android\n功能强大，支持多个订阅\n\n\niOS\nSpectre\n免费安装，支持多协议\n\n\n\n方式三：商业 VPN（适合海外/出差/公共 Wi‑Fi 隐私保护）商业 VPN 通常是合规注册的国际服务商提供的加密连接服务，常用于隐私保护、跨区访问与公共 Wi‑Fi 安全。\n\n主流品牌：ExpressVPN、NordVPN、Surfshark、ProtonVPN、PureVPN\n支持平台：Windows、macOS、Android、iOS、Linux、浏览器插件\n\n优点：\n\n界面友好，开箱即用\n覆盖全球多个服务器节点\n适合流媒体、浏览、隐私保护\n多数产品提供退款保障或试用期（以官网条款为准）\n\n缺点：\n\n在中国大陆的可用性会随地区与时间变化，购买前需确认是否支持退款/试用\n优质服务一般需订阅付费\n无法定制底层配置，灵活度低于 VPS\n对“规则分流/策略组/精细化控制”的支持通常不如 Clash 类客户端\n\n\n三种方式的对比与选择建议一张表快速看懂\n\n\n方案\n上手难度\n费用结构\n国内环境稳定性（经验）\n可控性\n典型场景\n\n\n\nClash（规则分流）+ 机场订阅\n低\n月付/年付\n中-高（看机场与线路）\n中\nAI/办公/资料/流媒体\n\n\n商业 VPN\n低（境外）/中（境内）\n月付/年付\n不稳定（需试用验证）\n低-中\n出差/公共 Wi‑Fi/隐私\n\n\n自建 VPS\n高\n服务器+域名等\n不稳定（需维护）\n高\n技术学习/备援/可控链路\n\n\n速查：按需求怎么选\nAI（ChatGPT/Claude）与远程办公：优先“稳定性 + 可用地区”的机场，准备备用节点/线路\n流媒体（YouTube/Netflix/Disney+）：优先有专线/优化线路且明确维护解锁的机场\n公共 Wi‑Fi 隐私保护（酒店/咖啡店/机场）：商业 VPN 或可信的自建方案更合适\n技术学习/备援：自建 VPS 可以学到完整链路，但建议和机场搭配使用，别把自建当唯一通道\n\n\n安全与隐私（必读）\n把订阅链接当“密码”：不要公开、不要截图发群、不要交给第三方代导入\n不使用来路不明的“免费 VPN/破解版客户端/共享订阅”，隐私与账号风险极高\n避免使用不可信的“在线订阅转换/订阅解析”网站，必要时在本地工具内完成\n尽量开启 Rule 分流，避免把所有国内流量都走代理；需要全局再临时切 Global\n在公共网络环境下，优先使用带 Kill Switch 的方案，避免断连后流量直连泄露\n\n\n法律与合规风险提示（重要）13. 中国境内科学上网的法律风险说明在中国大陆，未经许可擅自建立或使用 VPN、代理服务连接国际互联网，可能违反相关法规。\n依据《中华人民共和国计算机信息网络国际联网管理暂行规定》第六条、第十四条的规定，以下行为存在法律风险：\n\n提供未经许可的 VPN 服务；\n建立代理节点用于商业化用途；\n散布非法信息、参与政治活动、攻击国内网站等违法行为。\n\n⚠️ 合规提醒：不同地区的法规、政策与执法口径可能随时间变化。本文仅做信息整理与技术科普，不构成法律建议；请自行了解并遵守所在地法律法规。\n\n14. 如何降低使用风险为最大限度保障安全与合规，建议用户：\n\n不传播违法内容，不参与违法活动；\n不搭建/转售未经许可的代理服务，不进行商业化兜售；\n仅将相关工具用于学习、科研、跨境办公等合规用途；\n认真阅读服务条款、隐私政策与退款/试用规则，避免误买误用；\n出现争议场景时，优先咨询专业法律人士。\n\n📌 免责声明：本文内容仅供信息参考与技术科普之用，不构成法律建议，使用者应对自己的行为负责。\n\n总结与建议15. 根据需求选择最合适的方式“科学上网”并非目的，而是一种工具，服务于学习、研究、工作与信息获取的需求。无论是使用 VPS、机场节点还是商业 VPN，每种方式都有其适用场景：\n\n如果你是开发者、技术爱好者：建议选择自建 VPS，可高度定制且安全可控；\n如果你是普通用户或学生：Clash + 机场服务兼顾稳定与便利；\n如果你希望快速使用、无需配置：商业 VPN 是最友好入门选择。\n\n🚀 关键建议：\n\n明确使用目的，不涉及违法内容；\n重视节点安全，避免使用来路不明的服务；\n关注协议加密方式与数据隐私政策；\n保持良好的数字素养与信息判断力。\n\n整体建议是：普通用户优先选择靠谱机场，有经验又愿意折腾的技术用户可以再考虑自建 VPS 作为补充，商业 VPN 更适合境外用户或经常出差的人群，而不是长期在中国大陆本地使用。\n翻墙并不是“翻越一道墙”，而是打破信息孤岛的一种手段。合理使用，是实现知识自由流通、个体认知成长的重要方式。\n\n常见问答（FAQ）1. 我“连上了”，但浏览器还是打不开网页 / 只有部分软件能用？优先按这个顺序排查：\n\n是否开启了系统代理或 TUN：浏览器一般依赖系统代理；部分应用需要 TUN 才能接管流量\nClash 模式是否选对：日常推荐 Rule，误开 Direct 会导致所有流量直连\nDNS 是否正常：DNS 污染/劫持可能导致“节点可用但网站打不开”，建议启用客户端内置的安全 DNS / 加密 DNS\n\n2. 订阅导入后没节点 / 更新失败怎么办？\n检查订阅链接是否被截断（复制时漏字符、末尾多空格）\n登录服务商面板确认订阅未过期、流量未用尽、账号未被风控\n先在客户端里“更新订阅”，不行再删除订阅重新导入\n\n3. ChatGPT/Claude 提示 403、地区不可用或验证码频繁？\n更换到服务支持的地区节点（不同服务限制不同）\n清理浏览器 Cookie 或用无痕窗口测试，避免“旧地区会话”干扰\n减少频繁切换节点与高频刷新，部分服务会触发风控\n\n4. 速度慢、晚高峰卡顿怎么改善？\n优先选“更近地区 + 更好线路”（中转/专线通常比直连更稳）\n用策略组的自动测速（url-test）与故障切换（fallback），避免死磕单一节点\n流媒体优先选标注解锁且长期维护的节点/套餐\n\n5. iOS 用什么客户端？iOS 常见客户端有 Spectre、Stash 等（可能需要外区 Apple ID）。具体安装与配置见图文教程：\n\nIOS如何用外网/苹果手机搭梯子-翻墙VPN软件工具 \n\n6. 免费科学上网工具能用吗？短期“能连上”不等于长期“安全可靠”。大量免费/超低价服务可能存在广告注入、隐私风险、稳定性差等问题；更建议选择口碑较好的服务。\n\n🌐 国外常用网站导航以下是整理的一些常用国外网站，涵盖搜索引擎、社交平台、流媒体、学术资源等多个领域，适合日常浏览、学习、工作与娱乐使用。\n🔍 搜索引擎\nGoogle – 全球最强搜索引擎，信息全面\nBing – 微软旗下，界面简洁，图像搜索强\nDuckDuckGo – 主打隐私保护，不追踪用户行为\nStartpage – 使用 Google 结果但无隐私追踪\nYahoo – 集新闻、邮箱、搜索于一体\n\n📺 视频与流媒体\nYouTube – 全球最大视频平台\nTwitch – 游戏与直播社区\nNetflix – 高质量剧集电影流媒体服务\nDisney+ – 迪士尼旗下流媒体，包含漫威/星战内容\nAmazon Prime Video – 亚马逊会员专属影视平台\n\n💬 社交与社区\nTwitter (X) – 全球热点信息首发平台\nFacebook – 世界最大社交网络\nReddit – 海外社区讨论中心，话题广泛\nInstagram – 图片/短视频分享平台\nLinkedIn – 海外职业社交首选平台\n\n📚 学术与工具\nWikipedia – 开源百科全书\nGoogle Scholar – 免费学术论文搜索引擎\nArchive.org – 互联网档案馆，保存旧网页/书籍/视频\nResearchGate – 全球科研人员社交与论文交流平台\nJSTOR – 权威论文与文献数据库\n\n💻 开发者与文档\nGitHub – 开源项目与代码托管平台\nStack Overflow – 编程问答社区\nMDN Web Docs – Web 开发权威文档\n\n🤖 AI 与生产力工具\nChatGPT – 对话式 AI 智能助手\nGemini (原 Bard) – Google 推出的 AI 工具\nClaude – Anthropic 公司出品的大模型助手\nPerplexity AI – 问答型 AI 搜索引擎\nNotion – 效率工具，可做笔记/知识库/项目管理\n\n\n","categories":["科学上网"],"tags":[]},{"title":"Marching Cubes之三维等值面提取算法（Dual Contouring）","url":"https://tanqingbo.cn/Marching-Cubes/","content":"上一篇介绍了Marching Cubes算法，Marching Cubes算法是三维重建算法中的经典算法，算法主要思想是检测与等值面相交的体素单元并计算交点的坐标，然后对不同的相交情况利用查找表在体素单元内构建相应的网格拓扑关系。Marching Cubes算法简单，但是存在一些缺陷：1.模型二义性问题；2.模型特征问题。\n　　对于二义性问题，以2D情形为例，存在一个单元中同一顶点状态而不同的连接方式（如下图所示）。\n\n图：2D中Marching Cubes算法的二义性问题\n　　那么对于上图中两种连接方式的不同选择，可能会导致在同一张图像上完全不同的结果（如下图所示），二义性在3D中的直接后果是产生“孔洞”。如果在一个单元中，一条对角线的两端点值大于等值面阈值，另一条对角线的两端点值小于等值面阈值，那么通常会发生这种二义性问题。\n\n图：二义性问题的不同结果\n　　对于特征问题，由于Marching Cubes算法只计算体素单元的交点坐标信息，并根据这些交点连接的三角面片来构建体素单元内的几何模型，这样假如体素单元内存在几何模型的特征信息（棱边、棱角），但是Marching Cubes算法最终构建出的几何模型会缺少这些特征信息（如下图所示）。\n\n图：左上-交点坐标和法向；右上-Marching Cubes算法；左下-Extended Marching Cubes算法；右下-Dual Contouring算法\n　　Dual Contouring算法[Ju et al. 2002]也是经典的等值面提取算法，相比Marching Cubes算法，Dual Contouring算法利用Hermite数据（交点的位置和法向）进行等值面构建，它克服了Marching Cubes算法所出现的缺陷。具体算法分两步：\n　　第一步：利用二次误差函数生成顶点坐标\n　　对于每个与等值面相交的体素单元，通过最小化二次误差函数来生成一个顶点坐标：\n \n其中pi为交点的位置，ni为交点的法向。\n　　误差函数可以写成矩阵形式：\n \n其中矩阵A的行向量为交点的法向ni，向量b的每个元素为ni·pi。\n　　极值点可以通过求解正则方程得到：\n \n　　但是文章指出这种方式会存在数值不稳定，并提出一种解决方法。基于QR矩阵分解计算正交矩阵Q，使得Q与[A b]相乘为如下上三角矩阵形式：\n \n其中A’为3*3的上三角矩阵，b’为长度为3的向量，r为标量。\n　　那么误差函数可以变化为：\n \n　　然后再根据上式计算极值点。\n　　第二步：生成网格面片\n　　对于每一条等值面相交的体素边，那么包含该体素边的4个相邻体素单元内必然都存在顶点，将这4个顶点连接生成1个四边形面片。\n　　\n　　文章[Schaefer et al. 2002]详细介绍了Dual Contouring算法的实现细节，通过总结该文可以得到Dual Contouring算法过程如下：\n　　对于每个与等值面相交的体素单元：\n　　1. 创建1个4*4的零矩阵用于存放QR矩阵分解的结果；\n　　2. 对于体素单元的每条相交边，计算交点的位置pi和对应的法向ni；\n　　3. 将向量[ ni.x, ni.y, ni.z, dot(pi,ni) ]添加到4*4的零矩阵底部；\n　　4. 通过QR矩阵分解得到3*3的上三角矩阵A’和向量b’；\n　　5. 求解线性方程组A’TA’x = (A’Tb’ - A’Tb’c) , 其中c是体素单元中所有交点的质心位置；\n　　6. 将计算得到的偏移量x加上质心位置c即为体素单元中的顶点坐标；\n　　7. 如果计算得到的顶点坐标位于体素单元之外，那么顶点坐标用质心位置c来代替；\n　　8. 对于每一条相交的体素边，将其周围4个体素单元内的顶点连接生成1个四边形面片。\n \n图：左- Marching Cubes算法；右-Dual Contouring算法\n \n图：左- Marching Cubes算法；右-Dual Contouring算法\n \n图：box与sphere相交模拟\n","categories":["数据结构与算法"],"tags":["算法","排序"]},{"title":"2026最新科学上网教程：Clash/Spectre/Trojan等翻墙工具全指南","url":"https://tanqingbo.cn/VPN-HELP/","content":"访问 Google、YouTube、Twitter 等国际网站变得异常困难。科学上网（又称翻墙、魔法上网）就是通过技术手段绕过封锁，访问被限制的网站与服务。它不仅满足日常浏览需求，还对开发者、留学生、外贸人士、资讯爱好者等群体至关重要。\n在众多翻墙方式中，机场服务 + 科学上网客户端是目前最主流、最高效、最易上手的解决方案。本文将从原理入手，结合客户端推荐、工具对比和进阶技巧，手把手教你实现自由上网。\n\n一、什么是科学上网？科学上网（Bypassing Internet Censorship）是指绕过网络审查和内容封锁，自由访问被限制的网站或服务。常见被封锁的服务包括：\n\n社交媒体：YouTube、Twitter、Facebook、Instagram\n搜索引擎：Google、Bing（部分地区）\n新闻媒体：BBC、纽约时报、维基百科等\n\n实现科学上网的方式有很多，例如 VPN、代理服务器、Tor、SSH 隧道等。其中，“机场 + 客户端”方案以速度快、操作简单、适配广泛的优势，成为最推荐的选择。\n\n二、什么是翻墙机场？机场，指的是提供网络代理节点的服务商。用户购买订阅后可获取一组代理服务器地址，通过客户端连接使用，绕过封锁访问互联网。\n购买机场服务地址：https://order.yizhihongxing.club/aff.php?aff=4818\n常见协议包括：\n\nShadowsocks（SS）\nV2Ray（VMess/VLESS）\nTrojan\nNaïveProxy\nClash/Xray（聚合协议）\n\n机场通常支持多种协议，用户可通过订阅链接一键导入节点，配合 GUI 客户端轻松完成配置。\n\n三、翻墙协议与客户端的关系这些翻墙协议本身通常是命令行程序，配置复杂。因此，开发者为其构建了图形化客户端（GUI），大大简化了使用门槛。GUI 客户端内置协议内核，通过可视化界面，帮助用户：\n\n一键导入订阅\n自动更新节点\n灵活设置代理规则\n实时查看连接状态\n\n\n四、主流客户端推荐及下载安装入口以下为各平台主流科学上网客户端推荐，适配主流协议和机场订阅：\n\n\n\n平台\n推荐客户端\n主要特点\n\n\n\nWindows\nClash for Windows\n功能丰富，订阅管理优秀\n\n\nmacOS\nSpectre\n适配良好，支持 Clash 订阅\n\n\nAndroid\nClash for Android\n功能强大，支持多个订阅\n\n\niOS\nSpectre\n免费安装，支持多协议\n\n\n 说明：点击客户端名称可查看详细教程与下载方式。\n\n五、科学上网客户端配置流程使用机场订阅链接结合客户端，可以快速配置完成科学上网：\n\n购买机场服务\n注册并购买套餐:https://order.yizhihongxing.club/aff.php?aff=4818\n获取机场提供的“订阅链接”（形如 https://example.com/sub）\n\n\n导入订阅到客户端\n打开客户端，找到“订阅管理”或“导入订阅”功能\n粘贴链接 → 点击更新 → 自动同步节点\n\n\n连接节点即可上网\n在节点列表中选择延迟低的线路\n点击“连接”或“启动代理”按钮\n打开浏览器，即可访问 Google、YouTube 等\n\n\n\n\n六、不同翻墙工具方式对比\n\n\n方法\n速度\n安全性\n抗封锁能力\n适用人群\n\n\n\n机场 + Clash\n★★★★☆\n★★★★☆\n★★★★☆\n大多数用户，追求稳定和速度\n\n\n机场 + V2Ray\n★★★★☆\n★★★★☆\n★★★★★\n对抗干扰能力要求高的用户\n\n\nVPN\n★★★☆☆\n★★☆☆☆\n★★☆☆☆\n新手用户，移动设备使用\n\n\nTor\n★☆☆☆☆\n★★★★★\n★☆☆☆☆\n重度隐私/匿名访问需求者\n\n\nSSH 隧道\n★★☆☆☆\n★★★★☆\n★☆☆☆☆\n远程服务器或技术测试使用\n\n\n\n七、拓展协议介绍：更多可选翻墙协议除了 Clash、Shadowsocks、V2Ray、Trojan 之外，还有其他较新的协议：\n\nNaïveProxy：基于 Chrome，伪装性强，抗封锁能力优秀\nHysteria：基于 QUIC 协议，速度快，适合高延迟环境\nWireGuard：极简高效的 VPN 协议，适合需要高性能连接的用户\n\n这些协议通常用于自建，部分机场也开始支持。\n\n八、机场 vs 自建：哪种更适合你？\n\n\n方式\n优势\n劣势\n适用人群\n\n\n\n机场\n简单快捷，无需运维，速度快\n节点不透明，隐私风险高\n普通用户\n\n\n自建\n自主可控，更安全，自由搭配\n技术门槛高，需自行维护\n技术熟练用户\n\n\n如你只是希望快速稳定上网，推荐使用机场订阅 + 图形客户端组合。\n","categories":["科学上网"],"tags":[]},{"title":"Seata分布式事务详解（入门级教程）","url":"https://tanqingbo.cn/Seata/","content":"Seata（Simple Extensible Autonomous Transaction Architecture）是一款开源的分布式事务解决方案，旨在解决微服务架构下的分布式事务问题。Seata通过提供简单易用的API和强大的事务管理能力，帮助开发者在分布式系统中实现数据一致性。\n\n什么是分布式事务？在微服务架构中，一个业务操作可能涉及多个服务，每个服务都有自己的数据库。为了保证数据的一致性，我们需要确保这些服务要么全部成功提交，要么全部回滚。这种跨多个服务的事务称为分布式事务。\n比如：假设我们有一个电商系统，用户下单时需要扣减库存、创建订单和扣减账户余额。这三个操作分别由库存服务、订单服务和账户服务处理。为了保证数据的一致性，我们可以使用Seata来管理这个分布式事务，确保以上三个服务要么全部成功提交，要么全部回滚。\nSeata的核心组件Seata的核心组件包括以下几个部分：\n1、Transaction Coordinator (TC)Transaction Coordinator（TC） 是Seata的核心组件之一，负责全局事务的管理。它协调各个分支事务的执行，确保事务的原子性和一致性。\n\n作用：TC负责全局事务的创建、提交、回滚等操作。\n特点：TC是无状态的，可以水平扩展，支持高并发场景。\n\n2、Transaction Manager (TM)Transaction Manager（TM） 是事务的发起者，负责定义全局事务的边界。TM与TC交互，发起全局事务的提交或回滚。\n\n作用：TM负责全局事务的开始、提交或回滚。\n特点：TM通常嵌入在业务逻辑中，与具体的业务代码紧密耦合。\n\n3、Resource Manager (RM)Resource Manager（RM） 负责管理分支事务的资源，与TC和TM协同工作，确保分支事务的正确执行。\n\n作用：RM负责分支事务的注册、提交、回滚等操作。\n特点：RM与具体的数据库或资源管理器交互，负责资源的锁定和释放。\n\nSeata的工作流程Seata的工作流程可以分为以下几个步骤：\n\n全局事务开始：TM向TC发起全局事务的开始请求，TC生成全局事务ID（XID）。\n分支事务注册：RM向TC注册分支事务，TC记录分支事务的状态。\n分支事务执行：RM执行分支事务，并将执行结果报告给TC。\n全局事务提交或回滚：TM根据分支事务的执行结果，向TC发起全局事务的提交或回滚请求。\n事务完成：TC协调所有分支事务的提交或回滚，确保事务的原子性。\n\n具体工作流程如下：\n\n实际案例假设我们有一个电商系统，用户下单时需要同时扣减库存和生成订单。这两个操作分别由库存服务和订单服务处理，属于不同的微服务。我们可以使用Seata来确保这两个操作的原子性。\n4.1 代码示例// 库存服务@GlobalTransactionalpublic void reduceStock(String productId, int quantity) {    // 扣减库存    stockService.reduce(productId, quantity);    // 生成订单    orderService.createOrder(productId, quantity);}\n\n在这个例子中，@GlobalTransactional注解标识了一个全局事务。如果库存扣减成功但订单生成失败，Seata会自动回滚库存扣减操作，确保数据一致性。\n","categories":["Java"],"tags":["Java","框架","Seata"]},{"title":"Android如何用外网/安卓手机搭梯子-翻墙VPN软件工具","url":"https://tanqingbo.cn/Android-VPN/","content":"由于不可描述的原因，很多地方都有墙的的存在。这就导致我们没办法用谷歌、Twitter、Instagram、Youtube、Netflix、ChatGPT等等优秀的平台。\n因此，我们需要翻墙，需要科学上网，这样就可以自由浏览墙外的资源，更好的学习，提升自我。\n既然墙阻挡了我们直接访问国际互联网上的某些特定服务，那么我们只能绕行了。方法就是使用梯子工具：\n\n找一台墙外的电脑，一台不经过墙，能自由上网的电脑\n把我们想访问的内容，交给这台没有限制的电脑来完成\n这台电脑访问到对应的内容后，再返回给我们\n由此，我们完成了通过这台电脑获取被墙的网络内容\n\n这台不经过墙，能自由上网的电脑，通常被成为代理服务器。\n而能够通过代理服务器访问外网的软件，通常被成为梯子、代理软件，也叫翻墙软件。\n\n由上述原理介绍，可以得到，要想实现科学上网，需要 代理服务器 + 翻墙软件 来实现。\n代理服务器一般通过购买来获得，当然网上也能找到免费的，不过我比较提倡用钱能解决的问题，尽量还是花些钱吧，这样方便、稳定、且一劳永逸。\n代理服务器购买代理服务的话，我个人推荐一支红杏的代理服务，它是銘佑科技（香港）有限公司（也是老薛主机，不会跑路型）推出的网络加速器服务，基于 Trojan 协议的科学上网方式，该协议会将您需要代理的网络数据伪装成 HTTPS 协议的正常网络数据，以通过防火墙的检测和封锁，连接速度快，它会帮助你在互联网上冲浪时保护你的隐私和安全。\n\n支持 Windows、MAC OS X、cross platform、Android、IOS、openwrt等系统，是非常实用的网络代理软件。\n我买的就是一枝红杏的VPN，亲测真的很好用，网速很快，Google、youtubu、Facebook啥的都能上。下面就教大家怎么用起来。\n打开一枝红杏官网。\n官网：https://order.yizhihongxing.club/aff.php?aff=4818\n翻到下面会有两种VPN的购买方式，如果是个人用的话，选择入门版就可以了，一个月100G足够用了。\n跳转到订购页面后可以先在右上角点击注册，注册一个新账号，然后再根据提示购买你的产品。\n购买之后依次点击上方导航栏中的 产品与服务-&gt;我产品与服务-&gt;查看详情，就能看到你购买的节点信息。\n\n\n\n购买完代理服务器之后，接下来需要安装一个软件来辅助我们进行科学上网。\n科学上网（翻墙）软件下载客户端：\n直接点击下载\n\n添加节点(通过订阅链接)：安装后打开首页，点击配置：\n\n点击新配置\n\n点击 URL (从 URL 导入)：\n\n在你购买代理服务器的界面复制 Clash 订阅链接(在产品详情页面获取)，如下：\n\n然后粘贴到URL处，再点击右上角的保存：\n\n下载完成后选中配置文件，然后返回首页点击 点此启动 开始使用：\n\n第一次启动时会请求 VPN 权限，需要点击确定允许。\n(该弹窗为系统弹窗，与客户端无关，如果无法点击基本上是其他 APP 有在使用悬浮窗权限导致，或者是一些系统的护眼模式)\n\n\n如果需要切换节点，请点开第二个 代理 选项即可。\n之后便可以自由的访问Google、Twitter、Instagram、Youtube、Netflix、ChatGPT等等这些优秀平台了。\n推荐阅读：Iphone如何用外网/苹果手机搭梯子-翻墙VPN软件工具 | IT码农\nWindows 翻墙教程：从零开始科学上网（最稳定的科学上网方案）| IT码农\n","categories":["科学上网"],"tags":[]},{"title":"手机/电脑如何翻墙上外网：VPN推荐、科学上网教程","url":"https://tanqingbo.cn/phone-win-open-Internet/","content":"为什么要翻墙/科学上网？由于不可描述的原因，很多地方都有墙的的存在。这就导致我们没办法用谷歌、Gemini、telegram、Twitter、Instagram、Youtube、Netflix、ChatGPT等等优秀的平台。\n因此，我们需要翻墙，需要科学上网，这样就可以自由浏览墙外的资源，更好的学习，提升自我。\n如何实现科学上网/翻墙？由上述原理介绍，可以得到，要想实现科学上网，需要 代理服务器 + 翻墙软件 来实现。\n准备代理服务器想要拥有一个可用的代理服务器，有两种方式，一种是自己搭建，另一种是通过购买的方式。\n\n自己搭建代理服务器：如果你有服务器搭建的相关经验，可以考虑自己做。首先你需要拥有一台VPS服务器，然后，可以在服务器上安装需要的翻墙软件。\n自己搭建代理服务器一般门槛都比较高、而且服务器也得花钱，还不稳定，我比较提倡用钱能解决的问题，尽量还是花些钱吧，方便、稳定、一劳永逸。\n购买代理服务：所以我比较推荐直接购买VPN机场服务，这样你只需要再下载一个翻墙软件就能直接使用了。目前我使用的服务是【一支红杏】：\n\n\n【一支红杏】：我自己使用了六七年多了，节点比较多（有50多个节点），包含美国、香港、新加坡、土耳其、阿根廷、印度等节点，还有一个优点是稳定，我用了六七年了一直都没出现过问题，且墙外你想访问的网站基本都能访问。\n【一支红杏】官网地址：https://order.yizhihongxing.club/aff.php?aff=4818\nWindows 端Windows端推荐使用 clash for Windows翻墙软件，详细的注册使用教程如下：\n注册教程：外网挂梯子/Windows电脑翻墙教程：2025年最稳定的科学上网方案 |  IT码农\niOS/MAC 端iOS 端想使用科学上网就稍微有麻烦，那些 App 都不在国内应用商店，所以首先你需要一个非中国大陆地区的 Apple ID 账户，然后在 App Store 下载 App，不过不用担心，我在下面教程都详细介绍了，你只需要根据教程一步一步来就行：\n注册教程：苹果/IOS系统手机实现科学上网教程-翻墙VPN软件工具 |  IT码农\nAndroid 端安卓端相对于苹果端要容易一些，详细教程如下：\n注册教程：安卓/Android系统手机实现科学上网教程-翻墙VPN软件工具 |  IT码农\n最后本文推荐的翻墙VPN用于日常工作、学习和娱乐，切勿浏览和传播敏感信息，包括黄赌毒，以及与政治、经济、文化、宗教等相关的敏感内容。\n","categories":["科学上网"],"tags":[]},{"title":"公认最好用的AI工具：Gemini到底该如何使用？（最全教程）","url":"https://tanqingbo.cn/Gemini/","content":"Gemini是谷歌推出的一款强大的人工智能工具，是公认的国外最好用的AI工具之一。然而，在中国使用Gemini却不是一件简单的事。为什么？因为中国的网络限制和Gemini的区域限制让直接访问变得困难。别担心，这篇文章将带你一步步了解如何在中国使用Gemini，介绍Gemini的最新功能，并推荐一些可靠的工具来帮助你突破障碍。无论你是想用它写文章、生成图片，还是探索更多可能性，这篇指南都会给你清晰的答案。\n为什么在中国使用Gemini这么难？在中国尝试访问Gemini时，你可能会遇到两个主要障碍。首先，Gemini并未在中国（包括香港）正式开放。谷歌明确表示，中国大陆和香港的用户无法直接使用这项服务。如果你尝试从未开放国家或地区登录Gemini的官网，屏幕上可能会跳出一句让人泄气的提示：“Gemini 目前不支持你所在的地区”（Gemini isn’t currently supported in your country）。这不是你的网络问题，而是谷歌的区域限制政策。\n\n第二个障碍是中国的网络防火墙（GFW）。GFW限制了对许多谷歌服务的访问，包括Gemini的官网和相关API。无论你用的是电脑还是手机，直接打开Gemini的网页通常只会得到一片空白或错误提示。这就像试图翻过一堵高墙，里面有你想要的宝藏，但门却被锁得死死的。\n那么，有没有办法绕过这些限制呢？答案是肯定的！通过一些工具和方法，你完全可以在中国体验Gemini的强大功能。接下来，我们会详细探讨如何做到这一点。\nGemini AI的功能有哪些？在深入如何使用Gemini之前，先来聊聊它到底能做什么。Gemini是谷歌的旗舰AI模型，集成了多种先进技术，能够处理文本、图片、视频等内容。它的多模态能力让它在众多AI工具中脱颖而出。以下是Gemini的一些核心功能，以及2025年最新的更新亮点。\nGemini可以生成高质量的文本，比如帮你写邮件、创作故事，甚至回答复杂的问题。它的语言处理能力非常自然，无论是中文还是英文，都能给出流畅的回答。比如，你可以问：“如何用中文写一首关于秋天的诗？”Gemini就能立刻创作一首充满意境的诗句。\n此外，Gemini还能分析和生成图片。如果你上传一张照片，它可以描述图片内容，甚至根据你的描述生成全新的图像。2025年的新功能Veo 3进一步提升了视频生成能力。你可以输入一段文字，比如“一只猫在月光下跳舞”，Veo 3就能生成一段流畅的动画视频，细节惊艳到让人以为是专业制作。\nGemini还有强大的代码生成和调试功能。如果你是个程序员，遇到代码问题，Gemini可以帮你找出错误，甚至直接生成一段可用的代码片段。它还能翻译语言、规划旅行、总结文章，功能多到让人眼花缭乱。简单来说，Gemini就像一个超级聪明的助手，几乎能帮你解决任何问题。\n如何在中国使用Gemini？\n现在进入正题：在中国怎么用Gemini？虽然有区域限制和网络封锁，但通过VPN访问官方服务或使用Gemini的API，你依然可以畅享它的全部功能。以下是两种主要途径的详细说明。\n解决方案1: 使用VPN翻墙访问GeminiVPN（虚拟私人网络）是绕过GFW的最佳翻墙工具。它可以让你的网络流量伪装成来自其他国家，从而访问被封锁的网站，比如Gemini的官网或应用。以下是具体步骤：\n\n选择一个可靠的VPN不是所有VPN都能稳定访问谷歌服务，所以选择很重要。下一节我们会详细介绍一款适合中国的VPN：一支红杏。\n下载并设置VPN在购买VPN订阅后，下载它的官方应用（可在官网或应用商店找到）。安装后，选择一个支持Gemini的服务器位置，比如美国、加拿大或新加坡。连接VPN后，你的网络就会“伪装”成来自这些国家。\n访问Gemini官网或应用打开浏览器，访问Gemini的官网。如果使用手机，可以下载Google Gemini的Android或iOS应用。登录谷歌账户后，你就可以开始使用Gemini了。如果遇到区域限制提示，尝试更换VPN服务器位置。\n保持VPN连接使用Gemini时，始终保持VPN开启，否则GFW可能会中断你的访问。注意，VPN的速度可能因服务器位置和网络状况而异，选择靠近中国的服务器（如日本或新加坡）通常能获得更好的体验。\n\n使用VPN的优点是能直接访问谷歌的官方服务，体验最新功能，比如Veo 3的视频生成。然而，VPN需要一定的费用，且需要稳定的网络环境。如果你更倾向于技术化的解决方案，可以考虑使用Gemini的API。\n解决方案2: 通过Gemini API访问对于有编程基础或想将Gemini集成到自己项目的用户，Gemini的API是一个强大的选择。API允许你通过编程方式调用Gemini的功能，比如生成文本、分析图片或创建视频，无需直接访问官网。以下是使用API的基本思路：\n要使用Gemini API，你需要先在谷歌云平台注册账户，启用Gemini API并获取密钥。这个过程需要访问谷歌云网站，因此必须使用VPN绕过GFW。此外，调用API的设备需要拥有一个非中国的IP地址。你可以通过两种方式实现这一点：一是使用位于中国境外的虚拟私有服务器（VPS），比如在新加坡或美国租用一台云服务器；二是在本地运行代码时保持VPN连接，确保网络流量伪装为来自支持Gemini的国家。\n许多开发者还使用第三方工具来简化API访问。例如，一些开源平台或商业服务提供了Gemini API的封装接口，让你无需自己编写复杂代码。这些工具通常有用户友好的界面，甚至支持直接在浏览器中测试API调用。不过，选择第三方工具时要确保其信誉良好，以保护你的API密钥和数据安全。\nAPI的优点是灵活性高，适合批量任务或定制化应用，比如开发一个支持中文对话的聊天机器人或自动生成视频内容的工具。然而，API调用需要付费（按使用量计费），且对网络稳定性要求较高。如果你在公司或学校网络中，可能需要额外配置代理来确保连接顺畅。\n最佳VPN推荐：翻墙访问Gemini的理想选择\n选择一款适合中国的VPN是成功使用Gemini的关键。以下是一款表现优异、特别适合访问Gemini的VPN。\n一支红杏VPN一支红杏VPN，它是銘佑科技（香港）有限公司（也是老薛主机，不会跑路型）推出的网络加速器服务，基于 Trojan 协议的科学上网方式，该协议会将您需要代理的网络数据伪装成 HTTPS 协议的正常网络数据，以通过防火墙的检测和封锁，连接速度快，它会帮助你在互联网上冲浪时保护你的隐私和安全。\n\n支持 Windows、MAC OS X、cross platform、Android、IOS、openwrt等系统，是非常实用的网络代理软件。\n我买的就是一枝红杏的VPN，亲测真的很好用，网速很快，Google、youtubu、Facebook啥的都能上。下面就教大家怎么用起来。\n打开一枝红杏官网。\n官网：https://order.yizhihongxing.club/aff.php?aff=4818\n翻到下面会有2种VPN的购买方式，如果是个人用的话，选择入门版就可以了，一个月100G足够用了。\n\n\n\n跳转到订购页面后可以先在右上角点击注册，注册一个新账号，然后再根据提示购买你的产品。\n购买之后依次点击上方导航栏中的 服务-&gt;产品/服务，就能看到你购买的节点信息。\n\n\n\n\n好了，别着急，接下来需要下载一个软件Clash Verge来辅助科学上网。\n\nClash Verge下载先放一个下载链接: https://order.yizhihongxing.club/index.php?rp=/knowledgebase/13/\n下载安装好之后登入后前往  产品/服务 ，点击【我的产品与服务】，接着打开【产品详情】页面。\n\n向下滑动，点击 Clash 配置右侧的获得地址，在弹出的窗口中，选择 复制地址 。\n\n如果点击获得地址没有反应，请更换使用 Chrome 、Firefox 或是 EDGE 浏览器访问客户中心。\n注1. 订阅链接与你的密码一样重要，请不要分享给他人，如不慎泄露，请在产品详情页面重置链接并提交工单申请重置服务密码。\n注2. 如果使用链接添加时报错，可以点击 下载配置 ，手动添加 \n4. 添加配置打开客户端后，使用第三步的订阅链接添加配置\n\n首先点击左侧 订阅(Profiles) ，粘贴订阅链接后点击 导入\n添加成功后点击左侧 代理(Proxies) 选择节点使用，就可以成功科学上网了。 \n\n\n\n以上是电脑端科学上网的教程，如果你想在手机端也实现科学上网的话，可以参考以下两个教程：\niOS/MAC 端注册教程：iphone如何用外网/苹果手机搭梯子-翻墙VPN软件工具 | IT码农\nAndroid 端注册教程：安卓/Android系统手机实现科学上网教程-翻墙VPN软件工具 | IT码农\n在中国使用Gemini的常见问题解答在使用Gemini的过程中，你可能会遇到一些疑惑。以下是一些常见问题和解答，帮助你更顺畅地使用。\n问题1：为什么我的VPN连上了还是无法访问Gemini？可能是VPN的服务器位置不支持Gemini，或者谷歌检测到你的IP异常。试试更换服务器（比如切换到美国或欧洲的服务器），或者清除浏览器缓存后重试。如果问题持续，联系VPN的客服，他们通常能提供针对中国的优化方案。\n问题2：Gemini API的费用高吗？Gemini API的费用基于调用量，具体价格可在谷歌云平台查看。普通用户的小规模使用通常成本较低，但如果需要频繁调用（比如生成大量视频），费用可能较高。建议先用免费额度测试。\n问题3：Gemini支持中文吗？完全支持！Gemini的中文处理能力非常强，无论是生成文本还是回答问题，都能给出自然流畅的回答。API调用也支持中文输入，效果同样出色。\n问题4：可以用Gemini免费吗？谷歌提供Gemini的免费版本，但功能有限，比如无法使用Veo 3的高级视频生成。API则需要付费，但谷歌云通常有新用户免费额度。如果你需要完整功能，可以考虑订阅Gemini Advanced（需通过VPN支付）。\n结尾在中国使用Gemini可能需要一些额外的努力，但通过VPN或API，你完全可以体验到这款AI的强大功能。ExpressVPN、Surfshark和NordVPN提供了稳定、安全的翻墙方案，而API则为开发者开启了更多可能性。Gemini的多模态能力，比如文本生成、图片分析和Veo 3的视频创作，能为你的工作和生活带来无限创意。\n所以，准备好了吗？拿起手机或电脑，试试文中提到的方法，解锁Gemini的魔法世界吧！不管是写一篇创意文章，还是生成一段炫酷视频，Gemini都能让你惊叹。只要跨过网络的“小门槛”，你就能和这个智能助手成为好朋友！\n","categories":["科学上网"],"tags":[]},{"title":"科学上网之Clash for Windows 实现电脑翻墙教程","url":"https://tanqingbo.cn/ClashForWindows/","content":"ClashForWindows是什么？ClashForWindows是一款基于Clash的Windows GUI代理客户端。它有以下几点优势：\n\n隐私保护：作为一款代理客户端，ClashForWindows可以帮助用户在浏览网页时隐藏自己的IP地址，保护用户的在线隐私。\n加密通信：ClashForWindows支持多种加密方式，包括但不限于Shadowsocks、VMess、Trojan等，可以保护用户的网络通信不被窃听。\n规则分流：ClashForWindows具有强大的规则分流功能，用户可以根据自己的需求设置不同的代理规则，防止不必要的数据泄露。\n透明代理：通过ClashForWindows，用户可以实现全局或者按需代理，有效避免了部分网站或应用对IP地址的限制。\n开源：ClashForWindows是开源软件，其源代码可以公开查阅，这意味着任何人都可以查看其内部实现，从而确保没有隐藏的恶意代码。\n\nClashForWindows下载下载链接：Index of /clash_for_windows/\n\n建议下载中文版的，Clash for Windows 下载和安装之后，可用通过 Clash for Windows 使用教程配置好Clash for Windows。\n添加配置文件添加配置文件一般有如下两种方式：\n\n远程订阅地址\n本地配置文件\n\n一般情况下，远程订阅地址（URL 导入）及本地配置文件（本地文件拖拽导入）都由节点服务商提供。\n远程订阅地址远程订阅地址即通过 URL 链接导入，一般的VPN服务商都会直接提供 Clash 节点地址，如果你不知道哪些VPN服务商靠谱的话，推荐使用【一支红杏】VPN服务商，我自己用了七八年了，主打一个安全、稳定！\n\n一支红杏支持 Windows、MAC OS X、cross platform、Android、IOS、openwrt等系统，是非常实用的网络代理VPN。\n网速很快，奈飞、电报、Google、youtubu、Facebook啥的都能上。\n\n🔗 官网地址：https://order.yizhihongxing.club/aff.php?aff=4818\n第一步：注册一支红杏账号并获取订阅地址\n打开官网：https://order.yizhihongxing.club/aff.php?aff=4818\n翻到下面会有VPN的注册方式，如果是个人用的话，选择入门版就可以了，一个月100G足够用了。\n购买之后依次点击上方导航栏中的 产品与服务-&gt;我产品与服务-&gt;查看详情，就能看到你购买的节点信息。\n\n\n\n第二步：Clash for Windows远程导入clash订阅地址点击上述图片红框右侧中的【获得地址】按钮，接着复制地址：\n\n打开Clash for Windows软件，然后点击界面左侧菜单 配置，在顶部输入框填入刚才复制的 URL 连接地址并点击 下载 即可，如下图所示。\n\n本地配置文件本地配置文件即通过本地文件拖拽导入，一般为无法通过远程订阅地址导入的情况下使用，可尝试在浏览器中下载配置文件后直接通过拖拽方式导入或点击 Import 导入，如下图所示。\n\n\n选择代理节点在添加为订阅地址之后，需要选择一个代理节点使用，点击软件主界面左侧的 代理 选项卡，软件右上角代理规则处默认保持 规则 即可，代理模式主要有以下四种：\n\n规则：所有请求根据配置文件规则进行分流\n全局：所有请求直接发往代理服务器\n直连：所有请求直接发往目的地，即不使用代理\n脚本：所有请求根据脚本文件规则进行分流\n\n全局模式可能会导致国内流量也走代理访问，除了网络会变慢外，还会消耗套餐流量。规则模式的好处就是区分国内国外的流量只有在规则内的国外网站才会走代理，这样即不影响国内访问速度，又节省套餐流量，所以如果没有什么特别的需求，一般选择 规则 即可。\n然后在展开的节点组之中任意单击鼠标左键选择一个节点即可，如下图所示：\n\n启用代理启用代理，需要点击界面左侧菜单 主页 选项卡，找到 系统代理 并开启开关即可，开启状态下按钮状态为绿色，如下图所示为开启状态。\n\n启动代理后系统托盘的图标会变色金色猫咪，以下是系统托盘图标颜色说明，代理启动后，可以打开浏览器，访问 Google / YouTube / ChatGPT 测试VPN是否正常。\n\n设置开机自动启动设置开机自启动，需要点击界面左侧菜单 主页 选项卡，找到 开机自启动 并开启开关即可，开启状态下按钮状态为绿色，如下图所示为开启状态。\n\n更新配置文件点击界面左侧菜单 配置，点击 更新全部 即可更新所有配置文件，如下图所示。\n\n其它设备设置VPNiOS/MAC 端注册教程：iphone如何用外网/苹果手机搭梯子-翻墙VPN软件工具\nAndroid 端注册教程：安卓/Android系统手机实现科学上网教程-翻墙VPN软件工具\n","categories":["科学上网"],"tags":[]},{"title":"外网挂梯子/电脑翻墙教程：2026年最稳定的科学上网方案","url":"https://tanqingbo.cn/clashvpn/","content":"在中国大陆，访问大部分境外网站（如 Google、YouTube、Twitter、ChatGPT 等）都会被网络防火墙阻断。常见问题包括：\n\n网站打不开 / 加载失败\n页面显示连接超时\n无法登录国际应用如 Discord、Telegram、OpenAI\n\n解决方法只有一个：使用科学上网工具+机场服务。\n\n🚀 科学上网 = 工具 + 节点（机场）你需要两样东西：\n\n科学上网工具：例如 Clash for Windows，用于接收并解析节点\n机场服务：例如「一支红杏」，提供高速稳定的加密节点，支持解锁 Google / YouTube / ChatGPT 等平台\n\n\n✅ 一支红杏机场简介（推荐）一支红杏是銘佑科技（香港）有限公司（也是老薛主机，不会跑路型）推出的网络加速器服务，基于 Trojan 协议的科学上网方式，该协议会将您需要代理的网络数据伪装成 HTTPS 协议的正常网络数据，以通过防火墙的检测和封锁，连接速度快，它会帮助你在互联网上冲浪时保护你的隐私和安全。\n\n支持 Windows、MAC OS X、cross platform、Android、IOS、openwrt等系统，是非常实用的网络代理软件。\n亲测真的很好用，网速很快，Google、youtubu、Facebook啥的都能上。\n\n🔗 官网地址：https://order.yizhihongxing.club/aff.php?aff=4818\n\n🖥 Win 电脑科学上网详细教程第一步：注册一支红杏账号并获取订阅链接\n打开官网：https://order.yizhihongxing.club/aff.php?aff=4818\n翻到下面会有VPN的注册方式，如果是个人用的话，选择入门版就可以了，一个月100G足够用了。\n跳转到订购页面后可以先在右上角点击注册，注册一个新账号，然后再根据提示购买你的产品。\n购买之后依次点击上方导航栏中的 产品与服务-&gt;我产品与服务-&gt;查看详情，就能看到你购买的节点信息。\n\n\n\n购买完代理服务器之后，接下来需要安装一个工具来辅助我们进行科学上网。\n\n第二步：下载 Clash for Windows（推荐工具）👉 下载地址（开源免费）：https://order.yizhihongxing.club/index.php?rp=/knowledgebase/13/\n下载安装好之后，前往 产品/服务 ，打开产品详情页面，向下滑动。\n点击 Clash 配置右侧的获得地址，在弹出的窗口中，选择 复制地址 或是 下载配置。\n\n\n第三步：导入一支红杏订阅链接\n打开 Clash for Windows\n\n左侧菜单点击【订阅/(Profiles)】（配置文件）\n\n粘贴一支红杏的订阅链接 &gt; 点击【导入】下载配置\n\n\n\n\n第四步：启动代理，开始上网\n在 Clash for Windows 界面左侧顶部开启「代理」开关\n选择一个延迟较低的节点（推荐香港 / 新加坡 / 日本）\n打开浏览器，访问 Google / YouTube / ChatGPT 测试即可\n\n\n🌎 一支红杏节点支持平台一览\n\n\n功能\n奶油云支持\n\n\n\nGoogle / YouTube / Gmail\n✅ 解锁\n\n\nChatGPT / OpenAI / Midjourney\n✅ 解锁\n\n\nNetflix / Disney+ / TikTok 海外版\n✅ 解锁（部分专线）\n\n\n支持协议\nVmess / VLESS / Trojan / SS\n\n\n\n❓ 常见问题解答Q：订阅导入后无节点？A：请检查 Clash 是否更新配置成功，或联系客服确认订阅是否正确。\nQ：YouTube 打不开、视频加载慢？A：建议更换节点（低延迟）、开启 TUN 模式、切换网络测试。\n\n✅ 总结Win 电脑要上外网，只需三步：\n\n注册一支红杏账号并获取订阅\n下载并安装 Clash for Windows\n导入节点、开启代理，立即畅游全网\n\n相比其他方法，Clash + 一支红杏机场方案安全、稳定、全平台支持，是目前最值得推荐的科学上网组合。\n📌 一支红杏官网地址：https://order.yizhihongxing.club/aff.php?aff=4818\n其它设备设置VPNiOS/MAC 端注册教程：iphone如何用外网/苹果手机搭梯子-翻墙VPN软件工具\nAndroid 端注册教程：安卓/Android系统手机实现科学上网教程-翻墙VPN软件工具\n","categories":["科学上网"],"tags":[]},{"title":"如何搭建HEXO静态博客网站","url":"https://tanqingbo.cn/HexoPage/","content":"前言\n建网站本身是一个很大的工程，涉及前端页面的搭建，网站数据的存储，还要购置服务器资源，甚至是后期的维护，过程相当繁琐。\n不过如果仅仅是想搭建个人的网站，写写博客，想要美观，又不想操心太多和写博客无关的事情。那么，Hexo + Kaze + Gitee Pages 的方式就很适合你。\n我自己的个人网站也是通过该方法搭建的：IT码农 - 一个专注于程序员成长的网站 | IT码农\n本文就讲下如何借助这三样免费的技术或服务，来搭建一个可访问的静态博客网站。\n\nHexo 简介Hexo 是什么？Hexo[1] 是一个快速，简单且功能强大的博客框架。如果你用 Markdown 写博客，Hexo 可以在几秒内生成带有精美主题的静态文件。\nHexo 安装前置要求\nNode.js（版本 10.13 以上，建议使用 12.0 以上版本）\nGit\n\n安装 Git\nWindows：下载并安装 git[2]。\nMac：使用 Homebrew[3] 安装。\nLinux（Ubuntu，Debian）：sudo apt-get install git-core\nLinux（Fedora，Red Hat，CentOS）：sudo yum install git-core\n\n安装 Node.jsNode.js 为大多数平台提供了 官方安装程序[4]。\n替代安装方法：\n\nWindows：使用 nvs[5] 安装它。\nMac：使用 Homebrew[6] 安装。\nLinux（基于 DEB / RPM）：与 NodeSource[7] 一起安装。\n其他：通过相应的软件包管理器进行安装。请参阅 Node.js 提供的指南[8]。\n\n安装 Hexo用 npm 安装 Hexo。\nnpm install -g hexo-cli\n\n\n\n\n使用以下指令查看是否安装成功。\nhexo version\n\n\n\n\n如果你想卸载 Hexo，使用以下指令：\nnpm uninstall -g hexo-cli\n\n运行 hexo安装后，你可以通过 hexo &lt;command&gt; 运行 Hexo。比如通过 hexo help 指令来获取使用帮助。\nhexo help\n\n\n\n\n帮助里提到 hexo init 命令可以创建一个新的 Hexo 文件夹，这个文件夹其实就是利用 Hexo 生成的站点信息了。接下来讲下怎么建站。\nHexo 建站初始化操作使用 hexo init &lt;folder&gt; 指令就可以在指定文件夹下建立站点信息，我一般用域名做名称，如下：\nhexo init java4u.cn\n\n站点初始化中：\n\n站点初始化完成，会生成指定的文件夹：\n\n目录结构进入该站点，我们看下目录结构，如下：\n\n图片\n这些文件有着各自的职责：\n\n_config.landscape.yml：自定义的主题配置文件，此处的 landscape 是默认主题。配置其他主题可以参考这种方式。\n_config.yml：站点全局的配置文件。\nnode_modules：node 模块文件夹。包含可执行文件和依赖的资源。\npackage-lock.json：node_modules 文件中所有模块的版本信息，模块来源。\npackage.json：Hexo 框架的基本参数信息以及它所依赖的插件。\nscaffolds：scaffolds 原意是脚手架，这里可以理解为模板文件夹。当你创建新的文章时，Hexo 会根据该文件夹下的对应文件进行初始化构建。\nsource：资源文件夹。这里是你放自己资源比如博文和图片的地方。_posts 文件夹下的 Markdown 和 HTML 文件会被解析并放到 public 文件夹下。其他文件或文件夹，如果开头命名不是 _ (下划线)，也都会被拷贝过去。\nthemes：主题文件夹。Hexo 会根据主题来生成静态页面。\n\n基于这样的结构，Hexo 就具备了生成静态网站的能力。\n本地启动我们先本地启动，看下实际效果。输入以下命令：\nhexo server\n\n\n\n\nHexo 会启动服务，将默认生成的网站运行在本机的 4000 端口上，可以直接访问 http://localhost:4000 就能看到网站首页，它基于默认主题生成，同时有一篇默认文章。\n\n这个页面只是官方提供的一个样例，看到它就意味着你本地环境跑通了。我们可以通过修改配置的方式，对页面相关元素做调整。\n核心配置以下是我们需要了解或者修改的配置信息。\npackage.json这个文件列出了 Hexo 的基本参数信息以及它所依赖的插件。可以看到，EJS[9]，Stylus[10] 和 Markdown[11] 渲染器都是默认安装的。\n{  \"name\": \"hexo-site\",  \"version\": \"0.0.0\",  \"private\": true,  \"scripts\": {    \"build\": \"hexo generate\",    \"clean\": \"hexo clean\",    \"deploy\": \"hexo deploy\",    \"server\": \"hexo server\"  },  \"hexo\": {    \"version\": \"\"  },  \"dependencies\": {    \"hexo\": \"^5.0.0\",    \"hexo-generator-archive\": \"^1.0.0\",    \"hexo-generator-category\": \"^1.0.0\",    \"hexo-generator-index\": \"^2.0.0\",    \"hexo-generator-tag\": \"^1.0.0\",    \"hexo-renderer-ejs\": \"^1.0.0\",    \"hexo-renderer-marked\": \"^3.0.0\",    \"hexo-renderer-stylus\": \"^2.0.0\",    \"hexo-server\": \"^2.0.0\",    \"hexo-theme-landscape\": \"^0.0.3\"  }}\n\n\n如果后边要切换主题，记得把最后一个默认的主题依赖删除掉。\n\n_config.yml可设置网站、网址、目录、文章、分类&amp;标签、日期/时间格式、分页和扩展等信息。\n网站\n\n\n\n参数\n描述\n\n\n\ntitle\n网站标题\n\n\nsubtitle\n网站副标题\n\n\ndescription\n网站描述，用于 SEO\n\n\nkeywords\n网站的关键词，支持多个关键词。\n\n\nauthor\n文章作者。\n\n\nlanguage\n网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 zh-Hans和 zh-CN。\n\n\ntimezone\n网站时区。Hexo 默认使用你电脑的时区。请参考 时区列表[12] 进行设置，如 America/New_York, Japan, 和 UTC 。一般的，对于中国大陆地区可以使用 Asia/Shanghai。\n\n\nURL\n\n\n\n参数\n描述\n默认值\n\n\n\nurl\n网址, must starts with http:// or https://\nhttp://example.com\n\n\nroot\n网站根目录，如果放子目录，设置 /blog/\n/\n\n\npermalink\n文章的 永久链接[13] 格式\n:year/:month/:day/:title/\n\n\npermalink_defaults\n永久链接中各部分的默认值\n\n\n\npretty_urls\n改写 permalink[14] 的值来美化 URL\n\n\n\npretty_urls.trailing_index\n是否在永久链接中保留尾部的 index.html，设置为 false 时去除\ntrue\n\n\npretty_urls.trailing_html\n是否在永久链接中保留尾部的 .html, 设置为 false 时去除 (对尾部的 index.html无效)\ntrue\n\n\n目录\n\n\n\n参数\n描述\n默认值\n\n\n\nsource_dir\n资源文件夹，这个文件夹用来存放内容。\nsource\n\n\npublic_dir\n公共文件夹，这个文件夹用于存放生成的站点文件。\npublic\n\n\ntag_dir\n标签文件夹\ntags\n\n\narchive_dir\n归档文件夹\narchives\n\n\ncategory_dir\n分类文件夹\ncategories\n\n\ncode_dir\nInclude code 文件夹，source_dir 下的子目录\ndownloads/code\n\n\ni18n_dir\n国际化（i18n）文件夹\n:lang\n\n\nskip_render\n跳过指定文件的渲染。匹配到的文件将会被不做改动地复制到 public 目录中。\n\n\n\n文章\n\n\n\n参数\n描述\n默认值\n\n\n\nnew_post_name\n新文章的文件名称\n:title.md\n\n\ndefault_layout\n预设布局\npost\n\n\nauto_spacing\n在中文和英文之间加入空格\nfalse\n\n\ntitlecase\n把标题转换为 title case\nfalse\n\n\nexternal_link\n在新标签中打开链接\ntrue\n\n\nexternal_link.enable\n在新标签中打开链接\ntrue\n\n\nexternal_link.field\n对整个网站（site）生效或仅对文章（post）生效\nsite\n\n\nexternal_link.exclude\n需要排除的域名。主域名和子域名如 www 需分别配置\n[]\n\n\nfilename_case\n把文件名称转换为 (1) 小写或 (2) 大写\n0\n\n\nrender_drafts\n显示草稿\nfalse\n\n\npost_asset_folder\n启动 Asset 文件夹[15]\nfalse\n\n\nrelative_link\n把链接改为与根目录的相对地址，建议使用绝对地址。\nfalse\n\n\nfuture\n显示未来的文章\ntrue\n\n\nhighlight\n代码块的设置, see Highlight.js[16] section for usage guide\n\n\n\nprismjs\n代码块的设置, see PrismJS[17] section for usage guide\n\n\n\n分类 &amp; 标签\n\n\n\n参数\n描述\n默认值\n\n\n\ndefault_category\n默认分类\nuncategorized\n\n\ncategory_map\n分类别名\n\n\n\ntag_map\n标签别名\n\n\n\n日期/时间格式\nHexo 使用 Moment.js[18] 来解析和显示时间。\n\n\n\n参数\n描述\n默认值\n\n\n\ndate_format\n日期格式\nYYYY-MM-DD\n\n\ntime_format\n时间格式\nHH:mm:ss\n\n\nupdated_option\n当 Front Matter 中没有指定 updated[19] 时 updated 的取值，支持 mtime(文件最后修改时间)，date(使用 date 的值)，empty(不指定)\nmtime\n\n\n分页\n\n\n\n参数\n描述\n默认值\n\n\n\nper_page\n每页显示的文章量 (0 = 关闭分页功能)\n10\n\n\npagination_dir\n分页目录\npage\n\n\n扩展\n【主题】\n\n\n\n参数\n描述\n默认值\n\n\n\ntheme\n当前主题名称。值为false时禁用主题\nlandscape\n\n\ntheme_config\n主题的配置文件。在这里放置的配置会覆盖主题目录下的 _config.yml 中的配置\n无初始配置\n\n\ndeploy\n部署部分的设置\n\n\n\nmeta_generator\nMeta generator[20] 标签。值为 false 时 Hexo 不会在头部插入该标签\ntrue\n\n\n【部署】\n配置如下：\ndeploy:  type: git  repo: &lt;repository url&gt; #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io  branch: [branch]  message: [message]\n\n\n\n\n参数\n描述\n默认\n\n\n\nrepo\n库（Repository）地址\n\n\n\nbranch\n分支名称\ngh-pages (GitHub) coding-pages (http://Coding.net) master (others)\n\n\nmessage\n自定义提交信息\n\n\n\ntoken\nOptional token value to authenticate with the repo. Prefix with $ to read token from environment variable\n\n\n\n常用指令创建文章使用以下指令：\nhexo new \"test\"\n\n或者简写：\nhexo n \"test\"\n\n\n\n\n运行服务器输入以下命令以启动服务器，你的网站会在 http://localhost:4000 下启动。在服务器启动期间，Hexo 会监视文件变动并自动更新，你无须重启服务器。\nhexo server\n\n或者简写：\nhexo s\n\n\n\n\n生成静态文件hexo generate\n\n或者简写\nhexo g\n\n监视文件变动立即重新生成。该操作会阻塞命令。\nhexo g --watch\n\n生成完毕后自动部署网站。\nhexo generate --deploy\n\n部署Hexo 提供了快速方便的一键部署功能，让你只需一条命令就能将网站部署到服务器上。\nhexo deploy\n\n或者简写为：\nhexo d\n\nHexo 主题为什么选择 KazeHexo 默认主题为 landscape，但我觉得不够美观，这里推荐 kaze[21] ,它有以下特性：\n\n响应式设计，适配桌面端、平板、手机等各种设备\n\n前端性能优化，加载快速，眨眼之间即可加载完成\n\n\n图片懒加载，应用懒加载技术加快页面的生成速度\n\n\n资源压缩，提升本地资源请求速度\n\n精简设计，不包含 Jquery 等额外库\n\n支持侧边栏小组件，例如最近文章，作者卡片\n\n暗黑模式，享受黑夜的魅力\n\n代码高亮，支持 prismjs\n\n公式渲染，支持 katex 和 mathjax\n\n评论系统，集成 valine、gitalk 和 livere\n\n访问量统计和谷歌分析支持\n\n\n安装 Kaze在 your site/themes 下输入\ncd themesgit clone https://github.com/theme-kaze/hexo-theme-Kaze.git\n\n\n\n\n安装成功后，会生出目录：hexo-theme-Kaze。\n修改站点配置文件 _config.yml 下的主题值为：hexo-theme-Kaze。\n\n用 hexo server 启动 Hexo 服务看下效果。\n\n会看到已经生成了默认的主题，只是很多东西都没有，需要改造一下。\n主题配置可在该主题目录下的 _config.yml 文件里配置。\n主题颜色在 color 中进行配置，以下是默认值。\ncolor:  text-color: \"#3c4858\"  text-strong-color: \"#2f3d4e\"  text-light-color: \"#909faf\"  divider-color: \"#e6e8ee\"  title-color: \"#475b6d\"  link-color: \"#3273dc\"  link-hover-color: \"#6596e5\"  info-text-color: \"#909faf\"  widget-background-color: \"#fff\"  body-background-color: \"#f2f5f8\"  border-color: \"#e1e4e9\"  pre-color: \"#2d2d2d\"  code-color: \"#50687c\"  code-background-color: \"#e9eaf0\"\n\n字号与字体在 font 中进行配置，以下是默认值。\nfont:  font-size: 16px # global font-size  font-family: '-apple-system,BlinkMacSystemFont,\"Segoe UI\",\"Helvetica Neue\",\"PingFang SC\",\"Microsoft YaHei\",sans-serif' # global font-family\n\n站点访问量统计访问量统计目前仅支持不蒜子，默认关闭，可统计站点总访问量和总访客数。\nfooter:  #------------------------  # pv / uv statistics config  #------------------------  statistics:    enable: false    type: busuanzi # now version only supports busuanzi    pv:      enable: true      style: 本站总访问量{}次 # the style will be shown as $1{pv}$2    uv:      enable: true      style: 本站总访客数{}次 # the style will be shown as $1{uv}$2\n\n数据分析analytics:  enable: false  type: google # google  google:    id:\n\nenable 开启分析支持（默认关闭）\ntype 目前仅支持 google\ngoogle.id 有关谷歌分析的具体使用说明和 id 使用可以参考谷歌文档[22]\n首页文章头图在文章 Front-matter 中 banner_img 可以设置首页头图\n小组件widgets:  showWidgetsMobiles: \"none\"\n\nshowWidgetsMobiles : 在窄屏幕上是否显示小组件，none 关闭（默认），flex 开启\n关于关于页面需要自行创建，在站点 source 中新建 about 文件夹并在文件夹内创建 index.md，该文件至少需要包含\n# at ${yoursite}/about/index.md---title: 关于layout: about---\n\n社交链接在 about 下的 social_links中进行配置，主题图标依赖于 iconfont[23]，Hexo 内置了一部分社交图标，你可以自定义其他 icon 文件或者解决方案来添加自定义图标。\nabout:  description: description  social_links:    - { icon: icon-github, link:  https://xxx}    # - { icon: icon, link: your link }\n\n\n\n\n友链友链格式按如下填写即可生成友链页面\nlinks:  example-name-1:    url: https://example.com    avatar: https://example.com/avatar.jpg  example-name-2:    url: https://example.com    avatar: https://example.com/avatar.jpg\n\n文章页搜索功能search:  enable: true  path: search.json  field: posts  searchContent: true\n\n\nenable 开启搜索功能（默认开启）\npath 文件名称（暂无用处）\nfield 需要搜索的范围，支持 posts | pages | all\nsearchContent 搜索文件是否包含正文内容（不建议开启，包含所有文章内容这样会使得搜索文件异常巨大）替代方案是搜索分类标签或使用 algolia 等第三方搜索服务（Todo）\n\n目录主题目录通过 Hexo 原生函数生成，具体可参见 文档[24]\ntoc:  showListNumber: false  maxDepth: 6  minDepth: 1\n\nshowListNumber 是否生成编号\nmaxDepth TOC 最大深度\nminDepth TOC 最小深度\n代码高亮参见代码 高亮文档[25]\n数学公式主题支持 mathjax 和 katex 两种渲染引擎，具体参见 相关文档[26]\ncopyrightcopyright:  enable: true  writer: # if writer is empty we will use config.author as writer  declare: 本博客所有文章除特别声明外，均采用&lt;a target=\"_blank\" rel=\"noopener\" href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh\"&gt;CC BY-NC-SA 4.0 协议&lt;/a&gt;。转载请注明出处！  style: warning\n\nenable 开起版权说明（默认开启）\nwriter 作者id，如果不填则会使用主题配置 author 或站点配置 author\ndeclare 版权声明具体内容，支持 html 语句\nstyle 声明内容样式，与 note 样式相同\n版权内容有三部分：作者、文章链接、版权声明\n作者使用 writer 参数，文章链接基于站点配置文件中url参数生成，版权声明使用 declare 参数\nFront-matterbanner_img设置文章与首页头图\nbanner_img_set在图片加载时预先加载的图片，可以设置为 loading 图或缩略图等\nexcerpt为文章设置在首页显示的简介，还可以通过 &lt;!--more--&gt; 来控制显示\n评论支持 valine，gitalk 和 livere\n具体设置可参考主题配置文档说明和相关评论插件文档\n字数统计主题集成 hexo-wordcount[27] 插件，在主题配置文件中设置\nwordcount:  enable: true\n\n开启（默认开启）\n图片画廊图片画廊功能基于 fslightbox[28]，在主题配置文件中设置\nfslightbox:  enable: true\n\n开启（默认开启）\n标签插件主题集成了一些标签方便书写\nnote在 markdown 文件中如下书写即可\n{% note style %}...markdown content{% endnote %}\n\n有五种样式可以选择，primary，success，info，warning，danger\n\n备案信息你可以在主题配置文件内增加备案信息。\nfooter:  #------------------------  # 备案配置  # 请将公安备案的缩略图置于 ${yoursite}/img/beian.png  RecordInfo: \"\" # '某ICP备xxx号'  govRecordInfo: \"\" # '某公网安备xxx号'  govRecordUrl: \"\" # 公网安备案信息地址  #------------------------\n\n站点托管为什么选择 Gitee PagesGitHub 和 Gitee 都提供免费的静态网页托管服务。我们可以使用 GitHub Pages 或 Gitee Pages 托管博客、项目官网等静态网页，这样就省去了购买服务器的钱，也不需要耗费太多精力维护。\nGitHub Pages 使用很广泛，我之前也用过，不过访问不够稳定，会影响页面加载速度。Gitee 是国内版的 GitHub，访问速度优秀，并且国内发展势头不错，因此我选取 Gitee Pages 来托管我的网站。\n建立仓库申请一个 Gitee 账号，创建一个新的仓库，仓库名尽量和账号名一致，这样可以避免一些因为路径引发的问题。\n\n然后在仓库首页服务一栏开启 Gitee Pages 服务。\n\n开启后，你就拥有了专属的二级域名网址。\n注意：仓库内容有变化，需要手动触发更新，页面才能真正生效。\n连接仓库一、安装 hexo-deployer-git[29]。\nnpm install hexo-deployer-git --save\n\n\n\n\n二、修改配置。\ndeploy:  type: git  repo: git@gitee.com:java4u/java4u.git\n\n注意上面的 repo 地址并不是仓库的地址，而是你下载/克隆项目时弹出的那个地址，type 如果是 git 就选择 SSH。\n\n图片\n三、生成/添加 SSH 公钥\nGitee 、GitHub 提供了基于 SSH 协议的 Git 服务，在使用 SSH 协议访问仓库仓库之前，需要先配置好账户/仓库的 SSH 公钥。\n先看下自己有没有配置过用户名和邮箱：\ngit config --global user.namegit config --global user.email\n\n\n\n\n如果没有就做下配置：\n# 设置邮箱git config --global user.email *********@qq.com# 设置用户名git config --global user.name '****'\n\n然后本地生成 SSH 公钥，邮箱为刚配置好的账户：\nssh-keygen -t rsa -C yong__1994@163.com\n\n生成后可查看 SSH 公钥：\ncat ~/.ssh/id_rsa.pub\n\n复制公钥去 Gitee 粘贴，添加。\n\n图片\n测试是否连接成功：\nssh -T git@gitee.com\n\n\n\n\n上传仓库执行部署命令，即可将本地资源上传远程仓库。\nhexo d\n\n\n\n\n图片\n手动更新远程仓库虽然可以看到提交记录，但静态网站不会感知到实时变更，需要去 Gitee Pages 服务页面做下更新。\n\n稍等片刻，访问 http://tanqingbo.cn 即可看到 Hexo 结合 kaze 主题搭建的静态网站。\n\n","categories":["编程资料"],"tags":["操作系统"]},{"title":"外网流媒体自由！","url":"https://tanqingbo.cn/popcorn/","content":"经常看海外剧的可能都知道外网的流媒体平台，比如网飞、HBO Max、Disney+、Prime Video，还有苹果的 tv+ 等，每家也都有自己拿得出手的王牌节目。如果有一个地方可以看众多流媒体的节目，岂不是爽哉！\n流媒体拼车服务商“环球巴士”就推出了一个五大外网流媒体的打包拼车服务——爆米花（popcorn）。只需一次订阅，在订阅期内就可以畅享网飞、HBO Max、Disney+、Prime Video、Crunchyroll 这五个平台的节目，也不需要挨个登录平台账号。\n\n前面四个相信大家都很熟了，Crunchyroll 我以前也没听过。Crunchyroll 专注于动漫内容，比如海贼王、进击的巨人、龙珠、火影忍者、SPY 等等都可以在这个平台观看。\n\n先说价格全家桶（包含所有 5 个平台）订一个月 ¥39.88，订一年 ¥349.88，平均一天不到一块钱。\n下单时用我的优惠码 Tanqingbo，可以有9折优惠，全家桶一年就只要 ¥314.89，不过优惠仅限「环球巴士」新用户。\n也可以只买单个流媒体，比如网飞一个月 ¥16.8，一年 ¥188.88。Crunchyroll 一年 ¥99.88。都比单独买拼车账号便宜不少。\n限制是什么？首先需要下载爆米花（popcorn）客户端，目前只有 Mac 和 Windows 版，其他平台还在开发中。所以如果你想在手机、iPad 或者 Apple TV 等流媒体盒子上直接看，这个就不适合你了。想在电视、投影等大屏上使用，只能把电脑通过 HDMI 线连到大屏上。\n另外，特殊网络条件也是要自己准备好的（亲测 hk、tw 节点最佳，并且界面会显示简中或繁中）。\n怎么买？扫描👇下方二维码（或链接）进入环球巴士。\n\n传送门：https://universalbus.cn/?s=wX0haoloon\n点「爆米花」的「上车」按钮，选择订阅时长和平台，购买后会收到兑换码。\n\n怎么兑换先通过下方链接下载并安装爆米花（Popcorn)）客户端，建议复制后在电脑浏览器打开。\nhttps://universalbus.cn/popcorn\n打开爆米花客户端，先注册账号登录，然后点右上角头像-我的兑换。\n\n输入兑换码，再点「立即兑换」就行了。\n\n回到爆米花客户端首页，想看哪个平台，就点平台 logo，然后点「开始播放」，就会在浏览器中打开这个平台，并且是已经登录好账号了。\n\n如果你更习惯在手机、iPad 上看，或者只想看某个平台，也可以买单独平台车。「环球巴士」的平台车非常丰富，涵盖 Netflix、Disney+、Max、Prine Video、Apple tv+、Hulu、Peacock、Paramount+、Crunchyroll。新用户输入优惠码 huang 同样可以在原价基础上打折。\n\n\n","categories":["科学上网"],"tags":[]},{"title":"无意中发现一位大佬的算法刷题pdf笔记","url":"https://tanqingbo.cn/halfrost/","content":"昨晚逛GitHub，无意中看到一位大佬（https://github.com/halfrost）的算法刷题笔记，感觉发现了宝藏！有些小伙伴可能已经发现了，但咱这里还是忍不住安利一波，怕有些小伙伴没有看到。\n关于算法刷题的困惑和疑问也经常听朋友们提及。这份笔记里面共包含作者刷LeetCode算法题后整理的数百道题，每道题均附有详细题解过程。很多人表示刷数据结构和算法题效率不高，甚是痛苦。有了这个笔记的总结，对校招和社招的算法刷题帮助之大不言而喻，果断推荐给大家。\n\n\n\n\n\n需要刷题笔记PDF文档的小伙伴可以直接点击下方链接下载：\n\n链接：https://pan.baidu.com/s/12VD7NnF2NJEgGsCoOIkNyw提取码：w31k\n\n每天进步一点点\n慢一点才能更快\n加油！\n更多干货内容，可以去我的个人网站：https://tanqingbo.cn/\n","categories":["数据结构与算法"],"tags":[]},{"title":"GPT-4o国内怎么使用？详细方法来了！！","url":"https://tanqingbo.cn/GPT-4o/","content":"最近两天，大家都被GPT-4o生图功能刷屏了。\n文末附上体验方式。\n还不了解的，先看老夫新测试的案例，下图是找的一张买家秀\n\n\n其他功能我都是半服，但这个精修我是真的服，拍摄都省了。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n再来一张\n\n上次的文章有很多人问，怎么进，有没有网址。\n\n目前国外GPT-4o有生图功能是20美元一月，约145元人民币。更高级版200美元一月，需要科学上网。\n\n\n下面分享一个网站，国内可以直接进入。\n无需gpt账号，无需科学上网，超方便。\n新用户填优惠码Tanqingbo，还有优惠价。\n\n一、登录网站，电脑和手机都可用。\n传送门：\nhttps://universalbus.cn/?s=wX0haoloon\n\n二、选择版本\n我自己买的标准版，6小时/60次。大家可以根据自己需求选择。\n这个对很多想体验下的宝子来说，完全够用了。6小时重置一次，自动恢复额度。\n\n标准版官方价格是48.88一个月，购买时候填写优惠码：Tanqingbo，新用户可打88折。\n标准版折后是：43.01元， 基础的折后：25.41元\n\n三、购买之后，从车票车队里点进去就能用\n无需gpt账号，无需科学上网，直接用。\n\n进入车队，有很多对话框\n\n选择一个对话，点击就直接跳转到gpt网站。\n\n如果使用中提示频率限制，就换一个对话重新进入。\n\n由于最近几天比较火，现在gpt生图卡顿也是时好时坏，每个人都会遇到，老夫也一样。\n遇到其他问题，也可以联系官网首页的客服。\n其他就不多说了，感兴趣的宝子快去体验吧。\n\n","categories":["科学上网"],"tags":[]},{"title":"PicGo + Gitee(码云)实现markdown图床，Typora配置PicGo","url":"https://tanqingbo.cn/PicGo-Gitee/","content":"markdown是一门易于上手能帮助作者专心写作的文档编辑语言，它的好处太多了，建议想自己动手做笔记写博客的朋友都可以学一学，10分钟上手（我昨天晚上还不会用，今天就开始用它写博客了。。足以证明它是真的很简单）\nTpyora是一款优雅的markdown编辑器，也推荐给大家，至于安装和配置，比安装word还简单，就不赘述了\n但是，这都不是重点，重点是咱们写博客的时候，总是需要插入图片的，图片存在本地的话上传到博客网站去就没法显示了，就算一个图一个图的复制粘贴上去，想移植到其他的博客网站，图就会失效，我们就需要图床\n\n图床是干什么的？图床就是一个便于在博文中插入在线图片连接的个人图片仓库。设置图床之后，在自己博客中插入的图片链接就可以随时随地在线预览了，并且不会因为任何意外原因无法查看，除非自己亲自删除。\n\n神奇的PicGo就是为了解决这个问题诞生的，它可以将图片上传到指定的图床上，然后返回markdown链接，直接粘贴到你的文档中，就搞定啦\n问题又来了，网上推荐七牛云阿里云都是要租赁服务器的，太麻烦还要钱，微博现在挂链接又很厉害。大部分人选择用github，但是github虽好却是国外的网站，速度终究比不上国内网站，研究了小半天，终于发现完美的解决方案\n最终决定使用PicGo + gitee码云来实现markdown图床\n废话说到这里，开始进入正题\n1. 安装\nPicGo\npicgo-plugin-gitee-uploader插件\n\n首先打开picgo官网，下载安装包\n如果速度慢，点击此地址下载：\nmac:  https://gschaos.club/down/PicGo-2.3.0-beta.3-mac.zip\nwin:  https://gschaos.club/down/PicGo-Setup-2.3.0-beta.3.exe\n安装之后打开主界面\n选择最底下的插件设置，搜索gitee\n点击右边的gitee-uploader 1.1.2开始安装\n这里注意一下，必须要先安装node.js才能安装插件，没装的自己装一下，然后重启就行。\n\n\n2. 建立图床库点击右上角的+号，新建仓库\n新建仓库的要点如下：\n\n输入一个仓库名称\n其次将仓库设为公开\n勾选使用Readme文件初始化这个仓库\n\n\n点击下一步完成创建\n\n3. 配置PicGo安装了gitee-uploader 1.1.2插件之后，我们开始配置插件\n配置插件的要点如下：\n\nrepo：用户名/仓库名称，比如我自己的仓库MysticalYu/pic，找不到的可以直接复制仓库的url,复制浏览器的仓库地址，而不是页面左上角显示的，容易出现大小写问题\n\n\n\nbranch：分支，这里写上master\ntoken：填入码云的私人令牌\npath：路径，一般写上img\ncustomPath：提交消息，这一项和下一项customURL都不用填。在提交到码云后，会显示提交消息，插件默认提交的是 Upload 图片名 by picGo - 时间\n\n这个token怎么获取，下面登录进自己的码云\n点击头像，进入设置\n\n\n\n找到右边安全设置里面的私人令牌\n\n\n\n点击生成新令牌，把projects这一项勾上，其他的不用勾，然后提交\n\n\n这里需要验证一下密码，验证密码之后会出来一串数字，这一串数字就是你的token，将这串数字复制到刚才的配置里面去。\n\n\n注意：这个令牌只会明文显示一次，建议在配置插件的时候再来生成令牌，直接复制进去，搞丢了又要重新生成一个。\n\n保存，完成即可。4. 将仓库配置成giteePage页我们需要通过链接来访问图片，这里将刚才建立的仓库设置成GiteePage页\n\n点击服务，选择Gitee Pages\n\n\n\n如果自己想使用Https的图片，比如自己的博客网站是支持SSL认证的话，可以勾选强制使用Https;    这里参考：为什么部署SSL证书后还是提示不安全\n\n\n开启成功后再次访问就会变成下面的页面，这里的更新间隔是一分钟，需要手动更新，当然也可以配置WebHook触发服务器钩子来调用API自动更新，这里不涉及这方面，不展开。\n\n这样我们就获得了一个可以访问的网址通过这个网址和上面PicGo配置的Path组合就可以访问我们需要的图片的。类似这种：\nhttps://mysticalyu.gitee.io/pic/img/20200409141450-lee-gh-2.jpg\ngitee图床访问异常如果你是要用gitee作为自己博客的图床的话，当我们获得上述图片链接之后可能还是不能在我们的博客中正常显示，那是因为gitee上了防盗链，不允许自己和外部未授权站点请求图片资源，这个过程是使用请求头里面的referer字段实现的，它会判断用户ip来源，然后禁止掉非法访问。\n我们只需要在HTML的head部分加上这样一行代码就可以解决了：\n&lt;meta name=\"referrer\" content=\"no-referrer\" /&gt;\n\n如果你是Hexo主题博客的话，可以在主题目录下的：layout/_partial/head.ejs中添加meta标签\n\nTypora配置PicGo**一个编写md文件的神器，官网地址：https://typora.io/ **  使用方法和基本配置见百度谷歌。\n这里说明一下如何配置PicGo文件上传到服务器。\n配置如下\n\n\n配置好PigGo的执行文件\n验证一下图片是否能上传成功\n\n\n这里可以选择插入图片的操作，比如直接上传服务器。\n以上配置后，基本就可以实现自己的图床了。\n推荐阅读Windows 翻墙教程：从零开始科学上网（最稳定的科学上网方案）\n苹果/IOS系统手机实现科学上网教程-翻墙VPN软件工具\n安卓/Android系统手机实现科学上网教程-翻墙VPN软件工具\n","categories":["工具"],"tags":["PicGo","Gitee"]},{"title":"Github双因素身份验证（2FA）注册教程","url":"https://tanqingbo.cn/GitHub-2FA/","content":"前言为了保证开发者账号的安全性，Github目前开始对有过代码贡献的开发者账号强推2FA认证。开发者收到Github官方邮件之日起一段时间内，可自行前往启用并注册2FA，而在这段时间后，开发者将无法正常使用Github，登录Github后将自动跳转至2FA的注册页面，我收到的邮件原文部分翻译如下：\n\nGithub将正式开始要求在GitHub.com上贡献代码的用户启用一种或多种形式的双因素身份验证(2FA)。 您收到此通知是因为您的帐户符合此标准，并且需要在2023年10月6日00:00 (UTC)之前注册2FA。\n您将在45天内通过电子邮件和平台收到额外的提醒。 在这45天的窗口之后，您对GitHub.com的访问将受到限制，直到您注册2FA。 我们认为你应该知道以下几点:\n\n2FA注册是必需的，如果您在2023年10月6日00:00 (UTC)之前没有注册，您将无法访问GitHub.com，直到您完成注册过程。 一旦您注册，您将无法在未来禁用2FA。\n注册2FA很容易，我们接受几个选项，包括TOTP移动应用程序，短信(SMS)，安全密钥和GitHub移动。 点击这里开始吧!\n已经注册了2FA? 谢谢你！ 此时你不需要采取任何行动。\n\n\n方式了解了注册2FA的必要性，下面直接进入注册教程。\n2FA提供了两个注册选项，分别是：\n\n使用认证App填写验证码\n接收sms短信验证码\n\n一、使用认证App （Authenticator App）1、安装身份验证浏览器插件验证界面如下：\n\n验证的app，官方推荐使用app或者拓展，如 1Password、Authy、Microsoft Authentator 或者生成一次性的密码的方式等等，这里为了方便注册，推荐一个使用浏览器插件的简便方式。\n身份验证器\n\n火狐插件传送门：身份验证器\nChrome插件传送门：身份验证器\nMicrosoft Edge传送门：(Authenticator: 2FA Client - Microsoft Edge Addons)\n2、点击插件右上角扫一扫，扫描页面中的二维码找到安装的浏览器插件左键打开主界面，点击扫一扫，扫描页面中的二维码，此时插件会出现一个6位数验证码，复制该验证码填写到Github页面的输入框进行提交。\n\n3、保存你的找回密码提交后进入到第二步，此时Github会给你生成找回密码，点击右下角Download下载txt文件，妥善保存你的找回密码。\n\n4、验证成功完成上一步密码保存后，就已经设置成功了，成功界面如下：\n\n此时你可以进一步设置安全Key，或者下载Github官方App来管理账号安全设置。\nGithub App官方下载地址传送门：\n苹果：App Store传送门\n安卓：谷歌应用市场传送门\n至此，我们的Github 2FA设置完成,下次使用密码登录的时候，便要求进行2次验证码认证了。\n二、接收sms短信验证码认证页面滑动到底部，可以看到SMS认证选项，点击右边Select按钮，切换到短信验证码验证界面。\n\nSMS认证界面：\n首先你需要进行验证码图片校验，验证通过后就会显示该界面。 \n\n经过查验，国家或区域代码中没有【China +86】选项，也就是不支持国内的手机号，如果没有国外手机号，这个方式可以放弃了。\n\n登录认证当我们成功设置2FA之后，下次使用账户密码登录Github后，还需要我们填写一个6位随机验证码，此时我们使用上述插件，复制插件内最新的验证码，填写到输入框进行验证即可。\n\n推荐阅读：\nWindows 翻墙教程：从零开始科学上网（最稳定的科学上网方案）\n苹果/IOS系统手机实现科学上网教程-翻墙VPN软件工具\n安卓/Android系统手机实现科学上网教程-翻墙VPN软件工具\n","categories":["科学上网"],"tags":[]},{"title":"香港银行开户保姆及教程，一天线上搞定了汇丰、中银、众安、天星、蚂蚁5家银行！","url":"https://tanqingbo.cn/HK-bank/","content":"准备工作 (漏了就白跑，别问我怎么知道的):证件: 身份证、港澳通行证，有效期都得大于6个月。手机号: 必须开通国际漫游收验证码！上网是另一回事。出入境记录: 抵港后，微信小程序“12367”下载PDF，只要有一次内地出境记录就行。收卡地址: 提前翻译好中英文，地址太长学点缩写 (Building→BLDG)。银行APP: 提前下好汇丰、中银、众安、天星，蚂蚁银行在支付宝小程序。\n开户流程:到香港找个信号好的地方开干。推荐顺序：先汇丰，再中银，最后搞定剩下的虚拟银行。\n🚀 第一站：汇丰银行 (HSBC)这家是老牌大哥，必须拿下。全程APP线上操作。打开 HSBC HK APP，点“我没有任何账户”。关键选择：“身处香港，没有香港身份证”。账户类型选 “汇丰one”。填信息：开户用途：就选“储蓄/投资”，别整那些复杂的。税务编号：就是你的内地身份证号。收件地址：把你准备好的中英文地址填进去，注意字数限制。上传资料：按提示拍身份证，然后用手机 NFC 功能把通行证贴在手机背后，它会自动读取芯片信息。设置用户名密码，提交。顺利的话，几分钟内就会收到审核通过的邮件。然后就等着收卡吧。\n\n🥈 第二站：中银香港 (BOCHK)中银也算是亲儿子，流程也挺顺。打开 BOCHK APP，点“开立账户”。身份选“中国居民身份证”，然后选 “我身处香港”。开户方式选“我不在分行”，然后“即时开立”。账户类型选 “自在理财”，这个也没存款要求。上传资料：这里就要用到你之前准备的出入境记录PDF了。然后按要求拍身份证和港澳通行证。人脸识别，找个亮堂点的地方。填个人信息：职业如实写，开户理由选“投资理财”或“储蓄”。地址一定要详细到门牌号。提交后也是很快出结果。\n\n🎯 第三、四、五站：众安、天星、蚂蚁这三家是虚拟银行，流程大同小异，放在一起说。基本就是填资料、上传证件、人脸识别三板斧。有几个点注意下：地址：同样要精确到门牌号。税务身份：一般都选“仅为内地税务居民”。税务号：填身份证号。出入境记录：都要上传。众安银行比较灵活，可以开户后，离港了再补充上传。\n\n","categories":["技术以外"],"tags":[]},{"title":"2025最佳AI工具：国外最新人工智能工具一览","url":"https://tanqingbo.cn/Best-AI-tools/","content":"在当今的科技世界中，人工智能（AI）已经成为了我们生活中不可或缺的一部分。它不仅改变了我们的生活方式，也正在逐步改变我们的工作方式。ChatGPT、DeepSeek等人工智能工具引起了广泛的关注和讨论，这无疑证明了AI在我们生活中的影响力。然而，它们只是众多优秀AI工具中的一员。实际上，现在的AI工具已经覆盖了各个领域，包括文本生成、图像生成、视频生成，以及音频和音乐生成等。这些工具不仅能帮助我们提高工作效率，还能为我们的生活带来更多的便利和乐趣。\n在本文中，我们将介绍一些国外最佳AI工具，包括它们的功能，以及它们如何改变我们的生活。我们将从对话AI工具和文本生成器开始，然后探讨AI图像生成器，接着是AI视频生成器，最后我们将研究AI音频和音乐生成器。在文章的最后，我们将对这些工具进行总结，并探讨AI的未来发展趋势。\n\n第一部分：对话式AI工具和文本生成器对话式AI工具和文本生成器是一类可以根据用户的输入生成各种类型的文本的AI工具。它们可以帮助用户完成各种任务，如写作、学习、娱乐等。它们也可以与用户进行交流，提供信息、建议、反馈或趣味。综合各大AI评测排行榜的数据，下面是一些优秀的对话式AI工具和文本生成器：\n1. ChatGPT\n网站：ChatGPT官网\nChatGPT可能是最有名的AI工具了，它是一个可以用聊天的方式帮助用户完成各种文本任务的AI助手，基于互联网上数十亿词汇训练而成的大规模语言模型。它可以为任何目的生成文本，如电子邮件、论文、诗歌、说唱等，也可以回答问题、解决问题、提供反馈或进行有趣的聊天。ChatGPT有多个版本的大规模语言模型，可以根据用户的需求选择。它广泛地被研究人员、开发者、学生、作家和爱好者使用。ChatGPT目前还没有对中国用户开放，所以在中国使用ChatGPT还有一些壁垒（参阅我们的ChatGPT注册教程）。\n2. Gemini\n网站：Gemini官网\nGemini是谷歌开发的最新一代对话式AI工具，它取代了之前的Bard。Gemini集成了谷歌最先进的AI技术，在多模态理解和生成方面表现出色，能够处理文本、图像、音频和视频等多种类型的信息。它可以用于各种任务，如信息搜索、内容创作、编程辅助等。参阅：Gemini在中国怎么用？\n3. Grok\n网站：Grok官网\nGrok是由xAI公司开发的一款AI助手，旨在提供更开放和有趣的对话体验。Grok以其幽默感和对问题的独特见解而闻名，它可以回答各种问题，并提供不同寻常的回答。目前，Grok主要集成在X平台上，供X Premium+订阅者使用。\n4. Claude\n网站：Claude官网\nClaude是Anthropic公司开发的下一代AI助手。Claude可以通过聊天界面和开发者控制台的API进行访问，能够完成各种对话和文本处理任务，同时保持高度的可靠性和可预测性。Claude可以帮助处理包括总结、搜索、创意和协作写作、问答、编码等在内的用例，还可以接受关于个性、语气和行为的指示。Anthropic公司提供了多种版本的Claude，可以根据不同的需求选择最合适的模型。\n5. Microsoft Copilot网站：Microsoft Copilot官网\nMicrosoft Copilot是一款集成在Windows和Microsoft 365中的AI助手，旨在提高用户的生产力。它可以帮助用户完成各种任务，如撰写电子邮件、创建演示文稿、总结文档等。Copilot利用了OpenAI的大规模语言模型，并结合了微软的生产力工具，为用户提供强大的AI支持。\n6. Mistral AI网站：Mistral AI官网\nMistral AI是一家欧洲的AI公司，致力于开发开源的大规模语言模型。他们的模型以其高效性和灵活性而著称，可以在各种硬件平台上运行。Mistral AI的模型可以用于各种任务，如文本生成、语言翻译、代码生成等，为开发者和企业提供强大的AI能力。\n\n第二部分：AI 图像生成器\n在这个部分，我们将介绍一些出色的AI图像生成器。这些工具可以根据用户的需求生成各种类型的图像，包括艺术作品、产品设计、动画角色等。它们的应用范围非常广泛，可以满足各种创意需求。\n1. Midjourney\n网站：Midjourney官网\nMidjourney以其卓越的艺术风格和高质量图像生成能力而闻名。它特别擅长创作风格化的图像，非常适合艺术家、设计师和任何寻求独特视觉效果的用户。用户只需输入简单的文本提示，Midjourney就能生成令人惊叹的图像。\n2. DALL-E 3网站：DALL-E 3官网\nDALL-E 3是OpenAI推出的最新一代图像生成模型。与前几代相比，DALL-E 3在理解复杂提示和生成逼真图像方面有了显著提升。它可以根据详细的文字描述生成高度还原的图像，适用于各种创意项目和设计任务。\n3. Adobe Firefly\n官网：Adobe Firefly官网\n Adobe Firefly是Adobe推出的AI图像生成工具，它与Adobe Creative Cloud紧密集成，为专业设计师提供了无缝的工作流程。Firefly可以与Photoshop、Illustrator等Adobe软件协同工作，提供强大的图像生成、编辑和修饰功能，极大地提高了设计效率。\n4. Stable Diffusion XL网站：Stable Diffusion XL官网\nStable Diffusion XL是一个开源的图像生成模型，以其高度的灵活性和可定制性而受到技术用户的青睐。用户可以根据自己的需求调整各种参数，生成具有独特风格的图像。Stable Diffusion XL的开源特性也促进了社区的协作和创新。\n5. Leonardo AI网站：Leonardo AI官网\nLeonardo AI专注于游戏开发和设计领域的图像生成。它提供了丰富的模型和工具，可以帮助游戏开发者快速创建高质量的游戏素材，如角色、场景、道具等。Leonardo AI的专业化功能使其成为游戏美术设计师的得力助手。\n\n第三部分：AI视频生成器\n随着技术的发展，AI现在已经能够生成令人惊叹的视频内容。这些工具可以根据用户的需求和描述，创造出各种类型的视频，包括动画、电影片段、音乐视频等。无论你是一名电影制作人，还是只是想要为你的社交媒体帖子创建一些有趣的视频，AI视频生成器都能为你提供强大的帮助。让我们一起来看看这些最先进的AI视频生成器吧。\n1. RunwayML网站：RunwayML官网\nRunwayML提供了一系列强大的AI视频编辑和生成工具，适合需要高级功能的创意专业人士。其功能包括文本到视频生成、风格迁移、对象移除、绿幕抠图等，可以帮助用户实现各种复杂的视频特效和创意。\n2. Synthesia\n网站：Synthesia官网\n Synthesia专注于AI虚拟人视频生成。它提供了多种AI虚拟人形象和语言选择，用户只需输入文本，即可快速生成由虚拟人播报的专业视频内容。Synthesia广泛应用于企业培训、产品演示、新闻播报等领域。\n3. Pika Labs网站：Pika Labs官网\nPika Labs专注于AI驱动的动画和视觉效果生成。它提供了易于使用的界面和强大的功能，使用户能够快速创建各种动画和视觉效果，无需专业的动画制作技能。Pika Labs适用于制作短视频、社交媒体内容、广告等。\n4. Descript网站：Descript官网\nDescript是一款多功能的视频和音频编辑工具，它集成了AI驱动的音频转录、编辑和视频编辑功能。Descript可以自动将音频和视频转录为文本，用户可以通过编辑文本来编辑音频和视频，极大地简化了编辑流程。Descript特别适合播客、视频创作者和内容营销人员。\n5. Invideo AI网站：Invideo AI官网\nInvideo AI专注于快速生成各种类型的营销和社交媒体视频。它提供了大量的模板、素材和预设动画，用户只需进行简单的拖拽和编辑，即可创建引人注目的视频内容。Invideo AI适合营销人员、社交媒体运营者和小企业主。\n\n第四部分：AI音频、音乐生成器\nAI音频和音乐生成器可以根据你的需求生成各种类型的音频，包括音乐、对话、声音效果等。它们可以帮助你创作出独特的音乐作品，或者为你的项目提供背景音乐。这些工具的使用非常简单，你无需拥有专业的音乐制作技能，只需要一些创意和热情。\n1. AIVA网站：AIVA官网\nAIVA (Artificial Intelligence Virtual Artist) 是一款专业的AI音乐生成工具，擅长创作各种风格的原创音乐，尤其适合游戏、电影和广告配乐。AIVA使用深度学习技术生成高质量的音乐，并提供多种编辑选项，用户可以根据自己的需求进行调整和定制。\n2. Soundful网站：Soundful官网\nSoundful专注于生成高质量的免版税背景音乐，适合视频创作者、播客和内容营销人员。Soundful提供了多种音乐风格和模板，用户可以轻松地找到适合自己项目的配乐，无需担心版权问题。\n3. ElevenLabs网站：ElevenLabs官网\nElevenLabs提供逼真的AI语音生成和语音克隆功能，适用于配音、有声读物制作和虚拟助手等领域。ElevenLabs可以生成多种语言和口音的语音，并提供强大的编辑工具，用户可以调整语速、音调、情感等参数，以获得最自然的语音效果。\n4. Lovo.ai网站：Lovo.ai官网\nLovo.ai可以生成多种行业和用途的逼真语音，并提供丰富的定制选项。它适用于各种应用场景，如广告、教育、娱乐、客户服务等。Lovo.ai的语音库包含多种声音风格和情感，用户可以根据自己的需求选择最合适的声音。\n5. Boomy网站：Boomy官网\nBoomy让音乐创作变得简单有趣。它允许用户通过简单的操作创作完整的歌曲，即使是没有音乐基础的用户也能轻松上手。Boomy提供了多种音乐风格和工具，用户可以尽情发挥创意，创作属于自己的音乐作品。\n\n总结\n在本文中，我们介绍了一些最好的AI工具，包括AI聊天工具、AI文字生成工具、AI图像、音频、音乐生成器等。这些工具各有特色，可以满足不同用户的需求。但是，我们也要注意，虽然AI工具带来了很多便利，但是我们也不能完全依赖它们。我们需要理智地使用这些工具，同时也要关注它们可能带来的问题，如隐私问题、版权问题等。\n对于中国大陆的用户来说，很多AI工具在中国大陆无法直接访问，可能需要使用翻墙软件如VPN翻墙才能访问。大家可以参考我们的翻墙VPN推荐：\niOS/MAC 端注册教程：iphone如何用外网/苹果手机搭梯子-翻墙VPN软件工具 | IT码农\nWindows 端这里推荐 clash for Windows\n注册教程：Windows 翻墙教程：从零开始科学上网（最稳定的科学上网方案） | IT码农\nAndroid 端注册教程：安卓/Android系统手机实现科学上网教程-翻墙VPN软件工具 | IT码农\n","categories":["科学上网"],"tags":[]},{"title":"Gemini在中国怎么用？","url":"https://tanqingbo.cn/how-to-use-Gemini/","content":"Gemini是谷歌推出的一款强大的人工智能工具，是公认的国外最好用的AI工具之一。然而，在中国使用Gemini却不是一件简单的事。为什么？因为中国的网络限制和Gemini的区域限制让直接访问变得困难。别担心，这篇文章将带你一步步了解如何在中国使用Gemini，介绍Gemini的最新功能，并推荐一些可靠的工具来帮助你突破障碍。无论你是想用它写文章、生成图片，还是探索更多可能性，这篇指南都会给你清晰的答案。\n为什么在中国使用Gemini这么难？在中国尝试访问Gemini时，你可能会遇到两个主要障碍。首先，Gemini并未在中国（包括香港）正式开放。谷歌明确表示，中国大陆和香港的用户无法直接使用这项服务。如果你尝试从未开放国家或地区登录Gemini的官网，屏幕上可能会跳出一句让人泄气的提示：“Gemini 目前不支持你所在的地区”（Gemini isn’t currently supported in your country）。这不是你的网络问题，而是谷歌的区域限制政策。\n\n第二个障碍是中国的网络防火墙（GFW）。GFW限制了对许多谷歌服务的访问，包括Gemini的官网和相关API。无论你用的是电脑还是手机，直接打开Gemini的网页通常只会得到一片空白或错误提示。这就像试图翻过一堵高墙，里面有你想要的宝藏，但门却被锁得死死的。\n那么，有没有办法绕过这些限制呢？答案是肯定的！通过一些工具和方法，你完全可以在中国体验Gemini的强大功能。接下来，我们会详细探讨如何做到这一点。\nGemini AI的功能有哪些？在深入如何使用Gemini之前，先来聊聊它到底能做什么。Gemini是谷歌的旗舰AI模型，集成了多种先进技术，能够处理文本、图片、视频等内容。它的多模态能力让它在众多AI工具中脱颖而出。以下是Gemini的一些核心功能，以及2025年最新的更新亮点。\nGemini可以生成高质量的文本，比如帮你写邮件、创作故事，甚至回答复杂的问题。它的语言处理能力非常自然，无论是中文还是英文，都能给出流畅的回答。比如，你可以问：“如何用中文写一首关于秋天的诗？”Gemini就能立刻创作一首充满意境的诗句。\n此外，Gemini还能分析和生成图片。如果你上传一张照片，它可以描述图片内容，甚至根据你的描述生成全新的图像。2025年的新功能Veo 3进一步提升了视频生成能力。你可以输入一段文字，比如“一只猫在月光下跳舞”，Veo 3就能生成一段流畅的动画视频，细节惊艳到让人以为是专业制作。\nGemini还有强大的代码生成和调试功能。如果你是个程序员，遇到代码问题，Gemini可以帮你找出错误，甚至直接生成一段可用的代码片段。它还能翻译语言、规划旅行、总结文章，功能多到让人眼花缭乱。简单来说，Gemini就像一个超级聪明的助手，几乎能帮你解决任何问题。\n如何在中国使用Gemini？\n现在进入正题：在中国怎么用Gemini？虽然有区域限制和网络封锁，但通过VPN访问官方服务或使用Gemini的API，你依然可以畅享它的全部功能。以下是两种主要途径的详细说明。\n解决方案1: 使用VPN翻墙访问GeminiVPN（虚拟私人网络）是绕过GFW的最佳翻墙工具。它可以让你的网络流量伪装成来自其他国家，从而访问被封锁的网站，比如Gemini的官网或应用。以下是具体步骤：\n\n选择一个可靠的VPN不是所有VPN都能稳定访问谷歌服务，所以选择很重要。下一节我们会详细介绍一款适合中国的VPN：一支红杏。\n下载并设置VPN在购买VPN订阅后，下载它的官方应用（可在官网或应用商店找到）。安装后，选择一个支持Gemini的服务器位置，比如美国、加拿大或新加坡。连接VPN后，你的网络就会“伪装”成来自这些国家。\n访问Gemini官网或应用打开浏览器，访问Gemini的官网。如果使用手机，可以下载Google Gemini的Android或iOS应用。登录谷歌账户后，你就可以开始使用Gemini了。如果遇到区域限制提示，尝试更换VPN服务器位置。\n保持VPN连接使用Gemini时，始终保持VPN开启，否则GFW可能会中断你的访问。注意，VPN的速度可能因服务器位置和网络状况而异，选择靠近中国的服务器（如日本或新加坡）通常能获得更好的体验。\n\n使用VPN的优点是能直接访问谷歌的官方服务，体验最新功能，比如Veo 3的视频生成。然而，VPN需要一定的费用，且需要稳定的网络环境。如果你更倾向于技术化的解决方案，可以考虑使用Gemini的API。\n解决方案2: 通过Gemini API访问对于有编程基础或想将Gemini集成到自己项目的用户，Gemini的API是一个强大的选择。API允许你通过编程方式调用Gemini的功能，比如生成文本、分析图片或创建视频，无需直接访问官网。以下是使用API的基本思路：\n要使用Gemini API，你需要先在谷歌云平台注册账户，启用Gemini API并获取密钥。这个过程需要访问谷歌云网站，因此必须使用VPN绕过GFW。此外，调用API的设备需要拥有一个非中国的IP地址。你可以通过两种方式实现这一点：一是使用位于中国境外的虚拟私有服务器（VPS），比如在新加坡或美国租用一台云服务器；二是在本地运行代码时保持VPN连接，确保网络流量伪装为来自支持Gemini的国家。\n许多开发者还使用第三方工具来简化API访问。例如，一些开源平台或商业服务提供了Gemini API的封装接口，让你无需自己编写复杂代码。这些工具通常有用户友好的界面，甚至支持直接在浏览器中测试API调用。不过，选择第三方工具时要确保其信誉良好，以保护你的API密钥和数据安全。\nAPI的优点是灵活性高，适合批量任务或定制化应用，比如开发一个支持中文对话的聊天机器人或自动生成视频内容的工具。然而，API调用需要付费（按使用量计费），且对网络稳定性要求较高。如果你在公司或学校网络中，可能需要额外配置代理来确保连接顺畅。\n最佳VPN推荐：翻墙访问Gemini的理想选择\n选择一款适合中国的VPN是成功使用Gemini的关键。以下是一款表现优异、特别适合访问Gemini的VPN。\n一支红杏VPN一支红杏VPN，它是銘佑科技（香港）有限公司（也是老薛主机，不会跑路型）推出的网络加速器服务，基于 Trojan 协议的科学上网方式，该协议会将您需要代理的网络数据伪装成 HTTPS 协议的正常网络数据，以通过防火墙的检测和封锁，连接速度快，它会帮助你在互联网上冲浪时保护你的隐私和安全。\n\n支持 Windows、MAC OS X、cross platform、Android、IOS、openwrt等系统，是非常实用的网络代理软件。\n我买的就是一枝红杏的VPN，亲测真的很好用，网速很快，Google、youtubu、Facebook啥的都能上。下面就教大家怎么用起来。\n打开一枝红杏官网。\n官网：https://order.yizhihongxing.club/aff.php?aff=4818\n翻到下面会有2种VPN的购买方式，如果是个人用的话，选择入门版就可以了，一个月100G足够用了。\n\n\n\n跳转到订购页面后可以先在右上角点击注册，注册一个新账号，然后再根据提示购买你的产品。\n购买之后依次点击上方导航栏中的 服务-&gt;产品/服务，就能看到你购买的节点信息。\n\n\n\n\n好了，别着急，接下来需要下载一个软件Clash Verge来辅助科学上网。\n\nClash Verge下载先放一个下载链接: https://order.yizhihongxing.club/index.php?rp=/knowledgebase/13/\n下载安装好之后登入后前往  产品/服务 ，点击【我的产品与服务】，接着打开【产品详情】页面。\n\n向下滑动，点击 Clash 配置右侧的获得地址，在弹出的窗口中，选择 复制地址 。\n\n如果点击获得地址没有反应，请更换使用 Chrome 、Firefox 或是 EDGE 浏览器访问客户中心。\n注1. 订阅链接与你的密码一样重要，请不要分享给他人，如不慎泄露，请在产品详情页面重置链接并提交工单申请重置服务密码。\n注2. 如果使用链接添加时报错，可以点击 下载配置 ，手动添加 \n4. 添加配置打开客户端后，使用第三步的订阅链接添加配置\n\n首先点击左侧 订阅(Profiles) ，粘贴订阅链接后点击 导入\n添加成功后点击左侧 代理(Proxies) 选择节点使用，就可以成功科学上网了。 \n\n\n\n以上是电脑端科学上网的教程，如果你想在手机端也实现科学上网的话，可以参考以下两个教程：\niOS/MAC 端注册教程：iphone如何用外网/苹果手机搭梯子-翻墙VPN软件工具 | IT码农\nAndroid 端注册教程：安卓/Android系统手机实现科学上网教程-翻墙VPN软件工具 | IT码农\n在中国使用Gemini的常见问题解答在使用Gemini的过程中，你可能会遇到一些疑惑。以下是一些常见问题和解答，帮助你更顺畅地使用。\n问题1：为什么我的VPN连上了还是无法访问Gemini？可能是VPN的服务器位置不支持Gemini，或者谷歌检测到你的IP异常。试试更换服务器（比如切换到美国或欧洲的服务器），或者清除浏览器缓存后重试。如果问题持续，联系VPN的客服，他们通常能提供针对中国的优化方案。\n问题2：Gemini API的费用高吗？Gemini API的费用基于调用量，具体价格可在谷歌云平台查看。普通用户的小规模使用通常成本较低，但如果需要频繁调用（比如生成大量视频），费用可能较高。建议先用免费额度测试。\n问题3：Gemini支持中文吗？完全支持！Gemini的中文处理能力非常强，无论是生成文本还是回答问题，都能给出自然流畅的回答。API调用也支持中文输入，效果同样出色。\n问题4：可以用Gemini免费吗？谷歌提供Gemini的免费版本，但功能有限，比如无法使用Veo 3的高级视频生成。API则需要付费，但谷歌云通常有新用户免费额度。如果你需要完整功能，可以考虑订阅Gemini Advanced（需通过VPN支付）。\n结尾在中国使用Gemini可能需要一些额外的努力，但通过VPN或API，你完全可以体验到这款AI的强大功能。ExpressVPN、Surfshark和NordVPN提供了稳定、安全的翻墙方案，而API则为开发者开启了更多可能性。Gemini的多模态能力，比如文本生成、图片分析和Veo 3的视频创作，能为你的工作和生活带来无限创意。\n所以，准备好了吗？拿起手机或电脑，试试文中提到的方法，解锁Gemini的魔法世界吧！不管是写一篇创意文章，还是生成一段炫酷视频，Gemini都能让你惊叹。只要跨过网络的“小门槛”，你就能和这个智能助手成为好朋友！\n","categories":["科学上网"],"tags":[]},{"title":"科学上网教程：2026年最新VPN选择与使用指南","url":"https://tanqingbo.cn/VPN2025/","content":"为什么要翻墙/科学上网？由于不可描述的原因，很多地方都有墙的的存在。这就导致我们没办法用谷歌、Twitter、Instagram、Youtube、Netflix、ChatGPT等等优秀的平台。\n因此，我们需要翻墙，需要科学上网，这样就可以自由浏览墙外的资源，更好的学习，提升自我。\n使用梯子翻墙的基本原理？既然墙阻挡了我们直接访问国际互联网上的某些特定服务，那么我们只能绕行了。方法就是使用梯子工具：\n\n找一台墙外的电脑，一台不经过墙，能自由上网的电脑\n把我们想访问的内容，交给这台没有限制的电脑来完成\n这台电脑访问到对应的内容后，再返回给我们\n由此，我们完成了通过这台电脑获取被墙的网络内容\n\n这台不经过墙，能自由上网的电脑，通常被成为代理服务器。\n而能够通过代理服务器访问外网的软件，通常被成为梯子、代理软件，也叫翻墙软件。\n\n如何实现科学上网/翻墙？由上述原理介绍，可以得到，要想实现科学上网，需要 代理服务器 + 翻墙软件 来实现。\n准备代理服务器想要拥有一个可用的代理服务器，有两种方式，一种是自己搭建，另一种是通过购买的方式。\n\n自己搭建代理服务器：如果你有服务器搭建的相关经验，可以考虑自己做。首先你需要拥有一台VPS服务器，然后，可以在服务器上安装需要的翻墙软件，自己搭建代理服务器一般门槛都比较高，对于新手来说我比较推荐直接购买代理服务，稳定高效、还省事。\n购买代理服务：如果你想更省心一点，可以直接购买翻墙服务，这样只需要再下载一个翻墙软件就能直接使用了。通常我们会从机场(代理服务提供商)来购买这样的服务。\n\n使用梯子工具/翻墙软件购买代理服务的话，我个人推荐一支红杏的代理服务，它是銘佑科技（香港）有限公司（也是老薛主机，不会跑路型）推出的网络加速器服务，基于 Trojan 协议的科学上网方式，该协议会将您需要代理的网络数据伪装成 HTTPS 协议的正常网络数据，以通过防火墙的检测和封锁，连接速度快，它会帮助你在互联网上冲浪时保护你的隐私和安全。\n\n支持 Windows、MAC OS X、cross platform、Android、IOS、openwrt等系统，是非常实用的网络代理软件。\n\n我买的就是一枝红杏的VPN，亲测真的很好用，网速很快，Google、youtubu、Facebook啥的都能上。下面就教大家怎么用起来。\n\n打开一枝红杏官网。\n\n官网：https://order.yizhihongxing.club/aff.php?aff=4818\n\n翻到下面会有2种VPN的购买方式，如果是个人用的话，选择入门版就可以了，一个月100G足够用了。\n\n\n  \n\n跳转到订购页面后可以先在右上角点击注册，注册一个新账号，然后再根据提示购买你的产品。\n\n购买之后依次点击上方导航栏中的 服务-&gt;产品/服务，就能看到你购买的节点信息。\n\n\n\n\n\n好了，别着急，接下来需要下载一个软件Clash Verge来辅助科学上网。\n\nClash Verge下载先放一个下载链接: https://order.yizhihongxing.club/index.php?rp=/knowledgebase/13/\n下载安装好之后登入后前往  产品/服务 ，点击【我的产品与服务】，接着打开【产品详情】页面。\n\n向下滑动，点击 Clash 配置右侧的获得地址，在弹出的窗口中，选择 复制地址 。\n\n如果点击获得地址没有反应，请更换使用 Chrome 、Firefox 或是 EDGE 浏览器访问客户中心。\n注1. 订阅链接与你的密码一样重要，请不要分享给他人，如不慎泄露，请在产品详情页面重置链接并提交工单申请重置服务密码。\n注2. 如果使用链接添加时报错，可以点击 下载配置 ，手动添加 \n4. 添加配置打开客户端后，使用第三步的订阅链接添加配置\n\n首先点击左侧 订阅(Profiles) ，粘贴订阅链接后点击 导入\n添加成功后点击左侧 代理(Proxies) 选择节点使用，就可以成功科学上网了。 \n\n\n\n最后再放以下一支红杏的官网：https://order.yizhihongxing.club/aff.php?aff=4818\n以上是电脑端科学上网的教程，如果你想在手机端也实现科学上网的话，可以参考以下两个教程：\niOS/MAC 端注册教程：iphone如何用外网/苹果手机搭梯子-翻墙VPN软件工具 | IT码农\nAndroid 端注册教程：安卓/Android系统手机实现科学上网教程-翻墙VPN软件工具 | IT码农\n最后本文推荐的翻墙 VPN仅用于日常工作、学习和娱乐，切勿浏览和传播敏感信息，包括黄赌毒，以及与政治、经济、文化、宗教等相关的敏感内容。\n","categories":["科学上网"],"tags":[]},{"title":"电脑翻墙教程：2026年最全指南，小白也能轻松学会","url":"https://tanqingbo.cn/computer-censorship/","content":"电脑翻墙是怎么回事？简单聊聊原理“翻墙”这个词听起来有点神秘，对吧？其实它说的就是绕过网络限制，让你能够访问那些在中国大陆或其他地区无法直接访问的网站和服务。最常见、最安全的方式就是使用VPN（Virtual Private Network，虚拟私人网络）。\n想象一下，你平时上网就像是走在一条公开的大路上，这条路上有很多检查点，有些地方不让你过。而VPN呢，就像是帮你开辟了一条秘密隧道。你通过这条隧道上网，你的网络流量会被加密，并且会“伪装”成从隧道另一端的服务器出去。这样一来，检查点就不知道你要去哪里，也不知道你在做什么了。\n2025年如何挑一个靠谱的电脑VPN？市面上的VPN服务商琳琅满目，挑一个好的VPN就像找一个靠谱的朋友，真的挺重要的。我自己在试用过程中，发现有几个关键点是必须考虑的，这样才能保证你的翻墙体验又快又稳。\n1. 速度和稳定性是王道这是我最看重的！毕竟谁也不想看着进度条转半天，或者刚连上VPN就掉线。Windows 翻墙教程：从零开始科学上网（最稳定的科学上网方案） |  IT码农\n\n选择有大量服务器的国家/地区的VPN： 服务器越多，分流效果越好，不容易拥堵。\n查看用户评价： 很多用户会在论坛或者社区分享他们的实际使用速度体验。\n\n2. 支持哪些设备？你主要是在电脑上用，但可能手机、平板也需要。\n\n检查是否支持你的操作系统： 确保它提供Windows、macOS、Linux等版本的客户端。\n多设备连接数： 一份账号可以同时连接几台设备？这也很实用。\n\n3. 易用性：界面是不是够简洁？特别是对于新手来说，一个操作界面复杂、设置一堆专业术语的VPN，会让人望而却步。\n\n推荐有中文界面的VPN： 这样操作起来更顺手。\n一键连接功能： 最好的VPN应该是下载安装后，点几下鼠标就能连上。\n\n2025年我个人推荐的VPN服务\n我自己使用的VPN服务是【一支红杏】，而且差不多用了六七年了，它的稳定性和响应速度绝对不用担心；\n节点：【一支红杏】支持的节点也比较多，有美国、香港、新加坡、日本、土耳其、阿根廷、印度等40多个节点，同时还支持 Windows、MAC OS X、Linux、cross platform、Android、IOS、openwrt等系统；\n支持的设备：基础板支持5台设备同时在线，升级版不限制设备数量，如果你只是订阅基础板的话，相当于你可以分享给5个人同时使用；\n\n\n电脑上设置VPN的超详细步骤第一步：注册一支红杏账号并获取订阅链接\n打开官网：https://order.yizhihongxing.club/aff.php?aff=4818\n翻到下面会有 VPN的注册方式，如果是个人用的话，选择基础版就可以了，一个月100G足够用了，而且还可以5个人同时使用。\n跳转到订购页面后可以先在右上角点击注册，注册一个新账号，然后再根据提示购买你的产品。\n购买之后依次点击上方导航栏中的 产品与服务-&gt;我产品与服务-&gt;查看详情，就能看到你购买的节点信息。\n\n\n\n购买完代理服务器之后，接下来需要安装一个工具来辅助我们进行科学上网。\n\n第二步：下载 Clash for Windows（推荐工具）👉 下载地址（开源免费）：https://order.yizhihongxing.club/index.php?rp=/knowledgebase/13/\n下载安装好之后，前往 产品/服务 ，打开产品详情页面，向下滑动。\n点击 Clash 配置右侧的【获得地址】，在弹出的窗口中，选择 复制地址 或是 下载配置。\n\n\n第三步：导入一支红杏订阅链接\n打开 Clash for Windows\n\n左侧菜单点击【订阅/(Profiles)】（配置文件）\n\n粘贴一支红杏的订阅链接 &gt; 点击【导入】下载配置\n\n\n\n\n第四步：启动代理，开始上网\n在 Clash for Windows 界面左侧顶部点击「代理/(Proxies)」开关\n选择一个延迟较低的节点（推荐香港 / 新加坡 / 日本）使用\n打开浏览器，访问 Google / YouTube / ChatGPT 测试即可，www.google.com\n\n\n❓ 常见问题解答Q：订阅导入后无节点？A：请检查 Clash 是否更新配置成功，或联系客服确认订阅是否正确。\nQ：YouTube 打不开、视频加载慢？A：建议更换节点（低延迟）、开启 TUN 模式、切换网络测试。\n\n✅ 总结Win 电脑要上外网，只需三步：\n\n注册一支红杏账号并获取订阅\n下载并安装 Clash for Windows\n导入节点、开启代理，立即畅游全网\n\n相比其他方法，Clash + 一支红杏机场方案安全、稳定、全平台支持，是目前最值得推荐的科学上网组合。\n📌 一支红杏官网地址：https://order.yizhihongxing.club/aff.php?aff=4818\n其它设备设置VPNiOS/MAC 端iOS 端想使用科学上网就稍微有麻烦，首选那些 App 都不在国内应用商店，所以首先你需要一个非中国大陆地区的 Apple ID 账户，然后在 App Store 下载 App。\n注册教程：iphone如何用外网/苹果手机搭梯子-翻墙VPN软件工具 | IT码农\nAndroid 端注册教程：安卓/Android系统手机实现科学上网教程-翻墙VPN软件工具 | IT码农\n最后本文推荐的翻墙VPN用于日常工作、学习和娱乐，切勿浏览和传播敏感信息，包括黄赌毒，以及与政治、经济、文化、宗教等相关的敏感内容。\n","categories":["科学上网"],"tags":[]},{"title":"科学上网国外视频网站推荐：2025最新国外视频网站","url":"https://tanqingbo.cn/video-websites/","content":"浏览视频网站一直是很多人上网时最喜欢干的事情之一。在国内，大家已经比较熟悉的视频网站有“优酷”、“腾旭”、“爱奇艺”等等。很多网友不满足于国内的视频网站，希望了解一下国外的视频网站中有哪些是值得浏览和收藏的。在这里我们就给大家介绍一些著名的国外视频网站。\n介绍前首先需要提醒一下，这位国外视频网站中很多都在国内被“墙”，所以要浏览这些网站，需要先“翻墙”，至于如何翻墙，可以使用VPN或参考我们给推荐提供的“翻墙软件指南”：\niOS/MAC 端教程：iphone如何用外网/苹果手机搭梯子-翻墙VPN软件工具 | IT码农\nWindows 端教程：Windows 翻墙教程：从零开始科学上网（最稳定的科学上网方案） | IT码农\nAndroid 端教程：安卓/Android系统手机实现科学上网教程-翻墙VPN软件工具 | IT码农\n闲话少说，现在就让我们给大家介绍一下那些值得推荐的国外视频网站。\n1. Youtube\n提到国外视频网站，大概Youtube要算其中的老大哥，也是很多网友翻墙后必下的App。YouTube也许是目前规模最大的海外视频网站。这家网站建于2005年，于2006年被互联网老大哥Google收购。Youtube是一个视频平台，用户不但可以观看别人发布的视频，自己也可以上传视频。这家视频网站拥有海量的视频，内容包罗万象。Youtube的界面还支持简体中文和繁体中文，上面其实有很多中文的视频，包括港澳台和中国大陆的视频都有。大部分Youtube上的视频都是可以免费观看的。\n网址：https://www.youtube.com/\n2. NetFlix\nNetFlix是另外一家最受欢迎的国外视频网址，这家公司最早从提供DVD出租业务起步，后来逐渐发展成为一个视频播放平台。NetFlix在世界各地很多国家提供付费视频服务，付费用户可以看到很多美剧、好莱坞大片等最新内容。NetFlix在各国的定价不等，提供的视频内容也不近相同，目前NetFlix还没有进入中国大陆。参见：奈飞（Netflix）全教程：如何在中国注册观看奈飞\n网址：https://www.netflix.com/\n3. Vimeo\nVimeo是一家成立于2004年的视频分享网站，这家视频网站于2007年为用户提供高清视频网站，在这一方面是行业的先驱。Vimeo不仅是一家视频网站，而且也是一个社交网络。Vimeo是很多影视爱好者上传、展示自己的视频、MV、纪录片和小电影作品的平台，在这里你能看到很多原创的视频内容，很多影视爱好者也通过这个平台互相认识和互动。Vimeo的网页界面干净、整洁，内容安排有序。\n网址：https://vimeo.com/\n4. DailyMotion\nDailyMotion是一家法国的视频分享网站，也是国外最有名的视频网站之一。DailyMotion每天吸引来自世界各地的用户，网站支持18种不同语言，其中包括中文。这家视频网站的用户中专业人士偏多，视频内容包括新闻报道、商业影片和电影短片等等。\n网址：http://www.dailymotion.com/\n5. Hulu\nHulu是一家美国的视频网站，于2007年成立。和Netflix相似，Hulu通过订阅的形式为用户提供最新的视频内容，包括电影、美剧等，其中以电视连续剧的内容为主。有趣的是，这家国外视频网站的名字在源于中文，Hulu与汉语的“葫芦”和“互录”谐音，这大概与这家视频网站的创始人中有一位华人有关。\n网址：https://www.hulu.com/\n6. LiveLeak\nLiveLeak是一家英国的视频分享网站，成立于2006年。用户可以在这家视频网站的平台上上传、分享视频。LiveLeak在内容方面偏重于与政治和新闻有关的内容，曾经因为于2007年发布萨达姆·侯赛因被处决的视频而在国际上引起争议。\n网址：https://www.liveleak.com/\n7. Vine\nVine是一家短视频分享网站，用户可以上传长度为6秒钟的视频。这家公司创立后被社交网络Twitter购买，用户可以使用Vine的手机APP拍摄、上传视频和其他用户分享。用户也可以在Vine的网站上搜索和观看其他用户拍摄、上传的短视频。Twitter于2016年宣布停止Vine的业务，用户不能再上传视频，但仍可观看和下载视频。\n网址：http://www.vine.co/\n8. UStream\nUstream是一家成立于2007年的视频分享网站，总部位于美国旧金山，于2016年被IBM收购，今后可能更加面向于为企业提供视频服务。这家视频网站在2008年美国总统大选期间非常活跃，几乎所有竞选人都通过这个视频网站回答支持者的问题。Ustream的网站支持多种语言，包括简体中文和繁体中文。\n网址：http://www.ustream.tv/\n9. MetaCafe\nMetaCafe是一家美国的视频分享网站，视频内容主要包括短电影、游戏、体育竞技、音乐和电视节目等。MetaCafe是最早通过付费的方式鼓励用户上传视频的网站之一。\n网址：http://www.metacafe.com/\n10. Viewster\nViewster是一家总部位于瑞士的视频网站，内容主要包括电影、电视节目等，很多可以免费观看（有广告）。此外，这家视频网站每年定期举办网上电影节活动。\n网址：http://www.viewster.com/\n11. Twitch\nTwitch是一个面向游戏玩家的网上视频平台，在这个平台上，很多游戏玩家发布游戏直播，吸引很多其他游戏玩家观看实况和学习技术。此外，Twitch还会定期举办一些和游戏相关的活动。Twitch覆盖的游戏种类非常多，几乎包括现有所有种类的游戏，这个视频网站已经成为一个游戏玩家的网上聚集地。\n网址：https://www.twitch.tv/\n访问国外视频网站必备工具：iOS/MAC 端教程：iphone如何用外网/苹果手机搭梯子-翻墙VPN软件工具 | IT码农\nWindows 端教程：Windows 翻墙教程：从零开始科学上网（最稳定的科学上网方案） | IT码农\nAndroid 端教程：安卓/Android系统手机实现科学上网教程-翻墙VPN软件工具 | IT码农\n","categories":["科学上网"],"tags":[]},{"title":"科学上网（翻墙）后必下的App，2025最佳国外App推荐","url":"https://tanqingbo.cn/open-app/","content":"在国内，因为防火长城GFW的存在，许多国际知名的网站都无法访问，同样，很多在海外非常火的App在国内根本无法找到。很多国内网友学会科学上网后想要了解国外的App，想知道有哪些海外App值得推荐和安装。本文就给大家介绍一些翻墙后必下的App，包括海外最有名的各类App，如海外社交媒体App、海外视频App、海外直播App、海外追剧App等。希望这些App能丰富大家的互联网生活。\n本文介绍的大部分App在国内的手机应用商定都无法找到，需要先科学上网，如大家需要找好用的科学上网翻墙教程，可以参考下面这下教程：\niOS/MAC 端教程：iphone如何用外网/苹果手机搭梯子-翻墙VPN软件工具 | IT码农\nWindows 端教程：Windows 翻墙教程：从零开始科学上网（最稳定的科学上网方案） | IT码农\nAndroid 端教程：安卓/Android系统手机实现科学上网教程-翻墙VPN软件工具 | IT码农\n翻墙后必下的App1. X（原名: Twitter推特）\nX（原名Twitter）是一个全球性的社交媒体平台，是一款翻墙后必下的App。 用户可以发布和分享短消息，也被称为“推文”。这是一个全球的信息交流平台，你可以在这里获取最新的新闻和观点，参与各种热门话题的讨论，甚至直接与名人和公众人物互动。X的实时性和开放性使其成为了获取全球动态的重要渠道，是最有名的海外社交网络之一。\niOS版App下载链接：X(Twitter) for iOS \n安卓版App下载链接：X(Twitter) for Android\n2. Facebook（脸书）\nFacebook是全球最大的社交网络平台，是一款翻墙后必下的App。 用户可以在这里分享生活动态，与朋友保持联系，参与各种社区的讨论。Facebook还提供了许多其他功能，如市场功能让你可以买卖物品，事件功能让你可以创建和参加各种活动，以及游戏和应用等，是最或的海外社交平台之一。\niOS版App下载链接：Facebook for iOS \n安卓版App下载链接：Facebook for Android\n3. YouTube\nYouTube是全球最大的视频分享平台，是一款翻墙后必下的App。 你可以在这里观看各种类型的视频，包括音乐、电影、新闻、教育内容等。YouTube不仅是观看视频的地方，也是一个充满活力的社区，你可以订阅你喜欢的频道，与其他用户互动，甚至上传自己的视频，是最火的海外视频平台之一。\niOS版App下载链接：YouTube for iOS \n安卓版App下载链接：YouTube for Android\n4. ChatGPT\nChatGPT是由OpenAI开发的一款基于AI（人工智能）的聊天工具，能够理解和生成自然语言。无论你是想提出问题、获取建议、写作，还是编写代码，ChatGPT都可以帮助你完成这些任务，让你可以轻松体验人工智能带来的便利。如果想要更多了解ChatGPT，可以参阅我们的ChatGPT中国注册和使用指南。\niOS版App下载链接：ChatGPT for iOS \n安卓版App下载链接：ChatGPT for Android\n5. TikTok（抖音国际版）\nTikTok是一个短视频分享平台，是一款翻墙后必下的App。 用户可以在这里观看和分享各种有趣的短视频。TikTok的算法会根据你的喜好推荐视频，你也可以关注你喜欢的创作者。此外，TikTok还提供了许多创作工具，让你可以轻松制作出富有创意的短视频，也是最火的海外直播平台之一。\niOS版App下载链接：TikTok for iOS \n安卓版App下载链接：TikTok for Android\n6. Telegram\nTelegram是一个即时通讯应用，以其安全性和速度而闻名，是一款翻墙后必下的App。 。用户可以在这里发送消息，分享文件和图片，创建群组和频道。Telegram的消息都是加密的，保护了用户的隐私。此外，Telegram还提供了许多其他功能，如自毁消息，机器人等，是最有名的海外社交网络之一。参阅：电报 (Telegram) 注册、使用教程。\niOS版App下载链接：Telegram for iOS \n安卓版App下载链接：Telegram for Android\n7. Discord\nDiscord是一个为各种兴趣爱好者设计的通讯平台，是一款翻墙后必下的App。 尽管最初是为游戏玩家设计的，但Discord现在已经发展成一个广泛的社区平台，用户可以在这里创建和加入各种社区，进行语音和文字聊天，分享图片和视频。Discord的服务器系统让你可以创建自己的社区，邀请朋友加入，一起分享兴趣，是最著名的海外社区App之一。\niOS版App下载链接：Discord for iOS \n安卓版App下载链接：Discord for Android\n8. Instagram\nInstagram是一个图片和视频分享平台，是一款翻墙后必下的App。 用户可以在这里分享生活照片和短视频，关注朋友和名人，发现新的趣事和灵感。Instagram的故事功能让你可以分享生活的瞬间，而IGTV则让你可以分享更长的视频，是最火的海外图片和视频App之一。\niOS版App下载链接：Instagram for iOS \n安卓版App下载链接：Instagram for Android\n9. Netflix\nNetflix是全球领先的订阅制流媒体服务，是一款翻墙后必下的App。Netflix提供各种电影和电视剧。Netflix的内容丰富多样，包括剧集、电影、动画、纪录片等，而且还有许多Netflix原创的高质量内容。Netflix的推荐系统会根据你的观看历史和喜好推荐内容，让你总能找到喜欢的节目，是最火的海外追剧app之一。参阅：奈飞（Netflix）全教程：如何在中国注册观看奈飞\niOS版App下载链接：Netflix for iOS \n安卓版App下载链接：Netflix for Android\n10. WhatsApp\nWhatsApp是一个即时通讯应用，是一款翻墙后必下的App。用户可以在这里发送消息，进行语音和视频通话，分享图片和文件。WhatsApp的所有通信都是端到端加密的，保护了用户的隐私。此外，WhatsApp还提供了群聊功能，让你可以和多个朋友同时聊天，是海外最有名的即使通讯App之一。\niOS版App下载链接：WhatsApp for iOS\n安卓版App下载链接：WhatsApp for Android\n11. Reddit\nReddit是一个社区驱动的内容分享平台，是最火的海外社区平台之一，是一款翻墙后必下的App。用户可以在这里发现，分享和讨论各种话题。Reddit有数以万计的社区，涵盖了各种主题，如新闻、科技、电影、游戏等。在Reddit，你可以阅读和参与讨论，也可以发布自己的内容。\niOS版App下载链接：Reddit for iOS \n安卓版App下载链接：Reddit for Android\n12. Spotify\nSpotify是一款流行的音乐和播客流媒体服务，提供数百万首歌曲和各种播客，是一款翻墙后必下的App。Spotify的个性化推荐和精心策划的歌单让你总能发现新的音乐。此外，Spotify还支持离线播放，让你在没有网络的时候也能享受音乐，是最火的海外音乐App之一。\niOS版App下载链接：Spotify for iOS \n安卓版App下载链接：Spotify for Android\n13. YouTube Music\nYouTube Music是YouTube的音乐流媒体服务，提供各种音乐和音乐视频，也是一款著名的国外音乐App，是一款翻墙后必下的App。YouTube Music的优势在于其庞大的音乐库和智能的推荐系统，无论你喜欢什么样的音乐，都能在这里找到。\niOS版App下载链接：YouTube Music for iOS \n安卓版App下载链接：YouTube Music for Android\n14. PayPal\nPayPal是一款全球领先的在线支付系统，用户可以在这里进行安全的在线交易，是一款翻墙后必下的App。。PayPal支持多种货币，可以在全球范围内发送和接收款项。此外，PayPal还提供购物保护，保障你的交易安全，是最有名的国外支付App之一。\niOS版App下载链接：PayPal for iOS \n安卓版App下载链接：PayPal for Android\n15. Google Maps\nGoogle Maps是一款提供全球地图信息和导航服务的应用，是一款翻墙后必下的App。。Google Maps的地图数据详尽准确，无论你在哪里，都能提供准确的导航。此外，Google Maps还提供街景和卫星图像，以及实时的交通信息，是最有名的国外地图和导航App之一。\niOS版App下载链接：Google Maps for iOS \n安卓版App下载链接：Google Maps for Android\n16. Google Translate\nGoogle Translate是一款强大的翻译工具，支持多种语言之间的即时翻译，是一款翻墙后必下的App。无论你需要翻译文本、语音，还是图片中的文字，Google Translate都能提供准确的翻译。此外，Google Translate还支持离线翻译，让你在没有网络的时候也能使用，是国外最有名的翻译App之一。\niOS版App下载链接：Google Translate for iOS \n安卓版App下载链接：Google Translate for Android\n翻墙VPN推荐：如果大家需要翻墙，可以参考下面这些最佳科学上网VPN推荐：\niOS/MAC 端教程：iphone如何用外网/苹果手机搭梯子-翻墙VPN软件工具 | IT码农\nWindows 端教程：Windows 翻墙教程：从零开始科学上网（最稳定的科学上网方案） | IT码农\nAndroid 端教程：安卓/Android系统手机实现科学上网教程-翻墙VPN软件工具 | IT码农\n","categories":["科学上网"],"tags":[]},{"title":"2025 年程序员薪资水平排行前十的城市","url":"https://tanqingbo.cn/0010-city/","content":"1、北京平均月薪：22,500元年薪范围：35万-150万高薪岗位：AI大模型开发、集成电路、自动驾驶算法\n2、上海平均月薪：21,800元年薪范围：32万-115万高薪岗位：金融合规开发、机器学习\n3、深圳平均月薪：20,500元年薪范围：30万-200万高薪岗位：游戏开发、算法工程（华为/腾讯系）\n4、杭州平均月薪：18,600元年薪范围：25万-55万高薪岗位：数据科学家、电商架构师、机器视觉\n5、广州平均月薪： 16,200元年薪范围：22万-50万高薪岗位：智能座舱、SaaS产品总监\n6、南京平均月薪：15,800元年薪范围：18万-40万高薪岗位：芯片设计、数字IC\n7、苏州平均月薪：14,900元年薪范围：17万-38万高薪岗位：生物医药CXO系统开发、工业AI应用\n8、成都平均月薪：13,500元年薪范围：15万-35万高薪岗位：游戏引擎开发、元宇宙内容设计\n9、宁波平均月薪：12,800元年薪范围：14万-32万高薪岗位：跨境贸易数字化架构师\n10、武汉平均月薪： 12,200元年薪范围：13万-30万高薪岗位：光电子嵌入式开发、自动驾驶算法\n（注：以上数据整理自猎聘《2025人才供需洞察》《2025互联网薪酬报告》领禾《2025中国薪酬指南》等，具体薪资因个人年龄、学历、经验等存在差异，仅供参考）\n👉🏻 IT码农学习网站：https://tanqingbo.cn/\n推荐阅读：\nWindows 翻墙教程：从零开始科学上网（最稳定的科学上网方案）\n苹果/IOS系统手机实现科学上网教程-翻墙VPN软件工具\n安卓/Android系统手机实现科学上网教程-翻墙VPN软件工具\n","categories":["技术以外"],"tags":[]},{"title":"IDEA常用快捷键及操作整理（详细图解)","url":"https://tanqingbo.cn/IDEA-shortcut-key/","content":"一、注释快捷键1.单行注释1.1 按两次 /\n如果要对这一行进行单行注释，将光标移动到该行语句的开头处再按两次 / 即可\n\n\n取消注释只需要把//删去即可\n1.2 Ctrl + /如果要对这一行进行单行注释，将光标移动到该行（只要光标在这一行就行），再按Ctrl + /\n\n\n取消注释还是一样把光标移动到该行，再按Ctrl + /即可\n2.多行注释2.1 Ctrl + / 一次注释多行把要注释的多行选中，再按Ctrl + / 也可以对多行进行注释\n\n\n取消注释还是一样把注释的多行选中，再按Ctrl + /即可\n2.2 / + * +Enter按回车之后两个/*之间的位置就可以写多行注释了\n\n2.3 Ctrl + Shift + /把要注释的多行选中，再按Ctrl + Shift + / 可以对多行进行注释\n\n\n取消注释还是一样把注释的多行选中，再按Ctrl + Shift + / 即可\n3.文档注释3.1 按/ + * + * +Enter对类注释\n在定义的类前按/ + * + * +Enter，回车之后就会生成文档注释的架子，类上的注释不会给任何东西，可以自己加上@author @version等等注释如果想要回车之后自动生成自己想要的注释，可以点击IDEA左上角主菜单–&gt;设置–&gt;编译器–&gt;文件和代码模板，然后修改即可\n\n\n3.2 按/ + * + * +Enter对方法注释在定义的方法前按/ + * + * +Enter，回车之后就会生成文档注释的架子，从上往下分别可以填写方法的作用，参数的作用，还有返回值的说明\n\n\n二、模板/自定义模板1.快速生成主函数1.1 psvm在一个类中输入psvm，IDEA会自动生成主方法main\n\n\n1.2 main在一个类中输入main，IDEA会自动生成主方法main\n\n\n2.快速生成打印语句2.1 sout在任意方法中输入sout，IDEA会自动生成打印语句\n\n\n要打印的语句.sout，IDEA会自动生成完整的打印语句，并把前面要打印的语句放到打印语句中\n\n\n2.2 soutm在任意方法中输入soutm，IDEA会自动生成打印当前类和方法名称的语句\n\n\n2.3 soutp在任意方法中输入soutp，IDEA会自动生成打印当前方法形参名称和值的语句\n\n\n2.4 soutv在任意方法中输入soutv，IDEA会自动生成打印一个值的语句\n\n\n2.5 souf在任意方法中输入souf，IDEA会自动生成打印一个格式化字符的语句\n\n\n3.快速生成普通for循环3.1 fori在任意方法中输入fori，IDEA会自动生成一个以i为索引，以i=0为起始条件，没有设置终止条件的普通的递增for循环\n\n\n3.2 数字.fori在任意方法中输入数字.fori，IDEA会自动生成一个以i为索引，以i=0为起始条件，以该数字为终止条件的普通的递增for循环\n\n\n3.3 arr.fori在存在数组arr时，在方法中输入arr.fori，IDEA会自动生成一个以i为索引，以i=0为起始条件，以数组长度为终止条件的普通的递增for循环\n\n\n3.4 str.length().fori在存在字符串str时，在方法中输入str.length().fori，IDEA会自动生成一个以i为索引，以i=0为起始条件，以字符串长度为终止条件的普通的递增for循环\n\n\n3.5 list.fori\n3.6 数字.forr在任意方法中输入数字.forr，IDEA会自动生成一个以i为索引，以i=数字为起始条件，以i&gt;0为终止条件的普通的递减for循环\n\n\n3.7 arr.forr在存在数组arr时，在方法中输入arr.forr，IDEA会自动生成一个以i为索引，以i=arr.length-1为起始条件，以i&gt;=0为终止条件的普通的递减for循环\n\n\n3.8 str.length().forr在存在字符串str时，在方法中输入str.length().forr，IDEA会自动生成一个可选择的索引，以str.length()为起始条件，以&gt;0为终止条件的普通的递减for循环\n\n\n3.9 list.forr  三、快速生成标准的JavaBean类1.快速生成构造函数（空参构造和有参构造）1.1 Fn + Alt + Insert(Alt + Insert)\n先提前看一眼我定义的属性，按下Fn + Alt + Insert会出现能生成的列表，第一个就是构造函数，点击或者回车\n\n\n回车之后我们会看到如下左图的画面1.如果我们要进行空参构造，最简单的方法是–&gt;点击无选择，还可以是–&gt;按两下Tab再按一下Enter（按第一下Tab是取消默认选择的第一个属性，按第二下Tab是让无选择这个按钮的背景变蓝，再按回车相当于用鼠标点了一下无选择）2.如果我们要进行有全部参数的构造，最简单的方法是–&gt;Ctrl+A全选，还可以是–&gt;按Shift不松再点击最下面的gender（就相当于把所有属性全选），全选之后如下右图，再按确定就会生成温馨提示：按Shift不松再点某个属性实际就是选中第一个属性到某个属性之间的所有属性，自己也可以尝试在很多个属性时不点击最下面的属性是怎样的\n\n\n生成无参构造的画面以及再生成有全部参数的构造画面如下\n\n\n2.快速生成Getter和Setter2.1 Fn + Alt + Insert(Alt + Insert)基本流程和上面构造函数大致一样，选中Getter和Setter再全选属性即可\n\n\n\n后续的生成的其他方法应该流程都大差不差，这里就不过多赘述了\n3.插件PTG 一键生成标准JavaBean点击主菜单–&gt;设置–&gt;插件–&gt;搜索PTG–&gt;安装按照了PTG之后，在填完属性之后，空白处右键–&gt;Ptg To JavaBean即可一键生成标准JavaBean\n\n\n\n四、与类名相关的快捷操作1.类的复制操作1.1 在同一个包中，把类重新复制一遍点击左侧要复制的类名（比如Test1，点击之后会变蓝），按Ctrl + C 再点击包名（点击之后会变蓝），再按Ctrl + V 改名为Test2，这样就相当于把这个类又复制了一遍\n\n\n\n当然也可以点击左侧要复制的类名（点击后会变蓝）再右键选择复制，然后点击包名（点击后会变蓝）再右键黏贴是一样的\n\n\n1.2 选择两个类复制到另一个包中按Ctrl + Alt 不松点击两个类（黑马程序员视频是这么教的，实际上我自己用的时候只要按Ctrl 不松就行了）然后按Ctrl + C（或者右键复制），再点击另一个包名按Ctrl + V（或者右键复制）\n\n\n\n\n\n2.类的拆分操作2.1 拆分并右移如下图，当我们编写JavaBean类和它的测试类时，每次编码都要单独点开切换还不好对应地敲代码\n\n\n为了让两个类同时在页面上，我们可以将类拆分并右移我们可以右键点击编码区上方的类名–&gt;拆分并右移\n\n拆分并右移的效果如下图\n\n想要取消还是右键点击编码区上方的类名–&gt;取消拆分\n\n五、IDEA常用快捷键1.Ctrl + …1.1 Ctrl + Y把光标移动到要删除行的任意位置，按Ctrl + Y 即可删除当前行\n\n\n1.2 Ctrl + D把光标移动到要复制行的任意位置，按Ctrl + D 即可删除当前行\n\n\n1.3 Ctrl + W选中文本，连续按可以扩大选中范围（以单词为单位）下图分别是没按之前与每次多按Ctrl + W一次之后的效果\n\n\n\n\n1.4 Ctrl + P在完成JavaBean类之后，如果在测试类中调用JavaBean类中的方法但是忘记了参数，可以按Ctrl + P 把方法所对应的参数进行展示，展示时的第一行时无参的情况，第二行时有参的情况，跟着展示敲即可上面的图是JavaBean类中的有参构造方法，下面的图是测试类中调用有参构造方法\n\n\n1.5 Ctrl + B如果想要在代码中查看某个类、方法或者接口的具体逻辑时，把光标定位在对应的类名、方法名或接口名上，按下Ctrl + B就能跳转到其定义的源码处当然源码还是比较复杂的，所以这个快捷键用的不多，也许以后有一定的能力之后或者实在需要了解底层原理时才会用到\n\n\n1.6 Ctrl(不松) + 点击要查询的类、方法或者接口Ctrl(不松) + 点击要查询的类、方法或者接口和Ctrl + B 一样都是用于查看源码，按住Ctrl不松移动鼠标光标指向要查询的类、方法或者接口（会变蓝）再点击一下即可因为这样要按住Ctrl不松，好像我就不好用快捷键截图了，我就潦草的把手机拍电脑的图片放上来了\n\n\n1.7 Ctrl + NCtrl + N 快捷键的作用是按类名搜索并打开类。按下后会弹出搜索框，可以在其中输入类名的关键字，IDEA会默认在项目文件中快速搜索所有类，并显示匹配的结果，方便我们快速定位和打开所需的类\n\n因为右上角默认在项目文件中搜索，如果想要搜索类的源码，我们可以把右上角的项目文件改为所有位置\n\n\n1.8 Ctrl + Fn + F12（Ctrl + F12）黑马程序员视频里教的是Ctrl + F12 ，但是我这么按只会出现计算器。按 Ctrl + Fn + F12（Ctrl + F12）可以在源码中搜索想要查看的类、方法或者接口假设我们先打开了java.lang的源码并在开头处，我们想要搜索查看toString的源码，按 Ctrl + Fn + F12（Ctrl + F12）然后可以下划在图中找到toString再点击（也可以直接键盘输入toString，图片中没有看到搜索框，但是一打字就出来了）\n\n\n\n\n1.9 Ctrl + X选中想要剪切的部分再按Ctrl + X ，再将光标移动到想要复制剪切内容的位置，再按Ctrl + V 即可完成剪切复制的操作\n\n\n\n\n1.10 Ctrl + ZCtrl + Z 是回退一步，如果在实际编码中不小心删去了部分内容，按Ctrl + Z 即可回退，当然可以按多次回退多次一步把选择的打印语句全部删除\n\n\n按Ctrl + Z 可以回退一步\n\n1.11 Ctrl + F如果想要在控制台搜索想要的内容，先点击一下控制台，再按 Ctrl + F 就会出现搜索框，在搜索想要的内容即可下图演示的是搜索全部时区名称中的Shanghai\n\n\n\n\n1.12 Ctrl + O功能：快速生成重写方法：当你在一个类中按下此快捷键时，IDEA 会弹出当前类可以重写的父类或接口的方法列表，选择后会自动生成对应的重写方法代码。适用场景：继承父类时，快速重写 toString()、equals()、hashCode() 等方法。实现接口时，快速生成接口方法的实现。类似快捷键：Ctrl + I：实现接口方法（Implement Methods）。Alt + Insert：生成代码（Getter/Setter、构造函数等）下图中TokenInterceptor类实现了HandlerInterception接口，在类中按Ctrl + O即可选择重写接口中的方法\n\n2.Alt + …2.1 Alt + Enter(回车)点击一下循环里面的变量或者把光标移动到变量上，再按Alt + Enter(回车) 可以选择把定义该变量的一行语句拆分为声明和赋值语句，一般此时我们可以把声明语句放到循环外部，只保留赋值语句在循环内部\n\n\n\n当敲出一个还未导入的方法名时（整个方法名会显示为红色），用鼠标点击一下红色的方法名或者把光标移动到红色的方法名上（等待一下会跳出两个小窗口），按Alt + Enter(回车)，再选择在’…’类中创建方法’…’即可自动生成一个方法\n\n\n\n\n2.2 Alt(不松) + 鼠标左键竖着选择变量进行批量修改竖着选择变量进行批量修改有两种方式：1.按住鼠标滚轮不松，再往下一拖，就可以竖着选择 2.如果没有鼠标滚轮，按住Alt不松再按鼠标左键拖动也可以竖着选择\n\n2.3 Alt + Insert当光标位于类、接口或枚举的定义体内时，按下Alt + Insert会弹出代码生成菜单，可生成的内容如下：\n\n3.Shift + …3.1 Shift + F6 +Fn（Shift + F6）黑马程序员视频中教的是按Shift + F6进行变量的批次修改，但是我自己的电脑Shift + F6只能调节屏幕亮度，我的是Shift + F6 +Fn。先选中要进行批量修改的变量，再按Shift + F6 +Fn（Shift + F6）下图假设我定义了一个getMax方法，现在复制黏贴过来并改为getMin方法，就可以使用到批量修改变量的快捷键\n\n\n\n\n然后把方法名getMax改为getMin，把if判断逻辑的&lt;改为&gt;就可以了\n\n4.Ctrl + Alt + …4.1 Ctrl + Alt + M选中main方法中的一段代码，按Ctrl + Alt + M ，IDEA会将选中的代码提取为一个独立的方法，这样可以使代码结构更加清晰，提高代码的复用性和可读性\n\n\n\n\n4.2 Ctrl + Alt + L当编写的代码格式混乱，例如缩进不一致、换行不规范等，按Ctrl + Alt + L 可以格式化代码，使代码更加清晰、易读下图中第一个是没有格式化前的，第二个是格式化后的\n\n\n4.3 Ctrl + Alt + V / .var当选中一段表达式或代码，按Ctrl + Alt + V ，IDEA会自动将选中的内容提取为一个局部变量，并为其生成合适的变量名简单来说，就是如果有sc.nextInt();那么按Ctrl + Alt + V 就会自动生成左边\n\n\n另一种方式是在所需内容的后面加上.var就会自动在左边生成合适的变量名\n\n\n4.4 Ctrl + Alt + T当选中一段表达式或代码，按Ctrl + Alt + T ，IDEA会让你选择包围方式，可以选择if，for，while等方式包围选中的表达式或代码\n\n\n\n5.Ctrl + Shift + …5.1 Ctrl + Shift + 上键/下键(↑/↓)一开始没发现，后面实操发现移动效果和Alt + Shift +上键/下键(↑/↓)不太一样，下面直接结合deepseek的总结进行区分功能：将当前光标所在的语法元素（如方法、类成员、函数等）或选择的代码块在作用域内向上或向下移动（重构代码结构)特点：按照语法结构(如方法、类成员、函数等)在作用域内向上或向下移动(重构代码结构)适用于调整类成员(方法、字段)或函数内部的语句块顺序如果光标在方法名上，会移动整个方法；如果在语句上，可能移动整个语句块如下图，光标移动到postHandle方法时，再按Ctrl + Shift + 下键即可将postHandle和afterCompletion方法调换位置\n\n或者是选中postHandle整个方法的代码块也可以\n\n移动完后效果如下\n\n\n5.2 Ctrl + Shift +U这个快捷键的功能是：快速切换选中文本的大小写(全小写转换为全大写/全大写转换为全小写)一般在定义常量类的时候常用\n\n\n6. Alt + Shift + …6.1 Alt + Shift +上键/下键(↑/↓)功能：将当前光标所在的整行或选中的代码块向上或向下移动（与其他行交换位置）特点：直接调整代码的物理顺序适用于快速调整代码行的位置(如交换相邻行的顺序)如果选中多行，会整体移动选中的代码块下图是该快捷键的适用场景\n\n\n下图是该快捷键不太适用的场景(可以结合Ctrl + Shift + 上键/下键来进行区分)这是没调整之前的样子\n\n这是按了两次Alt + Shift +上键的效果(一开始两个方法之间间隔一行)，不难发现该快捷键是直接调整代码的物理顺序，所以会出现下图这样的情况(如果想要调换两个方法的位置应该使用Ctrl + Shift + 上键/下键)\n\n六、IDEA常用操作小技巧1.利用小箭头收起括号中内容不管是方法，while循环，for循环等等，如果括号内的代码很多或者已经完成括号内全部代码，我们可以把鼠标移动到左边框（代码行号与代码框之间）的位置，会自动显现出向下的小箭头，点一下就可以把相应括号内的代码收起来这样编写代码的时候会更加清晰，更方便编写\n\n\n2.重写方法名+Enter(回车)重写方法的时候，只需要打出要重写方法的名称，然后IDEA会自动跳出重写该方法的选项，就不需要@Override再慢慢地敲了\n推荐阅读Windows 翻墙教程：从零开始科学上网（最稳定的科学上网方案）\n苹果/IOS系统手机实现科学上网教程-翻墙VPN软件工具\n安卓/Android系统手机实现科学上网教程-翻墙VPN软件工具\n","categories":["编程经验"],"tags":[]},{"title":"注册ChatGPT详细指南","url":"https://tanqingbo.cn/how-to-signup-chatgpt/","content":"最近ChatGPT真受欢迎，但是有些人注册时会经常面临不服务它们的地区问题，现在我们给你详细问题解决。\n1、准备\n代理（也就是科学上网）。要求是韩国，日本，印度，新加坡，美国、澳大利亚这些国家的地址都合适。对其他的我们还不太清楚，反正香港或中国的代理肯定不行。不会科学上网的朋友可以看下面这篇教程：\n\nWindows 翻墙教程：从零开始科学上网（最稳定的科学上网方案）\n\n找一个国外手机号码，如果你没有用过接码平台也行，有些接码平台是无法接的，所以我们推荐一个就是sms-activate.org\n\n准备一个浏览器，建议用谷歌浏览器\n\n\n2、开始一步一步注册打开接码平台 sms-activate.org，注册一个账号，这个是用来接收验证码用的，因为国内的号码接收不到验证码。\n\n然后要充值余额\n\n一次接码OpenAi的验证码费用是大概25卢布，人民币来看差不多是2块钱，不过只能充美金，就先充直个1美金钱，可以选择对你任何方便方式，支付宝也有。\n\n充值完成可能需要等一会，就先放着，直接进行下一步。\n3、注册一个OpenAI账号首先打开ChatGPT的账户注册页面。\n\n推荐使用谷歌邮箱注册，点击红圈中的按钮就行。因为有人反映使用其它邮箱注册收不到邮箱验证，但是也有人使用163邮箱收到验证了，所以为了以防万一，推荐谷歌邮箱注册。\n用邮箱注册后你要验证邮件。进去邮箱，查看email里的链接。\n\n点击“Verify email address”之后，会让你输入一些注册信息：\n \n当然，有一些人会在这里遇到一个问题，会出现说不能在当前国家服务的提示。\n\n不用怕，一般你出现这种问题，就是因为你的代理没有全局，或者位置不对。香港或中国的的代理是100%无法通过的。可以试着切换科学上网工具的节点，然后重新打开浏览、或者换个浏览器试试。基本上切换全局代理，这个问题就可以解决了。\n如果在PC端这个问题你一直没有解决的话，不要死磕，改用手机注册也行，手机上也推荐使用谷歌浏览器，记得要开科学上网。\n代理没有问题的话，刷新页面，就可以继续看到正常工作的注册页面了。\n \n接着需要验证手机号码，打开前面注册的接码平台账号，在左侧搜索OpenAi，选择一个国家，点击”小黄车”。\n\n我两次注册都是选择的“印度尼西亚”，很顺利的收到验证码了。\n\n然后我们复制这个号码，粘贴过去。然后我们点击发送验证码就完成了。注意每个电话号码前面都有个区号，openai的注册页面已经自动填写区号了，所以大家在粘贴电话号码的时候，记得把区号去掉。\n等一会接码网站会提示收到验证码，我们复制粘贴填写就好啦。\n\n这里你要选择你打算如何使用OpenAI。选择第二项就好啦。到这chatgpt账号就算注册成功了。\n4、使用ChatGPT\n注册完后，打开ChatGPT网站去登陆。\n登录网站：https://chat.openai.com/auth/login\n\n登录成功之后，下面这个地方就可以开始写你的任何巧妙的句子了。取乐吧！\n推荐阅读Windows 翻墙教程：从零开始科学上网（最稳定的科学上网方案）\n苹果/IOS系统手机实现科学上网教程-翻墙VPN软件工具\n安卓/Android系统手机实现科学上网教程-翻墙VPN软件工具\n","categories":["科学上网"],"tags":[]},{"title":"2026最新中国科学上网终极指南：VPN推荐、翻墙教程、科学上网工具评测","url":"https://tanqingbo.cn/great-firewall/","content":"为什么要翻墙/科学上网？由于不可描述的原因，很多地方都有墙的的存在。这就导致我们没办法用谷歌、Twitter、Instagram、Youtube、Netflix、ChatGPT等等优秀的平台。\n因此，我们需要翻墙，需要科学上网，这样就可以自由浏览墙外的资源，更好的学习，提升自我。\n如何实现科学上网/翻墙？由上述原理介绍，可以得到，要想实现科学上网，需要 代理服务器 + 翻墙软件 来实现。\n准备代理服务器想要拥有一个可用的代理服务器，有两种方式，一种是自己搭建，另一种是通过购买的方式。\n\n自己搭建代理服务器：如果你有服务器搭建的相关经验，可以考虑自己做。首先你需要拥有一台VPS服务器，然后，可以在服务器上安装需要的翻墙软件，自己搭建代理服务器一般门槛都比较高，对于新手来说我比较推荐直接购买代理服务，稳定高效、还省事。\n购买代理服务：如果你想更省心一点，可以直接购买翻墙服务，这样只需要再下载一个翻墙软件就能直接使用了。通常我们会从机场(代理服务提供商)来购买这样的服务。\n目前我使用的服务是【一支红杏】：\n\n\n【一支红杏】：我使用了6年多了，节点比较多，有美国、香港、新加坡、土耳其、阿根廷、印度等节点，还有一个有点是稳定，我用了六七年了一直都没出现过问题，且墙外你想访问的网站基本都能访问。\niOS/MAC 端iOS 端想使用科学上网就稍微有麻烦，首选那些 App 都不在国内应用商店，所以首先你需要一个非中国大陆地区的 Apple ID 账户，然后在 App Store 下载 App。\n注册教程：iphone如何用外网/苹果手机搭梯子-翻墙VPN软件工具 |  IT码农\nWindows 端这里推荐 clash for Windows\n注册教程：Windows 翻墙教程：从零开始科学上网（最稳定的科学上网方案） |  IT码农\nAndroid 端注册教程：安卓/Android系统手机实现科学上网教程-翻墙VPN软件工具 |  IT码农\n最后本文推荐的翻墙VPN用于日常工作、学习和娱乐，切勿浏览和传播敏感信息，包括黄赌毒，以及与政治、经济、文化、宗教等相关的敏感内容。\n","categories":["科学上网"],"tags":[]},{"title":"中国四大软件外包公司","url":"https://tanqingbo.cn/4-Software/","content":"最近，很多小伙伴问：只有外包的 offer 能去吗？\n大环境不行，面试太少了，很多本科生想进外包都没机会。\n非常时期，不需要在意那么多，外包作为过渡也是没问题的，很多外包其实比小公司还要好多了。\n也不要太担心去外包会污染自己的简历，只要接触的项目还可以，写在简历上再润色一下，那就完全没问题的，放心！\n默默沉淀，提高个人竞争力，等待时机成熟再溜就好了。\n根据网上的资料，整理出来的一份国内软件外包公司的名单。\n找工作的同学都要看看，根据自身的情况，学历低的 、没有经验的，可以先到外包公司试试，或者不想进去的也要了解一下， 避免找工作时被坑了。\n1、软件外包公司名单国内软件外包公司多如牛毛，下面列举的占全部名单可能不到千分之一 。\n名单不分先后 ：\n\n2、如何区分是否是外包公司我把大家的留言整理一下。\n\n电话邀请面试时，对方问学历、做过哪些项目、用过哪些技术等问题，99%是外包公司(且是外派形式)。因为，外包HR从来不会认真去阅读你的简历，只要发现你的简历更新了，立马给你打电话，在电话里问东问西。\n公司简介中出现 系统提供商、服务提供商、IT外包 、人力资源 等字眼，99%是外包公司；\n面试的地址和公司的地址不一样；\n包吃、包住；\n不在本公司，去其他公司，或者出差到外地；\n以总公司名义进行招聘，等入职时签的是子公司，子公司是外包公司。（一些正规的公司也都喜欢搞这种套路）\n\n3、外包公司真是无一是处吗？不再赘述，大家可以搜索一下。\n补充几点：\n\n招聘是为 开发新项目，特别是大型项目，里面不是累成狗，是累的不如畜X。\n不在本地工作，派到外地，或者所谓的 封闭式开发 。一旦进去，就跟到缅北差不多 。\n签短期合同， 比如先3、5个月合同，后期看项目进度。这3、5个月估计不会把你当人用。\n拿着3，4线城的工资，外派到一、二线城市工作。大冤种！\n\n4、软件外包的几种形式4.1、 人力外包；给甲方公司，成为甲方公司项目组的一员。通俗点来说，就是在工作上你是属于甲方的，但是在薪酬福利方面还是属于外包公司的。这类型的外包是目前市场上较为流行的，可以大大解决传统企业的it人才缺口。\n4.2、 以开发团队的形式外派开发新项目；这种形式经常需要开发团队各个地方各种公司到处跑，等项目完成后将开发成果交付给项目的开发团队，便可回到所在的公司继续开展项目。**在开发期间把员工不当ren，开发完毕后，没有接到下家项目的，要么被逼走，要么只发当地的最低工资。\n在一个项目组中，会存在人力外包、项目外包等多种形式的外包团队。\n软件外包的形式灵活多样，不限上述几种。\n5、哪些情况可选择外包\n经验不足、学历较低、 又想进大公司，可以通过外包公司进入；\n人力外包。除了工资和薪酬福利，其他与甲方完全一致，可以考虑一下；\n维护项目，工作量不大，可以考虑；\n年龄偏大，众所周知，超过35岁的开发人员找工作特别难，可以考虑\n…\n\n推荐阅读如何使用梯子工具实现翻墙-科学上网工具VPN？\n","categories":["技术以外"],"tags":[]},{"title":"科学上网最全指南，含翻墙软件","url":"https://tanqingbo.cn/Open-Internet2/","content":"为什么要翻墙/科学上网？由于不可描述的原因，很多地方都有墙的的存在。这就导致我们没办法用谷歌、Twitter、Instagram、Youtube、Netflix、ChatGPT等等优秀的平台。\n因此，我们需要翻墙，需要科学上网，这样就可以自由浏览墙外的资源，更好的学习，提升自我。\n使用梯子翻墙的基本原理？既然墙阻挡了我们直接访问国际互联网上的某些特定服务，那么我们只能绕行了。方法就是使用梯子工具：\n\n找一台墙外的电脑，一台不经过墙，能自由上网的电脑\n把我们想访问的内容，交给这台没有限制的电脑来完成\n这台电脑访问到对应的内容后，再返回给我们\n由此，我们完成了通过这台电脑获取被墙的网络内容\n\n这台不经过墙，能自由上网的电脑，通常被成为代理服务器。\n而能够通过代理服务器访问外网的软件，通常被成为梯子、代理软件，也叫翻墙软件。\n\n如何实现科学上网/翻墙？由上述原理介绍，可以得到，要想实现科学上网，需要 代理服务器 + 翻墙软件 来实现。\n准备代理服务器想要拥有一个可用的代理服务器，有两种方式，一种是自己搭建，另一种是通过购买的方式。\n\n自己搭建代理服务器：如果你有服务器搭建的相关经验，可以考虑自己做。首先你需要拥有一台VPS服务器，然后，可以在服务器上安装需要的翻墙软件，自己搭建代理服务器一般门槛都比较高，对于新手来说我比较推荐直接购买代理服务，稳定高效、还省事。\n购买代理服务：如果你想更省心一点，可以直接购买翻墙服务，这样只需要再下载一个翻墙软件就能直接使用了。通常我们会从机场(代理服务提供商)来购买这样的服务，关于机场的推荐，可以参考科学上网（翻墙）软件之—VPN篇。\n\n使用梯子工具/翻墙软件购买代理服务的话，我个人推荐一支红杏的代理服务，它是銘佑科技（香港）有限公司（也是老薛主机，不会跑路型）推出的网络加速器服务，基于 Trojan 协议的科学上网方式，该协议会将您需要代理的网络数据伪装成 HTTPS 协议的正常网络数据，以通过防火墙的检测和封锁，连接速度快，它会帮助你在互联网上冲浪时保护你的隐私和安全。\n\n支持 Windows、MAC OS X、cross platform、Android、IOS、openwrt等系统，是非常实用的网络代理软件。\n我买的就是一枝红杏的VPN，亲测真的很好用，网速很快，Google、youtubu、Facebook啥的都能上。下面就教大家怎么用起来。\n打开一枝红杏官网。\n官网：https://order.yizhihongxing.club/aff.php?aff=4818\n翻到下面会有2中VPN的购买方式，如果是个人用的话，选择入门版就可以了，一个月100G足够用了。\n跳转到订购页面后可以先在右上角点击注册，注册一个新账号，然后再根据提示购买你的产品。\n购买之后依次点击上方导航栏中的 服务-&gt;产品/服务，就能看到你购买的节点信息。\n\n\n\n\n好了，别着急，接下来需要下载一个软件Clash Verge来辅助科学上网。\n\nClash Verge下载先放一个下载链接: https://order.yizhihongxing.club/index.php?rp=/knowledgebase/13/\n下载安装好之后登入后前往  产品/服务 ，点击【我的产品与服务】，接着打开【产品详情】页面。\n\n\n向下滑动，点击 Clash 配置右侧的获得地址，在弹出的窗口中，选择 复制地址 。\n\n\n如果点击获得地址没有反应，请更换使用 Chrome 、Firefox 或是 EDGE 浏览器访问客户中心。\n注1. 订阅链接与你的密码一样重要，请不要分享给他人，如不慎泄露，请在产品详情页面重置链接并提交工单申请重置服务密码。\n注2. 如果使用链接添加时报错，可以点击 下载配置 ，手动添加 \n4. 添加配置打开客户端后，使用第三步的订阅链接添加配置\n\n首先点击左侧 订阅(Profiles) ，粘贴订阅链接后点击 导入\n添加成功后点击左侧 代理(Proxies) 选择节点使用 \n\n\n最后再放一个一枝红杏的官网：https://order.yizhihongxing.club/aff.php?aff=4818\n我觉得还是蛮好用的\n","categories":["科学上网"],"tags":[]},{"title":"如何在国内注册ChatGPT？ChatGPT怎么用？","url":"https://tanqingbo.cn/ChatGPT-VPN/","content":"ChatGPT是OpenAI研发的一款大型语言模型，凭借智能对话、文本生成、翻译等强大功能风靡全球。但由于多方面原因，ChatGPT在中国大陆无法注册、无法直接使用。如何在国内注册ChatGPT？ChatGPT怎么用？这篇ChatGPT中文教程将提供ChatGPT官网、注册、账号购买、下载、充值等全面教程，带你顺利踏入ChatGPT的世界。\nChatGPT简介\nChatGPT是什么？ChatGPT是OpenAI开发的一款大型语言模型聊天机器人，于2022年11月30日发布。ChatGPT能够基于在预训练阶段所见的模式和统计规律，来生成回答，还能根据聊天的上下文进行互动，真正像人类一样来聊天交流。\nChatGPT有哪些用途？作为最受欢迎的AI工具之一，ChatGPT可用于多种应用，包括编写和调试代码、创建报告、演示文稿、电子邮件和网站。此外，它还能回答各种问题，如推荐书籍、解释概念等，被广泛应用于教育、娱乐、业务和技术领域。\nChatGPT的版本\nChatGPT免费版： ChatGPT免费版用户可以免费使用基本功能，ChatGPT免费版运行的是GPT-3.5。\nChatGPT Plus版：ChatGPT同时提供付费的Plus版，月费20美元，提供优先访问、更快的响应时间以及首先体验新功能的机会。Plus版用户将运行GPT-4和最新版本的GPT-4o，还可以使用图片生成等附加功能。\nChatGPT企业版：OpenAI也推出了面向企业的ChatGPT Enterprise，提供比基本版本更多的安全增强和管理控制选项。对于企业版的定价，组织可以联系OpenAI的销售团队了解更多信息。\n\nChatGPT的服务限制：1. ChatGPT不可用的国家/地区由于各种原因（包括隐私担忧和传播错误信息的指控），ChatGPT目前在很多国家/地区无法使用，包括：俄罗斯、中国（包括香港）、朝鲜、古巴、伊朗、叙利亚、意大利、阿富汗、不丹、中非共和国、乍得、厄立特里亚、斯威士兰、利比亚、南苏丹、苏丹和也门等国家/地区访问。\n国内注册ChatGPT的现状目前在中国国内无法直接注册ChatGPT。这主要是由于以下原因造成的：\n\n网络限制：ChatGPT官网需要翻墙才能访问，国内直接访问可能会受到限制。\n政策限制：由于ChatGPT服务尚未向包括中国在内的部分国家开放，所以以中国IP地址注册ChatGPT会被拒绝。\nVPN限制：即使使用VPN翻墙访问ChatGPT，有些VPN流量会被ChatGPT识别，ChatGPT也会拒绝服务。\n支付方式： 目前ChatGPT的付费版本仅支持国外信用卡或PayPal等支付方式，国内支付手段有限。\n手机验证：最早注册需要境外手机号接收验证码，国内手机号通常无法使用，但从2023年底开始注册普通ChatGPT已经不需要手机号码验证了。\n\n尽管如此，随着科技发展和互联网的开放，解决这些挑战的方法也越来越多。接下来，我们将为你提供行之有效的注册指南，助你突破重重阻碍，成功注册ChatGPT。\n\nChatGPT注册第1步：翻墙访问ChatGPT\n解锁ChatGPT的第一步，就是跨越网络这道鸿沟。国内小伙伴们可能会遇到无法直接访问ChatGPT官网的难题，别担心，多种翻墙工具可以助你一臂之力！\nVPN可以用来翻墙访问ChatGPTChatGPT的网站在国内无法打开，所以必须翻墙，而VPN作为一种科学上网翻墙软件可以用来冲破这一道壁垒，让国内网友也可以访问ChatGPT。\n并不是所有VPN都可以用来访问和注册ChatGPT虽然VPN可以用来翻墙，但并不是所有VPN都可以用来访问和注册ChatGPT。首先，在中国好用的VPN非常少，大部分VPN根本无法用来翻墙。其次，即使根据靠谱的翻墙软件VPN推荐选择了一款可以成功翻墙的VPN，但如果ChatGPT可以识别这一款VPN，还是会被拒绝服务。\n哪些VPN可以用来翻墙注册ChatGPT？基于上面提到的两个原因，如果想要使用VPN翻墙注册ChatGPT账号，这个VPN必须满足3个条件：\n\n这个VPN可以成功翻墙（大部分VPN不能满足这个条件）\n这个VPN提供ChatGPT所支持国家的服务器节点（大部分VPN满足这个条件）\n使用这个VPN访问ChatGPT时不会被ChatGPT发现用户在使用VPN（部分VPN满足这个条件）\n\n所以，选择VPN时，要考虑以上三点，特别是第三点，很容易被忽略。\n基于这些要求，可以用来在中国使用ChatGPT的VPN并不多，大部分免费VPN更是无法满足这些要求。建议大家使用以下这个VPN来注册ChatGPT（关于VPN，可以参阅我们的翻墙软件科学上网VPN推荐文章）:\n如何使用梯子工具实现翻墙 科学上网？\n翻墙后访问ChatGPT的具体步骤：\n连接VPN后，访问ChatGPT官网。\n\n点击”Sign Up”（账号注册）按钮（如下图）：\n\n\n\n\n进入ChatGPT账号注册页面（如下图）：\n\n\n\n\nChatGPT账号注册第2步：准备海外EMAIL邮箱\n注册ChatGPT需要输入一个EMAIL地址，或者使用现有的Google、Microsoft或Apple帐号。如果使用EMAIL邮箱注册，建议不要使用国内邮箱（如163、qq等），这是因为ChatGPT本来就不对中国用户开放，使用中国邮箱，会让ChatGPT觉得你来自中国，进而拒绝你的注册请求。\n所以注册ChatGPT建议使用海外邮箱。如果已经成功翻墙，注册海外邮箱并不算难，而且很多邮箱是免费。\n如果还没有海外邮箱，可以考虑注册Gmail邮箱（注册链接）。如果平时不常使用Gmail，可以开启Gmail的邮件自动转发功能，把这个邮箱每次收到的邮件自动转发到平时常用的邮箱里，以确保能够及时收到所有邮件。\n准备好海外Email邮箱后的具体步骤：\n在ChatGPT注册页面（见上一步配图）的“Email address”输入框中填入自己的邮箱地址。\n\n点击“Continue”（继续）按钮。\n\n填写新账号的密码（要求至少12个字符），然后点击“Continue”（继续）按钮。\n\n查看电子邮件，找到来自OpenAI的邮箱验证邮件，点击邮件中的“Verify email address”（验证邮箱）按钮。\n\n点击完邮箱验证按钮后会看到下面这个页面，需要完善你的个人信息，请填写你的姓名（Full Name）和出生年月日（Birthday)，如下图：\n\n\n\n\n完善个人信息以后，ChatGPT账号注册就已经完成，你就可以使用ChatGPT了。（注：最早注册需要境外手机号接收验证码，国内手机号通常无法使用，但从2023年底开始注册普通ChatGPT已经不需要手机号码验证了。）\n\nChatGPT怎么用？和其它AI工具，如Gemini、Grok、Claude一样，ChatGPT是一款非常强大的人工智能对话工具，能够帮助用户完成各种任务，从日常问答、写作辅助到复杂问题的分析。无论你是想寻求知识，进行创意写作，还是寻找建议，ChatGPT都能成为你的得力助手。那么，ChatGPT具体该怎么使用呢？\n与ChatGPT互动的方法与ChatGPT互动非常简单。你只需要输入问题或指令，ChatGPT会通过自然语言处理技术生成相应的回答。以下是一些常见的互动场景：\n\n提问问题：你可以直接向ChatGPT提出任何问题，比如“什么是量子计算？”或“如何做一道美味的蛋糕？” ChatGPT会基于海量的知识库为你提供详细解答。\n创意写作：如果你需要帮助进行创意写作，比如写小说、诗歌或文章，ChatGPT可以根据你的提示生成内容，帮助你拓展思路。\n语言翻译：你可以让ChatGPT翻译语言，比如将中文翻译成英文，或者反之。\n代码生成与调试：对于程序员来说，ChatGPT能够帮助生成代码片段，解释复杂的算法，甚至协助调试代码。\n建议与灵感：如果你需要旅行计划、生活建议，或者商业灵感，ChatGPT也可以提供有价值的参考。\n\nChatGPT的使用平台ChatGPT可以在多个平台上使用，方便你随时随地与它互动：\n\n网页版：通过电脑或手机浏览器访问ChatGPT的官方网站，直接在网页中进行对话。\n移动应用程序：有些平台提供了ChatGPT的手机应用，方便用户在移动设备上使用。\n第三方集成：一些生产力工具或应用（如Slack、Notion等）已经将ChatGPT集成进去，用户可以在这些应用中直接与ChatGPT互动。\nAPI接口：对于开发者来说，ChatGPT也提供API接口，允许将其功能集成到自定义应用或服务中，扩展AI的使用场景。\n\nChatGPT使用小技巧\n明确输入：为了获得最准确的回答，建议在输入问题或指令时尽量简洁明了。你可以提供更多背景信息或具体要求来让ChatGPT更好地理解你的需求。\n多轮对话：你可以和ChatGPT进行多轮对话，每一轮都可以基于上一轮的回答，继续深入探讨一个话题。\n反馈与优化：如果你对某个回答不满意，可以尝试重新提问或者改变问题的表述，ChatGPT会根据不同的提问方式给出新的答案。\n\n\n总结：以上就是我们针对中国大陆用户的ChatGPT注册和使用教程。虽然在中国使用ChatGPT有一些困难，但通过VPN等翻墙工具，大家还是可以注册和使用ChatGPT的。希望可以帮助大家顺利翻墙完成ChatGPT账号注册，并顺利使用ChatGPT，以下是我们的适用于ChatGPT的翻墙VPN推荐：\nWindows 翻墙教程：从零开始科学上网（最稳定的科学上网方案）\n苹果/IOS系统手机实现科学上网教程-翻墙VPN软件工具\n安卓/Android系统手机实现科学上网教程-翻墙VPN软件工具\n","categories":["科学上网"],"tags":[]},{"title":"奈飞（Netflix）全教程：如何注册观看奈飞？","url":"https://tanqingbo.cn/Netflix-VPN/","content":"喜欢追美剧的网友可能听说过“奈飞”（Netflix）这个平台。奈飞到底是什么？在中国能看奈飞吗？看奈飞需要翻墙吗？奈飞是否支持中文？如何注册奈飞账号？如何下载奈飞？如果你有上面这些问题，请看我们这篇奈飞教程。\n\n奈飞是什么：奈飞（Netflix，又译“网飞”）是一家总部位于美国的影视平台，类似于国内的腾讯视频、优酷视频、爱奇艺等平台。奈飞是全球最大、最有名的影视平台之一，覆盖大量国家和地区，在世界各地拥有大量用户。奈飞的影视平台提供大量内容，包括电视剧、电影、动画、纪录片等等。\n与国内视频平台不同，奈飞上的内容不能免费观看（可以免费试用一个月，但需要先把账号绑定付款方式）。奈飞采用会员制，付费会员交纳月费后，就可以观看平台上所有内容，而且没有广告。奈飞的视频可以在电脑、平板、手机、智能电视等多种设备上观看，并支持下载内容到本地观看。\n奈飞官网：奈飞官网的网址是：https://www.netflix.com/\n奈飞好剧有哪些？\n奈飞自创办以来制作了很多精良的影视作品，著名奈飞好剧包括《纸牌屋》、《心灵猎人》、《超感猎杀》、《女子监狱》、《后翼弃兵》、《黑镜》等等。可以说每隔一段时间都会有新的奈飞好剧上线。\n-—–\n奈飞在中国能看吗？奈飞为全球超过190个国家和地区提供服务，目前只有4个国家和地区没有奈飞的服务：中国大陆（不包括港澳台地区）、克里米亚共和国、叙利亚阿拉伯共和国、朝鲜民主主义人民共和国。\n由于中国大陆的政策限制（境外公司不得在中国大陆境内开展视听服务），所以奈飞还没有进入中国。虽然奈飞的官网并没有被屏蔽（因此不翻墙也可以访问），但如果在中国大陆打开奈飞官网，仅可以看到“无法使用”（Not Available）的错误信息。\n如何在中国观看奈飞？奈飞平台会根据访问者的IP地址来确定该访问者来自于哪个国家/地区。中国大陆的网民直接访问奈飞时会显示中国大陆的IP地址，所以会被拒之门外。\n要想突破奈飞对中国大陆的地域限制，可以使用VPN来访问奈飞。一般来说，大部分VPN软件都会提供位于世界各地的服务器节点，例如日本VPN服务器节点、香港VPN服务器节点等。如果在访问奈飞之前先用VPN连接到一个国外的VPN服务器节点（如美国），然后再打开奈飞，奈飞就会以为你来自于中国以外的地区，于是就会允许你正常访问。\n需要注意的是：因为近年来世界各地有很多人试图使用VPN突破奈飞的地域限制，所以奈飞平台逐渐学会识别来自于VPN的流量，一旦发现就会加以阻断，因此，很多VPN是无法用来突破奈飞的地域限制的。目前还有一些VPN可以突破奈飞的阻断，然而这些VPN中很多在中国又无法使用。那么问题来了：在中国好用、而且可以用来看奈飞的VPN有哪些呢？\n可以在中国用来看奈飞的VPN：根据大量国内网友和相关技术网站的翻墙软件评测和VPN排行，如果想要在中国大陆使用VPN访问和观看奈飞，大家可以选择下面这个VPN：\n如何使用梯子VPN工具实现翻墙 科学上网？\n奈飞账号：如何注册？价格是多少？在中国大陆注册奈飞账号和观看奈飞的条件上文已经提到，奈飞目前并没有进入中国，而且奈飞并不像国内视频平台那样允许免费观看（仅提供一个月免费试用，需要先绑定付款方式），所以，要想在国内注册和观看奈飞还是有一定门槛的，至少要满足下面三个条件：\n\n可以使用VPN（或本人在境外）注册奈飞账号\n可以使用奈飞接受的付款方式（信用卡、PayPal、礼品卡等）购买奈飞会员\n拥有一个稳定的、可以长期看在国内看奈飞的VPN。\n\n奈飞账号的分级：\n奈飞账号分成三个级别：\n\n基本套餐（Basic）：只可以播放480p标清视频，同一时间只能在一台设备上观看。\n标准套餐（Standard）：可以播放1080p高清视频，最多可以同时在两台设备上观看。\n高级套餐（Premium）：可以播放4K+HDR超高清视频，最多可以同时在四台设备上观看。\n\n奈飞账号的分区：\n奈飞覆盖全球上百个国家和地区，每个奈飞账号也只能属于一个国家和地区。奈飞账号的具体分区是由账号注册时的IP地址决定的。例如，注册奈飞账号时如果使用的是美国的IP地址（本人在美国注册或使用VPN的美国节点），这个账号就属于美区的。如果事后想更换帐户的国家/地区，需要比较麻烦的步骤。\n奈飞在每个国家/地区都有自己的原创和授权影视作品目录，在不同国家/地区登录奈飞，可以看到的内容是不完全一样的。例如，奈飞美国区提供大概4000部电影和1600部电视剧，而奈飞的香港地区仅提供大约2000部电影和1000部电视剧。\n奈飞的内容提供由用户登录的IP地址决定，而不是由账户所属地区决定。例如，即使你的奈飞账号是美国的，你旅行到香港（或者借助VPN用香港的IP访问奈飞），你看到的内容也是奈飞香港地区的内容。\n奈飞账号的价格：奈飞覆盖全球上百个国家和地区，个不同国家的奈飞账号价格也是不同的。例如：以下是一些不同国家和地区的奈飞价格列表：\n\n\n\n国家、地区\n基本套餐价格\n标准套餐价格\n高级套餐价格\n\n\n\n美国\n8.99美元\n13.99美元\n17.99美元\n\n\n英国\n5.99英镑\n9.99英镑\n13.99英镑\n\n\n加拿大\n9.99加币\n14.99加币\n18.99加币\n\n\n香港\n63港币\n78 港币\n93 港币\n\n\n台湾\n270 新台币\n330 新台币\n390 新台币\n\n\n新加坡\n11.98 新元\n15.98 新元\n19.98 新元\n\n\n购买奈飞账号的付款方式：\n奈飞在不同国家地区支持的付款方式不同，大部分都接受信用卡（VISA或MasterCard），国内银行的信用卡很多都可以接受。有些国家地区还支持PayPal和礼品卡。\n购买奈飞账号如何省钱：前面已经提到，在不同国家/地区购买奈飞会员价格不同，奈飞为不同国家/地区提供的内容也不一样。但是，奈飞并不是根据账号注册时所属区域来决定显示哪个地区的内容，而是根据账号登录时的实时IP地址来决定内容的。于是，很多网友摸索出一个用便宜价格购买奈飞账号的方法：\n注册奈飞账号时选择奈飞价格最便宜的国家，而观看奈飞时选择内容最多（或者对自己语言支持最好）的国家。举例来说，目前奈飞会员价格最低的国家是土耳其，所以在注册前先用VPN连接到一个位于土耳其的VPN节点，付款注册成为土耳其会员后就可以一直以土耳其会员的便宜价格续费。而每次观看前，只要用VPN连接到一个其它地区（如美国、香港），然后再登录奈飞，就可以看到这个地区（如美国、香港）的奈飞内容了。\n当然，这种方法是否一直可行目前还不确定，在这里仅供大家参考。\n-—–\n奈飞下载：\n在不同设备上观看奈飞，可能需要下载安装不同的软件或APP。当然，如果人在国内，下载前可能需要先翻墙。\n\n在电脑观看奈飞\n：\n\n可以直接使用浏览器登录奈飞官网（https://www.netflix.com/）观看，不需要下载其它软件。\nWindows用户也可以通过微软的应用商店下载奈飞的Windows版软件。\n在国内观看前需要先连接一个好用的电脑翻墙VPN。\n\n\n在iPhone或iPad上下载奈飞\n：\n\n在App Store搜寻“Netflix” APP，下载安装后即可。\n在国内观看前需要先连接一个好用的iOS翻墙VPN。\n\n\n在安卓手机、安卓平板或安卓版电视盒子上下载奈飞\n：\n\n如果设备上装有Google Play应用商店，只需要搜“Netflix” APP，下载安装即可。\n如果没有Google Play应用商店，可以在Google搜索“Netflix APK”，然后从可靠的网站下载奈飞的APK安装文件安装即可。\n在国内观看前需要先连接一个好用的安卓翻墙VPN。\n\n\n\n-—–\n奈飞的中文支持：奈飞界面的中文支持：奈飞用户登录奈飞网站后，可以把页面设置成中文的。根据用户登录时IP，奈飞会把中文界面选项自动配置成简体中文或繁体中文：\n\n对于大部分国家的IP地址，如美国、英国、香港、台湾等，中文页面会自动使用繁体中文。\n如果IP属于新加坡、印度、马来西亚，中文页面会自动使用简体中文。\n\n奈飞视频的中文字幕支持：奈飞在不同国家和地区对中文字幕的支持是不同的。例如奈飞美区的视频对中文字幕的支持率比较低，可能只有奈飞原创影视剧集支持中文字幕。而在华人较多的地区，如香港、台湾、新加坡、马来西亚等地，中文字幕的支持率就高得多。\n-—–\n奈飞教程：总结在这篇文章里我们介绍了著名国外视频平台奈飞（Netflix），并提供了在中国大陆注册奈飞账号、下载、观看奈飞的方法和技巧。\n如果想要在中国大陆使用VPN访问和观看奈飞，大家可以选择下面这几个VPN：\nWindows 翻墙教程：从零开始科学上网（最稳定的科学上网方案）\n苹果/IOS系统手机实现科学上网教程-翻墙VPN软件工具\n安卓/Android系统手机实现科学上网教程-翻墙VPN软件工具\n","categories":["科学上网"],"tags":[]},{"title":"电报(Telegram)下载注册教程，电报群怎么加入？","url":"https://tanqingbo.cn/Telegram-VPN/","content":"电报(Telegram)下载注册教程，电报群怎么加入？电报（Telegram）是一个国外著名的即时通讯APP，在功能上和微信、Whatsapp相似，但又有一些不同之处，例如，Telegram有加密聊天的功能，使用这种功能，聊天双方的内容完全保密，不会担心被监控或被第三方偷窥。\n另外，和微信群一样，Telegram上有很多“电报群”，内容五花八门，从科技、娱乐，到区块链、炒币，应有尽有。而且，很多电报群加入时不需要别人邀请，知道地址后可以自己直接加入。此外，电报群不像微信群那样有500人的人数限制，很多电报群有成千上万的人，非常热闹。\n和微信一样，大部分电报的用户都是通过手机（安卓Android、苹果iOS等）使用它的，但Telegram也提供网络版和桌面应用程序。\n\n下面给大家提供一个电报和电报群的教程，包括注册、下载、使用，加入电报群等。\n第一部分：电报（Telegram）安装教程：安装电报（Telegram）第一步：翻墙Telegram是很多网友翻墙后必下的App，这是因为电报是一个内容五花八门、可以畅所欲言的APP，所以可想而知它在国内早已被墙，是无法直接使用的，所以要下载、安装和使用Telegram，第一件事就是翻墙。大家可能已经熟悉各种科学上网的方式，如果还不熟悉，可以看一下下面这篇教程：\n如何使用梯子工具实现翻墙 科学上网？\n安装电报（Telegram）第二步：下载电报APP或软件在需要安装Telegram的设备（手机或电脑）上翻墙，然后通过浏览器访问电报（Telegram）官网，然后点击导航栏的“Apps”链接，在打开的网页上能看到Telegram在不同设备上的APP和软件的下载链接：\nTelegram手机版：\n\n安卓APP：点击“Mobile apps”下面的“Telegram for Android”。如果手机上没有安装Google Play应用商店，可以在其它手机应用商店里搜索“telegram”，或用Google搜索“telegram apk”直接通过下载的apk安装。\niPhone、iPad APP：点击“Mobile apps”下面的“Telegram for iPhone and iPad”，会连接到App Store的Telegram页面。如果在国内的App Store找不到Telegram，那么可以尝试使用海外版苹果账号登录海外版App Store。实在不行的话，可以考虑使用Telegram的网页版或电脑桌面程序版。\n\nTelegram电脑桌面程序版：\n\n（在电脑浏览器上）点击“Desktop apps”下面的“Telegram for Windows/Mac/Linux”，下载安装文件。\n\nTelegram电脑网页版：\n\n（在电脑浏览器上）点击“Web apps”下面的“Telegram Web-version”，直接访问页面，不需要安装任何软件。\n\n安装电报（Telegram）第三步：注册Telegram账号安装好电报的APP或桌面软件之后，打开Telegram（如果使用网页版，直接访问电报网页版的页面），你会看到一个让你输入电话号码来注册账号的界面，你需要选择国家和区号（中国大陆是+86），然后输入你的手机号码。接下来你会收到验证码，将验证码输入后，再输入一些个人信息，注册就完成了。\n安装电报（Telegram）第四步：通过汉化添加Telegram中文版目前Telegram的官方软件还不支持中文，页面都是英文的，如果大家觉得用英文版不方便，可以自己汉化电报、添加中文版界面。\n汉化Telegram的具体方法是在浏览器的网址输入框里输入这个网址：”t.me/zh_CN“，打开页面后，点击”VIEW CHANNEL“，如果是在已经安装了电报APP的手机上操作的话，就会进入电报APP，并会看到针对Telegram不同版本（Android、iOS、Desktop）的汉化包下载链接和安装方式，按照上面的方法下载、设置，就可以使用Telegram的汉化中文界面了。\n\n第二部分：电报（Telegram）使用指南：如何在电报添加联系人（好友）比起微信通过扫二维码添加好友的方式，在Telegram添加联系人还是更麻烦一些。\n以手机版Telegram为例，点击页面左上角的三个横杠标志，在菜单中点击“联系人”（Contacts），第一次打开时会弹出页面要求访问手机通讯录来获得手机联系人名单，如果允许的话点击“继续”。点击通讯录里的人名，就可以添加新的联系人，如果对方目前还没有加入Telegram，可以选择发出邀请。\n如果需要添加的人不在手机通讯录里的联系人，点击“联系人”（Contacts）页面右上角的“+”号，然后会看到一个页面，可以通过输入对方电话号码的方式来邀请对方成为自己的联系人。如果已经知道对方的Telegram用户名，也可以通过搜索来添加好友，点击“联系人”（Contacts）页面上方的放大镜搜索图标，然后输入对方的用户名，就可以搜索了。\n如何和联系人聊天以手机版Telegram为例，点击页面左上角的三个横杠标志，在菜单中点击“联系人”（Contacts），然后会看到联系人列表，点击想要聊天的联系人，就可以进入聊天页面了。\n如何使用电报的加密聊天Telegram有一个加密聊天的功能，可以保证聊天内容的私密性，因为聊天内容是加密存储的，除了聊天双方之外，别人不会知道聊天内容，即使是Telegram的后台人员也无法监控内容。这个功能在微信是没有的。\n使用方法：以手机版Telegram为例，点击页面左上角的三个横杠标志，在菜单中点击“新建加密对话”，然后选择联系人就可以开始加密聊天了。\n如何加入电报群Telegram的群组（电报群）类似于微信群，不同的是电报群没有500人的上限，据说上限是10万人。另外，电报群分为公开群和私密群两种，私密群类似于微信群，需要有邀请链接才能加入，加入后也不能看到加入前的聊天内容。而公开群有一个公开的地址，例如：t.me/newbie_chat，这个Telegram新手帮助群的代号就是newbie_chat。如果想要加入这个公开群，进入Telegram主界面，在上端的搜索框中输入“@newbie_chat”，然后点击下面出现的选项中正确的那一个，就可以进入这个电报群的页面（可以看到页面上方显示该群的成员数量），然后点击界面下方的“加入”（Join），就可以进群，也可以发言参加讨论了。\n如何订阅频道Telegram的频道（Channel）基本相当于微信的公众号，用户可以订阅，但不能发言。和群组一样，电报频道也有一个公开地址，如：t.me/features，这个频道定期发布Telegram的新功能。如果想订阅这个频道，进入Telegram主界面，在上端的搜索框中输入“@features”，然后点击下面出现的选项中正确的那一个，就可以进入这个电报频道的页面（可以看到页面上方显示频道的订阅者数量），然后点击界面下方的“加入”（Join），就可以订阅这个频道了。\n电报、电报群安全小贴士：虽然电报和电报群不像微信那样随时受到有关部门的监控，但并不是说就完全安全了，如果使用不慎，还是有可能招警察叔叔上门的。如何使用电报和电报群时保证安全呢？请看这些建议：\n1. 隐藏自己的电话号码\nTelegram注册要使用电话号码，如果设置不当，你电报账号的电话号码可能被别人看到，如果你用国内手机注册，那么如果有关部门能查到你的电话号码，你也就完全暴露了。为防止这种情况，你可以在“隐私和安全”（Privacy and Security）的设置里把你的电话号码设置成完全不可见（或仅联系人可见），并把“谁能通过电话号码找到我”设成我的联系人，而不是所有人。\n2. 如果有可能，尽量不要用国内电话号码注册Telegram\n国内电话号码是实名制的，如果号码暴露，有关部门可以随时找到你。如果有海外的电话号码（包括虚拟号码如Google Voice等），尽量使用海外号码注册Telegram。\n3. 在电报群里发言仍要小心\n虽然电报群不像微信群那样随时受到监控、有可能随时被炸，但并不代表完全私密。有些电报群是公开的，所有人都可以加入，那么有关部门也可以派便衣加入，刺探群里人在聊什么。所以，虽然没有炸号危险，在电报群发言也不能掉以轻心。\n访问电报（Telegram）必备工具：因为Telegram在国内被封，所以使用前必须翻墙，以下是一些访问Telegram好用的翻墙教程：\nWindows 翻墙教程：从零开始科学上网（最稳定的科学上网方案）\n苹果/IOS系统手机实现科学上网教程-翻墙VPN软件工具\n安卓/Android系统手机实现科学上网教程-翻墙VPN软件工具\n","categories":["科学上网"],"tags":[]},{"title":"从什么事情知道别人没把你当朋友？","url":"https://tanqingbo.cn/2025-07-15/","content":"《一句顶一万句》里面有这样一个故事：\n杨百顺的爹老杨，是个卖豆腐的，住在河南延津县+杨家庄。\n老杨和马家庄+赶大车的老马是好朋友，至少老杨是这样认为的，但其实老马从心底看不起老杨，但这并不影响他们之间的友谊，不是因为老马也把老杨朋友了，而是老马说起笑话离不开老杨。\n老杨对别人说起朋友，第一个说的就是老马，而老马背后说起朋友，一次也没有提到过老杨。\n杨百顺11岁那年，镇上铁匠老李给母亲做寿。\n那天中午，大家都去吃酒席。老杨迟到了，老李觉得老杨和老马是好朋友，就把老杨的座位空在老\n马身边。没想到老马急了，要他换地方。\n杨百顺在老李家帮忙挑水，刚好听到了。第二天，老杨在家里埋怨酒席吃得不痛快，不是因为酒菜做的不好，而是身边坐的不是老杨，所以吃的不痛快，杨百顺就把昨天听到的话告诉了老杨。\n之后半个月，老杨没理老马。半个月后，两人又恢复了来往。\n40年后，老杨中风了，瘫痪在床，家里的掌柜换成了大儿子杨百业，老杨一切都要看杨百业的脸色\n行事。\n有一次，杨百业问老杨：“当年老马不拿你当人，你为啥非巴结他做朋友？”\n老杨说：“记得第一次和他见面，就被他说住了。论起事来，同样一件事，我只能看一里，他能看十里，我只能看一个月，他一下能看十年。因此以后遇到事就想找他商量。”\n杨百业说：“听明白了，还是想占人便宜，遇事自己拿不定主意，就想借人一双眼。既然他看不上\n你，为啥还跟你来往呢？\n老杨说：“方圆百里，哪儿还有一下看十里和看十年的人呢？老马也是一辈子没朋友。”\n所以老杨离不开老马，是想借老马一双慧眼，遇事可以找他商量，老马离不开老杨，是因为他讲的笑话离不开老杨，所以只好一边嫌弃一边将就地和老杨做塑料朋友。\n但在外人看来，他们确实是很好的朋友。\n这个故事还有个第三者，就是邻摊卖葱的老段，在老杨瘫痪的时候，老段来看望过老杨，\n当年一起在镇上一起摆摊的时候，老段就对老杨很好，老杨瘫痪的时候，老段还来看望老杨，可是老杨却从来没有把老段当成朋友。\n","categories":["技术以外"],"tags":[]},{"title":"iphone如何用外网/苹果手机搭梯子-翻墙VPN软件工具","url":"https://tanqingbo.cn/iphone-open-internet/","content":"由于不可描述的原因，很多地方都有墙的的存在。这就导致我们没办法用谷歌、Twitter、Instagram、Youtube、Netflix、ChatGPT等等优秀的平台。\n因此，我们需要翻墙，需要科学上网，这样就可以自由浏览墙外的资源，更好的学习，提升自我。\n既然墙阻挡了我们直接访问国际互联网上的某些特定服务，那么我们只能绕行了。方法就是使用梯子工具：\n\n找一台墙外的电脑，一台不经过墙，能自由上网的电脑\n把我们想访问的内容，交给这台没有限制的电脑来完成\n这台电脑访问到对应的内容后，再返回给我们\n由此，我们完成了通过这台电脑获取被墙的网络内容\n\n这台不经过墙，能自由上网的电脑，通常被成为代理服务器。\n而能够通过代理服务器访问外网的软件，通常被成为梯子、代理软件，也叫翻墙软件。\n\n由上述原理介绍，可以得到，要想实现科学上网，需要 代理服务器 + 翻墙软件 来实现。\n代理服务器一般通过购买来获得，当然网上也能找到免费的，不过我比较提倡用钱能解决的问题，尽量还是花些钱吧，这样方便、稳定、且一劳永逸。\n代理服务器购买代理服务的话，我个人推荐一支红杏的代理服务，它是銘佑科技（香港）有限公司（也是老薛主机，不会跑路型）推出的网络加速器服务，基于 Trojan 协议的科学上网方式，该协议会将您需要代理的网络数据伪装成 HTTPS 协议的正常网络数据，以通过防火墙的检测和封锁，连接速度快，它会帮助你在互联网上冲浪时保护你的隐私和安全。\n\n支持 Windows、MAC OS X、cross platform、Android、IOS、openwrt等系统，是非常实用的网络代理软件。\n我买的就是一枝红杏的VPN，亲测真的很好用，网速很快，Google、youtubu、Facebook啥的都能上。下面就教大家怎么用起来。\n打开一枝红杏官网。\n官网：https://order.yizhihongxing.club/aff.php?aff=4818\n翻到下面会有两种VPN的购买方式，如果是个人用的话，选择入门版就可以了，一个月100G足够用了。\n跳转到订购页面后可以先在右上角点击注册，注册一个新账号，然后再根据提示购买你的产品。\n购买之后依次点击上方导航栏中的 产品与服务-&gt;我产品与服务-&gt;查看详情，就能看到你购买的节点信息。\n\n\n\n购买完代理服务器之后，接下来需要安装一个软件来辅助我们进行科学上网。\n科学上网（翻墙）软件下载客户端：苹果手机需要下载一个名叫Spectre的软件来辅助我们进行科学上网，如果你持有非中国大陆地区的 Apple ID 账户，您可以直接前往商店免费获取(由于苹果公司的限制，相关类型客户端无法在中国大陆地区商店上架）。\n客户端图标样式： ，如果在应用商店通过搜索安装客户端，要仔细确认客户端的图标样式。\n如果你没有非中国大陆地区的 Apple ID 账户，可以手动注册一个海外地区的Apple ID。\n申请海外 Apple ID准备工作：\n\n打开 https://account.apple.com \n点击右上角 创建你的 Apple 账户（手机访问需要点击下拉箭头），\n创建一个全新的 Apple 账户（中国大陆）\n\n\n在你手机上的 App Store 登录刚刚注册好的Apple ID，因为是新 Apple ID 第一次登录，所以会有图中的提示，点「检查」进入下一步\n切换 APPLE ID 时，打开 AppStore ，点击右上角的头像，拉到最底部点击退出登陆，再重新登陆即可，不要在设置中切换 iCLOUD 账户。\n\n选中「同意条款和条件」，点击「下一页」，选择付款方式为「无」，填好必填信息，再点「下一页」完成创建，然后在 App Store 退出你的 Apple ID\n\n开始修改地区用电脑打开 https://account.apple.com ，登陆刚刚注册的 Apple ID ，\n点击左侧的个人信息后，再点击右侧的国家或地区进行切换。\n\n切换国家或地区选择「香港」，点击「继续更新」（当然您也可以选择您喜欢的国家或地区）。\n现在 APPLE 更新了政策，很多地方需要手机短信验证，因此推荐选择 香港 地区，可以使用 +86 号码验证。\n\n付款方式选择 无 然后设置其他信息，然后点击右上角的「保存」\n\n然后在 App Store 重新登录您的海外 Apple ID 即可搜索 Spectre VPN 下载客户端了。\n下载好 Spectre客户端之后，然后在在你购买代理服务器的界面复制订阅链接(在产品详情页面获取)，如下：\n\n注：订阅链接与您的密码一样重要，请勿分享给他人，如不慎泄露，请在产品详情页面重置链接。\n点击 订阅按钮 可以选择 复制订阅链接 或是 显示订阅二维码。\n复制链接后点击客户端主界面的 添加服务器。\n\n\n点击 切换服务器 - 订阅 右侧的 + ，在新弹出的窗口中，粘贴订阅链接，点击完成即可完成添加。\n点击 扫码  按钮可以通过扫码的方式添加 (请更新至 1.0.0.19 以上版本)。\n\n\n\n添加完成后，即可选择一个节点，点击连接开始使用。\n\n4. 启动连接添加完成后，主界面会显示节点信息，点击顶部 未连接 右侧的按钮即可开始使用代理。\n\n第一次连接时，客户端会请求 VPN 设置权限，请选择允许。\n\n如果需要添加更多或是切换节点，请点击 切换服务器 进行添加或是更换节点。\n之后便可以自由的访问Google、Twitter、Instagram、Youtube、Netflix、ChatGPT等等这些优秀平台了。\n对了，如果你不需要科学上网的时候记得把下面这个按钮关掉，需要科学上网的时候在打开，这样可以提升你的上网体验。\n\n","categories":["科学上网"],"tags":[]},{"title":"文献引文分析利器 HistCite 详细使用教程暨 HistCite Pro 首发页面","url":"https://tanqingbo.cn/HistCite-Pro/","content":"如果你选修过中国科学技术大学罗昭锋老师的《文献管理与信息分析》，那么你一定不会对HistCite 感到陌生，这是一款非常强大的引文分析工具，可以快速绘制出某个研究领域的发展脉络，快速锁定某个研究方向的重要文献和学术大牛，还可以找到某些具有开创性成果的无指定关键词的论文。\n如果说一次引用表示给你的文章投一票，那么并不是所有票都有效，只有相同领域文章的引用才能真正体现你在这个领域中的实力。所以在 Web of Science （以下简称 WOS）上按照被引次数倒序排列，越靠前不一定就越重要。还有一种情况，你发明了某种材料，但是后来名字变了，之后的文章使用的关键词都是新名字，别人搜新名字的关键词是搜不到你的开创性文章的，但是很显然你的文章是非常重要的。通过 HistCite 可以直观的看出这个研究领域的论文全部引用了你的文章，可以体现你的文章的重要性。\n好了，下面开始使用这个工具。首先要了解一点，HistCite 这款软件是 Thomson Reuters （汤森路透）公司开发的，和 WOS 是一家公司，所以 HistCite 只支持 WOS 数据库，对于 Scopus 等数据库则无能为力，不过 Github 上面有人写了一个可以将 Scopus 导入 Histcite 进行分析的脚本——Scopus2Histcite，有兴趣的同学可以去试试看。\n2016年10月，汤森路透知识产权与科技业务被 Clarivate Analytics （科睿唯安）公司收购了，从此 WOS 也是归该公司所有，因此导出的数据纯文本也发生了些许变化，从而不能直接导入 HistCite 进行分析。不过别担心，HistCite Pro 完全兼容新的文件格式！\n打开WOS，注意数据库要选择核心合集（Core Collection）！\n\n例如简单检索一下石墨烯在锂离子电池负极中的应用：\n\n检索结果不是太多，可以全部导出，如果文献太多的话，可以先按照被引频次降序排列，只导出前2000篇就差不多了。\n\n下面开始导出文献信息，点击页面上的【保存至 Endnote Online】按钮右边的下拉按钮，选择【保存为其他文件格式】。\n\n在弹出的菜单中，记录数填写1到500，因为每次最多只能导出500篇文献，所以上面的2819篇文献需要分成6次导出，后面导出的时候依次填写501到1000、1001到1500等等。。。记录内容选择【全记录与引用的参考文献】，文件格式选择【纯文本】，然后点击发送即可得到导出的 txt 文件，类似可以导出其他5个。\n\n注意：含500个记录的txt文档一般是3M左右，如果你的只有几百K，请仔细按照上面这张图进行导出！！！\n下面使用 HistCite 来分析这6个txt格式的引文数据文件。由于 HistCite 多年不更新，现在存在各种 Bug，比如直接打开 HistCite，一加载文件就报错：No such file or directory。\n\n尝试第二种方法。选中所有的 txt 文件，然后拖到 HistCite 的图标上，放开鼠标，果然自动打开了软件。\n\n但是，事情好像并没有那么简单，又出现了一个报错：Format Unknown。\n\n在受到这么多折磨之后，我用 Python 开发了一个方便使用的脚步，于是一个以 HistCite 源程序为核心的精简易用免安装版本问世了，就叫 HistCite Pro 吧。\n\n由于 HistCite 源程序只支持 Windows 系统，所以 Pro 版本也只能在 Windows 下使用！\n你只需要下载 HistCite Pro 的压缩包（下载链接见文末）并解压（建议解压到 C 盘或者 D 盘的根目录下，保证路径中不含中文），就可以直接用，不需要安装，同时去掉了很多没用的文件，大大缩小了软件体积。对于从WOS上导出的txt数据文件，不用做任何修改，只要把全部的txt放到 TXT 文件夹里面，然后双击 main.exe 并输入数字 1 即可一键完成加载，非常方便。（下面是整个操作过程的动图，点击播放）\n\n如果输入数字 1 发现没有自动打开浏览器窗口，或者打开的是一个空白网页，或者可以打开网页之后显示的条目数为0，首先检查一下前面的导出操作没有错误，然后看一下自己的 IE 浏览器能不能正常打开百度等网页，如果 IE 浏览器有故障，可以参考这个链接进行修复。\n如果还不行，那就是 HistCite 内核本身存在的设计缺陷（毕竟这么多年没有官方更新了），在少部分电脑上会出现兼容性问题。所以我采用 Python 的多线程成功实现了Advanced 模式，基本可以解决绝大部分兼容性问题，即输入数字 3。\n注意：在该模式下，程序所在路径中的所有文件夹和文件的命名都不能含有中文。\n\n该模式启动之后会自动打开两个浏览器窗口，先打开默认的 IE 浏览器窗口（记为 A 窗口），一般显示的 Records 数量为 0，然后 5 秒之后会调用系统默认浏览器（推荐安装 Chrome 浏览器并设置为默认）打开另一个窗口（记为 B 窗口），一般在 B 窗口就可以正常进行数据的导入。等导入完成之后，你可以将 A 窗口关闭，在 B 窗口里面分析数据，或者刷新 A 窗口也是可以分析数据的。\n\n好了，数据加载完毕，下面开始分析数据吧，点击 Tools 菜单下的 Graph Maker。\n\n在弹出的页面上点击 Make Graph 即可得到一张引文关系图，包含了最有价值的前 30 篇文章的完整引文关系，这个数字 30 是可以自行修改的。\n\n这张图看起来不是很清楚，在左边的Size选项中选择 Full 模式，重新绘制一张高清图，然后右击图片“另存为”一张图片即可。\n\n\n图上有 30 个圆圈，每个圆圈表示一篇文献，中间的数字是这篇文献在数据库中的序号。圆圈越大，表示被引用次数越多。不同圆圈之间有箭头相连，箭头表示文献之间的引用关系。多数情况下，你会看到最上面有一个圆圈较大，并有很多箭头指向这篇文章。那么这篇文章很可能就是这个领域的开山之作。\n通过我绘制出的这张关系图，我们发现标号为29、49、56、60的四个大圆圈非常显眼，可见这四篇文献的被引次数都是非常高的，我们对全部文献进行按照 LCS 排序，发现前四位刚好就是这 4 篇文献。\n\n再回到那张圆圈箭头关系图，可见石墨烯在锂离子电池负极材料中的应用研究主要起源于2008年（29号文献），其通讯作者Honma来自日本，看来日本在石墨烯电池方面的研究开展得相当早。之后，在2010年，很多原创性的成功迸发而出，具有代表性的就是49、56、60、48号文献，非常有趣的是，2010年诺贝尔物理学奖的获奖项目刚好是石墨烯，其中的关联显而易见。之后的几年，石墨烯在锂离子电池负极方面的研究越来越多，方向约越来越细。\n好了，前面提到HistCite可以找到某些具有开创性成果的无指定关键词的论文，我们来看看是怎么办到的。点击页面上的【Cited References】，然后就可以看到本地库中的文献参考的全部文献信息，后面带有加号的表示本地txt库中没有包含。如果然后按照 Recs 数排序，可以看到有几篇 Recs 数很大的文献并没有在分析范围之内，这些往往就是被遗漏的重要文献。正常情况下点击加号（+）后的 WOS 就可以自动通过 WOS 将文献载入分析。\n\n如果点击之后网页报错，内容是：Routing Error。Error massage：cannot process request with unsupported DestLinkType:CitedLookup。\n\n这是由于 WOS 地址解析错误，可以按照以下方法来解决。\n首先在任何网页浏览器中打开 Web of Science 网页，点击【被引参考文献检索】标签（英文版是【Cited Reference Search】）。复制当前页面的网址，后面要用。网址格式为：http://apps.webofknowledge.com/UA_CitedReferenceSearch_input.do?SID=**&amp;product=UA&amp;search_mode=CitedReferenceSearch，注意最后以 CitedReferenceSearch 结尾。\n\n然后在 Histcite 工具栏 tools下拉菜单中选择 Settings 点击。\n\n在弹出的对话框中，往下找到 WoS link 这一栏，默认选择是 Universal setup，改选 Manual setup version 4，然后在 ISI web of knowledge 4 location URL 下面的框里粘贴刚才复制的网址，再点击【Set】即可。\n\n然后再点击遗漏文献后面加号（+）后的 WOS 就可以打开 WOS 并自动将文献信息填进去，然后点击【检索】。\n\n在搜索结果中找到所需要的文献（一般被引次数最多的那个就是），点击【完成检索】即可显示引用了该篇文献的所有文献，同样可以导出 txt 加入 Histcite 进行分析。\n\n同样的，我们点击 Histcite 页面的【Authors】按钮，可以找到本领域的一些大牛，具体的操作步骤读者可以自己去摸索。\n那么我们怎么把文献记录导出到Endnote呢？首先点击菜单栏中【Tools】下的【Mark&amp;Tag】选项，调出标记选择工具栏。\n\n下图红框内就是标记选择工具栏。左边栏用于指定选择范围，可以选择当前列表中的全部文献，也可以按照序号（#）、LCS、LCR等数值的区间来选择文献，还可以手动勾选需要的文献。中间栏表示的是需要导出的信息范围，可以只导出记录本身，也可以选择导出引用的文献或者被引的文献。右边栏的【Mark】按钮就是确认选择按钮。\n\n所以，我们选择好了需要导出的文献记录，点击【Mark】按钮。\n\n然后，我们就会发现上面出现了一个新的标签【Marks】，后面的数字就是我们选中的记录条数，如果发现这个数字不正确，点击【Mark】按钮旁边的【Unmark】来重新选择。确认无误之后，点击图示的【Marks】标签链接，即可显示全部被选的文献记录。\n\n好的，下面依次点击【File】、【Export】、【Records…】来导出选中的文献记录。\n\n成功导出后得到一个 .hci 格式的文本文件，直接修改后缀为 txt。如果导出不成功，一般多尝试几次就可以。\n\n好的，现在我们打开Endnote，依次点击【File】、【Import】、【File…】按钮。\n\n在弹出的对话框中通过【Choose…】找到刚才的txt文件，【Import Option】选择 Multi-Filter (Special)**，【Duplicates】选择 **Import All，然后点击【Import】按钮即可导入。\n\n评论中沈曦同学提到了将 HistCite 选好的文献导入到 Noteexpress 软件里的方法，具体操作是在导入时将过滤器选择为 web of science。\n最后附上HistCite里面几个重要的英文缩写（感谢Dingledodies同学）：\nGCS（global citation score）， 某一文献在WOS数据库中的总被引用次数。有些引用这篇参考文献的文章可能和你的研究方向毫无关系，但GCS还是会把这个引用数据记录下来。\nLCS（local citation score），某一文献在本地数据集中的被引用次数。因为你导入Histcite的文章都是和你检索词有关系的，可以认为这些文章是你的研究同行，因此如果某一篇文献的LCS值很高，就意味着它是你研究领域内的重要文献，很有可能是你领域内的开创性文章，注意LCS高的文献和GCS高的文献不一定是同一篇！\nLCR（local cited references）， 某一文献引用本地数据集中参考文献的数目。根据LCR值的排序，可以快速定位近期关注该领域的重要文献，因为某一篇文献引用当前数据集中的文献数越多，说明它非常关注你检索的这个研究方向的文献，和你的研究肯定有相似或者可参考之处，可以从该文章中发现新动向。\nCR（cited references）， 某一文献引用WOS数据库中参考文献的数目。这个值越高，说明这篇文献很可能是综述性文献，可根据该值的排序，也可快速定位综述文献。\n通过网盘分享的文件：\nHistCite Pro 网盘下载链接: https://pan.baidu.com/s/1VnG4OYsKBprrTr5sVQbklQ?pwd=bc23 \n提取码: bc23 \n","categories":["图像处理与机器学习"],"tags":[]},{"title":"Windows 翻墙教程：从零开始科学上网（最稳定的科学上网方案）","url":"https://tanqingbo.cn/Win-OpenInternet/","content":"在中国大陆，访问大部分境外网站（如 Google、YouTube、Twitter、ChatGPT 等）都会被网络防火墙阻断。常见问题包括：\n\n网站打不开 / 加载失败\n页面显示连接超时\n无法登录国际应用如 Discord、Telegram、OpenAI\n\n解决方法只有一个：使用科学上网工具+机场服务。\n\n🚀 科学上网 = 工具 + 节点（机场）你需要两样东西：\n\n科学上网工具：例如 Clash for Windows，用于接收并解析节点\n机场服务：例如「一支红杏」，提供高速稳定的加密节点，支持解锁 Google / YouTube / ChatGPT 等平台\n\n\n✅ 一支红杏机场简介（推荐）一支红杏是銘佑科技（香港）有限公司（也是老薛主机，不会跑路型）推出的网络加速器服务，基于 Trojan 协议的科学上网方式，该协议会将您需要代理的网络数据伪装成 HTTPS 协议的正常网络数据，以通过防火墙的检测和封锁，连接速度快，它会帮助你在互联网上冲浪时保护你的隐私和安全。\n\n支持 Windows、MAC OS X、cross platform、Android、IOS、openwrt等系统，是非常实用的网络代理软件。\n亲测真的很好用，网速很快，Google、youtubu、Facebook啥的都能上。\n\n🔗 官网地址：https://order.yizhihongxing.club/aff.php?aff=4818\n\n🖥 Win 电脑科学上网详细教程第一步：注册一支红杏账号并获取订阅链接\n打开官网：https://order.yizhihongxing.club/aff.php?aff=4818\n翻到下面会有VPN的注册方式，如果是个人用的话，选择入门版就可以了，一个月100G足够用了。\n跳转到订购页面后可以先在右上角点击注册，注册一个新账号，然后再根据提示购买你的产品。\n购买之后依次点击上方导航栏中的 产品与服务-&gt;我产品与服务-&gt;查看详情，就能看到你购买的节点信息。\n\n\n\n购买完代理服务器之后，接下来需要安装一个工具来辅助我们进行科学上网。\n\n第二步：下载 Clash for Windows（推荐工具）👉 下载地址（开源免费）：https://order.yizhihongxing.club/index.php?rp=/knowledgebase/13/\n下载安装好之后，前往 产品/服务 ，打开产品详情页面，向下滑动。\n点击 Clash 配置右侧的获得地址，在弹出的窗口中，选择 复制地址 或是 下载配置。\n\n\n第三步：导入一支红杏订阅链接\n打开 Clash for Windows\n\n左侧菜单点击【订阅/(Profiles)】（配置文件）\n\n粘贴一支红杏的订阅链接 &gt; 点击【导入】下载配置\n\n\n\n\n第四步：启动代理，开始上网\n在 Clash for Windows 界面左侧顶部开启「代理」开关\n选择一个延迟较低的节点（推荐香港 / 新加坡 / 日本）\n打开浏览器，访问 Google / YouTube / ChatGPT 测试即可\n\n\n🌎 一支红杏节点支持平台一览\n\n\n功能\n奶油云支持\n\n\n\nGoogle / YouTube / Gmail\n✅ 解锁\n\n\nChatGPT / OpenAI / Midjourney\n✅ 解锁\n\n\nNetflix / Disney+ / TikTok 海外版\n✅ 解锁（部分专线）\n\n\n支持协议\nVmess / VLESS / Trojan / SS\n\n\n\n❓ 常见问题解答Q：订阅导入后无节点？A：请检查 Clash 是否更新配置成功，或联系客服确认订阅是否正确。\nQ：YouTube 打不开、视频加载慢？A：建议更换节点（低延迟）、开启 TUN 模式、切换网络测试。\n\n✅ 总结Win 电脑要上外网，只需三步：\n\n注册一支红杏账号并获取订阅\n下载并安装 Clash for Windows\n导入节点、开启代理，立即畅游全网\n\n相比其他方法，Clash + 一支红杏机场方案安全、稳定、全平台支持，是目前最值得推荐的科学上网组合。\n📌 一支红杏官网地址：https://order.yizhihongxing.club/aff.php?aff=4818\n其它设备设置VPNiOS/MAC 端注册教程：iphone如何用外网/苹果手机搭梯子-翻墙VPN软件工具\nAndroid 端注册教程：安卓/Android系统手机实现科学上网教程-翻墙VPN软件工具\n","categories":["科学上网"],"tags":[]},{"title":"苹果/IOS系统手机实现科学上网教程-翻墙VPN软件工具","url":"https://tanqingbo.cn/ios-open-internet/","content":"由于不可描述的原因，很多地方都有墙的的存在。这就导致我们没办法用谷歌、Twitter、Instagram、Youtube、Netflix、ChatGPT等等优秀的平台。\n因此，我们需要翻墙，需要科学上网，这样就可以自由浏览墙外的资源，更好的学习，提升自我。\n既然墙阻挡了我们直接访问国际互联网上的某些特定服务，那么我们只能绕行了。方法就是使用梯子工具：\n\n找一台墙外的电脑，一台不经过墙，能自由上网的电脑\n把我们想访问的内容，交给这台没有限制的电脑来完成\n这台电脑访问到对应的内容后，再返回给我们\n由此，我们完成了通过这台电脑获取被墙的网络内容\n\n这台不经过墙，能自由上网的电脑，通常被成为代理服务器。\n而能够通过代理服务器访问外网的软件，通常被成为梯子、代理软件，也叫翻墙软件。\n\n由上述原理介绍，可以得到，要想实现科学上网，需要 代理服务器 + 翻墙软件 来实现。\n代理服务器一般通过购买来获得，当然网上也能找到免费的，不过我比较提倡用钱能解决的问题，尽量还是花些钱吧，这样方便、稳定、且一劳永逸。\n代理服务器购买代理服务的话，我个人推荐一支红杏的代理服务，它是銘佑科技（香港）有限公司（也是老薛主机，不会跑路型）推出的网络加速器服务，基于 Trojan 协议的科学上网方式，该协议会将您需要代理的网络数据伪装成 HTTPS 协议的正常网络数据，以通过防火墙的检测和封锁，连接速度快，它会帮助你在互联网上冲浪时保护你的隐私和安全。\n\n支持 Windows、MAC OS X、cross platform、Android、IOS、openwrt等系统，是非常实用的网络代理软件。\n我买的就是一枝红杏的VPN，亲测真的很好用，网速很快，Google、youtubu、Facebook啥的都能上。下面就教大家怎么用起来。\n打开一枝红杏官网。\n官网：https://order.yizhihongxing.club/aff.php?aff=4818\n翻到下面会有两种VPN的购买方式，如果是个人用的话，选择入门版就可以了，一个月100G足够用了。\n跳转到订购页面后可以先在右上角点击注册，注册一个新账号，然后再根据提示购买你的产品。\n购买之后依次点击上方导航栏中的 产品与服务-&gt;我产品与服务-&gt;查看详情，就能看到你购买的节点信息。\n\n\n\n购买完代理服务器之后，接下来需要安装一个软件来辅助我们进行科学上网。\n科学上网（翻墙）软件下载客户端：苹果手机需要下载一个名叫Spectre的软件来辅助我们进行科学上网，如果你持有非中国大陆地区的 Apple ID 账户，您可以直接前往商店免费获取(由于苹果公司的限制，相关类型客户端无法在中国大陆地区商店上架）。\n客户端图标样式： ，如果在应用商店通过搜索安装客户端，要仔细确认客户端的图标样式。\n如果你没有非中国大陆地区的 Apple ID 账户，可以手动注册一个海外地区的Apple ID。\n申请海外 Apple ID准备工作：\n\n打开 https://account.apple.com \n点击右上角 创建你的 Apple 账户（手机访问需要点击下拉箭头），\n创建一个全新的 Apple 账户（中国大陆）\n\n\n在你手机上的 App Store 登录刚刚注册好的Apple ID，因为是新 Apple ID 第一次登录，所以会有图中的提示，点「检查」进入下一步\n切换 APPLE ID 时，打开 AppStore ，点击右上角的头像，拉到最底部点击退出登陆，再重新登陆即可，不要在设置中切换 iCLOUD 账户。\n\n选中「同意条款和条件」，点击「下一页」，选择付款方式为「无」，填好必填信息，再点「下一页」完成创建，然后在 App Store 退出你的 Apple ID\n\n开始修改地区用电脑打开 https://account.apple.com ，登陆刚刚注册的 Apple ID ，\n点击左侧的个人信息后，再点击右侧的国家或地区进行切换。\n\n切换国家或地区选择「香港」，点击「继续更新」（当然您也可以选择您喜欢的国家或地区）。\n现在 APPLE 更新了政策，很多地方需要手机短信验证，因此推荐选择 香港 地区，可以使用 +86 号码验证。\n\n付款方式选择 无 然后设置其他信息，然后点击右上角的「保存」\n\n然后在 App Store 重新登录您的海外 Apple ID 即可搜索 Spectre VPN 下载客户端了。\n下载好 Spectre客户端之后，然后在在你购买代理服务器的界面复制订阅链接(在产品详情页面获取)，如下：\n\n注：订阅链接与您的密码一样重要，请勿分享给他人，如不慎泄露，请在产品详情页面重置链接。\n点击 订阅按钮 可以选择 复制订阅链接 或是 显示订阅二维码。\n复制链接后点击客户端主界面的 添加服务器。\n\n\n点击 切换服务器 - 订阅 右侧的 + ，在新弹出的窗口中，粘贴订阅链接，点击完成即可完成添加。\n点击 扫码  按钮可以通过扫码的方式添加 (请更新至 1.0.0.19 以上版本)。\n\n\n\n添加完成后，即可选择一个节点，点击连接开始使用。\n\n4. 启动连接添加完成后，主界面会显示节点信息，点击顶部 未连接 右侧的按钮即可开始使用代理。\n\n第一次连接时，客户端会请求 VPN 设置权限，请选择允许。\n\n如果需要添加更多或是切换节点，请点击 切换服务器 进行添加或是更换节点。\n之后便可以自由的访问Google、Twitter、Instagram、Youtube、Netflix、ChatGPT等等这些优秀平台了。\n对了，如果你不需要科学上网的时候记得把下面这个按钮关掉，需要科学上网的时候在打开，这样可以提升你的上网体验。\n\n","categories":["科学上网"],"tags":[]},{"title":"软件著作权申请教程（超详细）（2025新版）软著申请","url":"https://tanqingbo.cn/software-copyright/","content":"一、注册账号与实名登记首先我们需要在官网里面注册一个账号，并且完成实名认证，一般是注册【个人】的身份。 中国版权保护中心官网\n中国版权保护中心www.ccopyright.com.cn/\n注册完成后点击下面进行登记，如果没有实名需要先实名认证（认证时间一般在3个工作日）\n实名认证需要\n1、身份证正面\n2、身份证反面\n3、手持身份证照片\n\n二、材料准备在认证审核的过程中我们就可以着手开始准备材料了。如果是多人合作开发著作权人不是一个人的话，还需要准备一份合作开发协议\n\n程序源代码，需要的是pdf类型的文件\n用户手册，需要pdf类型的\n合作开发协议书\n\n以下是一些模板示例文件提供给大家参考：\n\n百度网盘链接：\n\n链接: https://pan.baidu.com/s/15kwMEiKZ5G_khnJBUMxouA?pwd=picz \n提取码: picz\n\n源代码：源程序前连续的30页和后连续的30页\n用户使用手册：提交登记软件的任何一种文档的连续的前30页和连续的后30页，每页不少于30行。若整个文档不到60页，应提交整个文档。可以是用户使用手册、程序说明书等\n合作开发协议书：这个如果是著作权人有多个（多个人一起开发）就需要提供这个材料\n三、申请步骤第一步，我们先选择计算机软件著作权登记申请，第一个图\n1.办理身份这里我们选择我是申请人\n\n2.软件申请信息\n权利取得方式：原始取得。\n软件全称：XX系统。比如我的是 XXXX博客系统。软件全称应简短明确，申请材料中的软件全称应保持一致\n软件简称：如果没有就空着 ，如果有，不要与软件全称完全相同。\n版本号：V1.0。建议按规范填写，如V1.0或1.0这两种形式。\n权利范围：全部权利。\n\n\n3.软件开发信息按照实际情况填写就可以了。\n\n软件分类：应用软件。前后端系统一般是应用软件。\n\n软件说明：原创。\n\n开发方式：单独开发。（其他方式需要提交相应的协议书）\n\n完成开发日期：选择完成开发的时间即可。\n\n发表状态：未发表。（如果是已发表，需要填写首次发表日期和首次发表地点）\n\n著作权人：\n\n国家：中国\n\n地区：学校所在省市区\n\n身份类别：事业单位法人 名称：学校名称\n\n统一社会信用代码证书：网上一般可以找到\n\n注意：著作权人如果是合作开发可以写多个，但是需要其他著作权人也注册该网站，且完成实名认证。后面需要获取每个人的手机号验证码才能继续。\n\n\n\n4.软件功能与特点这一页的内容比较多，可以参考我下面的\n\n开发的硬件环境：四核intel i5 CPU，16GB内存，512固态硬盘，10Mbps网络带宽\n\n运行的硬件环境：服务端内存2G以上，硬盘空间不低于40G； 客户端4G及以上内存，硬盘空间16G及以上\n\n开发该软件的操作系统：Windows 10操作系统\n\n软件开发环境 / 开发工具：开发环境：JDK8，node.js16.17.1，Vue3 开发工具：IntelliJ IDEA VsCode\n\n该软件的运行平台 / 操作系统：Cent OS 8.9\n\n软件运行支撑环境 / 支持软件：JDK8，nginx-1.24.5，MySQL5.0及以上版本\n\n编程语言：Java JavaScript HTML SQL Python\n\n源程序量：实际的代码行数 Java代码行数：IDEA插件Statistic可以统计行数 vue代码行数统计方法：在项目根目录打开git bash,执行下列代码 find ./src “(“ -name “.html” -or -name “.vue” -or -name “.js” -or -name “.ts” -or -name “.css” -or -name “.styl” -or -name “.less” -or -name “.scss” “)” -print | xargs wc -l\n\n开发目的（可以借助AI工具来写）\n\n面向领域 / 行业：教育行业等…\n\n软件的主要功能（可以借助AI工具来写\n\n软件的技术特点：本系统具有简单性、面向对象、健壮性、平台独立与可移植性等特点。\n\n程序鉴别材料：提交登记软件源程序连续的前30页和连续的后30页（前、后各连续30页可以按开发时间排序，也可以按功能主次等自定义排序），每页不少于50行。若源程序整体不到60页，应提交全部源程序。\n\n文档鉴别材料：提交登记软件的任何一种文档的连续的前30页和连续的后30页，每页不少于30行。若整个文档不到60页，应提交整个文档。文档是指用来描述程序的内容、组成、设计、功能规格、开发情况、测试结果及使用方法的文字资料和图表等，如程序设计说明书、流程图、用户手册等。\n\n这个文档也是按照以下模板填写即可。\n\n链接: https://pan.baidu.com/s/15kwMEiKZ5G_khnJBUMxouA?pwd=picz\n\n提取码: picz\n\n\n\n5.填报完成在填报完成之后需要打印一个签章页签字（如果不是个人需要盖章）\n\n然后再申请完成之后就是待受理状态，这段时间等待即可。\n\n","categories":["技术以外"],"tags":[]},{"title":"安卓/Android系统手机实现科学上网教程-翻墙VPN软件工具","url":"https://tanqingbo.cn/Android-open-internet/","content":"由于不可描述的原因，很多地方都有墙的的存在。这就导致我们没办法用谷歌、Twitter、Instagram、Youtube、Netflix、ChatGPT等等优秀的平台。\n因此，我们需要翻墙，需要科学上网，这样就可以自由浏览墙外的资源，更好的学习，提升自我。\n既然墙阻挡了我们直接访问国际互联网上的某些特定服务，那么我们只能绕行了。方法就是使用梯子工具：\n\n找一台墙外的电脑，一台不经过墙，能自由上网的电脑\n把我们想访问的内容，交给这台没有限制的电脑来完成\n这台电脑访问到对应的内容后，再返回给我们\n由此，我们完成了通过这台电脑获取被墙的网络内容\n\n这台不经过墙，能自由上网的电脑，通常被成为代理服务器。\n而能够通过代理服务器访问外网的软件，通常被成为梯子、代理软件，也叫翻墙软件。\n\n由上述原理介绍，可以得到，要想实现科学上网，需要 代理服务器 + 翻墙软件 来实现。\n代理服务器一般通过购买来获得，当然网上也能找到免费的，不过我比较提倡用钱能解决的问题，尽量还是花些钱吧，这样方便、稳定、且一劳永逸。\n代理服务器购买代理服务的话，我个人推荐一支红杏的代理服务，它是銘佑科技（香港）有限公司（也是老薛主机，不会跑路型）推出的网络加速器服务，基于 Trojan 协议的科学上网方式，该协议会将您需要代理的网络数据伪装成 HTTPS 协议的正常网络数据，以通过防火墙的检测和封锁，连接速度快，它会帮助你在互联网上冲浪时保护你的隐私和安全。\n\n支持 Windows、MAC OS X、cross platform、Android、IOS、openwrt等系统，是非常实用的网络代理软件。\n我买的就是一枝红杏的VPN，亲测真的很好用，网速很快，Google、youtubu、Facebook啥的都能上。下面就教大家怎么用起来。\n打开一枝红杏官网。\n官网：https://order.yizhihongxing.club/aff.php?aff=4818\n翻到下面会有两种VPN的购买方式，如果是个人用的话，选择入门版就可以了，一个月100G足够用了。\n跳转到订购页面后可以先在右上角点击注册，注册一个新账号，然后再根据提示购买你的产品。\n购买之后依次点击上方导航栏中的 产品与服务-&gt;我产品与服务-&gt;查看详情，就能看到你购买的节点信息。\n\n\n\n购买完代理服务器之后，接下来需要安装一个软件来辅助我们进行科学上网。\n科学上网（翻墙）软件下载客户端：\n直接点击下载\n\n添加节点(通过订阅链接)：安装后打开首页，点击配置：\n\n点击新配置\n\n点击 URL (从 URL 导入)：\n\n在你购买代理服务器的界面复制 Clash 订阅链接(在产品详情页面获取)，如下：\n\n然后粘贴到URL处，再点击右上角的保存：\n\n下载完成后选中配置文件，然后返回首页点击 点此启动 开始使用：\n\n第一次启动时会请求 VPN 权限，需要点击确定允许。\n(该弹窗为系统弹窗，与客户端无关，如果无法点击基本上是其他 APP 有在使用悬浮窗权限导致，或者是一些系统的护眼模式)\n\n\n如果需要切换节点，请点开第二个 代理 选项即可。\n之后便可以自由的访问Google、Twitter、Instagram、Youtube、Netflix、ChatGPT等等这些优秀平台了。\n","categories":["科学上网"],"tags":[]},{"title":"如何使用梯子工具实现翻墙-科学上网工具VPN？","url":"https://tanqingbo.cn/choose/","content":"前言　　科学上网，又叫翻墙。说到这，问题就来了，既然要翻墙，那么什么是墙呢？great firewall, 就是对网络进行封锁。想要看看墙外面的世界，就得翻墙。　　之前我有提到过用hosts翻墙，但是不太稳定，经常得更换源，还上不了youtubu，所以干脆就放弃了。我比较提倡用钱能解决的问题，尽量还是花些钱吧。方便、稳定、一劳永逸。所以今天给大家介绍花钱的翻墙办法。\n一枝红杏\n先摆一下一枝红杏的介绍：一支红杏网络加速器是銘佑科技（香港）有限公司，（也是老薛主机，不会跑路型）推出的网络加速器服务，基于 Trojan 协议的科学上网方式，该协议会将您需要代理的网络数据伪装成 HTTPS 协议的正常网络数据，以通过防火墙的检测和封锁。连接速度快，它会帮助你在互联网上冲浪时保护你的隐私和安全。\n支持 Windows、MAC OS X、cross platform、Android、IOS、openwrt等系统，是非常实用的网络代理软件。\n我买的就是一枝红杏的VPN，亲测真的很好用，网速很快，Google、youtubu、Facebook啥的都能上。下面就教大家怎么用起来。\n打开一枝红杏官网。\n官网：https://order.yizhihongxing.club/aff.php?aff=4818\n翻到下面会有两种VPN的购买方式，如果是个人用的话，选择入门版就可以了，一个月100G足够用了。\n跳转到订购页面后可以先在右上角点击注册，注册一个新账号，然后再根据提示购买你的产品。\n购买之后依次点击上方导航栏中的 服务-&gt;产品/服务，就能看到你购买的节点信息。\n\n\n\n\n\n好了，别着急。接下来需要下载一个软件Trojan来辅助科学上网。\n\nTrojan或者Clash先放一个下载链接: https://order.yizhihongxing.club/index.php?rp=/knowledgebase/13/\n下载安装好之后登入后前往  产品/服务 ，点击有效的服务，打开产品详情页面，向下滑动。\n点击 Clash 配置右侧的获得地址，在弹出的窗口中，选择 复制地址 或是 下载配置。\n\n如果点击获得地址没有反应，请更换使用 Chrome 、Firefox 或是 EDGE 浏览器访问客户中心。\n注1. 订阅链接与你的密码一样重要，请不要分享给他人，如不慎泄露，请在产品详情页面重置链接并提交工单申请重置服务密码。\n注2. 如果使用链接添加时报错，可以点击 下载配置 ，手动添加 \n4. 添加配置打开客户端后，使用上一步的订阅链接添加配置：\n\n首先点击左侧 订阅(Profiles) ，粘贴订阅链接后点击 导入\n添加成功后点击左侧 代理(Proxies) 选择节点使用 \n\n\n5. 客户端使用介绍正常在添加配置后，前往设置，开启 系统代理 后即可正常使用\n\n客户端模式（在 代理 (Proxies) 界面右上角切换）介绍：\n规则模式：自动区分是否代理大陆网站的流量，日常情况推荐使用这个模式\n全局模式：所有转发给客户端的流量都会经过代理，切换到全局模式后请选择节点，不需要选择 DIRECT \n直连模式：不使用代理\n最后再放一个一枝红杏的官网：https://order.yizhihongxing.club/aff.php?aff=4818\n我觉得还是蛮好用的\n","categories":["科学上网"],"tags":[]},{"title":"如何使用梯子工具实现翻墙 科学上网？","url":"https://tanqingbo.cn/Open-Internet/","content":"梯子工具是一种网络代理工具，它可以帮助我们突破网络封锁，从而自由的不受限制地浏览互联网（科学上网）。\n为什么要翻墙/科学上网？由于不可描述的原因，很多地方都有墙的的存在。这就导致我们没办法用谷歌、Twitter、Instagram、Youtube、Netflix、ChatGPT等等优秀的平台。\n因此，我们需要翻墙，需要科学上网，这样就可以自由浏览墙外的资源，更好的学习，提升自我。\n使用梯子翻墙的基本原理？既然墙阻挡了我们直接访问国际互联网上的某些特定服务，那么我们只能绕行了。方法就是使用梯子工具：\n\n找一台墙外的电脑，一台不经过墙，能自由上网的电脑\n把我们想访问的内容，交给这台没有限制的电脑来完成\n这台电脑访问到对应的内容后，再返回给我们\n由此，我们完成了通过这台电脑获取被墙的网络内容\n\n这台不经过墙，能自由上网的电脑，通常被成为代理服务器。\n而能够通过代理服务器访问外网的软件，通常被成为梯子、代理软件，也叫翻墙软件。\n\n如何实现科学上网/翻墙？由上述原理介绍，可以得到，要想实现科学上网，需要 代理服务器 + 翻墙软件 来实现。\n准备代理服务器想要拥有一个可用的代理服务器，有两种方式，一种是自己搭建，另一种是通过购买的方式。\n\n自己搭建代理服务器：如果你有服务器搭建的相关经验，可以考虑自己做。首先你需要拥有一台VPS服务器，然后，可以在服务器上安装需要的翻墙软件，自己搭建代理服务器一般门槛都比较高，对于新手来说我比较推荐直接购买代理服务，稳定高效、还省事。\n购买代理服务：如果你想更省心一点，可以直接购买翻墙服务，这样只需要再下载一个翻墙软件就能直接使用了。通常我们会从机场(代理服务提供商)来购买这样的服务，关于机场的推荐，可以参考科学上网（翻墙）软件之—VPN篇。\n\n使用梯子工具/翻墙软件购买代理服务的话，我个人推荐一支红杏的代理服务，它是銘佑科技（香港）有限公司（也是老薛主机，不会跑路型）推出的网络加速器服务，基于 Trojan 协议的科学上网方式，该协议会将您需要代理的网络数据伪装成 HTTPS 协议的正常网络数据，以通过防火墙的检测和封锁，连接速度快，它会帮助你在互联网上冲浪时保护你的隐私和安全。\n\n支持 Windows、MAC OS X、cross platform、Android、IOS、openwrt等系统，是非常实用的网络代理软件。\n我买的就是一枝红杏的VPN，亲测真的很好用，网速很快，Google、youtubu、Facebook啥的都能上。下面就教大家怎么用起来。\n打开一枝红杏官网。\n官网：https://order.yizhihongxing.club/aff.php?aff=4818\n翻到下面会有2中VPN的购买方式，如果是个人用的话，选择入门版就可以了，一个月100G足够用了。\n跳转到订购页面后可以先在右上角点击注册，注册一个新账号，然后再根据提示购买你的产品。\n购买之后依次点击上方导航栏中的 服务-&gt;产品/服务，就能看到你购买的节点信息。\n\n\n\n\n好了，别着急，接下来需要下载一个软件Trojan来辅助不科学上网。\n\nTrojan或者Clash先放一个下载链接: https://order.yizhihongxing.club/index.php?rp=/knowledgebase/13/\n下载安装好之后登入后前往  产品/服务 ，点击有效的服务，打开产品详情页面，向下滑动。\n点击 Clash 配置右侧的获得地址，在弹出的窗口中，选择 复制地址 或是 下载配置。\n\n如果点击获得地址没有反应，请更换使用 Chrome 、Firefox 或是 EDGE 浏览器访问客户中心。\n注1. 订阅链接与你的密码一样重要，请不要分享给他人，如不慎泄露，请在产品详情页面重置链接并提交工单申请重置服务密码。\n注2. 如果使用链接添加时报错，可以点击 下载配置 ，手动添加 \n4. 添加配置打开客户端后，使用第三步的订阅链接添加配置\n\n首先点击左侧 订阅(Profiles) ，粘贴订阅链接后点击 导入\n添加成功后点击左侧 代理(Proxies) 选择节点使用 \n\n\n最后再放一个一枝红杏的官网：https://order.yizhihongxing.club/aff.php?aff=4818\n我觉得还是蛮好用的\n","categories":["科学上网"],"tags":[]},{"title":"科学上网翻墙软件介绍，2025年最全科学上网教程","url":"https://tanqingbo.cn/‌Accessing-the-Open-Internet/","content":"引言：什么是“科学上网”？科学上网，又叫翻墙。说到这，问题就来了，既然要翻墙，那么什么是墙呢？great firewall, 就是对网络进行封锁。想要看看墙外面的世界，就得翻墙。之前我有提到过用hosts翻墙，但是不太稳定，经常得更换源，还上不了youtubu，所以干脆就放弃了。我比较提倡用钱能解决的问题，尽量还是花些钱吧。方便、稳定、一劳永逸。所以今天给大家介绍花钱的翻墙办法。\n一枝红杏\n先摆一下一枝红杏的介绍：一支红杏网络加速器是銘佑科技（香港）有限公司，（也是老薛主机，不会跑路型）推出的网络加速器服务，基于 Trojan 协议的科学上网方式，该协议会将您需要代理的网络数据伪装成 HTTPS 协议的正常网络数据，以通过防火墙的检测和封锁。连接速度快，它会帮助你在互联网上冲浪时保护你的隐私和安全。\n支持 Windows、MAC OS X、cross platform、Android、IOS、openwrt等系统，是非常实用的网络代理软件。\n我买的就是一枝红杏的VPN，亲测真的很好用，网速很快，Google、youtubu、Facebook啥的都能上。下面就教大家怎么用起来。\n\n打开一枝红杏官网。\n\n官网：https://order.yizhihongxing.club/aff.php?aff=4818\n翻到下面会有两种VPN的购买方式，如果是个人用的话，选择入门版就可以了，一个月100G足够用了。\n跳转到订购页面后可以先在右上角点击注册，注册一个新账号，然后再根据提示购买你的产品。\n购买之后依次点击上方导航栏中的 服务-&gt;产品/服务，就能看到你购买的节点信息。\n\n\n\n\n好了，别着急，接下来需要下载一个软件来辅助科学上网。\n\n先放一个下载链接: https://order.yizhihongxing.club/index.php?rp=/knowledgebase/27/\n下载安装好之后，前往  产品/服务 ，点击有效的服务，打开产品详情页面，向下滑动。\n点击 Clash 配置右侧的获得地址，在弹出的窗口中，选择 复制地址 或是 下载配置。\n\n如果点击获得地址没有反应，请更换使用 Chrome 、Firefox 或是 EDGE 浏览器访问客户中心。\n注1. 订阅链接与你的密码一样重要，请不要分享给他人，如不慎泄露，请在产品详情页面重置链接并提交工单申请重置服务密码。\n注2. 如果使用链接添加时报错，可以点击 下载配置 ，手动添加 \n添加配置打开客户端后，使用上一步的订阅链接添加配置：\n\n首先点击左侧 订阅(Profiles) ，粘贴订阅链接后点击 导入\n添加成功后点击左侧 代理(Proxies) 选择节点使用 \n\n\n客户端使用介绍正常在添加配置后，前往设置，开启 系统代理 后即可正常使用\n\n客户端模式（在 代理 (Proxies) 界面右上角切换）介绍：\n规则模式：自动区分是否代理大陆网站的流量，日常情况推荐使用这个模式\n全局模式：所有转发给客户端的流量都会经过代理，切换到全局模式后请选择节点，不需要选择 DIRECT \n直连模式：不使用代理\n最后再放一个一枝红杏的官网：https://order.yizhihongxing.club/aff.php?aff=4818\n\n","categories":["科学上网"],"tags":[]},{"title":"如何挑选Clash机场服务","url":"https://tanqingbo.cn/choose2/","content":"选择Clash机场前的准备工作在选择Clash机场之前，首先要明确自己的使用需求和场景。不同用户对速度、稳定性、安全性和兼容性有不同的要求，因此必须结合自身情况进行评估。\n了解自己的上网需求\n视频观看：需要高速、稳定的节点，建议选择IEPL或CN2专线。\n社交平台访问：Telegram、Twitter、Instagram 等对速度要求适中，关键是可用性和低延迟。\n程序开发或科研：需要稳定连接 GitHub、Docker、学术期刊等，注重解析速度与全局代理功能。\n远程办公：对连接稳定性和隐私性要求较高，需选择带有隐私保护机制的服务。\n游戏加速：玩外服游戏（如美服、日服、韩服）或连接PSN/Xbox平台时，对延迟和丢包极为敏感，建议选择具备UDP中继支持、游戏专线或IEPL节点的机场服务。\n\n常见使用场景\nNetflix、YouTube、Disney+ 等流媒体平台解锁\nChatGPT、OpenAI API 访问\n海外APP更新或切换国际应用商店\n境外远程桌面控制、VPS运维和远程编程\nSteam、Epic 平台外服联机游戏，或主机平台在线服务（如 PSN、Xbox Live）\n\n是否支持主流协议优质机场一般支持多种协议：\n\nVMess：兼容性广，适合新手。\nShadowsocks（SS）：轻量、速度快。\nTrojan：基于TLS，更加隐蔽稳定，适合对隐私要求高的用户。确保你选择的机场支持你所需的平台与协议。\n\n\n影响Clash机场选择的关键因素优质的Clash机场服务应满足以下几个核心要素：\n节点速度与稳定性\n节点的带宽、运营商质量决定了使用体验。\n建议选择有“中转节点”或“IEPL专线”的服务，避免高峰期掉速。\n\n支持的协议类型\n看是否支持Vmess/Trojan/SS等多个协议，支持越多适配性越高。\n特别注意是否支持新一代的Clash Meta结构。\n\n月流量与价格性价比\n比较不同机场的“GB价格”，如1元=1G或10元=100G。\n注意是否包含回国流量、境外方向流量区分。\n\n是否有IEPL/优质专线加速\nIEPL专线不走公网，速度与稳定性远优于普通线路。\n适合高频使用者、跨境工作者或流媒体用户。\n\n客服响应速度与服务态度\n优质机场一般提供 Telegram 或 Ticket 系统支持。\n看客服是否及时、态度是否专业，特别在节点故障时。\n\n\nClash机场对流媒体与AI工具的支持能力在评估Clash机场服务质量时，是否能够顺利解锁流媒体服务和访问AI工具，是非常重要的参考指标。部分机场可能存在 Netflix 无法观看、ChatGPT 403 错误等情况，因此需要特别关注。\n流媒体解锁能力优质的Clash机场应具备解锁主流流媒体平台的能力，以下为常见需求及注意事项：\n\nNetflix 解锁：部分节点支持特定区域（如港区、美区、日区）解锁，优选标记为“NF”或“Stream”类型的节点。\nDisney+、HBO Max、Hulu：需要美国、香港、台湾、新加坡等地区的原生IP支持。\nYouTube Premium：需节点所在IP为可开通地区，避免印度、马来西亚等“低价区”影响功能。\nSpotify、Pandora 等音乐服务：大多数节点可支持，但需确认解析域名无污染。\n\n\n✅ 建议选择提供“流媒体解锁能力标识”的机场，部分还会展示各节点支持的服务图标。\n\nAI工具访问支持随着AI工具的普及，越来越多用户需要通过Clash机场访问境外AI服务。以下是常见使用场景：\n\nChatGPT（OpenAI）：需要节点IP位于美国、英国、日本、新加坡等支持地区。部分中国香港IP会被封锁或验证频繁。\nClaude（Anthropic）：需要美国/英国IP，部分地区访问受限。\nMidjourney（Discord）：需稳定连接 Discord 并绕过 CDN 限制。\nStable Diffusion、Hugging Face、Perplexity：通常对节点稳定性和速度要求较高。\n\n\n🔒 注意事项：部分AI服务对访问频率敏感，需避免因共享IP被滥用导致“403 Forbidden”或“机器人验证”频繁。\n\n选择建议\n优先选择机场提供“流媒体解锁测试结果”或“ChatGPT可用IP提示”的服务商。\n留意机场公告，有些会特别标注“AI专区”、“Netflix专区”节点。\n对于AI工作者/开发者，建议选择具备稳定高速节点与专属出口IP的机场方案。\n\n\n如何判断一个机场是否安全可靠？安全性是选择机场时极为重要的一环，以下几个方面可以有效判断一个机场的可信度：\n是否实名注册/注册门槛\n一些机场不开放注册或采用邀请码制度，这种相对更为安全。\n提供“免费机场”注册时，务必注意信息是否泄露。\n\n是否支持匿名支付\n支持加密货币（如USDT、TRX、BTC）或虚拟卡支付的机场，在隐私保护方面表现更佳。\n使用支付宝/微信支付可能泄露身份信息，慎重选择。\n\n用户评价与口碑\n通过 Telegram 群组、Reddit、知乎等平台了解用户反馈。\n查找关键字如“跑路”、“丢包”、“高延迟”等负面反馈。\n\n是否有跑路风险\n经常更换域名、官网打不开、客服失联、无法续费等都是跑路预警信号。\n建议定期备份订阅链接，并准备替代机场方案。\n\n\nClash机场推荐评估维度一个优秀的机场服务商往往在多个维度都表现出色，以下是具体考量点：\n是否提供免费试用服务\n免费试用能快速了解服务质量，不满意可及时更换。\n百变小樱等机场提供3天高速IEPL专线体验。\n\n多平台兼容情况\n需支持 Windows、macOS、Android、iOS 等常见平台。\n是否提供平台适配教程、客户端下载一站式支持。\n\n软件工具推荐\nClash for Windows (CFW)\nClash Verge / Verge Reborn\nClash.Meta GUI 客户端\nShadowrocket（iOS），Surfboard（macOS/iOS）\n\n\nClash机场的订阅配置与使用体验配置订阅链接后能否顺利连接和自动更新，是决定体验流畅与否的关键。\n订阅链接的更新频率\n优质机场会定期更新节点订阅，避免废弃或掉速节点。\n看是否支持手动/自动一键更新。\n\n是否支持一键导入配置\n现代客户端一般都支持直接粘贴订阅链接自动导入。\n有些机场还提供二维码扫码导入功能。\n\n国内运营商兼容性表现\n针对中国三大运营商（联通、电信、移动）优化程度不同。\n有的节点在电信表现良好，但在移动网络下掉速明显。\n\n口碑良好的Clash机场推荐（示例）以下是一些被用户广泛推荐、体验稳定的Clash机场服务商，供参考：\n一支红杏机场\n试用：新用户可免费试用3天高速IEPL专线。\n协议支持：支持 VMess、Trojan、Shadowsocks。\n平台支持：全平台支持，含详细教程。\n专线节点：包含IEPL节点，适合重度用户。\n稳定性：节点更新及时，运营周期较长，口碑良好。\n配置教程：科学上网（翻墙）软件之—VPN篇\n\n其他推荐机场（简要）\n喵帕斯：稳定性好，支持Trojan，适合开发者。\nSpeedCAT：主打IEPL高阶套餐，适合游戏和视频用户。\nJust My Socks：搬瓦工官方机场，低延迟但价格偏高。\n\n\n⚠️ 注意：推荐机场仅供参考，请自行判断安全性与适用性。\n\n\n常见误区与避坑指南免费机场一定好吗？\n免费机场常因用户多、维护差，出现掉线、节点失效等问题。\n很多“免费机场”其实收集用户信息或用于引流牟利，隐私风险高。\n\n高价就代表高质量？\n并不总是如此。有些机场价格虚高但节点性能平平。\n建议关注用户口碑、服务细节（如客服响应、故障率）而非单纯价格。\n\n专线就一定适合你？\nIEPL专线更适合视频、直播、远程办公、游戏等高带宽场景。\n若你仅需偶尔查资料或访问网页，普通节点性价比更高。\n\n\nClash机场游戏玩家的选择建议游戏用户的需求与一般用户有所不同，以下几点应特别留意：\n游戏玩家常见场景\n游玩Steam、Epic上外服游戏（如美服、日服、韩服）\n登录PSN/Xbox主机服务，访问锁区商城\n尝试使用低延迟线路打联机对战类游戏（如COD、Valorant）\n\n游戏节点的选择建议\n优选IEPL或CN2 GIA游戏优化节点\n避免中继节点或中转过多的节点，可能导致延迟高\n使用支持“UDP中继”功能的机场，对主机类应用更友好\n某些机场提供“游戏专属入口”或“UDP优化节点”，可优先考虑\n\n工具建议\n配合使用Proxifier、SSTap、TUN模式实现游戏进程代理\n避免将全局流量代理，以免导致其他应用速度受影响\n\n\nClash机场的法律与合规性问题使用机场的法律边界\n中国大陆对VPN/翻墙工具的使用有限制，用户应注意合规风险。\n个人使用一般不会被追责，但提供翻墙服务的行为属于违法行为。\n\n如何降低法律风险\n不要公开分享机场信息或订阅链接\n不要参与机场推广分销（除非你确定合法）\n不将机场用于非法用途（如攻击网站、传播非法内容）\n\n关于支付方式\n推荐使用虚拟支付方式如 USDT、TronLink、PayPal（非实名）以保护隐私\n避免绑定国内实名账户进行机场充值\n\n\n总结与建议挑选Clash机场服务不仅仅是看价格与流量，还需要综合考虑以下几点：\n\n明确自身需求（浏览网页？流媒体？游戏？开发？）\n关注节点质量（稳定性、延迟、丢包率）\n尽量选择支持多协议、跨平台的服务商\n注意注册门槛与付款方式，优先考虑有匿名性保障的选项\n时刻准备替代机场，避免一家独大，降低跑路风险\n\nFAQ（常见问题解答）Clash机场和SSR机场一样吗？不完全一样。Clash是一个多协议聚合平台，支持包括SS（Shadowsocks）、SSR、VMess、Trojan等协议。而SSR机场通常只支持ShadowsocksR协议，兼容性较差，更新也比较少。\n为什么我的节点连接不上？可能原因包括：\n\n节点被墙或过期（机场方已删除）\n订阅未及时更新（建议使用自动更新订阅功能）\nClash客户端未正确设置（端口占用、配置导入错误）\n网络环境被限制（如校园网或公司局域网）\n\nClash可以自动切换节点吗？是的。Clash客户端支持按延迟自动选择最优节点（延迟策略），也支持手动设定策略组（如“国外网站用节点A，国内走直连”）。高级用户可通过配置规则文件实现更灵活控制。\n如何防止机场跑路？建议采取以下预防措施：\n\n使用短周期套餐（如月付）\n不在单一机场投入过多预算\n定期备份订阅链接及配置\n加入机场通知渠道（如Telegram群组）第一时间掌握变动\n使用支持匿名支付的服务，减少身份暴露风险\n\n有哪些支持Telegram客服的机场？不少优质机场(一支红杏、悠兔机场、BoostNet)等都在Telegram设有客服频道或用户群，可实时获取节点公告、维护通知以及用户反馈。但请注意防范冒充客服或钓鱼链接。\n推荐阅读\n2025科学上网指南 \n\n","categories":["科学上网"],"tags":[]},{"title":"EditPlus软件的安装、激活和配置过程分享","url":"https://tanqingbo.cn/EditPlus软件的安装、激活和配置过程分享/","content":"最近使用到EditPlus软件，与大伙分享一下这款软件的安装以及激活过程：\n1 、官网下载：https://www.editplus.com/download.html\n\n官网截图，按照自己所需的版本进行下载。\n2、安装过程：\n\n安装截图，打开安装包进行安装，点击Accept。\n\n编辑安装路径，然后选择软件的安装路径，然后其余选项均默认就行。\n\n提示软件安装完成，点击OK退出！\n3、软件激活\n\n点击刚刚安装好的EditPlus图标，打开软件，\n\n点击Yes进行确认，\n\n然后选择默认的目录就可以。\n\n之后在Username输入：Vovan\nRegcode输入：3AG46-JJ48E-CEACC-8E6EW-ECUAW\n点击Register。（当然也可以在网上搜一个注册软件，生成注册码。）\n提示注册完毕，重启软件。\n4、配置过程可参考如下链接：\nhttps://www.jianshu.com/p/d7af9a5c4\n","categories":["Java"],"tags":["edit"]},{"title":"几个很重要的感悟","url":"https://tanqingbo.cn/几个很重要的感悟/","content":"前几天照镜子，发现自己头上有几根很明显的白头发，就让对象帮我拔一下，没想到一下子就拔出了几十根白头发，这个结果吓了我一跳，我以为自己也就零星两三根白头发而已。\n\n老一辈都说，白头发多是因为要操心的事情多，仔细想想，可能确实是这个样子，从高中的时候开始我基本就没怎么让家里操过心了，一路走到现在都是我自己选择的结果。\n高中三年，我爸就在开学的第一天送我来过学校，之后的三年他们就再也没有来过我学校了，学习上的事情基本也没怎么管过我，倒不是他们不想管，而是我爸妈一个初中毕业，一个小学毕业，他们想管也无能无力。\n三年下来我的成绩还算可以，顺利考上了一所211，然后在当年土木、建筑行业很火的情况下阴差阳错的选择了计算机专业，毕业那年正好赶上计算机专业大火，各个互联网大厂都在疯狂的攻城掠地、疯狂的招人。很多人可能会觉得我运气不错，自己瞎选的专业毕业的时候也能成为大热门。\n但是热门这东西就跟风口似的，它出现的时候你并不会意识到，等它过去之后，你才发现原来自己当时处在风口上，所以毕业之后在计算机行业热的发烫的情况下，我并没有直接参加工作，而是选择继续攻读研究生，由于在学校成绩还可以，拿到了保送名额，当时华科、哈工大以及中科院都发来了录取意向，最终我选择了哈工大，跟一位导师攻读他的直博生。\n就读之前，这位导师的饼画的又大又甜，就读之后，他差不多就失踪了，我们组没有组会、没有跑实验的设备，也没有指导老师，当然入学之后我也没有看到成功毕业的博士，所以在拖了五年之后我转成硕士毕业了。今年毕业如你所见，互联网行业江河日下，各大厂纷纷裁员。靠运气选到的大热门，最终也会凭运气错过它。\n不过还好，在没有人管的博士那五年，我也没闲着，从最开始的焦虑、掉头发、睡不着觉，到后来慢慢找到自己喜欢做的事情，我开始创业做自媒体，两年的时间把自己的号做到了行业前列，在其它同学还在愁怎么往游戏里面充钱的时候，我已经自己开公司，并且在新一线买房了。\n毕业之后面临继续创业还是找一份稳定工作的选择，前两年的口罩危机加上市场行情变化，不少合作过的公司都倒闭了，在见识过动荡的行情之后，最终还是选择找一份稳定的工作，不过稳定也意味着收入减少，而且毕业后又赶上买车和新房装修，看着自己的存款一点点的在减少，危机感和焦虑感又上来了，又想要再折腾一下。\n总之一路磕磕绊绊，就这样过来了，记得有一回和朋友聊天，他说为什么现在很多人要么就沉迷于搞钱、要么就去体制内？我说因为钱或者体制可以给他们的未来兜底，让他们过的更有安全感一点。他说我不需要兜底，我的爸妈已经给我兜底了。听完之后有种想打人的冲动，有时候也会偶尔羡慕一下家里可以给自己兜底的朋友，因为他们肯定没有我这么多的白头发，哈哈，就这样结尾吧！\n","categories":["技术以外"],"tags":[]},{"title":"宣布一件大事","url":"https://tanqingbo.cn/宣布一件大事/","content":"你好，我是厂长。\n不知道大家有没有注意到，过去一年我们好像被AI大模型刷屏了，从ChatGpt走红到国内各种大模型涌现：文心一言、讯飞星火、通义千问等等。\n身边也有研究生朋友把自己的研究方向换成了AI大模型方向，为的就是抓住这波红利。\n虽然大模型已经火了一年了，但可能仍然还有很多朋友对此一脸懵逼，下面就简单的和大家来聊一下这个话题。\n\n1、什么是AI大模型？我们常说的大模型即AIGC，全称AI-Generated Content，狭义上是指通过人工智能技术自动生成内容的生产方式。广义的AIGC可以基于训练数据和生成算法模型，自动生成新的文本、图像、音乐、视频、3D交互内容等各种形式的内容和数据，甚至可能开启科学新发现，创造新的价值和意义。\n其实早在2018年，就有人指出创造性人工智能是未来人工智能的重要研究方向，各个大厂和高校也纷纷有团队在做这方面的工作，直到去年（2022年）ChatGPT的发布，AIGC模型才受到大家广泛的关注，并迅速向大众领域扩散。\n2、AIGC为什么能刷屏？我个人理解，一方面是因为它足够的智能，确实能帮我们解决很多实际的问题。\n自从chatgpt问世之后，它的应用场景已经渗透到我们生活的方方面面了，从写作、写代码、到翻译、论文润色、再到角色扮演等等，这些工作它都可以很好的胜任，如果我们可以利用好AI工具的话，将大大提升我们的工作效率。\n另一方面，任何一个新东西的问世，它都可能带来致富的机会，假如你是自媒体从业者，以前你一天只能写一篇文章或者一个视频脚本，有了AI的辅助之后可能你一天能写100篇文章和视频脚本，效率提升之后市场竞争自然也会提高很多。\n3、我们能做什么？一个新事物的诞生，有的人图个新鲜，有的人能看到机会。AI时代的到来，不管是对我们普通个体还是创业者来说都将带来切实的利益。\n对于普通个体来说，如果我们能够很好的利用AI工具，不仅能提高自己的工作效率、提升职场竞争力，还可以发展自己的一份小副业；对于创业者来说，即多了一条创业赛道，还能降低自己的创业成本。\n\n所以我建议大家一定要去好好了解学习利用AI工具，我自己也建了一个AI破局群，加群即送一套《AI效率提升工具包》，而且群内还有免费直播，大家如果感兴趣的话，可以加进去看一下。\n","categories":["技术以外"],"tags":[]},{"title":"我！真！的！找到了！爱上学习！的方法！","url":"https://tanqingbo.cn/我！真！的！找到了！爱上学习！的方法！/","content":"我！真！的！找到了！爱上学习！的方法！📝\n接下来我说的这个方法，你可要记好了。\n它可以让你在一定程度上，喜欢上学习。📚\n1️⃣\n先记住两个概念：峰值和终值。✍️\n·\n心理学家丹尼尔·卡尼曼发现，人们对体验的记忆由两个核心因素决定‼️：\n·\n✅第一个是体验最高峰的时候，无论是正向的最高峰还是负向的最高峰，一定是能记得住的。（峰值）\n·\n✅第二个是结束时的感觉。（终值）\n·\n我们可以利用这个原理，在学习过程中，主动创造正向的峰值和终值。\n2️⃣\n关于峰值，虽然学习在总体上是枯燥的，但总有你喜欢的某个科目；某个科目，总有你喜欢且擅长的某个章节；或者，总有某个环节是你喜欢的：喜欢看书？或者是喜欢做题？也可能喜欢背单词？👀\n·\n每次的学习过程，穿插着安排你喜欢且擅长的科目/章节/环节。📕📗📘📙\n·\n这样一来，你每次都会有学得得心应手、轻松愉悦、反馈满满的时刻，也就是出现了正向的“峰值”。☄️\n·\n每当你学习难搞、恐惧的科目，在负面情绪达到顶峰之前，可以先转换到喜欢且擅长的环节，安抚好情绪之后，再回头继续做难的事情，以此避免负向峰值的出现。❌\n·\n比如我写文章时，需要做的两件主要的事情，是“输入”和“输出”。\n·\n我非常喜欢“输入”：看书、看公开课、跟人探讨、学习一些付费课程等等，无论多枯燥多抽象，我都觉得很有意思。🙈\n·\n“输出”比输入难多了，写得不顺畅，就会很烦躁。🚬\n·\n所以我每次只写25分钟，时间一到，虽然没完成，也立刻收手，去做我喜欢的“输入”。这一过程来回替换。🉑\n·\n整个过程基本不会出现负向的“峰值”；“输入”和“输出”，都能及时高效完成。🐒\n·\n关于终值，每次学习的末尾，都要以你最喜欢、最能带给你反馈感的环节结束。别去学最难的东西，也别在纠结焦虑中，让学习体验以痛苦终结。🤦🏻‍♀️\n·\n在你反馈感很强、情绪高涨满足的时刻结束学习，留下一个正向的终值。\n·\n千万别学到想吐才结束。🙅🏻\n3️⃣\n·\n学习、工作、跑步、读书，还有与男/女朋友约会，巧妙利用这一定律，创造正向的峰终体验，会让你对整件事情的记忆，变得愉悦起来。💃🏻\n·\n爱学认学，从峰终值开始。大脑可真好骗吼，像个大傻子。👀\n·\n——————🔚——————\n·\n","categories":["技术以外"],"tags":[]},{"title":"梯形图入门","url":"https://tanqingbo.cn/梯形图入门/","content":"1、串联：所有条件都成立，才有输出，即触点I0与I1同时得电，线圈Q0才会得电。\n\n2、并联：只要有一个条件成立，就有输出。即触点I0与I1满足一个得电，线圈Q0得电。\n\n3、自锁：通过自身触点保持线圈持续得电\n\n启动和停止都满足以停止信号优先\n\n\n\n启动和停止都满足以启动信号优先\n\n\n4、顺序启动，同时停止。（先送煤气再送氧气）\n\n5、顺序启动，分别停止。\n\n6、顺序启动，逆序停止。\n\n7、互锁：同一时刻只能有一个输出，两个输出进行切换时必须先经过停止。\n\n\n同一时刻只能有一个输出，两个输出进行切换时不需要经过停止。\n\n\n\n","categories":["PLC"],"tags":[]},{"title":"Unity Pro V13(EcoStruxure Control Expert)软件的安装及授权","url":"https://tanqingbo.cn/untiypro XL安装/","content":"UnityPro XL13.0软件介绍：\nUnityPro XL13.0软件系统能够提升 ModiconM340，M580，Momentum，Premium，Quantum和QuantumSafety应用软件的设计方案高效率和特性。Unity Pro是ModiconM340，M580，Momentum，QuantumSafety，Premium和QuantumPLC及其Atrium扩展槽PLC的通用性程序编写，调试和运行的系统软件，作为IEC61131-3程序流程，Unity Pro认可PL7和Concept的规范。另外需要注意的是， UnityPro XL13.0版本之后的软件名称变更为“EcoStruxure Control Expert”，目前最新的版本为“Ecostruxure Control Expert V15.2”。\nUnity Pro 13.0的新功能\n-支持新的Modicon M580高端\n-支持新的Modicon M580 HSBY CPU\n-在Modicon M580上支持LL984语言\n-Modicon M580现在支持Quantum Ethernet IO drop\n各版本的软件兼容的PLC版本见下表：\n\nUnityPro XL13.0软件兼容性：\nUnityPro V13 支持以下操作系统：\n1.支持Microsoft Windows 7 Professional 32/64位，且要求如下：\nMicrosoft Internet Explorer 5.5或更高版本\n在Windows 7 64位系统上，为了使用Unity Pro V13，必须安装Windows 7 Service Pack 1（SP1）\n对于使用DTM（Device Type Manager）的项目，建议使用Windows 7 64位（例如：使用Modicon M580控制器的项目）\n2.支持Microsoft Windows 10 Professional 32/64位\n对于使用DTM（Device Type Manager）的项目，建议使用Windows 10 64位（例如：使用Modicon M580控制器的项目）\n3.支持Microsoft Windows Server 2012 R2\n推荐版本：Windows Server 2012 R2标准版\nUnityPro XL13.0软件的安装及授权步骤：\n1、选择安装文件的安装包文件，点击安装，语言选择中文，安装必须的项目。\n\n\n\n2、使用Unity Pro XL安装向导，接受许可证中的条款，输入用户信息，接着输入部件号和序列号。\n\n\n\n\n\n3、选择安装路径，安装类型选择“完整安装”，勾选“通讯驱动安装”，直至安装完成。\n\n\n\n\n\n\n\n4、软件授权，在开始菜单中找到“注册工具”选项，弹出对话框显示“该产品未注册”，选择立刻注册，输入收到的授权代码，结束授权过程。\n\n\n\n\n\n5、打开软件，在联网状态下会自动进行DTM软件更新，此时整个软件安装及授权过程结束。\n\n6、安装完成之后再可以安装一个汉化包，这样就可以查看中文帮助文档了，Unity pro XL各种版本的汉化包下载地址如下：\nhttps://www.schneider-electric.cn/zh/faqs/FA420897/\nUnityPro_V130_HF_Multilanguages_Online_Help.exe\n\n","categories":["PLC"],"tags":[]},{"title":"国庆假期","url":"https://tanqingbo.cn/国庆假期/","content":"之前在朋友圈看到有人晒大草原的照片，那种高原大草原的景色真的超级好看，本来以为在内蒙古那边，结果一看定位：南山牧场，就在湖南省境内，那我必须也要安排上了。（小时候还经常看到南山奶粉的广告，没想到产地就在我们省内。）\n所以趁着国庆小长假，去了一趟南山牧场，具体位置在邵阳市城步县，去的时候也做了一些攻略，网上说那边全是盘山公路，本来还担心开车过去会不会有危险，电车会不会充电不方便，去了之后就有点庆幸还好是开着车过来的，我建议大家如果过来玩的话最好也是自驾，因为景点与景点之间其实隔的很远，南山小镇上没有公共交通方式，也租不到车。\n此外，虽说都是盘山公路，但是路修的很宽，自驾的话，路上的风景真的超级美，小镇上有一个加油站，也有两个充电桩，电车和油车都不用担心续航问题，我就是回程在景点内的充电桩上充的电，开回湘潭全程400多公里，中间没有补过能。\n给大家推荐游玩路线：\n第一天：\n出发去南山小镇，从城步县到南山小镇中间会路过一条小河，好像叫巫水，水不深特别适合小朋友或者情侣去玩水。\n当天建议住在南山小镇山，离景点比较近，办完入住之后可以去旁边的高山红哨、紫阳峰转转，小镇旁边还有一个湖也可以去转转，晚上可以逛逛小镇，全是各种餐馆和酸奶牛奶特产店，个人觉得那些奶制品还蛮好吃的，可以尝尝。\n第二天：\n早上可以去大丫口观景台看日出，然后回小镇吃个早餐、退房，接着去风电观景台、老山界，为什么最后去老山界，因为它在回程的半山腰上了，逛完老山界就可以直接下山回家了。\n对了，南山小镇上的海拔有1600多米，还是有点小冷，建议带好防寒的衣服。\n最后请大家欣赏照片吧！\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["技术以外"],"tags":[]},{"title":"为高考学子推荐的六个就业前景广阔的专业","url":"https://tanqingbo.cn/为高考学子推荐的六个就业前景广阔的专业/","content":"引言高考是每个学子人生的重要节点，选择适合自己的专业是未来职业发展的关键一步。在当前的就业环境中，有些专业因为市场需求的增长和未来发展的趋势而备受推崇。在本文中，我将结合薪资待遇、热门岗位以及未来发展趋势，为刚参加完高考的同学们推荐六个适合报考的专业，希望能够给大家提供一些有益的参考和思路。\n一、计算机科学与技术专业计算机科学与技术是当前最热门的专业之一。随着信息技术的迅猛发展，计算机专业的需求量不断增加。从软件开发到数据分析，从人工智能到网络安全，计算机专业的应用领域广泛。毕业生可以在互联网公司、科技企业、软件开发机构等领域找到就业机会。岗位包括软件工程师、数据科学家、网络安全专家等，薪资待遇高，发展潜力巨大。\n二、金融与经济学专业金融与经济学专业是与现代经济密切相关的领域。随着经济全球化的深入发展，金融行业对专业人才的需求不断增加。金融与经济学专业培养学生具备金融市场分析、投资管理、财务规划等方面的知识和技能。毕业生可以在银行、证券公司、保险机构、投资基金等金融机构就业。岗位包括金融分析师、投资经理、财务顾问等，薪资待遇较高，且未来发展潜力巨大。\n三、人工智能与大数据分析专业人工智能和大数据分析是当今最热门的领域之一。随着科技的不断进步，人工智能技术在各个行业中得到了广泛应用。从智能机器人到自动驾驶车辆，从语音识别到自然语言处理，人工智能正在改变着我们的生活和工作方式。大数据分析则是对海量数据进行挖掘和分析，为企业决策提供有力支持。这两个领域的专业人才需求量大，薪资待遇高，就业前景广阔。\n四、互联网与电子商务专业互联网与电子商务是当前最具活力的行业之一。随着电子商务的兴起和互联网的普及，越来越多的企业需要电子商务专业人才来开展线上业务和市场推广。该专业培养学生具备网站开发、电子商务运营、数字营销等方面的知识和技能。毕业生可以在互联网公司、电子商务企业、传统企业的电商部门等就业。岗位包括网站开发工程师、电商运营经理、数字营销专家等，薪资待遇较高，未来发展潜力巨大。\n五、人力资源管理专业随着企业管理水平的提升和人才流动的增加，人力资源管理专业成为越来越重要的专业之一。这个专业培养学生掌握人力资源管理、招聘、员工培训等方面的技能，他们可以在各类企事业单位、政府机构以及人力资源服务公司等就业。岗位包括人力资源经理、招聘专员、培训师等，薪资待遇稳定且有较大的发展空间。\n六、医疗与健康管理专业医疗与健康管理是一个快速发展的领域，随着人们对健康的关注度增加，对医疗和健康管理专业人才的需求也在上升。这个专业培养学生具备医疗机构管理、健康政策分析、医疗数据分析等方面的知识和技能。未来，随着人口老龄化的加剧和医疗服务的提升，该领域将会有更多的就业机会。例如，医院管理者、健康政策分析师、医疗数据分析师等岗位都有较好的薪资待遇和发展前景。\n对于即将踏入大学校园的同学们，我想给出以下几点学习建议： 首先，要了解自己的兴趣和优势，选择符合自己特长和潜力的专业，这样才能更好地发挥自己的优势并取得好成绩。 其次，要保持良好的学习习惯和积极的学习态度。学习是一场马拉松，不是高考结束了就停止了，它需要长期坚持和不懈努力，每天合理安排时间，掌握好学习方法，做到高效学习。 此外，要广泛开阔自己的视野，多参加实践活动，提升自己的综合能力和竞争力。 最重要的是相信自己的潜力，勇敢面对挑战，追求自己的梦想。无论选择哪个专业，只要你热爱它，努力学习，就一定能够在未来的学习和职业道路上取得成功。\n","categories":["技术以外"],"tags":[]},{"title":"你们常用的工作方法和思考方式是什么？","url":"https://tanqingbo.cn/你们常用的工作方法和思考方式是什么？/","content":"明末崇祯年间，灾荒四起，朝廷无钱赈灾，导致西北流贼盛行，四处都有农民军造反；\n于是皇上就让大家讨论一下，该怎么去解决这个问题，时任都察院右佥都御史杨鹤的观点成功脱颖而出。\n因为他说：造反的人，不能杀。\n“国家现在比较困难，应该培养元气，不能乱杀”。\n这个思考方式之所以得到支持，是因为崇祯觉得，不用调兵、不用军饷、就能平息叛乱，太省钱了。\n于是杨鹤就被任命为三边总督，去前线平叛去了。\n按照杨总督的工作方法，前期的效果确实很好，没过多久，那些农民军的首领就归降了，为了安抚这些归降的农民军，崇祯皇帝还特意凑了十几万两银子让杨鹤去花。\n最后的结果就是，银子花完之后，那些人又重新开始造反了，而且再次造反之后，追随的人更多，问题更加严重、一发不可收拾。\n之所以会这样，是因为杨鹤没有搞清楚一个问题：就是那些人为什么要造反？\n答案是为了活下去，而活下去就要有钱、有粮食。\n所以等钱花完之后，他们肯定会再次造反。\n而崇祯为了省钱，采纳了杨鹤的工作方法，最后问题不仅没有解决、还让问题更加严重了。\n后来杨鹤的继任者洪承畴上任，他的工作方法和思维方式就跟杨鹤截然不同。\n杨鹤是，投降前，好言好语招抚，投降后，好吃好喝招待。\n而洪承畴是，投降前他说，如果不投降，就杀掉你们，投降后他说，你们投降了，所以杀掉你们。总之不管是抵抗还是不抵抗、投降还是不投降，都得被杀。\n最后的结果就是，在洪承畴上任之后，短短的几个月，西北的局势便开始稳定，各路农民军纷纷受挫，首领被杀。\n这就是不同的工作方式和思考方法带来的结果。\n虽然有点文不对题，但是还是觉得挺有意思的，值得深思，所以分享给大家。\n","categories":["技术以外"],"tags":[]},{"title":"被车撞了！","url":"https://tanqingbo.cn/被车撞了！/","content":"买了新车之后，因为是新手司机上路，开了不到4个月，车身已经被划伤好多处了，有的是我自己不小心划的，有的是车在停车场，不知道被谁划伤的，找不到肇事者了。不过好在都是小小的划伤，不影响车的颜值、也不影响驾驶体验。\n一开始我还很心疼，后来也释然了，只要是开车上路，肯都会有小刮小蹭的。\n直到上周末，我在路上被其它车给撞了。\n\n\n\n\n三车追尾，算是一起不小的交通事故，最后面的白车基本报废了，中间的黑车当场也被拖走了，因为我的车是最前面一辆，损伤相对较小，只伤了后备箱和保险杆，等交警处理完之后，自己颤颤巍巍的开走，第二天送4S点返修了。\n事情是这样的，当天下午我正开着车从家里回单位，下着不小的雨，路况也不复杂，因为靠近红绿灯路口，有点堵车，我的车在最前面，稳稳的把车停住了，过了一两秒之后，就听到哐当一声，车身猛然一晃，我心想坏了，肯定是被追尾了。\n下车一看，果然三辆车撞到一起了，而且最后一辆白车还在往外冒烟，路过的公交车司机好心借了个灭火器，喷了几下没冒烟了。具体经过是最后的白车车速过快，开车还有点走神，我和中间的比亚迪都刹住车了，结果白车直接撞上比亚迪，导致比亚迪又撞上我的车。\n\n好在没有人员受伤，大家情绪也都很稳定，没有大吵大闹，按照流程报警、报保险，然后等待交警过来处理，最后处理结果：白车车主全责，罚款100元。\n真的万幸不是在高速路上，大家的车速也不是特别的快，开车上路一定要谨慎，不要随意变道、也不要走神，否则很容易成为马路杀手，害人害己！\n","categories":["技术以外"],"tags":[]},{"title":"典型的深度学习网络","url":"https://tanqingbo.cn/AIGC中典型的深度学习网络/","content":"前面一篇文章给大家介绍了常见的AIGC模型都有哪些，链接如下：\n国内外常用的AIGC模型\n今天接着分享一下在AIGC的应用中典型的深度学习网络。\n1、生成对抗网络生成对抗网络网络（Generative Adversarial Network，GAN），是深度学习领域的一个重要里程碑。它可以帮助神经网络用更少的数据进行学习，生成更多的合成图像，之后还可以用来识别和建设更好的神经网络。\n主要思路是由两个神经网络来玩“猫捉老鼠”的游戏。一个是生成器，另一个是判别器。生成器用来创造出看起来像真实图像的假图像，而判别器则用来判断它们是否是真的。如图下图：\n\n在相互对抗中，生成器生成的图像逐渐达到以假乱真的地步，从而让判别器难以判断真假，使得生成的数据分布更加接近真实数据分布。\nGAN 有助于创建图像，还可以创建现实世界的软件虚拟场景，例如英伟达就是采用大量的生成对抗网络技术来增强虚拟现实模拟系统的。GAN 的最大优势是其不依赖于先验假设，而是通过迭代的方式逐渐学习到数据的分布。因此，目前 GAN 已经广泛应用在媒体、广告、游戏、娱乐等行业，可以用来创造虚构的任务、画面，模拟人脸老化、图像风格变换以及产生化学分子式等。早期的 GAN 生成图像的效果比较一般，但研究人员加快创新和进一步优化模型，尤其是 StyleGAN 出现让生成的图像足以以假乱真。\n下图中的人脸全部都是由GAN模型自动生成的，值得注意的是，这些人脸并不是从真人的照片中修改而来，而是模型从零开始修改的全新人脸。\n\n但是GAN也有一定的不足，主要集中在稳定性和收敛性方面。例如，GAN的生成器和判别器之间需要很好地同步，但是在实际训练中很容易出现判别器收敛而生成器发散的情况，因此两者的训练需要精心设计才能避免不同步的情况出现。另外，如果GAN模型对于输出结果的控制力不足，就容易产生随机图像，同时图像的分辨率也不高。更为重要的是，让生成的数据分布接近真实数据分布，还会产生新的问题，那就是生成的内容是非常接近现有的内容，但很难实现突破和创新。\n2、TransformerTransformer 是继 GAN 之后，深度学习领域的另一个重大研究成果。2017年谷歌和多伦多大学的研究人员共同发表了一篇著名的论文“Attention Is All You Need”，该论文提到了一个自然语言处理的模型Transformer。\nTransformer 是一款基于自然语言的序列传导模型，论文简洁清晰地阐述了这个新的网络结构 Transformer 基于注意力机制，不需要进行递归和卷积，因此模型在质量上更胜一筹，需要的训练时间也减少了很多。\n由于Transformer 诞生于自然语言理解领域，因此对人类语言的理解更加容易。\n例如这句话：“青蛙发现了一只蝴蝶。它试图抓住它，但是只抓住了翅膀的末端。”\n这里面第二个句子的结构令人困惑：“它”指的是什么？如果是卷积神经网络，则只会关注“它”周围的词，并不理解“它”到底指代的是什么。但是如果把每个词和其他词结合起来，就会发现这两句话是说“青蛙抓住了蝴蝶，蝴蝶失去了部分翅膀”。这种关联性就是Transformer模型中提到“Attention”机制，而且这种方法和人类思考模式很接近。\n为什么这么说呢?\n因为“Attention”机制模仿的就是人类视觉所特有的大脑信号处理机制。具体来讲，在看一幅图像或一段文字的时候，眼睛会快速扫描全局，找到需要重点关注的部门(即所谓的注意力焦点)，之后再进一步对相关区域进行仔细观察。这是人类在长期进化中获得的一种生存技能，这种机制极大提高了我们信息处理的效率和准确性。\n更进一步说，Transformer 的这个“Attention”机制，成功消除了训练数据集需要标注的需求，这一变化让互联网或者企业里的海量文本数据可以直接成为模型训练的数据源，这可以说是具有标志性的创新。\nTransformer 是一个具备强大通用性的底层架构，2018 年在其基础上实现了第一款自然语言处理模型–BERT。BERT模型没有使用预先标记的数据库进行训练，而是采用了自我监督学习的方法进行。\n当BERT模型在海量的文本中进行分析挖掘的时候，能够自行找到隐藏的单词或者根据上下文猜测其中的含义，这种做法和我们考试做题的思路很接近，非常类似于人类大脑学习的机制。之后这类模型又被其他人工智能机构广泛采用，在语言、视觉、多模态等领域，都有着很好的应用。\n可以说Transformer语言模型在理解文本方面的能力实现了质的飞跃。我们现在熟知的很多模型都来自Transformer ，具体如下图所示：\n\n自然语言是所有可训练数据中最丰富的，能够让基础模型在语境中学习、转换成各种内容形式，到 2019年，人工智能理解人类自然语言的水平就已经超过人类平均水平。\n也就是说在这个时候，人工智能已经具备了“能听会看”，下一步的突破就是理解、思考和决策。也正因为如此，大规模语言模型(Large Scale Language Model，LSLM)成为新一轮科技巨头的竞争领域。\n","categories":["图像处理与机器学习"],"tags":[]},{"title":"国内外常用的AIGC模型","url":"https://tanqingbo.cn/国内外常用的AIGC模型/","content":"在聊AIGC模型之前，先给大家解释一下什么是AIGC。\nAIGC全称：AI-Generated Content，中文译为“人工智能生产内容”。狭义上是指通过人工智能技术自动生成内容的生产方式。广义的AIGC可以基于训练数据和生成算法模型，自动生成新的文本、图像、音乐、视频、3D交互内容等各种形式的内容和数据，甚至可能开启科学新发现，创造新的价值和意义。\n其实早在2018年，就有人指出创造性人工智能是未来人工智能的重要研究方向，各个大厂和高校也纷纷有团队在做这方面的工作，直到去年（2022年）ChatGPT的发布，AIGC模型才受到大家广泛的关注，并迅速向大众领域扩散。\n本文将为大家介绍当前国内外一些典型的AIGC模型，希望对大家的工作和学习能有所帮助！\n一、海外AIGC模型1、Stable DiffusionStable Diffusion由来自慕尼黑大学的Robin Rombach(Stability AI公司)和Patrick Esser(Runway 公司)的团队，在 Björn Ommer 教授的领导下主导开发。 Stable Diffusion 作为文本生成图像模型，由于交互简单、生成速度快，极大地降低了使用门槛。因此 Stable Diffusion 成了当前热门的AIGC 绘画生成应用，其理念是“AI by the people, for the people”(可理解为“AI 取之于民，用之于民”)。 Stable Diffusion 不仅公开了算法和训练数据，也公开了训练好的模型参数，与同类型的模型相比 Stable Diffusion 要小很多。\nStable Diffusion 主要由三个部分组成，分别是 VAE、U-Net 网络和 CLIP 文本编码器。在具体的实现过程中，首先使用 CLIP 模型将文本转换为表征形式，然后引导扩散模型 U-Net 在低维表征上进行扩散，之后将扩散之后的低维表征送入VAE 中的解码器，从而实现图像生成。\n2022年10月18日，Stability AI公司获得1.01亿美元投资，估值达10亿美元，公司宣布将继续研发拥有生成图片、语言、音频、视频和 3D 的 AIGC 生成模型。\n2、DALL-E 2DALL-E 2 来自 OpenAI，命名来源于著名画家 Dali 和机器人总动员 Wall-E，是在DALL-E的基础上的升级版，其分辨率是之前版本的4倍，发布不到3个月注册用户就超过100万。DALL-E 2有着较好的理解力和创造力，参数达到了 3.5亿个。\nDALL-E 2 主要由三个模块组成，分别是 CLIP 模型、先验模型和扩散模型。CLIP模型主要是用来对齐文本和图片特征，其中先验模型主要是将文本表征映射为图片表征，扩散模型则是根据图片表征来生成完整的图像。首先使用 CLIP文本编码器来获得文本编码，之后使用先验模型将文本编码映射为图片编码，最后使用扩散解码器用图片编码生成完整图片。\n当然，DALL-E 2也有不足之处，例如容易将物体和属性混淆，无法精准地通过文本在图像中得以实现等。\n3、Imagen VideoImagen Video倾向于打造高质量视频。其工作原理与 DALL-E 2 比较像。首先将文本极性编码表征，之后使用扩散模型将表征映射成为完整图像，同时会通过两个扩散模型来进一步提高分辨率。由于Imagen 使用了T5-XXL模型直接编码文本信息，然后使用条件扩散模型，直接用文本编码生成图像，因此在Imagen 中不需要学习先验模型。同时，Imagen 在语义保真度上做得更好。\n4、Make-A-VideoMake-A-Video 是 Meta 公司在 2022 年9月发布的，使用者可以用文本的方式生成简洁和高质量的短视频。Meta使用的系统模型可以从文本-图片配对数据中，学习现实世界的样子并从视频片段中推理没有文本情况下的变化。从实现场景来看，Mate也提供了多种使用方式，比如使用文本描述不同类型的场景动作、使用单张或一对图片生成变化视频、在原始视频中加入额外的元素和变化等。\n二、国内AIGC模型1、太极腾讯基于自身在自然语言处理和图像多模态等方面积累的经验，打造了通用场景模型——太极文生图大模型。太极文生图采用了 Diffusion 路线：使用在表情场景积累的 Imagen 生成技术(RGB空间Diffusion)，生成的图片相关性很好；使用 Stable Diffusion 技术(Latent Diffusion)生成的图片细节相对更为丰富。因此太极文生图是两套模型并行研发的方案，并在原分辨率基础上进一步优化了超分模型，支持1024像素x1024像素的分辨率。下图展示了太极文生图大模型的一些作品。\n\n为保证大模型能够快速高效落地，太极文生图还定制开发了配套的太极-HCF ToolKit，它包含了从模型蒸馏、压缩量化到模型加速的完整能力。在文字生成图像的场景下，使用其中的HCF异构加速组件进行SD、Imagen的模型推理加速，整体性能与业界领先水平相当。后续，太极大模型将持续集成使用HCF ToolKit 相关组件，并在算子定制、图优化、模型压缩等方向持续发力，确保文生图服务的整体性能。\n2、文心一言2022年百度世界大会上，百度公司对外发布了 AIGC 应用，百度公司创始人李彦宏将 AIGC 的发展分为助手、协作和原创三个阶段。至此，AIGC 开始在国内各大互联网公司全面推进。同时，百度公司也发布了自研的 ERNIE-ViLG 文生图模型，包括工业设计、游戏制作、服装设计、Logo 设计、盆栽设计、动漫设计、珠宝设计、传统艺术等诸多领域。用户可以输人自然语言让AI生成符合描述的图像。\n还有一个显著的特点在于，ERNIE-ViLG模型能够深刻地理解中文表达，也更了解中国文化，这对国人在使用模型的时候更加便利。据了解，百度公司也主动开放了ERNIE-ViLG模型的API接口，以此降低AIGC的应用门槛，推动相关应用规模化和产业化。\n3、太乙 Stable Diffusion当前国内的AIGC 应用，主要是基于翻译API上英文的 Stable Diffusion 模型进行开发，但是由于中英文之间存在着文化差异，导致我们在输入文本的时候，会遇到对于中文独特的叙事和表达，英文模型很难正确匹配图像内容的情况。\n为此，粤港澳大湾区数字经济研究院(以下简称“IDEA研究院”)开源了第一个中文版本的Stable Diffusion模型-太乙 Stable Diffusion，该模型基于0.2亿筛选过的中文图文对进行训练，从而实现了具备中文内核的AIGC模型。下面展示了太乙 Stable Diffusion大模型的作品。    \n君不见黄河之水天上来 ，唯美，油画\n\n滔滔江水，连绵不绝 ，唯美，插画\n\n飞流直下三千尺 ，唯美，插画\n\n可以看到它能够很好的理解中文古诗词的意思。当前多数AIGC模型还无法和具有中国特色文化背景的语言相结合，太乙模型将有望加快AIGC 全球市场化过程中中国文化产业的数字化转型发展，促进各个相关行业的升级。\n4、CogView智源研究院在 2021年5月推出了中文的文图生成模型CogView，这项工作和OpenAI可以说是在同一时期开展的技术探索。2022年上半年，智源研究院推出了 CogView2.0 和视频生成 CogVideo。在 Stable Diffusion开源之后，智源研究院也基于 Stable Diffusion尝试做了中文版和国画版，生成效果非常不错。\n5、MSRA2021 年 11 月微软亚洲研究院与北京大学联合发布了女娲模型，女娲模型用来从输入的文本、图像或者视频生成图像或者视频。同时，女娲模型还具备图像补全等多种功能。\n6、ModelScope阿里巴巴达摩院联合CCF开源发展委员会共同推出AI模型社区“魔搭’(ModelScope)，旨在降低AI的应用门槛。达摩院率先向社区贡献了300多个经过验证的 AI模型，超过三分之一的模型是中文模型。这些模型全面开源、开放，并把模型变为直接可用的服务。\n7、DPM-Solver随着Stability AI的开源模型 Stable Diffusion 被广泛使用，业内专家也在不断对该模型进行优化。扩散模型在使用的过程中需要进行去噪，整个过程需要串行计算50~100步才可以获得较高质量的图片，这导致生成一张图片的时间会较长，限制了模型的部署和落地。为此清华大学的朱军教授带领团队提出了DPM-Solver。\n该模型是一种针对扩散模型特殊设计的高效求解器，这种算法不需要额外的训练，同时适用于离散时间和连续时间模型，可以在20-25步内实现收敛，并且只用10~15 步就能获得非常高质量的采样。在 Stable Diffusion上，串行计算25 步的DPM-Solver 就可以获得优于50步PNDM的采样质量，因此采样速度直接翻倍。这一基于 DPM-Solver的创新使扩散模型的采样速度不再是瓶颈。\n在人类科技发展史上，每一次巨大变革主要是围绕以下两个方面：一方面是人与世界之间的关系，另一方面是建立人与人之间新的关联。在门户网站时代，我们利用门户网站给用户打开了一扇窗户，大家可以通过门户网站来获得更多的数字信息。假如搜索引擎和门户网站是连接人和世界的管道，那么人们就会通过这个管道来获取世界上的信息和内容。在搜索引擎时代，更多的则是信息从另一端推送给用户。同样是管道的架构，但是不同的管道和不同的技术让信息能够更好地进行结构化处理，并让用户更好地获得所需要的信息。\nAIGC时代会诞生一种新结构，首次把人与世界的连接、人与人之间的连接更好地结合在一起，而且是用一种更加自然的方式。这种方式就是使用自然语言实现人与计算机之间的交互。如果用户想要获得自己喜欢的内容并不断调整，那么推荐引擎将替代搜索引擎成为主流。\n以上就是当前国内外一下常见的AIGC模型，想要更加全面地理解AIGC，就需要大家自己在实际的使用过程中自行挖掘了。\n","categories":["图像处理与机器学习"],"tags":[]},{"title":"户口的意义","url":"https://tanqingbo.cn/户口的意义/","content":"我看关注我的人大多数都是年轻人，很多人可能并不了解户口到底有啥用，而最近又恰逢毕业季，一大波应届生毕业走向社会，所以在这个时间节点，我觉得很适合跟大家来聊一下 户口的意义。\n那户口到底有什么用呢？\n未来的发展趋势肯定是城市化、越来越多的资源肯定也会逐渐向城市转移，包括教育资源、医疗资源、生活服务等等。别不相信，现在已经在发生了，就拿我居住过的那个小镇来说，大家现在都拼命把孩子送到县城、或者市里面去上学，导致我现在的那所母校只能把附近的小学都合并过来才能勉强维持。\n而想要留在大城市，自然就离不开户口这个话题，但是大城市也不是你想落户就能落户的，拿上海举例，想要在上海落户，要连续持有上海居住证满7年，并且社保和个税还不能断缴，注意是持有居住证满7年，而不是缴纳个税满7年哦。\n而大多数毕业生刚来上海，都没有去办居住证的意识，等你有这个意识的时候起码好几年过去了，然后居住证再持有7年，就可能10多年过去了。当你等了10年，各方面条件都满足，拿到落户资格之后，也并不代表你立马就能落户，还需要去排队，还得评价你对城市的贡献度设定优先级。所以你知道落户有多难了吧。\n既然这么难，那这一纸户口能做什么呢？\n拿教育资源举例，大家可以去查一下985、211这些名校在北京上海的录取率，然后再对比一下其它省份就知道大城市的教育资源有多牛逼了。有时候你想要上名校，仅仅靠努力是不够的，你参加高考的位置同样很重要。而你想要在这些大城市参加高考，你就必须得有当地的户口。\n说了这么多，可能有人会问：既然落户这么难，跟我们有什么关系呢？\n有关系，准确来说是跟应届生有关系，因为今年上海新出的政策，只要你是应届生的话，可以不走前面7年的居转户流程，最快3个月便可以在上海落户。\n很多人在北京上海这些城市赚了不少钱，但最终因为没有搞定户口的原因，黯然离开。所以大家如果是今年毕业，保有应届生身份的话，真的建议大家不要错过政策机会，去了解一下上海等大城市落户规则，因为错过了应届生身份，以后再想落户可能就得多付出上百倍的成本了。\n我这边恰好也有朋友是做落户方面工作的，大家如果感兴趣的话，可以加一下群，我帮大家链接一下，群里会有人针对大家具体的问题给大家答疑，帮助大家解决落户的问题，抓住应届生红利。\n不管你是想落户，还是想了解一下相关政策都可以加群。\n\n你只有好好的规划当下，才能从容的面对未来，大家都可以去了解一下。\n","categories":["技术以外"],"tags":[]},{"title":"吃苦的三种境界","url":"https://tanqingbo.cn/吃苦的三种境界/","content":"人要做大事，赚大钱，一定是需要吃苦的，这一点是不用怀疑的。\n不吃苦不可能成事，但大多数人能吃的苦，往往只是一种最初级的苦。\n什么是最初级的苦呢？\n就是纯体力上的消耗，这种消耗其实不耗费太多能量的，比如每天搬砖两个小时，地铁上班八九个小时，在完全流程化、流水线的事情上，劳累的精疲力尽。\n这看似很辛苦，但其实门槛很低，只要是身体健全的人都可以做到，甚至根本不算是真正的吃苦，只是体力上有些劳累而而已。\n而相比体力的辛苦更高一个境界就是脑力的吃苦。\n人要上一个大台阶，就要吃脑力的苦。我们都说人要多思考，多动脑筋，其实这是很难做到的事情。因为大多数的人宁可在体力上吃苦，也不愿意真正每天不断思考，不断寻找突破。\n因为脑力的苦是一个更消耗的事情，需要消耗大量的能量，这种所消耗的能量远在体力的痛苦之上。\n而比脑力的苦再高一个境界的便是心力的苦。\n真正做大事情，心里要扛下巨大的痛苦，需要扛住太多的个人情绪，需要对太多的人、太多的事情负责，需要敢于面对种种的矛盾、面冲突以及他人的不理解，需要容忍太多的倒戈背叛，需要顶住最大的风浪险阻。\n心理的苦，才是最高级的吃苦。\n当然，我们无论在吃哪一种苦，我们其实都无需抱怨。\n人活着总会经历各种痛苦，每种人都有每种人要吃的苦，也都是自己的选择，吃多大的苦，就做多大的事情。\n","categories":["技术以外"],"tags":[]},{"title":"有哪些十分干净、利落但又包含哲理的名著句子和诗句？","url":"https://tanqingbo.cn/摘抄/","content":"1、瞎子一旦恢复视力，第一件事就是，扔掉他手.上的拐杖，即使这个拐杖帮助他很多年。一马克吐温\n2、不要以为熟悉的人就会善待你，有时候他们比陌生人都可怕。–萧伯纳\n3、情绪稳定的人，本质上没有弱者，真正的强者是说软话做狠事。一毛姆\n4、你被什么保护，就会被什么限制，猪到死都不明白，杀死它的人和喂养它的人是什么关系。\n5、没有实力，就不要对别人好。不然，很容易被定义为讨好。\n6、当你面对现实而失去了天真，你才意识到自己的愚昧，不要等到诚恳被虚伪击败时，你才明白自己的不机智。\n7、真诚这张牌，加上任何一张都可以，唯独不能单出，单出就是死牌。\n8、聪明的人口齿伶俐，讨厌的人擅长伪装，而你对一切都不太擅长，所以容易上当受骗。\n9、不要轻易同情任何人，即使是最亲密的人，因怜悯谁，你的潜意识就会自动背负谁的命运。\n10、能够生存下来的物种，并不是那些最强壮的，也不是那些最聪明的，而是那些对变化做出最快反应的。-达尔文\n11、不看破红尘，因为红尘本来就是破的。\n","categories":["技术以外"],"tags":[]},{"title":"蔚来ET5试驾体验","url":"https://tanqingbo.cn/蔚来ET5试驾体验/","content":"前面写了比亚迪汉、小鹏P7i的试驾体验，链接如下：\n小鹏P7i试驾体验\n比亚迪汉试驾体验！\n今天接着分享蔚来ET5的试驾体验，实话实说，我是蔚来ET5的颜粉，颜值也是ET5最大的卖点之一。\n\n我身边不少朋友，不管是男生还是女生，都特别喜欢它的颜值，可以说是男女通吃的一款车型。\n同样是按照先静态后动态的顺序来给大家介绍一下ET5，先说静态感受：\nET5的长宽高分别为4790/1960/1499mm，轴距2888mm，尺寸整体比Model 3大了一圈，比小鹏P7i稍宽，但比P7i要短。\n然后蔚来他们家的动力系统没有前驱后驱之分，全系标配四驱，动力杠杠的，这也导致了车的价格并不便宜，当然这个价格也跟他们的服务和换电有关系。\n在整体的布局及规格上，ET5拥有前后双电机的布局、激光雷达、ADAM超算平台全系标配，在有关安全的配置上，ET5都有搭载。\n内饰方面值得好好夸一夸，设计风格很独特、颜色拿捏的也很到位，看上去有种简洁又高级的感觉，就很和谐、很舒服。\n\n氛围灯的效果也很赞，普通氛围灯与凹凸纹理形成的明暗光影效果很浪漫。\n\n然后是驾驶体验：\nET5的驾驶位坐进去之后明显感觉重心有点偏高，因为它有换电系统，需要留下换电空间，如果你的身高在180以上的话，就可能有一种座椅hold不住身体的感觉。在我试驾的几辆车当中，座椅设计最有跑车感觉的是智己LS7，重心超级低，像是坐在地板上开车一样。\n在试驾的过程中，我主要体验了一下辅助驾驶、语音助手、还有隔音效果，由于没上高速，城区的辅助驾驶只能说中规中矩吧，常规的自动跟车、打灯变道基本上都能实现，隔音效果也还不错，不过语音助手nomi就有一点智障了，每次都需要唤醒，试驾员说可以连续对话，但是试了几次都没有成功，而且还有一点听不懂人话。\n传个视频给大家感受一下：\n\n\n最后再吐槽一下蔚来ET5的价格和配置，ET5的起售价是32.8w，560km标准续航，如果想要选择710km长续航的话，起售价是38.6w，比宝马三系的起售价还要高不少，而且这个价格只是丐版，想要更舒适一点的话，就需要另外加钱选装，比如：\n外观颜色1w、Nappa真皮内饰2.25w、NOMI语音助手4.9k、适享套装9.5k，其中适享套装包括香氛系统、方向盘加热、前排座椅通风按摩、后排座椅加热等。\n如果我们选择710长续航、并且上面列的那几个选装都加上的话，价格就来到了43.29w，我觉得这个价格还是有点贵的，性价比肯定是谈不上。\n总的来说，蔚来ET5适合那种单身或者已婚没有小孩，并且预算充足的用户选购，如果身高超过175，记得要多次试驾体验，看看舒适度符不符合自己的预期。\n","categories":["技术以外"],"tags":[]},{"title":"小鹏P7i试驾体验","url":"https://tanqingbo.cn/小鹏P7i试驾体验/","content":"前面写了比亚迪汉的试驾体验，链接如下：\n比亚迪汉试驾体验！\n今天接着分享小鹏P7i的试驾体验，P7i是小鹏今年特别重要的一款车型，没有丐版，上来就是702续航，而且所有的配置都拉满了，可见对它的重视程度。\n\n先说静态体验：\n小鹏P7i和老款P7的外观基本没啥变化，4.88米的车长，1.89米的车宽，1.45米的车高，轴距2.99米，和比亚迪汉对比尺寸确实要少一圈，不过颜值很扛打，虽说是好几年前的造型了，现在依旧耐看，这也是我要吐槽的点，小鹏好像就P7一款能看的车，其它车型都好丑。\n后排坐垫变长了，大腿可以放在坐垫上了，倾斜角度也做了调整，而且采用的是慢回弹海绵，支撑性和舒适性都强了不少。\n\n全系（P7i非P7）标配了前排座椅通风加热、后排座椅加热、电动尾门、电吸门、香氛系统、丹拿音响、高速NGP。这些配置其它车都是需要另外加钱选配的，但是P7i全都做成标配了，省的自己再做选择，这样做的结果就是价格并不便宜，起售价就是24.9w，比特斯拉model 3的起售价还要高，不过model 3是丐版毛坯房，续航还低，这样想的话稍微能好接受一点。\n去试驾的时候，忘记带驾照了，然后他们第二天开车来我家带我去试驾的，这点体验还不错。\n试驾员带我在高速和城区转了几圈，怎么说呢？小鹏的辅助驾驶功能和语音助手功能确实有点惊艳，在高速上可以实现自动变道、超车、下匝道，几乎不需要人为干预，甚至处理的比我还果断。\n语音助手可以不使用唤醒词，直接跟它对话就行，它能分清楚我们是在和它对话还是和人对话，这个用起来真的太舒服了。其它几款车在使用语音助手的时候每次都需要唤醒，这个就很不爽。\n给大家上传个视频感受一下：\n\n\n我一共去试驾了汉、小鹏P7i、蔚来ET5、智己LS7这几款车，除了汉没有体验辅助驾驶功能之外，其它几款车都体验了，小鹏给我的体验是最好的，同样是在城市NGP没有开通的情况下，小鹏可以识别出红绿灯，但是其它两款识别不出来。\n好了，说完了优点，接下来该吐槽缺点了：\n驾驶位双连屏设计，我觉得有点突兀，副驾驶位空出那么大一块地方，都够吃盒饭了，看上去很不和谐，这一点蔚来的设计稍微能好点，看上去很舒服很和谐。\n\n\n然后是氛围灯设计，驾驶台那块的氛围灯真的有点塑料，我没有拍到照片，可以看一下前面的试驾视频，那个氛围灯效果，灯带像是后期粘上去的一样。\n副驾座椅坐着不太舒服，由于跑车造型，车的顶棚太矮，底盘又有点高，我175的身高做进去感觉快要顶头了，如果再高一点的话，可能就会有点难受了。主驾其实也有类似的问题，不过好在主驾有腰脱，高低有四向调节，而且双脚有支撑点，这样稍微能舒服一点。\n后背箱空间开口有点小，空间也偏小，而且为了加装热泵空调，P7i的前备箱也备干掉了，所以千万不要指望它特能装，典型为了造型牺牲了空间的设计，不过溜背造型确实是香，好看。\n\n总体来说，如果没有家庭、不太看重品牌、又比较喜欢智能驾驶体验的话，小鹏P7i是一个很不错的选择的，至少从目前来看，小鹏的品牌效应并不强，但是驾驶体验确实不错，开车的人很爽，至于坐车的人爽不爽，那就不知道了。\n大致的体验就这些，篇幅有限，后续再接着给大家更新蔚来ET5、智己LS7的试驾体验。\n","categories":["技术以外"],"tags":[]},{"title":"比亚迪汉试驾体验！","url":"https://tanqingbo.cn/比亚迪汉试驾体验/","content":"最近几天深度试驾了比亚迪汉、小鹏P7i、蔚来ET5、智己LS7，接下来会分4篇文章依次给大家分享一下这四个品牌的车试驾体验。\n\n\n\n\n这四个品牌总共花了三天时间，也算是比较深度的试驾吧，静态和动态、前后排、主副驾都感受了一下。\n一个一个说下感受吧，先说好的，再说不好的。\n先说比亚迪汉，这个车从外表看上去真的很大，接近3米的轴距、1.91米宽、1.49米高，感觉要比普通B级车大一整圈，里面的空间也很大，它应该去卷C级车的赛道。\n\n我看的是汉DMI尊享版，起售价是23.7w，内饰方面跟奔驰很像，真皮座椅以及天然真木内饰真的超级有质感，喇叭也有点柏林之声的造型，坐进去给人一种：这车肯定不便宜的感觉。\n\n\n后排空间也很大，因为我是跟我妈一起去看的，她老人家也觉得后排很舒适，没有拥挤的感觉，前排通风加热、电动尾门，该给的功能也都给了。\n此外，比亚迪4S店的服务体验我感觉做的也挺好，我们去了之后就主动给我们安排零食、饮料，甚至还要带我们去吃午饭，由于我出门忘带驾照了，他们还协助我办好电子驾照，然后安排试驾，这一点还是挺贴心的。其它几家都是让我回去拿驾照，下次再来试驾。\n试驾的时候，操控感也很不错，因为我不是老司机，只能捡我感受明显的来说，加速很快，而且很线性，不像我之前开的油车，一脚油门下去需要等发动机反应一会动力才上来，它的是动力随踩随有，响应很及时，底盘很稳，想超谁的车，只要我想就能超过去。\n说完了优点，说点我个人觉得不是很好的点。\n一个是龙鳞纹内饰设计，我真的是欣赏不来，没长在我的审美上面，太像老年人的style了……好吧，为了不得罪人，只能说每个人的审美都不一样。\n\n其次是转弯半径过大，毕竟是C级车的尺寸，新手上路的时候可能需要稍微注意一下。\n另一个就是我比较关注的智能驾乘体验，比如辅助驾驶和语音助手。如果你是冲这个这两个功能来的，建议千万不要选比亚迪，因为它的语音助手虽说中规中矩，但是辅助驾驶功能相对于其它新能源车来说几乎等于没有。\n去试驾的时候，试驾员说他们的辅助驾驶功能做的也很成熟，但是让演示就有点遮遮掩掩，说什么在城区还是自己开着舒服，没必要使用辅助驾驶，到最后也没给我演示这个功能。这个跟小鹏截然相反，小鹏的试驾员主动带我去高速和城区转了好几圈，感受他们的NGP辅助驾驶功能。\n比亚迪它自己在网上宣传的时候，也是着重讲刀片电池、舒适性、安全性，对辅助驾驶智能体验方面提的很少。\n我觉得，如果想要吸引更多年轻用户，还是要老老实实升级智能驾驶功能，因为年轻人可能更喜欢接触一些新的东西。\n整的来说，如果不是太追求智能驾驶体验，也可以接受它的内饰设计语言的话，比亚迪汉确实是一个不错的选择的，空间足够大，也很舒适，外形也挺好看的，有时在路上看到，会忍不住多看两眼。\n比亚迪汉给我的感受大概就这些，篇幅有限，后续再接着给大家更新小鹏P7i、蔚来ET5、智己LS7的试驾体验。\n","categories":["技术以外"],"tags":[]},{"title":"ChatGPT！王炸级更新！！！","url":"https://tanqingbo.cn/ChatGPT！王炸级更新！！！/","content":"ChatGPT最近宣布推出插件功能，赋予ChatGPT使用工具、联网、运行计算的能力。\n有多牛逼，举例来说，之前的 ChatGPT 如果相当于 iPhone手机的话，现在的插件就相当于苹果的 App Store。\n直接解决了ChatGPT原有不能联网的问题，原地起飞！\n\n对于个体而言，ChatGPT插件的发布，意味着原有的办公方式将迎来一场智能化的变革。\n也就是说，ChatGPT的应用，很快将出现在生活中的各个场景，不得不说，AI时代的进程，真的太快了，而且必定会越来越快。\n所以还在质疑AI时代的同学们不要犹豫了，抓紧了解AI甚至加入到AI赛道，用吴世春大佬的一句话就是：AI到了IPhone时刻，现在在AI领域学习一年，相当于其他行业混十年。\n\n其实AI最近的发展还远不止ChatGPT，AI画图软件MJ的强大表现也令人咂舌，我发一张大家感受下：\n\n这种水平的制作直接能释放无数设计师的劳动力，直接能让游戏、动漫等领域的生产力提升几十倍甚至上百倍。\n另外如果我们将AI底层的能力赋能给各个行业会发生什么呢？以后我们会有一个7*24小时的外教客服，它几乎通晓一切，能跟我们练100种外语并能分析我们的发音卡点；我们会有一个智能外卖客服，它能理解我们今天最想吃的东西并推荐给我们；我们还会有：论文助手、翻译助手、周报助手、健康助手等等。\n今天我们所有的互联网应用都将会被AI重新颠覆一次，这是必然会发生的事情。\n在未来会有两类人，一类人是会使用AI，甚至会用AI做创新工具的人、另一类是不了解AI或者抵触AI的人。\n前者的生产力效率将是后者的10倍起步！\n那么我们这些普通人，我们应该做什么呢？\n我的答案是：尽快了解AI甚至杀入AI领域，只有这样我们才能在未来的社会竞争中站稳脚跟，而不是被淘汰。\n最后再介绍下我共同参与建设的星球：\n8天时间，星球已经突破9000成员，已经跃居ChatGPT&amp;AI类全国第二！\n这个星球内邀请了很多行业内真正的AI大咖，比如腾讯的大模型技术专家、阿里的大模型技术专家、虾皮算法部门技术专家、头条的算法专家、商汤的AI产品专家。\n甚至还有好几个光年之外（王慧文AI创业团队）的超级大咖加入，甚至互联网超级投资大佬吴世春也加入了。\n简单说下这个星球能给大家提供什么：\n1. 这里有AI行业内的高手，为你分享ChatGPT最新的玩法。\n2. 你可以在这里找到志同道合的小伙伴，一起探讨甚至实现AI创业。\n3. 大家有AI相关的问题可以在星球提问，我们会尽力解答。\n4. 4月10日前加入星球的小伙伴，都有一项额外福利，可以免费获得newbing独立账号一个（基于gpt4.0）。\n5.  为了让大家方便使用AI产品，加入我们就送星球合伙人研发的ZelinAI，ZelinAI原价全年999元，星球会员一年免费！它让小白也能用好ChatGPT，甚至能零代码创建AI应用。\n6.一个月最少一次AI领域大佬的技术直播，上周末已经举办第一次，有系列录播。\n现在星球在运营初期，正式运营价格定为699，目前给出了加入的最低价198，星球马上要来一波大的涨价，如果你还在犹豫，可能最后就要以更高价格加入了。\n早就是优势，建议大家尽早以便宜的价格加入！进入星球后，如果有任何不满意的地方，三天内随时可以退出，直接退款，不会有任何损失，如果你是白嫖党，还能够把里面的所有内容，包括交流信息、资料、课程都看一遍再走，没有任何问题；\n有兴趣的朋友们，欢迎扫码加入本星球：\n\n\n","categories":["技术以外"],"tags":[]},{"title":"到长沙了！","url":"https://tanqingbo.cn/来长沙了！/","content":"早上起来拉开窗帘，看着窗外的好天气，心情大好，觉得还是应该要写篇文章记录一下。\n作为一个湖南人，我在哈尔滨呆了9年，前两年手上有点积蓄，准备给自己买房的时候，思来想去，最后把目标城市定在了长沙。\n湖南伢子终归还是要返乡的呀！所以今年毕业之后，我直接就来到了长沙，其实前几天就到了，然后开始忙着租房子，顺便和朋友约了顿饭。\n租房的那天下午，本来打算让中介带我多看几个小区，结果看的第一个房子就订下来了，主要是屋子里面有个大全景窗，采光非常好，装修风格我也蛮喜欢的，就把合同签了。\n\n可能有点草率，但是管它呢，我现在又不上班，住哪其实都差不多。\n还有一个我喜欢的点就是，住的地方一公里以内，就是长沙最大的商圈：梅溪湖步步高，走路就能过去。\n\n我这两天晚上经常背着电脑过去办公，主要是在家办公白天还好，晚上确实有点无聊，于是我就去步步高找一家星巴克，或者找一家清吧，坐一会。\n\n我自己的房子也买在梅溪湖步步高的对面，预计今年9月份就能交房，交房之后我就能捣鼓自己的家了，有点小期待。\n也许生活就是这样吧，走走停停，忙忙碌碌，然后再夹杂着一些小小的期待。\n再聊聊工作方面吧：\n在研究生阶段，非常有幸进入了自媒体行业，这两年通过自己的折腾成绩还算不错，回顾这两年的经历，用波澜壮阔来形容也不为过。\n前一段时间，非常焦虑，因为毕业之后我面临两个选择：\n到底是继续ALL IN创业，还是找一份稳定的工作？\n创业的收入要比正常打工的收入高出很多很多，这是事实，而且我已经在这条路上取得了一点的成绩；但是焦虑，需要时刻紧绷着，几乎没有休息和放空的时间，这也是事实。\n思考了很久之后，最终还是找了一份稳定的工作，可能这跟我的性格有关吧，我还是希望生活能够轻松安逸一点，能有时间留给自己去追剧、看电影、打球、遛狗，去发展自己的爱好。\n当初跟我一起创业的小伙伴，现在有不少人发展比我好很多，收入也甩了我好几条街，有时候他们也会过来怂恿我要不要入局一起干。\n说实话，我很羡慕他们，也很佩服他们，但是我自己始终拿不出孤注一掷的勇气。\n仔细想想，可能还是因为我面临的选择较多吧，很多成大事的人都是别无选择和退路，只能背水一战的人。\n但是有谁规定人生在世，一定要成事呢？\n不紧不慢、不急不缓的走好脚下的路，自信且笃定的生活。\n“一生好入名山游”、“细雨骑驴入剑门”的人生态度同样值得推崇！\n希望我能做到！\n","categories":["技术以外"],"tags":[]},{"title":"我毕业了","url":"https://tanqingbo.cn/我毕业了/","content":"从2017年9月入学，到2023年3月毕业，\n在哈工大整整五年半的时间，终于画上句号了。\n回首这五年时间，我好像经历了好多的事情，\n因为科研问题焦虑到睡不着觉，要靠吃褪黑素才能入睡，中间还因此休学了一年；\n偶然的原因开始做自媒体，恰好赶上互联网红利，也有投资人因此抛来橄榄枝；\n重仓中概股，亏损十几万；\n买房，在新一线安家；\n当然，还有些事情不好意思说，也有些东西不能聊，只能往肚子里咽。\n曾经满怀希冀、一腔热血，却跌落谷底，遍体鳞伤，\n不过好在一切又都好起来了，我毕业了，又找了份不错的工作。\n所以你看，这个世界神奇的地方就在于，不管你经历了多漫长的黑夜，阳光总会升起，只要你相信。\n5年前入学的时候，我来长沙爬了一次岳麓山，后来休学期间在北京住了一年，现在，我又回到了长沙，\n兜兜转转一大圈，同一个城市，同样是开启新的篇章，虽然依然有些焦虑和迷茫，但多了份勇气和自信，虽有千般重负，却也坦诚无忧！\n我相信，我们都会迎来属于自己的辉煌时刻的。\n五陵年少金市东，银鞍白马度春风。\n落花踏尽游何处，笑入胡姬酒肆中。\n","categories":["技术以外"],"tags":[]},{"title":"怎么更快的赚钱？","url":"https://tanqingbo.cn/怎么更快的赚钱？/","content":"在聊“怎么更快的赚钱？”这个问题之前，我们首先要明确一个观点，那就是赚钱其实是一件很难的事情，当我们明确这个观点之后，在追求”钱“过程中，也就有了一个心里预期，我们想要赚到很多的钱，所以遇到一些困难是应该的，这样自己也就更容易能坚持下去。\n接下来我们再来聊聊怎么才能更快的赚到钱？\n说起来也很简单，就一句话：想要获得经济回报，赚到很多钱，那就要提供社会有需求但是无从获得的东西，并且利用杠杆效应不断的放大。\n普通人有订外卖的需求，所以诞生了美团和饿了么；很多人都有出国的需求，然后诞生了新东方；我们都有便捷打车的需求，滴滴就诞生了。\n你可能会说，这些都是大公司干的事情，跟我一个没技术、没资金的普通人有什么关系？但其实只要你细心观察，普通人也是有很多机会的。\n前段时间有个博主在网上教大家怎么坐高铁，迅速爆红积累了几十万粉丝，你可能会说，坐高铁还需要人教吗？\n但事实情况就是，很多人真的就一辈子没有坐过高铁，而且这里面有很大一部分还是经常网上冲浪的年轻人、高学历人群。我的一个博士室友，快30岁了，跟他交流我才发现他第一次坐高铁的时间就是今年。\n当人们第一次面对一个陌生事物的时候，总会多多少少有一些恐惧的情绪在里面，这个时候你要是能提供一些指导，解决他们的需求，你就能迅速积累影响力以及经济上的回报。\n所以有时候我们需要跳出自己的固有思维去看问题，也许你习以为常的东西，就是人家接触不到且正好需要的东西。\n比如你会徒手写代码、你有过考研、考四六级或者考公的经验，再或者你游戏玩的很溜，有玩游戏上分的经验等等，你的这些经验和技能在社会上肯定会有很多人不具备并且想要具备的，这个时候你的用武之地就来了。\n当你找到一个新的需求，而你恰好又具备相关的经验或者技能的时候，你的机会就来了。\n这期间你可以先免费在抖音、小红书、微信等平台分享你的经验，这个过程可能会消耗你的一些时间，但是你让人家看到了你的专业度、赢得了关注和声誉。\n接下来要做的事情就是最大限度的利用杠杆效应，扩大自己提供的产品或服务的规模。\n通常大家理解的杠杆都以为是资金，但其实不是。常用的杠杆有三种：\n第一种是劳动力杠杆，也就是雇佣别人给你打工，一些小公司、小工作室用的都是这种模式，雇佣一些员工，迅速将自己所提供的服务规模化。\n但是这种杠杆的效果不是最好的，因为它涉及到人员管理，人员管理工作其实是一件非常复杂的事情，需要高超的领导技巧，弄不好管理者会落个众叛亲离、被手下生吞活剥的下场。\n第二种是资本杠杆，就是利用钱来扩大决策的影响力，很多大型公司的高层，他们在做的其实都是财务工作，怎么利用有限的资本释放出最大的影响力来。\n资本的放大效应非常明显，而且管理资本比管理人更容易，因为随着资本的不断增加，其管理难度会远远低于管理不断扩张的团队。\n最后一种杠杆是复制边际成本为零的产品。这是一种全新的杠杆，也是我们普通人最触手可及的杠杆，其中包括书籍、视频、互联网、电影、代码等。\n而且在所有的杠杆中，这也是最值得我们研究的杠杆，随着互联网的爆发式增长，你不需要雇佣员工、也不需要资本投资，你就可以借用互联网把自己的劳动成果放大千百倍。\n比如以前一个销售在卖产品的时候，他一次只能服务一个客户，但是如果借助直播的力量，他可以同时向几百万人介绍自己的产品。现在那些头部带货主播就是典型的例子，李佳奇在做直播之前就是一个柜员，是互联网杠杆赋予了他如此多的财富和影响力。\n这种新的杠杆特点之一就是，使用他们不用经过任何人的同意。要使用劳动力杠杆就需要有人决定追随你；使用资本杠杆就需要有人给你提供资金。\n而你写代码、拍视频、录直播、写书这些工作不需要经过任何人的许可，并且一旦你完成了这些工作之后，他们就可以自行运转，代码写好之后可以自己在机器上不休息的运行、拍的视频可以在你睡觉的时候仍然传播，这就是杠杆的力量。\n曾几何时，人类社会是没有杠杆的，你帮我砍8小时的柴，我就支付你8小时的工钱，后来人类发明了资本、合作、科技、生产力等各种手段，人类社会进入了杠杆时代，在这样的时代里，作为一名劳动者，只有最大化的发挥杠杆效应，才能利用有限的时间和精力产生巨大的影响力和收益。\n与一个没有利用杠杆的劳动者相比，利用杠杆的劳动者产出会增加成千上万倍，收入的差距自然也会相差成千上万倍。\n","categories":["技术以外"],"tags":[]},{"title":"校招污点公司名单","url":"https://tanqingbo.cn/校招污点公司名单/","content":"最近在逛GitHub的时候，发现一个很有意思的项目，叫做「CampusShame-校招污点与非污点公司名单」。\n如果一家公司在校招的过程中，对应届生做过一些不太体面的事情，就会很荣幸的收录到这个名单上面，可以说对大家找工作避雷很有帮助。\n校招污点行为包括但不限于：毁意向书、毁两方协定、毁三方协定、故意卡试用期、试用期裁员、大量裁应届生等。\n这个项目的信息主要来自于牛客网、脉脉、知乎、微博等公开论坛，有些帖子点进去看可能会发现已经被删掉了，说明该帖子已经在互联网工作论坛产生了较大的影响，涉事企业为了挽救自身品牌形象，启用了公关手段删帖保脸面。好在互联网是有记忆的，很多贡献者提供了原帖子的快照。\n项目地址：https://github.com/forthespada/CampusShame\n主页似曾相识的logo配色，配上陈坤的台词，戏谑中带点无奈。\n\n项目一共汇总了21-23届校招污点公司名单：\n\n\n帖子很长，我就不一一给大家截图了，作为找工作的应届生，大家可以花时间去看看这份名单，留意一下自己心仪的公司是否上榜，看看是否有什么不能接受的黑记录，在正式签约之前，多了解一些信息，多给自己留一些退路。\n自己也可以找学长学姐、或者目标公司熟人了解一下，帖子中说的污点是否属实，总之要做到心中有数，这样不容易被hr忽悠，找到满意工作成功的概率也就越大。\n最后再贴一下项目地址：\nhttps://github.com/forthespada/CampusShame\n","categories":["技术以外"],"tags":[]},{"title":"一条高产爆款内容生产线！","url":"https://tanqingbo.cn/一条高产爆款内容生产线/","content":"在IP各项能力中，内容是最为重要的，因为做内容的能力不仅关系到流量的获取，对销售变现也有决定性影响。\n任何技能都可以通过三点来掌握：1、科学的方法论；2、反复的刻意练习；3、从量变到质变，秉持长期主义思想。\n一、做内容的三大要素1、真实真诚\n为了避免人设崩塌，唯有真实的IP才能走得更稳、更远。\n此外就是真诚，能迅速拉近与客户的距离，达到这一目标的条件是：自己首先卸下防备，让别人能快速看透你。\n怎么才能做到真诚，让人一眼看透呢？答案是讲4F故事，就是failure（失败）、flaws（缺点）、frustrations（沮丧）和firsts（初次经历）。\n2、持续产出\n持续产出有两方面的意义：\n\n从用户的角度看，持续产出是存在感和信任感的体现；\n从传作者角度来看，持续产出是一种习惯，是一种不断精进的状态，也是一个贴近用户的正反馈循环。做商业相关的内容，切记憋大招，必须持续产出，先把内容投放给市场，再快速看反馈：看用户评价和口碑，看内容相关数据。\n\n3、干湿结合\n学习机械性知识是反人性的，因此内容一定要干湿结合。\n\n“干”指的是认知、逻辑、框架、总结、方法论、专业名词等，可以让IP建立起特定领域权威感、专业感，这个是变现的前提。\n“湿”指的是情绪、故事、笑点、泪点、案例、颜值等，可以让IP建立起丰满、鲜活的人设，产生人格魅力。\n\n所以做内容必须做到干湿结合：既有逻辑、体系，能抓住重点有干货，又能做到有趣，各种故事张口就来，与内容紧密结合。\n流量就是掺了水的干货。\n二、内容的形式有哪些种类，哪些适合搞流量？\n最适合引流的是短视频和直播，最适合变现的是直播和线下演讲，最合适提高形象的是长图文，最适合刷存在感的是短图文。\n三、如何把一份时间卖N次一份时间卖N次的案例：\n\n一次高质量连麦，可以作为朋友圈素材、存放到案例库、做成演讲稿、放在课程里做素材、直播间里分享、录制成短视频、写书当案例。\n\n四、如何构建强大的内容体系模板","categories":["技术以外"],"tags":[]},{"title":"最近很火的ChatGPT到底该怎么玩？","url":"https://tanqingbo.cn/最近很火的ChatGPT到底该怎么玩？/","content":"这段时间，想必大家肯定早就领教过 ChatGPT 的威力了吧。\n我们跟它说各种内容，比如写代码、汇总周报、查攻略、写小红书、查百科什么的，ChatGPT 都对答如流，根本不在话下。\n比如说让它用Java写一个时间复杂度小于等O(nlogn)排序算法，思路清晰，代码正确：\n\n比如让它帮我汇总一下周报，其实我这周什么也没干，但是想让chatgpt帮我写的充实一点，显得我做了很多事情：\n\n写的还挺正式的，看起来我好像本周确实为公司做出了不少贡献。\n再比如告诉它小红书的写作风格，它可以自动帮我进行小红书创作：\n\n真的不比真人博主写的差。\n当然chatgpt还有很多有趣的功能，比如查攻略、推荐电影、解答疑惑等等。\n\n但是由于一些门槛限制的原因，很多人都玩不了，所以我建了一个chatgpt的交流群，群里有注册教程，也有群友交流玩法.\n\n由于需要维护成本，进群收费15元，直接转账然后加微信，给我看转账截图就可以了，我拽你进群。\n\n我的微信号：best_bobo2，二维码如下：\n\n","categories":["技术以外"],"tags":[]},{"title":"最近很火的ChatGPT到底该怎么玩？","url":"https://tanqingbo.cn/ChatGPT/","content":"这段时间，想必大家肯定早就领教过 ChatGPT 的威力了吧。\n我们跟它说各种内容，比如写代码、汇总周报、写邮件、写诗句、查百科什么的，ChatGPT 都对答如流，根本不在话下。\n比如说让它基于 Vue3 写一个 div 的拖拽实现，思路清晰，代码正确：\n\n比如让它汇总和润色一个周报：\n\n写的还蛮 “充实” 的感觉的。\n当然还有各种有趣的功能大家去 ChatGPT 继续试试吧～\n那其实这次我要介绍的不是 GhatGPT，而是一个 ChatGPT 的客户端。\n为什么要客户端呢？因为有了客户端我们就不用每次单独开一个浏览器，而且也不会迷失在无数的 TAB 里面了，而且客户端其实基于 ChatGPT 多了一些新的功能。\n让我们来看看吧。\n介绍开门见山，这个客户端的 GitHub 地址是：https://github.com/lencx/ChatGPT，支持 Mac、Windows、Linux。\n\n截止写文的时候，客户端已经更新到 0.7.0 版本，支持的功能有：\n\n多平台的支持，Mac、Linux、Windows\n支持导出 ChatGPT 的历史，生成图片、PDF、分享连接\n自动升级提醒\n通用 / 全局快捷键\n系统托盘设定\n支持一些快捷命令和配置选项\n\n下面我们就来看看怎么搞吧。\n安装安装其实挺简单的，官网提供了下载安装包，大家可以到这里 https://github.com/lencx/ChatGPT#-downloads 选择自己平台的安装包下载安装。\n我这边是 Mac，安装完了之后会有这样的一个图标：\n\n打开之后需要让我们注册或登录 OpenAI 的账号。\n界面和 https://chat.openai.com/ 是一样的，因为客户端其实就是外包了一个网页而已：\n\n需要提醒下的是，如果你从来没用过 GhatGPT，在注册新账号的时候，有一步是验证手机号，这时候如果我们输入国内手机号会被提示 “地区不被支持”。这时候建议开全局国外代理，并且使用国外手机号来完成验证。\n这里推荐一个网站 https://sms-activate.org/，我们可以花一块钱左右买到一个 OpenAI 验证的手机号接收一次验证码。\n搜索 OpenAI 服务，并选择对应地区即可，我选择的是马来西亚能成功接收到验证码（一开始选了一个印度的但没接收到验证码），而且也挺便宜的。\n\n就是这样，希望大家能成功注册到一个 ChatGPT 账号。\n测试接下来就是一些常规操作了，进入之后我们就可以输入各种文字来尝试 ChatGPT 了，比如：\n\n这时候大家会说，这客户端和网页有啥不一样啊？网页也有这功能啊。\n有的，看图里面，右侧的几个其实就是客户端多出来的功能，分别是生成分享图片、PDF 和链接。\n比如我点一下 “生成分享图片” 的按钮，就可以生成这样的一个分享图，还蛮不错的：\n\n当然 PDF 也是一样的。\n快捷命令当然我觉得客户端更好用的功能在于一个叫快捷命令的功能，我们可以输入一些命令，启用 ChatGPT 的一些功能。\n首先，我们输入一个 / 就能激活快捷命令，如图所示：\n\n我们可以看到，这里已经内置了好多个快捷命令，比如 poet、chef、rapper 等，代表了让 ChatGPT 实现的一些功能。\n比如这里有一个 /javascript_console 的快捷命令：\n\n选中之后输入框就会多这么一些文字：\n\nI want you to act as a javascript console. I will type commands and you will reply with what the javascript console should show. I want you to only reply with the terminal output inside one unique code block, and nothing else. do not write explanations. do not type commands unless I instruct you to do so. when i need to tell you something in english, i will do so by putting text inside curly brackets {like this}. my first command is console.log(“Hello World”);\n\n大意就是告诉 ChatGPT，我会告诉你一段 JavaScript 代码，你帮我执行并输入结果，然后我的第一个命令是一个 console.log 语句。\n对，就是这样，直接发出去即可：\n\n然后 ChatGPT 就会按照我们说的来执行了。\n\n接着，由于 ChatGPT 有记忆功能，它能知道刚才我们让它干了什么。\n所以接下来，我们就可以接着让它干事情了。\n接着继续输入第二段代码，它就能接着继续输出了：\n\n是的，就是这个流程。\n还有很多其他的功能，比如输入 /poem 作诗：\n\n接着我们输入新的作诗要求就可以了：\n\nOK，这下大家应该理解了吧，我们利用了 ChatGPT 的上下文记忆功能，结合一些快捷键，就能快速让 ChatGPT 帮我们完成想要的事情了。\n那所以，如果我们把想要 ChatGPT 做的工作都收录整理下来，那么以后是不是就能直接调用了。\n比如说，我输入一个中文类别的命令 /汇总周报，然后描述好要让它帮我们做什么，接着就可以让它帮我们汇总周报了。\n想的挺好，ChatGPT 客户端可以做到吗？可以！\n我们通过 ChatGPT 的菜单里面打开 ‘Control Center’，就可以看到这样的一个配置界面：\n\n我们可以切换到 Language Model - User Custom 部分，这里我们就可以添加一些自定义指令了。\n比如我这里点击 Add Model 按钮，添加这样的一个指令：\n\n这里第一个 /{cmd} 就是我们到时候实际敲的命令，Act 就是对命令的一个描述，会出现在命令的描述里面，Prompt 就是告诉 ChatGPT 的话，这里我们需要详细描述一下需要 ChatGPT 做的事情，并给出一个示例。\n编辑好了之后点击保存。\n然后重启下 ChatGPT，这时候我们就可以输入 /汇总周报 命令了：\n\n然后点击空格转换为实际的文字，然后发出去：\n\nOK，接下来我们就可以让它帮我们整理第二份周报了，而且第二次也不需要告诉他那么多前提了。\n\n所以，到现在大家能体会到这个快捷指令的便捷用途了吧，我们可以提前录入好一些要求，然后第二次我们就无需赘述那么多要求，直接输入最直接的要求，ChatGPT 就可以帮我们完成其中的操作了。当然第一次的时候，我们也可以自行替换想要替换的输入文本，同样也可以达成想要的效果。\n有人说？那我应该整理一些什么命令呢？都行呀，比如整理周报、起草邮件、写 Python 代码，都行。\n这里给大家介绍一个资源，叫 awesome-chatgpt-prompts，GitHub 地址是： https://github.com/f/awesome-chatgpt-prompts，这里面汇总了各种快捷命令，大家也可以到里面寻找些灵感，也可以贡献命令到这个 Repo，这样命令就会被自动收录到 ChatGPT 这个客户端里面。\n总结好了，这次给大家介绍了 ChatGPT 客户端的基本使用，想必 ChatGPT 网页来说，会有如下的几个优点：\n\n独立的窗口运行，不用每次单独打开浏览器，也不会迷失在茫茫的 TAB 里面。\n带了额外的转换分享功能，比如生成图片、生成 PDF、分享链接等，这是网页所不具备的功能。\n带了便捷的快捷命令功能，利用它我们可以快捷输入想要的命令，并且可以自己管理一些命令，已备后续之需。\n\n大家可以试用哈，希望这次分享对大家有帮助！\n","categories":["技术以外"],"tags":[]},{"title":"基金的种类有哪些？","url":"https://tanqingbo.cn/Fund-type/","content":"很多人聊到理财都知道要买基金，但是等他们注册基金账户之后往往会一脸懵逼，因为他们会发现原来基金的种类还分很多种：债券型、混合型、股票型基金等，不同的风险偏好和投资目的，适合购买的基金类型也不同，如果分不清这些基金类型的差别，盲目的去购买基金，100%会亏钱。\n那基金都有哪些分类方法？分别都有哪些种类呢？\n\n1．按投资对象分类（1）债券型基金：基金超过80%的资金都投资于债券。（2）股票型基金：基金超过80%的资金都投资于股票。（3）混合型基金：基金的部分资金投资于股票，部分资金投资于债券，投资比例可以调整。（4）货币基金：全部资产都投资在各类短期货币市场上，如购买国债、央行票据、商业票据、银行定期存单、政府短期债券、同业存款、同业拆借等。货币基金流动性高，风险极低，收益高于一般银行定期、活期存款。债券的风险低于股票。收益与风险同比相关。因此，这几种基金收益和风险的排序如下所示：\n股票型&gt;混合型&gt;债券型&gt;货币基金&gt;银行定期&gt;银行活期\n2．按是否能中途申购或赎回分类（1）开放式基金：比较灵活，规模不固定，随时可以申购和赎回。（2）封闭式基金：资金规模固定，申购、赎回时间也固定，期间无法赎回，有点类似于定期存款。\n3．按交易地点分类（1）场内基金：在股票市场可以买卖，费率较低，无法设定自动定投。和股票一样，交易日每一刻的价格都在波动。场内信息繁杂，需要具备一定的专业知识寻找。（2）场外基金：在股票市场以外的其他市场可以买卖，如银行、证券公司代销、基金公司直销等。操作简单，费用相对较贵。以净值为价格进行交易，一天只有一个价格。\n4．按发行方式分类（1）公募基金：以公开方式募集，普通人也能参与，只收管理费，不收业绩报酬，每个交易日都能申购及赎回，流动性强。受监管严格规定，不能参与股指期货对冲等。（2）私募基金：门槛较高，一般需要100万元起。在收费方面，除管理费外，还有业绩提成。信息不对外披露，具有较强的保密性。可以投资的范围较广。\n5．其他除上面这些分类方法外，还有一些常见的基金名词。（1）ETF基金，英文全称是Exchange Traded Funds，即交易所买卖基金。买卖手续与股票完全一样。ETF基金管理的资产是一揽子股票组合，并与特定指数的成分股票相同，每只股票的数量与该指数的成分股构成比例一致。ETF基金交易价格取决于它拥有的一揽子股票的价值。因此，大盘股指数升，ETF基金就升；大盘股指数跌，ETF基金就跌。ETF的交易费和管理费都很低廉，持股组合比较稳定，风险分散，流动性高，单笔投资便可以获得多元化的投资效果，节省大量时间及金钱，非常适合投资小白参与。（2）分级基金，指把一个基金投资组合（母基金），根据基金收益或净资产的不同，分解成两级或多级子基金，预期风险和收益比较低的子基金称为A类基金；预期风险和收益比较高的子基金称为B类基金。投资者可根据自身的风险偏好，选择适合自己的子基金。\n","categories":["技术以外"],"tags":[]},{"title":"我27岁了","url":"https://tanqingbo.cn/27岁了/","content":"我27岁了\n这是一个扎心的年纪，\n以前过生日总是很开心，\n现在却为生日发愁，\n因为距离三十岁又近了一年。\n\n我27岁了，\n这一年，我做了一些事情，\n我完成了我的毕业论文，\n成功减肥20斤，\n在新一线买了房子。\n我27岁了，\n在过去的几年，\n我走了不少的弯路，\n那些曾经以为过不去的坎，\n现在也都过来了。\n我27岁了，\n越来越看不清爱情的样子，\n但是渴望身边有这样一个人\n每天忙完一起吃饭、\n一起遛狗、一起看电影。\n我27岁了，\n存了笔fuck u money，\n买得起自己想要的房子和车子，\n也给未来的职业规划\n多了几分选择的底气。\n","categories":["技术以外"],"tags":[]},{"title":"国产 API 神器Eolink，太强了！","url":"https://tanqingbo.cn/Eolink/","content":"今天发现了一款国产化的接口测试工具，看它官网中的中文页面，倍感心切，很干净，深度解决了postman 和 swagger 的95%痛点。\n这个国产软件就是Eolink，结合了 API 设计、文档管理、自动化测试、监控、研发管理和团队协作的一站式 API 生产平台，还集成 Gitlab、Jenkins、钉钉、企业微信、飞书等平台，满足API团队协作和流程自动化的所有功能。\n\n目前 SaaS 产品 完全免费 ，你可使用web版，也可下载桌面端，Windows、Mac、Linux 平台均支持！\n文末我放了个视频，如果你不想阅读文字，可以直接看视频介绍。\n当然，也可以自己上手体验一把。\n体验地址：\nhttps://www.eolink.com/?utm_source=w2201\n01. Eolink 及其创新理念Eolink 是一款专业级的一站式 API 协作平台，其团队早在 2016 年就发布了国内首个集 Swagger+Postman+Mock+Jmeter 单点工具于一身的开源产品 Eoapi，并于2017年正式发布了全球首个在线 API 全生命周期管理平台，\n针对API研发协作中的痛点，Eolink提出了创新理念：文档与测试驱动开发（DTDD），简单地说就是：\n\\1. 用标准文档代替口头约定和笔记文档，让开发、测试、运维、协作有迹可循；\n\\2. 快速用测试结果推动开发进度，让团队沟通更充分、管理有事实依据，实现敏捷开发。\n\n这套理念经过大量用户验证，逐步形成了以下的API研发测试流程，将后端、前端、测试等团队更好地结合在了一起\n02. API研发测试天花板目前市面上有众多 API 研发工具，但 Eolink 依然在功能深度、广度以及用户体验等方面都做到了更好，尤其是针对批量操作和重复工作开展了大量自动化和智能化提升。其实一个产品是不是用心打磨过，体验好不好，一上手就知道了。让我们 Eolink 到底有多强！\n1. 支持所有类型的 API 文档管理\n无论使用什么语言开发，无论是 HTTPS、Websocket、TCP、UDP 等什么协议，还是 Restful、SOAP、WebService 等什么规范，Eolink 都可以协助团队快速、统一、规范地管理起来。\n2. 一键发起 API 测试，打通 API 文档与测试\nEolink 可以一键发起测试，支持自动生成测试数据，能够通过 Javascript 代码对请求报文、返回结果等进行加解密、签名等处理。一键发起，让繁琐的API测试变得简单顺滑。\n3. 0 代码自动化测试，一键进行大范围回归测试\n当 API 发生变化时，可以一键进行 API 回归测试，系统会自动根据规则判断返回结果并得出测试报告，方便团队快速了解 API 改动的影响范围，可减少超过 95% 的测试时间！\n4. 根据 API 文档生成 Mock API\nEolink 支持非常强大的动态 Mock API，可以根据不同的请求参数自动返回不同的 HTTP Status Code、Header、Body等数据，并且支持在一个 API 文档里创建多个 Mock API 。\n5. 强大的 COOKIE 管理功能\n在测试需要 Cookie 的 API 时，Eolink支持在 Cookie 管理里添加所需的 Cookie 信息，系统会自动存储 Cookie，下次测试其他相同域名的 API 时会自动传递 Cookie 请求参数。\n目前 SaaS 产品完全免费，你可使用 web 版，也可下载桌面端，Windows、Mac、Linux 平台均支持！\n体验地址：\nhttps://www.eolink.com/?utm_source=w2201\n03. Eolink迷人的小亮点我还发现 Eolink 几个隐藏的亮点功能，用起来特别香！\n\\1. API变更智能通知\n\\2. API文档评论功能\n\\3. API历史版本比对\n\\4. 定时测试任务\n\\5. 支持数据驱动\n\\6. 项目分析报表\n我直接上图，大家一看就懂。\n\n当 API 发生变化时通过邮件和站内信自动通知相关成员，并且已与QQ和和飞书打通\n\n直接在 API 文档上发布评论，沟通内容会跟随 API 文档不同版本存档\n\n回滚查看API文档历史版本，智能查找不同版本文档差异\n\nEolink支持定时测试任务，或者将 API 自动化测试平台集成到Jenkins上，实现代码提交即触发测试，实现项目在无人值守的情况下自动测试，解放劳动力\n\n通过数据驱动模拟多种场景，以此来看场景用例执行情况，避免测试流程空跑，使测试案例更接近真实\n\n强大的项目数据统计分析功能和醒目的可视化呈现，团队开发工作一目了然\n当然，Eolink 的功能还远不止如此，还有很多亮点可以探索。\n目前 SaaS 产品完全免费，你可使用 web 版，也可下载桌面端，Windows、Mac、Linux 平台均支持！\n体验地址：\nhttps://www.eolink.com/?utm_source=w2201\n04. 全球首个API全生命周期管理平台Eolink除了 API 管理、自动化测试服务以外，还是全球首个API全生命周期管理的SaaS平台，提供包括 API网关、API监控、API 自动生成等服务。API-First大势所趋，不掌握API全生命周期管理容易掉队！\n\n截至目前，Eolink 已经为包括奇安信、深信服、泰康集团、索尼、统一企业、博时基金、圆通速递等数千家各行业领先的企业提供API管理服务，实力非常硬，口碑非常好，值得信赖！\n目前 SaaS 产品 完全免费，你可使用 web 版，也可下载桌面端，Windows、Mac、Linux 平台均支持！更加厉害的是，他们竟然还有开源产品！欢迎大家来体验~\n体验地址：\nhttps://www.eolink.com/?utm_source=w2201\n","categories":["Java"],"tags":["API","Eolink","框架"]},{"title":"推荐几个比较优秀的Java开源项目","url":"https://tanqingbo.cn/Java-project/","content":"先来看一张编程语言图谱，了解一下 Java 最近20 年到底有多火。\n\n从趋势图可以看出，Java 在最近 20 年里一直处于前三的位置，可见受欢迎的程度还是很高的。\n\n好了，废话不多，直接上干货项目，如果觉得有价值，记得 三连支持。\n\n1、mall地址：https://github.com/macrozheng/mall\nmall项目是一套电商系统，包括前台商城系统及后台管理系统，基于SpringBoot+MyBatis实现。前台商城系统包含首页门户、商品推荐、商品搜索、商品展示、购物车、订单流程、会员中心、客户服务、帮助中心等模块。后台管理系统包含商品管理、订单管理、会员管理、促销管理、运营管理、内容管理、统计报表、财务管理、权限管理、设置等模块。\n \n2、advanced-java地址：https://github.com/doocs/advanced-java\n本系列知识出自中华石杉，可以作为互联网 Java 工程师进阶知识完全扫盲。学习本系列知识之前，如果你完全没接触过 MQ、ES、Redis、Dubbo、Hystrix 等，那么我建议你可以先在网上搜一下每一块知识的快速入门，跟着入门 Demo 玩一下，然后再开始每一块知识的学习，这样效果更好\n \n3、matrix地址：https://github.com/Tencent/matrix \nMatrix是一款微信研发并日常使用的 APM (Application Performance Manage) ，当前主要运行在 Android 平台上。Matrix 当前监控范围包括：应用安装包大小，帧率变化，启动耗时，卡顿，慢方法，SQLite 操作优化，文件读写，内存泄漏等等。\n4、miaosha地址：https://github.com/qiurunze123/miaosha \n该项目是对高并发大流量如何进行秒杀架构，而做的一个系统整理，如果你完全没接触过 MQ、SpringBoot、Redis、Dubbo、ZK 、Maven,lua等，那么我建议你可以先在网上搜一下每一块知识的快速入门\n5、arthas地址：https://github.com/alibaba/arthas \nArthas旨在帮助开发人员解决Java应用程序的生产问题，无需修改代码或重新启动服务器。有了Arthas，你就可以在不重新启动JVM或需要额外的代码更改的情况下实时地对问题进行故障排除。\n6、spring-boot地址：https://github.com/spring-projects/spring-boot \n从最根本上来讲，Spring Boot 就是一些库的集合，它能够被任意项目的构建系统所使用。简便起见，该框架也提供了命令行界面，它可以用来运行和测试Boot应用。框架的发布版本，包括集成的CLI（命令行界面），可以在Spring仓库中手动下载和安装。\n具有如下特性：\n● 创建独立的Spring应用程序\n● 嵌入的Tomcat，无需部署WAR文件\n● 简化Maven配置\n● 自动配置Spring\n● 提供生产就绪型功能，如指标，健康检查和外部配置\n● 绝对没有代码生成和对XML没有要求配置\n7、tutorials地址：https://github.com/eugenp/tutorials \n该项目是一系列小而专注的教程，每个教程都涵盖一个明确的开发领域。大多数教程项目都专注于Spring Framework（和Spring Security）。以下技术是重点：core Java，Jackson，HttpClient，Guava。\n8、qmq地址：https://github.com/qunarcorp/qmq \nQMQ是去哪儿网内部广泛使用的消息中间件，自2012年诞生以来在去哪儿网所有业务场景中广泛的应用，包括跟交易息息相关的订单场景；也包括报价搜索等高吞吐量场景。\n9、symphony地址：https://github.com/b3log/symphony \n一款用 Java 实现的现代化社区（论坛/BBS/社交网络/博客）平台。分为社区版和商业版\n10、incubator-dubbo地址：https://github.com/apache/incubator-dubbo\nDubbo 是阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring 框架无缝集成。目前，incubator-dubbo 作为一个孵化中的 apache 项目，毕业后,项目移出incubator,成为正式开源项目。\n\n","categories":["Java"],"tags":[]},{"title":"推荐几个在线学习SQL的网站！","url":"https://tanqingbo.cn/推荐几个在线学习SQL的网站！/","content":"给大家推荐几个我自己学习SQL时用过的在线学习网站，不仅包含了大量SQL理论知识，还不用自己劳神搭建数据库，在交互式环境里面练习SQL，肯定可以帮你快速入门SQL。\n1、W3Cschool MySQL教程这个网站包含了MySQL从入门到深入的详细教程，你可以在这上面学习一些简单的增删改查操作，也可以去学习SQL的高级教程，并且每个章节还配有实战环节。\n\n2、SQL语句教程这个 SQL 教程网站列出常用的 SQL 指令。包含以下几个部分：\n\nSQL 指令: SQL 如何被用来储存、读取、以及处理数据库之中的资料。\n表格处理: SQL 如何被用来处理数据库中的表格。\nSQL语法: 这一页列出所有在这个教材中被提到的 SQL 语法。\n\n对于每一个SQL指令，都列出及解释这个指令的语法，并用一个例子来让读者了解这个 指令是如何被运用的。可以收藏起来当做SQL字典来用，随时进来查询。\n\n3、SQL在线练习有时候在做数据库题目时，机器没有安装SQL环境，这时可以考虑免费在线SQL数据库，也就是我给你推荐的这个网站，网页左上方菜单栏包含一个下拉框，改下拉框可以选择数据库类型及版本，当前支持的有MySQL 5.6、Oracle 11g R2、Postgre 等免费在线SQL数据库，极大的方便了我们在线练习SQL语句。\n\n4、IT码农该网站汇总了数据库学习过程中需要用到的图书（电子书）、教程、文档，所有相关资料均提供电子版免费下载，涵盖高性能MySQL、深入浅出MySQL、MongoDB权威指南、MySQL必知必会、MySQL技术内幕InnoDB存储引擎、SQL查询的艺术、SQLite 权威指南等，帮助开发者全面学习了解﻿数据库的编程知识！\n\n","categories":["工具"],"tags":["数据库","MYSQL"]},{"title":"买房了。。。","url":"https://tanqingbo.cn/bought-a-house/","content":"2020年的时候，因为疫情的原因，在家待了半年多时间，那段时间因为没有什么科研压力，正好在家里面也比较闲，于是疯狂的迷上了搞钱，混了不少圈子，也参加了一些聚会，当时经常听到一个话题就是买房。\n有人在社群分享他是怎么通过在上海买房，不到一个月赚了100万，去苏州那边，朋友也说工业园区的房子很有升值价值，于是我在心里下了一个决定：买房，一定要尽快搞到购房资格，然后买房。\n当时我手上大概有30多万可移动资金，不过这点钱在房子面前其实是不够看的，好在购房资格还没办下来，我还有时间。\n对我来说，买房的需求大致就两个：第一，保值，有升值的空间；第二，如果需要，我可以直接入住。\n思来想去，最后把目标城市定在长沙，因为我本身就是湖南人，长沙也是一个处于中游的新一线城市，发展潜力不少。\n不过长沙比较烦人的一点就是，需要在当地交两年的社保才能拿到购房资格，从2020年到2022年，也就是今年正好两年。\n今年春节的时候，趁着我有时间在老家，于是赶紧联系了一位长沙的房屋中介带我去看房，看房之前我自己也做了些攻略，主要计划看梅溪湖二期、洋湖、麓谷这个几个片区。\n\n先说说梅溪湖二期，熟悉长沙的朋友应该都知道，梅溪湖算是长沙的一张名片，不管是环境、基础设施建设，还是教育，在长沙都是首屈一指的，房价当然飙升的也极快，从刚开始规划建设到现在房价已经翻了好几倍了。不过上面所有这些介绍都仅限于梅溪湖一期，梅溪湖二期到目前为止，它还是一张没有兑现的大饼，由于政府把梅一打造成了长沙之光，梅二自然也是万众瞩目，我第一站去看的就是梅二的房子，别问我为什么不买梅一，因为梅一没有新房了，梅二目前也只有碧桂园博萃梅溪这个小区在卖。\n到了梅二之后，我才知道为什么买房一定要自己实地来考察一下，虽然网上传的很好，但是到了梅二之后我才发现原来这边一片荒凉，小区对面就是还没开发的荒地，到了售楼部，置业顾问非常卖力的跟我介绍梅一的辉煌以及政府对梅二的规划，总结一句话就是：梅二一定会比梅一更牛逼。但是我出门看了看对面的荒地，又上网查了一下碧桂园这家公司，发现差评不少，想了想还是放弃梅二了，这张大饼我有点害怕。\n然后是洋湖，洋湖板块的定位是生态新城，其中有6000亩洋湖湿地，环境特别好，感觉去那边空气都要新鲜一些，官方是这样介绍的：\n以6000亩洋湖湿地为核心，总部经济为支撑，生态宜居为引擎，文化创意为动力，定位为功能复合的总部经济基地、城市中心的湿地公园、生态宜居的活力新城，是全国人居环境范例和智慧城市试点区。\n去看了两个小区，都是学区房，小学初中配套就读的学校就在小区旁边，而且是四大名校附属中学，小区环境也挺好，但是就是离商场和地铁口有一点距离。\n再来说说麓谷，长沙称麓谷叫麓谷科技新城，很多科技公司都规划在麓谷这边，像腾讯和华为在麓谷这边都有分公司，深信服、CSDN也都在这边，这边也看了两个小区，最后我把房子定在了麓谷这边，准确是说是在梅溪湖一期和麓谷交接的地方，小区的名字就不说了免得有打广告的嫌疑，说一下我选择的理由：\n\n小区附近有商场和地铁，对面就是河西最大的商场「步步高梅溪湖新天地」，旁边的地铁可以直通长沙西高铁站和黄花机场，交通很方便；\n长沙的互联网公司基本都在这边，因为我本身学计算机的，所以这个对我还是很有吸引力的；\n精装交付，所有房间都带地暖、中央空调和新风系统，之前看的那几个小区都不带地暖，因为我在东北待惯了，冬天还是习惯有暖气的房间；\n小孩初中配套就读四大名校之一的长郡麓谷中学，不用微机派位。\n\n当然缺点也有，小区傍边有一条高架，靠近高架的房子可能会有噪音，不过我选的房子不在那附近，而且是小高层，得房率高，阳台视野也不错。\n最后就是关于首付和房贷的问题了，其实到今年我手上的钱差不多可以支撑我全款买房了，不过今年开年以来市场行情不是很好，到处都是裁员和破产的消息，我在股市也亏了不少钱，可以贷款的话，就没有必要全款买房了，所以还是按30%+混合贷的方式。\n本来有想过把商贷部分还清，只留下低息公积金贷款，这样等我毕业之后，单位的公积金抵扣房贷，相当于也不用还房贷了。不过后来我想了一下，多数业主的房子在居住六七年之后，大概率会换第二套房子，也就是说商业贷款的利息你其实只还了六七年左右，这点利息远没有你算的30年那么高，而且自己手上还多了一笔流动资金，还是很香的（这只是我个人的想法，不具备参考价值）。\n买房对于每一个家庭来说应该都算是一件不少的事情，当我自己在售楼部交首付签合同的那一刻，我还是挺骄傲和自豪的，我终于要有自己的房子了，靠自己的双手赚来的房子。\n不过骄傲和自豪也仅限那一刻，人生还有很多的难题需要去攻克，这只是第一关的小boss，将来还要面对毕业、找工作、结婚、生小孩、孩子教育……\n啊，救命~\n","categories":["技术以外"],"tags":[]},{"title":"为什么大厂们一边裁员，一边招人。。","url":"https://tanqingbo.cn/Layoffs-and-Hiring/","content":"今天分享一篇来自于知乎的文章，为什么分享这一篇，是因为它解决了我，包括我身边很多人的一个疑惑：\n为什么大厂们一边在疯狂裁员，一边又在大量招人？\n今年是特别魔幻的一年，一方面不断传出各个大厂大规模裁员的新闻，另一方面又可以看到某某大厂给应届生开出四五十万乃至更高的Offer消息。\n很多问题，或许就像文中说的那样：都是在赌。\n\n作者：东岳老师\nhttps://www.zhihu.com/people/tian-tian-quan-75-47\n真实在大厂工作过，十几年的互联网老兵告诉你事实。\n大厂里面有很多的业务线，也有很多的部门，每个部门负责的都不一样，阿里不是只做淘宝，腾讯也不是只做微信，一个大厂有数百条业务线，有的赚钱，有的赔钱。但是通常赔钱的最多。\n通常大厂是这样玩的:\n上层领导看中了一个方向，比如说游戏是赚钱的，于是就大量开始招聘游戏岗位。\n公司往这方面投钱，比如说一年投入1000万，然后制定一个目标，实现三年盈利。通过招聘，你顺利进入了他们的游戏业务线，成为大厂员工。\n光环加顶，有些刚进入大厂的员工觉以为祖坟冒青烟了，但也可能冒黑烟。\n因为公司业务线刚开辟，所以就大量招人，高层来赌这个业务三年后一定盈利。把人力，金钱，物力投入进去。至于高层哪来的那么大自信赌成功，说真的，他们也都是懵逼状态。\n高层之间也内卷，总裁副总裁一大批，负责的业务都不同。\n我在某厂做总监时，经常跟一些总裁开会讨论方案，他们真的啥也不懂。因为这群人年龄太大了，很多都是投资人，根本不懂互联网，都是瞎指挥。\n懂互联网的也是极个别人，总裁眼里只有钱。其他都没有。各种不着调的想法每次和他们开完会恨不能摔门而去。\n但你还得执行他们不靠谱的想法，谁让咱们是打工人。就算方案是屎也得给老板做出臭豆腐的口感。实现不了怎么办，假装很努力的加班啊，得让老板看到咱很努力的干啊。\n高层画大饼不要紧，咱也得吃饭啊。\n高层天天开会，传达给中层的就TM一句话，今年我们要实现十个亿的目标!\n卧槽，毛线都没有呢，那怎么办，上有政策下有对策，中层也有办法，你们知道中层每天都在干什么吗，天天写PPT!天天给高层做实现十个亿目标的汇报，一次一次被打回重改，直到改到高层认为PPT可以真的能实现十个亿目标位置。\nPPT是个好东西，不仅能造车，还能造梦!\n很遗憾的是，高层和中层一本正经的搞了PPT很长时间，大家一致认为从PPT上面已经证明能够实现十个亿的目标。\n但多数业务实际根本不可能像预想的那样盈利，PPT终究是PPT，当不能盈利时，这条业务线就会被砍掉，你经常发现大厂裁员是整条业务线从上到下全部被裁掉就是这个问题。\n老板层总是有各种想法，每年都要想我要做什么，总之都是为了赚钱。\n有的老板都是拍脑门，反正人家有钱，玩得起。瞎折腾怕什么，万一折腾成功了呢。就像有个人说的那样，梦想总是有的，万一实现了呢。\n把钱往里面一投资，找一堆写手，做几篇新闻，搞几个概念，开始忽悠了。全都给我上，产品，技术，运营，招起来!上层要干什么事情呢，上层要拿着PPT去资本市场忽悠钱。\n有一次和某个总裁喝酒，无意之间他说了一句话，我们不这样的话，股票就会跌的，我们只有这样做股票才能涨。\n我忽然恍然大悟，其实他们根本不是做互联网的，他们就是一群在股市圈钱的人。是的，只要折腾起来，股民才会不断的被割韭菜。原来赔掉的钱可以通过股市赚回来!资本市场才是真正赚钱的地方。\n互联网从诞生开始，就是靠资本一轮一轮融资的吹起来的，互联网公司本质就是投资公司，而高层就是投资人，靠着一个一个的故事融钱，用钱赚钱，而至于这个业务，他们并不关心能不能做成。他们只关心手里的股票能不能升值。\n但是问题是，你不可能所有开辟的业务线都赔钱吧，股东也不是傻子啊，靠股市画大饼早晚会被做空。所以他们总得有点赚钱的业务啊。\n十条业务线九条可能都赔钱，但有一条业务线赚钱就成功。公司高层都是赌徒心理，因为他们也没办法判断哪个业务能成功。多生几个孩子，总有一个孩子能成器吧。\n不成器的孩子怎么办，放弃吧。然后继续生孩子，继续招人。大厂靠着自己的招牌不用担心招不到人，反正人人都想进大厂。\n就算全都裁掉，照样能够招到。就算赔掉一个亿对大厂来说只不过是交学费而已。毕竟人家赚一个亿也就是小目标。\n那问题在于，为什么他们不用原有的团队做呢，因为原有团队在高层看来就是败军之将，给你三年时间都没搞成你在高层眼里已经没有价值，不裁你才怪呢。老板看你不顺眼，他们眼中只有一个单词：loser!\n这类新闻屡见不鲜:\n字节跳动方面，本地生活和房产业务受到影响。去年10月，字节跳动本地生活被曝出从22个城市撤退，仅保留了北京、上海等几个城市。\n字节跳动HR相关负责人回应媒体称，裁员信息属实，系公司正常业务调整。\n大部分的公司都是公司业务正常调整，简单来说就是，这孩子不成器，赶出家门。\n那你说，我这条业务线搞成了，那总不会被裁吧。\n呵呵，你想的天真了，一条业务线搞成了照样裁掉一半，这叫组织人员优化，本身做这条业务线就需要大量人参与进来，就像你建一座桥，建设时候需要几千人，建完了只需要几十人维护就可以了。\n那你说，我只要努力就不会被裁吧，呵呵，裁掉你和你努力不努力无关系，什么末尾淘汰制只不过是裁你的理由，制定一个规则，让员工内卷，因为员工内卷对企业最有好处。\n只有裁员，才能让员工感到危机。\n你虽然花费了大量时间精力，什么996啊，公司是不会看在眼里的，公司只看你成本太高了。\n三十五岁为什么会被裁，你知道，你在一家公司干十年你的薪资得有多高，不给你加薪资你不满意，给你加薪资老板不满意，反正有的是人干活，这么高薪资不需要你了，就裁掉了。\n与你能力无关系。只和你成本有关系。\n在大厂的业务线，中层压力最大，因为裁员先把中层干掉。中层在公司的定位就是背锅的，中层一般都是总监或者级别副总裁级，负责承上启下，只要业务快玩完了，为了给公司交代，稳定军心，高层首先要把中层拿来祭旗了。\n中层天天要逼着底层加班，也并不是真的很忙，因为他要做给高层看，让高层觉得他很努力，一定能成功。但是中层消息也很灵敏，见势不妙，没等裁员就脚底抹油提前跑路了。\n跑之前中层这群老油条们还得给底层没有经验的职场小白PUA，兄弟们，挺住，困难只是暂时的。只要团结一心，一定可以的！\n你会说中层难道不想要补偿吗？呵呵，你太小看中层了，在业务没有倒闭前另谋其主，还TM能吹牛皮一把说这业务做的很成功。\n你看，离开我就倒闭了吧。真要耗到业务干倒闭了拿那个裁员补偿，对他们来说找工作都不好找。中层早就提前谋划好了出路，重要的人该走的都走光了。\n多说句中层的话题，中层之间也经常在一起喝酒，不同的业务线之间也会互相交流经验，我参加过很多聚餐，喝酒前大家牛皮吹一波，我们做的是十个亿的大项目，这算什么，我们做的是一百亿的大项目。\n你们说的都不是什么，我们定下目标一千亿。酒过三巡，真情流露，大家互相安慰，兄弟，早撤吧，我看透了，这活没希望。\n等你有一天做了中层，就知道中层才是互联网公司最苦逼的，上面领导骂你，底下员工骂你，回家老婆骂你，辞职不敢，没有一边讨好。多少底层想要往上爬到中层，等你爬上去，就知道这哪是人生巅峰，是TM火山口!\n上也上不去，下也下不来。每件事处理起来都是贼烫手。做中层久了就知道，有些事不能硬撑，关键时候跑路才是上上策，孙子兵法得作为案头书天天阅读，不然你怎么在这么复杂的环境中生存下去。\n这就是你看到的类似新闻:\n某某大厂某事业部负责人离职，加入某某公司。\n但你看到这种消息后一般还不到裁员时候，因为裁员需要一个过程。\n三个月后，轮到HR上场了，HR会在一夜之间发个通告，因某某原因，公司无法经营，宣布裁员，底层员工被打的措手不及!\n前一天还在加班到凌晨十二点，这时候你忽然看到HR也在加班，你心里想，嗯，公司又开始招人了。\n公司肯定发展越来越好了。其实人家加班是制定裁员名单呢，今天一上班就被告知裁员。没等你反应过来，整个部门都没有了。\nHR才是互联网公司效率最高的职位!昨天，还许诺你加薪，今天你一脸懵逼的发呆，看着同事一个一个打包离开。\nHR就告诉你一句话，今天必须走。按劳动合同，给你n+1补偿。其实发布裁员公告之前，所有准备都已经提前三个月准备好了。连给你n+1的钱都准备好了。\n有的大厂裁员也很有情怀，临走还发给职场小白一个毕业证，同学!恭喜你在某厂顺利毕业了!\n呵呵，有的应届生刚入职第一天就毕业了，这速度真TM的快啊!给我的50万年薪呢？这么快就没了?咱好歹号称是大厂啊，别这样糊弄人行不？\n这时候你看到的新闻就是:\n某厂内部员工在某APP传闻裁员，整个事业部都被裁撤，未经官方证实。\n于是一轮从招聘到裁员的过程就结束了，宣布一条不靠谱的业务线彻底消失，老板的大饼没有画成。\n从项目立项，到招人，到投资扩建，到疯狂炒概念，再到负责人离职，内部传出裁员，公司证实属实。\n众位朋友，等你经历互联网十年你就知道这种招聘裁员戏天天上演。只是大部分都没有爆出来而已。因为很多业务线都不起眼，还没有人知道就已经消亡了。\n然后公司继续开辟新业务线，继续靠着大厂这个招牌白嫖打工者的青春，反正你不来是有别人来，我反正是给钱的，你不做还有别人做。真招不到人就开始画大饼，给应届生开高薪。\n一毕业就来个年薪五十万，卧槽，我这工作十几年的都没一个应届生薪资高，你招他来做什么？\n后来我明白，很多人都是凑数的。裁员的时候容易点。要招我这种老油条，连签合同我都得看三遍，敢裁我，分分钟给你讲劳动法。别TM忽悠我，罗翔的刑法讲义我天天看。\n应届生就容易多了，签合同都不看一眼，裁你时候给你一个绩效不合格，他们还觉得自己没有尽全力，对不起公司。也不用n+1补偿，因为连n都没有。看起来薪资那么高，其实用工成本真的很廉价。很多都是做给外界看的。\n其实很多人，不过是陪着高层赌未来，高层赌不对没关系，可以继续赌，毕竟人家不会担心自己被裁掉。本身高层眼里也没有员工，只有利益，员工自己堵不对，只能被裁了。\n老板赌上的是钱，员工陪赌的是未来。老板赌输了钱，大不了再赌一把，员工赌没了未来，就真的啥也没有了。有的员工连命都赔赌进去了。\n所谓某些互联网大厂，也不过是披着一层炫酷的外衣，进去也是996的工作。因为你得陪着老板赌这种不靠谱的未来。\n只是，你人生需要做的是淡定！看庭前花开花落，云卷云舒，莫纠结！很多事情，对打工人来说都很无奈，最后苦的还是打工人。\n你方唱罢我登场，今天他被裁，明天你被裁，也只是打工人的命运。与你能力高低真没关系。如果有关系，那你不过是个背锅侠而已。裁你，也只是杀鸡给猴看。\n领导说，我们给社会每年输送一千人才。呵呵，确实是这样，陪你玩几年，你赚的盆满钵满，我们成了人才。两全其美，何乐不为呢。\n我TM混了互联网十五年不是做人才就是走在做人才的路上!\n青春就那么几年，你从小到大都是很优秀，拿着985的学历拼进大厂，恋爱都不敢谈，每天996的为公司奋斗，养着房东，养着这个城市，养着身体几十万亿的细胞。\n不到三十岁的小伙子头发秃顶，肾虚无力，腰间盘突出，赌上了自己一切，用自己拼搏卷走了无数人，梦想有一天出人头地，你做好了最优秀的自己，无一刻休息，只为了明天更好，最后结局被裁了。最后如梦初醒，才知道自己是小丑。\n真实，上面的话都不敢说，我敢说只因为我不在大厂干了，也不想再进去。就算封杀我也无所谓。我坚决反对拿员工前途做赌注的公司!\n我要说这些话，也希望企业裁员慎重考虑!同时也希望企业不要盲目的招聘，因为真的很多同学因为你们的招聘赌上了未来。我不怕得罪那么多的大厂，我只希望彼此都真诚些，大家都是为了更好的未来。\n我没有针对任何大厂，我只说一种现象，希望我写这些不会被封掉。\n人生苦短，善待自己!\n","categories":["技术以外"],"tags":[]},{"title":"终于，月入两万！！","url":"https://tanqingbo.cn/Monthly-income-2W/","content":"有一些比较卷的小伙伴，毕业时能斩获不少offer,往往会纠结去互联网还是去研究所。\n最近逛知乎的时候，看到有位老哥分享了他在西安某研究所工作的体验和心得，特地分享给大家。\n希望可以给有同样纠结的小伙伴有个参考的意义。\n\n\n作者：易贝贝\nhttps://www.zhihu.com/question/64371326/answer/2251105460\n\n北航博士，2019 年 7 月毕业，入职西安某所。\n先发个收入截图吧。\n\n首先声明我这个收入是要低于跟我同年上大学，2014年硕士入所的同学的，我比较熟的技术部门的同学收入加公积金在30左右了，不是很多人想的博士才这么点硕士更少了。我要达到这个数字估计还得两年左右。\n有人说说博士才这点钱，对于不了解行情的，我只能回答：能赚很多钱是世人对博士最大的误解；对于秀优越的，你先看看自己是不是下面两种情况里的反面典型。对于我来说，可能因为是穷苦人家的孩子，从小没见过啥钱，所以觉得这个收入还可以。\n还有一些学弟也是博士纠结待遇问题，问我收入问什么这么少，我这里有点心得跟你们分享下，不一定全对。\n首先我司名声在外，确实不愁招不到人，所以没有安家费，博士也没有什么特殊的照顾，就按正常的工资体系发钱。\n有些单位会给博士安家费，为什么给安家费你可以琢磨一下，据我所知北京的几个大总体基本都没有安家费，或者有跟没有一样。\n有些单位会拔高薪酬给你，这样一方面是可能不能持续，比如给你三五年，另一方面造成新老员工工资倒挂，引起内部矛盾，工程领域是很需要师徒传承的，一个新人一来单位就因为待遇问题被敌视，你可以想象一下。\n而且客观讲，我们总体单位不会因为一个博士来了就会有什么大的技术提升，你来了也是学习。我有时候觉得单位不嫌我年龄大肝不动肯收留我就该知足了。\n对于找工作尤其是体制内的的博士，如果一个单位承诺给你很多钱，可能是：\n\n1、这个单位真的很有钱，大家收入都很高;\n2、你确实能给单位做别人做不了的贡献，单位很需要你。\n\n如果不是这两点，你就要考虑是不是坑了。\n虽然国企的钱不是人力自己家的，但是人力想要超出工资体系地给你报酬其实是件挺不好办的事，这事在国企可能比私企难度大得多，如果他能正常的招到他想要招的优秀的博士，他干嘛要给自己找事，还容易引起矛盾，为了让你谢他吗？\n对于私企逻辑更简单，企业逻辑跟风投一样，他给你一块钱钱，你创造10块钱100块钱的价值（此价值不一定是马上看到的经济利益），你创造不了开了你就是了。\n心得分享完毕，继续正题。\n周围房价不到两万，两公里外华润盖在西安ccbd万象城旁边的大平层不到两万五，地段参考北京国贸旁边的新城国际。\n当年在一院面试，人力跟我说你找个航天的女朋友，两个人攒五年可以不靠家里在北京买房。我们这边附近各方面还可以的房子（100平左右，南北通透，小区还可以），差不多200w，我周围的年轻人基本入职两年也都买房了，毕竟五六十万的首付自己攒一点家里凑一点还是容易很多。\n我觉得吧，衡量一个工作好坏，不同的人有不同的衡量标准，我本来想说钱肯定是最重要的但不是唯一的，后来觉得可能对有些人来说钱都不是最重要的。\n与我而言，收入，稳定性，是不是喜欢，有没有意义，我能不能胜任，累不累，地方在哪离家近不近…都是需要考虑的问题。\n我觉得研究所真正的吸引力在于这么几点：\n1、最重要的，你做的事是对国家对民族对社会对自己有意义的事\n你不只为了谋生而单纯的在给资本家打工，不是在帮资本家割韭菜，更不是在帮外国的资本割中国人的韭菜，你是在为中华民族的伟大复兴做贡献，这里怕得罪人被喷，我不展开说了。\n我没有在开玩笑，我现在的工作是综合考虑家庭（我是西安土著），收入，专业，稳定等各个方面的最优解。\n但是我司做的东西没有航母，核潜艇，歼20，运20，远轰，战略导弹，反舰弹道导弹，高超声速巡航武器，载人航天那么牛逼闪闪，我有时候跟同学师兄弟们聊天的时候想想人家做的东西，是有些遗憾的，虽然这些单位性价比甚至绝对收入都不如我们。\n2、稳定，我工作了一个月就明白了一个道理\n其实很多企业能给人那么多钱，是因为没有很大的负担，可以给拼命干活的年轻人很多钱，可是，谁又能一直拼命下去呢，谁又能保证自己一定可以上得去呢，升职这种事不光要自己努力，也要机遇的，所以很多看似目前收入很高的工作，其实是把未来很多年的钱，拿出一小部分现在给你，让你拼命干活。\n换言之，我们现在的收入一般，其实是把一部分该给年轻人拼命的钱给了肝不动的同志，我觉得这也没啥，毕竟现在单位的基业也是他们肝出来的。\n我一直觉得一个理论挺对的，从体制内出去，收入翻翻是至少的，要不然想都别想。不用担心公司倒闭，不用担心自己被优化，也就少了很多勾心斗角，安心干自己工作就好，这种感觉也是可以折现的。\n所以我很同意别的答主说的航天适合家境小康的人，毕竟在年轻人尤其是男人最缺钱的25-35岁，系统内可能同样需要拼命但是不给你那么多钱。\n这个时候如果家里能给一笔启动资金或者全款买房，生活就不会捉襟见肘。就我个人而言，我家在西安算小康，在北京是赤贫。\n所以在西安的研究所我觉得自己收入还可以。我面完载人航天总体部搜了一下周围小1000万的房子，想了想月供三万的日子，我觉得我的家庭承载不了这样的理想。\n","categories":["技术以外"],"tags":[]},{"title":"滴滴程序员被亲戚鄙视：年薪八十万还不如二本教书的...","url":"https://tanqingbo.cn/滴滴程序员被亲戚鄙视：年薪八十万还不如二本教书的/","content":"最近在知乎看到这个话题：年薪80万还不如二本教书的，说实话看完还挺感触的：\n\n\n\n因为我本人就是在读博士，也有很多朋友在互联网大厂上班，对目前高校和互联网的待遇也算是有一定的了解，简单和大家聊聊我的看法吧：\n首先高校老师的待遇并没有大家想象的那么好，这位程序员的亲戚对老师的看法估计还停留在二三十年前，老一辈的高校老师确实是有很多隐形福利，比如说集资房、附属中学、退休工资也高、而且时间自由、大把假期，真的是美滋滋。\n但是新一代的高校老师就没有这么爽了，目前的高校早就人满为患了，很多学院的教授职位就一个名额、退一个上一个，上百个副教授等着抢，还有上百个讲师等着挤进副教授的队伍，大多数人副教授就到头了。\n你可能会说至少清闲、可以混日子混到退休，那也未必，学校的科研任务不会放过你，发不出paper就得转岗，教授转副教授、副教授转图书馆管理员的例子不在少数，讲师更惨，三年一评、非升即走。\n但从社会地位和体面程度来看，从亲戚的态度来看，其实已经很显而易见了，在老一辈看来，就算你年薪80万，但是仍然只不过是一个大城市的打工仔，工作压力大、稳定性差，老师就不一样了，未来是有可能成为大教授的。\n而且老师作为传道授业解惑的先生，无论什么时候都值得我们去感恩和尊敬。就算你年入千万，但是作为孩子的家长，面对老师，你也得毕恭毕敬、客客气气的。\n从个人自由程度来看，目前程序员，尤其是一线大厂的高薪程序员，基本上都是朝九晚十，下班回到家基本都是十点之后了，而且八十万年薪很有可能是基层领导，可能30岁左右了，周末还得经常加班，虽然是赚的多，但基本上没有个人生活。\n所以啊，在我看来，没有什么躺平的职业，各有各的难、也各有各的好，奋斗是永恒的主题、想清楚自己想要什么就好了，被误解或者鄙视了，于其辩解、委屈，不如回一句：“叔叔阿姨过年好！”毕竟日子是自己的。\n","categories":["技术以外"],"tags":[]},{"title":"推荐10个堪称神器的网站","url":"https://tanqingbo.cn/6-website/","content":"有哪些网站，你一旦知道就离不开了？\n今天分享6个我亲测过的网站，我敢保证都是神器中的战斗机，点赞收藏起来，偷偷变强！\n不管你是学生党还是已经工作多年，都一定可以帮助到你！\n1、 IData-知识检索大学生涯中大家经常回需要从知网上下载各种文献资料，但如果不在学校或者学校没有购买知网权限，我们就需要一个新的文献下载工具——IData。\n如果需要查询相关文献，可以在IData网站中直接检索；只需要1块钱就可以无限次的下载论文，对于学生来说非常实惠啦！\n链接：https://www.cn-ki.net/\n\n2、 搞定设计作为一个学生党，大家平时作课程设计、创业比赛、路演答辩等等……总需要各种各样的海报、PPT、配图等等，“搞定设计”这个网站就为大家免费提供了很多漂亮又丰富的平面设计素材和模板，能够非常好的满足大家的设计需求！\n链接：https://www.gaoding.com/\n\n3、 大学生资源网是一个功能超级强大的在线视频网站，里面不仅有从考研到大学到小学的免费课程，还有关于电脑网络、医学视频、历史地理等全面的知识，非常适合在校大学生。\n包括资格考试的视频也有：工程建筑、考试认证、财会考试、公务员考试、司法考试。\n这都是花钱都买不到的财富！\n链接：http://www.http://dxzy163.com/\n\n4、 虫部落很多同学可能已经很熟悉虫部落了，它是一个整合了几十个搜索引擎的搜索引擎网站，在这一个网站上，你不仅可以搜索电子书和表情包，还可以搜索知乎、bing、微信推送、电影等等等等……从此告别多个搜索框来回切换，一个虫部落就可以搞定！\n链接：https://search.chongbuluo.com/\n\n5、 叮当设计这是一个PPT模板、PS素材等平面设计资源下载网站，而且比较重要的一点是，所有资源都是免费的，不是一部分免费，一部分收费。是绝对的全部免费，是不是非常良心呢？赶快收藏起来，以防不时之需！\n链接：https://www.dingdangsheji.com/\n\n6、 纳米学习导航这是一个学习导航网站，它收集了100多个学习网站的链接，内容包括了英语、面试题、考研、托福、考公务员等各个领域，mark一个相当于收藏了100多个！\n链接: http://1nami.com/\n\nok，这就是今天的分享，记得mark下来，提升自己从来不嫌晚，更多干货，我们下期再说。\n","categories":["工具"],"tags":["网站","工具"]},{"title":"26 岁 了","url":"https://tanqingbo.cn/2 6 岁 了/","content":"今天是2021年的最后一天，\n也是我农历26岁的生日。\n\n26岁，我应该要参加工作了。\n然而我还在为博士毕业而发愁。\n26岁，见到亲戚朋友，他们不再问你考试的分数更多问的是：准备在哪买房？结婚了吗？\n26岁，和朋友聊天的话题从网络游戏、娱乐八卦\n变成了房价、副业、基金、搞钱\n26岁，我应该有自己的事业，因努力而安心\n然后我却经常焦虑到掉头发，甚至失眠\n26岁，我变得精打细算，花钱不再大手大脚\n我开始规划手上的存款，该买哪里的房子和什么样的车子\n26岁，我不再谈梦想，不会再轻易流泪\n更不会因为一点挫折就放弃自己的坚持\n26岁，我没有了年少的轻狂、把遇到的所有挫折困难都当作一种人生的阅历，\n试着去包容去忍耐，学着去敬畏。\n26岁，26年过去了，真快啊！\n还是要继续努力，提升自己，创造价值！\n许个愿望：希望自己的内心变得更强大一点、能够接受更多、放下更多，顺便再多交几个真心的朋友！\n也祝大家新年快乐、元旦快乐！\n","categories":["技术以外"],"tags":[]},{"title":"被拉黑了。。。","url":"https://tanqingbo.cn/被拉黑了。。。/","content":"经常有朋友在微信上面问我要学习资源，一般他求的那个电子书或者资料我有的话，我都会分享给他，但有时候也会遇到不爽的情况，比如下面这种：\n\n这哥们，问我要电子书，可是信息发出来还不到半小时就把我拉黑了，等我看到消息准备回复他的时候，就只能看到一个红色叹号了。\n真的，不知道大家有没有这种感觉，本来好心要帮他，可是回消息的时候发现已经不是好友了，就那一瞬间，一整天的好心情都没有了。\n没有及时响应，就立刻删好友，这种情绪不太稳定的人，我真的不太喜欢。其实我也想第一时间回复大家微信上的消息，但是我也有自己繁忙的工作，而且我微信上有近2万多好友，每天光收到的消息就上千条，很难做到立刻响应，所以我一般都是选择睡觉之前统一处理微信上的消息。\n不过好在像今天这种事情算是小概率事件，写公众号这么久，多数情况下我收到的消息是这样的：\n\n看到这些鼓励和肯定的话，瞬间又充满动力了，甚至可以说，正是因为有大家的鼓励，我才可以坚持输出三年之久。\n好了，不开心的事情吐槽完了，下面给大家分享几个我在微信上经常会被问道的几个问题吧：\nQ：学历对程序员重不重要？\nA：\n这个要分情况来回答，如果你毕业之后是想要去事业单位、银行、研究所等，那么学历对你很重要，研究生的优势肯定要大于本科生、博士的优势肯定大于研究生、而且学校越牛逼越好。比如说研究所，至少得是211及以上学校得研究生才有机会进去，如果你是本科生，肯定没有指望。而且像上面提到得那几个单位，不同得学历进去，薪资待遇也是不一样的。\n但是如果你是想去互联网大厂，学历的优势就没有那么明显了，不管你是本科生还是研究生，只要是技术水平到了，都有机会进去，一个本科生和一个研究生如果他们的技术水平差不多的话，他们的薪资待遇也不会有太大的差别。\n所以主要还是看你想去什么单位，不过我还是建议想去互联网大厂的朋友也读个研究生，因为对于大多数的本科生来说，他们毕业的时候达不到大厂的技术水平。\nQ：怎样才能变得自律？\nA：\n首先要明白一点，不管是自律，还是拖延，背后的本质都是习惯，好习惯持续让人进步，坏习惯则让人一步步堕落。我一直不太相信：失败是成功之母，我更相信的是：成功是成功之母。意思就是如果你在计划内达成了目标，那么下一次，你将会更有信心去完成你的目标，这相当于有了一个正向反馈，往复循环多次，你将会养成一个习惯，叫做习惯完成目标，想要养成这个习惯，其实也不难，你只需要做到两点：第一，不要定那种激动人心的大目标，而是要定那种，靠自己努努力就能达成的小目标，比如说背单词，你要定每天背50个单词，坚持一个月，而不是定那种一周背完一整本词汇书这种目标。再比如说健身，你要定的是那种一周去两三次健身房，而不是说我下周就要练出8块腹肌或者人鱼线。第二，既然你目标是合理的，可以达成的，那么每次你就一定要全力以赴的去达成你的目标。做到这两点，相信你一定能养成完成目标的习惯，成为一个超级自律的人。\nQ：大一新生，报了计算机专业，从未接触过计算机，觉得自己很菜该咋办？\nA：\n你要清楚的是，高中的学习和大学的学习不太一样，在高中的时候有家长和班主任追在屁股后面催你学习，条件好的家庭还可以请家教培养你各种兴趣爱好和编程能力，所以当你刚进入大学校园的时候，你感觉你不如人家牛逼的时候并不能代表你不行，可能只是代表你的家庭条件或者母校没有人家好，但能考到同一所学校，说明智商都是一样的。\n第二点就是，大学是一场马拉松，我见过很多同学入学的时候各种牛逼，当我还在努力弄清楚什么是编程的时候，他们已经能做一些小项目了，可是有一部分“大一时候的大佬”等到毕业的时候也没见到他们比入学的时候强多少，因为大学是一个开放的学习环境，再也没有人像高中班主任那样这么上心的催你学习了，全靠自己的自制能力，有的同学可能习惯被管着的学习方式，一旦没有人管了，就放弃治疗了，所以只要你的自制能力比较强的话，4年的时间，足够你追上任何一个大佬。\n还有就是编程实践能力真的很重要，在大学期间千万不要为了让自己的卷面成绩考的很漂亮而放弃了自己的动手能力，毕竟你以后去公司是要给公司带来效益的，而不是看你考试成绩打了多少分。\n今天就分享这么多了，大家有啥困惑，欢迎找厂长聊天，可能不会立刻回复，但看见了一定会解答！\n最后宣传一下我建的【晋级的程序员】社群，旨在帮助新手小白快速上手找到编程的乐趣，里面沉淀了大量编程相关经验教程以及学习资料，目前社群人数已经超过1500人，大家如果有需要的话可以加入：\n\n","categories":["技术以外"],"tags":[]},{"title":"卧槽，还有985大学在大一上C语言课？？","url":"https://tanqingbo.cn/卧槽，还有985大学在大一上C语言课？？/","content":"今天在知乎上看到这样一个问题：为什么现在部分985高校还是给大一上C语言课：\n\n这个题主是某985CS专业学生，发现学校居然给大一教C语言程序设计，而不是现在最流行的Java或者Python，不由得产生了疑问。\n没错，现在很多高校计算机专业的教学方法确实有些落后，但是作为一所985高校，大一的时候教学生C语言还真没有什么问题。\n首先，我们学的是 Computer Science，而不是 Programming Language，语言真的真的真的不是重点。985/211 这种国内最顶尖的一批高校，应该注重通识教育而不是专项教育，在专业上更要注重基础、底层、偏向原理。\n只有掌握了最核心的东西，学起那些偏技能的东西才会很快很轻松。\n而且相对于现在比较流行的Java和Python，虽然C/C++难度更大、门槛更高，但如果你真的深入去学习的话，优势也是蛮明显的。\n我觉得至少有以下几点优势：\n1、能帮你打好结实的编程基础\n不管你以后走什么样的技术路线，不管你用不用它做开发，一名熟悉C/C++的开发人员，假如他不是一个偏执狂的话，再学习Java或Python，都要容易得多。\n2、竞争小\n现在很多大学都主流教java,，因为java相对C简单，而且应用范围也蛮广的，但是java的效率不如C，正因为很多人觉得C很难所以就放弃了，也就造就了Java竞争力非常大，不少互联网大厂提前批第一天开放的时候，投递Java后端开发的应届生是最多的。\nC/C++竞争力小，而且真正的高级C++程序员很抢手的，可以说是，有钱都不一定招得到。\n3、工资高\nC/C++程序员平均工资普遍比其他语言高，当然是在同等技术情况下，不可能一个C/C++普通程序员和一个java的老鸟比。如果普通java程序员和普通C/C++程序员相比的话，基本上都是C/C++程序员工资高一些，而且C的上限比Java高太多了。\n当然每一门语言都有自己的特点，也不是说Java就不好，一门语言没有好坏，主要是看使用者如何使用了，如果能把一门语言研究透彻，无论是什么语言那也是前途无量的，但是就就业的话，如果你是科班生，C是一个不错的选择，说实话，Java竞争力太大了，可以去各大招聘平台去看一下，对比一下C就会发现，往往很多工资很高的岗位，没有C++程序员去，但是Java岗，一个岗位去应聘的人非常多。\n还是那句话，语言没有好坏，只是看使用者能把一门语言发挥到什么程度，我这边也顺便给大家分享点C/C++的学习资料吧，希望对大家有用：\n1、《C语言小白变怪兽》\n既适合对计算机一窍不通的小白也适合有编程基础的读者，还可以用来进阶。这本书的作者还在不断地更新这本书，学起来通俗易懂，深入浅出，只要认真看就一定能看懂，这是C语言入门的首选教材。\n\n链接：https://pan.baidu.com/s/1GJcFGcBCivjFyEv5riZgTA\n提取码：w4tl\n\n2、《C Primer Plus》\n畅销30余年的C语言入门经典书籍，至今无人能撼动它的地位，最符合C语言标准的书籍，作为一名C语言程序员不收藏一本都觉得自己很水。\n\n链接：https://pan.baidu.com/s/1cOt06KTKD54bMZ__IdGADw\n提取码：98gd\n\n3、《C和指针》\n这本书的特点是在指针上花了大功夫，指针绝对是C语言的精髓，理解了就等同于攻克了最难的部分。\n除了头尾两章，指针贯穿全书，并用了大量通俗易懂的例子来讲解，正是指针使得C语言如此之强大，所以要学习C语言的精髓，就是要精通指针。\n\n链接：https://pan.baidu.com/s/1pLjXjntwAGiJjjDDeOMGIQ\n提取码：3mjt\n\n4、《C专家编程》\n这本书适合已经具备C语言基础想进阶的读者。这是一本吐槽C语言的书，基本上介绍了大多数C语言的坑，有不少精髓，在C语言界久负盛名，进阶时一定要看。\n\n链接：https://pan.baidu.com/s/17e0bLmau1q90kDyW1Szn6Q\n提取码：4097\n\n把以上4本书学透，C语言基本上就差不多了，最后强调一下：不管学习哪门语言，实践都是在第一位，因为最终我们都是要上手写代码，解决具体问题的，所以大家在学习的过程中一定要多实践、多写代码。\nC语言很重要，不管你以后想从事什么方向，如果你想在程序员这条路上走的更远，C语言都是要重点掌握的！\n","categories":["编程经验"],"tags":[]},{"title":"选Java还是C++？","url":"https://tanqingbo.cn/选Java还是C++？/","content":"前两天有个读者遇到了这样一个问题：学校同时开了C++和Java两门课程，但是精力有限，到底是选择Java还是C++深入学习。\n\n其实不管你学哪一门语言，最终的目的都是为实际应用和找工作赚钱服务的。\n所以我先说一下这两门语言的应用场景以及市场的岗位情况吧！\n先说 C++这门语言主要是用来做一些底层开发以及在一些对于性能要求比较高的业务场景下使用。\nC++在找工作的过程中，能够投递的岗位主要有 Linux/C++后台开发、嵌入式开发、游戏研发、服务器开发、编译器研发等。\n它能干的活其实不少，很多人都在担心学了C++找不到工作。。。说实话，还没到那个地步，虽然比不上Java岗位多，但也绝对不少的。\n再说说Java不管你信不信，Java都是毫无争议的互联网第一语言。\n你看各种培训机构，Java培训广告满天飞。\n可以说我们现在能够尽情在互联网各种冲浪，Java这门绝对是语言居功至伟！！！\n就因为它能干的活实在是太多了！！！\n它可以做网站，可以搞Android开发，还有就是做一些软件开发，甚至现在很火的大数据开发用的也是Java。\n学了Java，能干的活确实很多，但是啊，相应的，它也是最卷的，不少互联网大厂提前批第一天开放的时候，投递Java后端开发的应届生是最多的。\n那么C++和Java到底选哪个？这两种语言：C++难学、难上手，但竞争小一些。\nJava好学一点，也比较容易上手学，但竞争大，内卷严重。\n你要问到底学哪个，其实就是鱼与熊掌的关系罢了。\n这个没有最优的选择，如果你是计算机科班出身，而且对C++有偏向性的话，那可以主要精力学习C++，\n因为C++可以帮你打下很结实的基本功，到时候如果你想要转学其它语言上手也会很快，\n但是如果你是非科班想转行的同学，那我建议还是学Java吧。\n因为它简单易上手，对于小白来说也比较友好，能找到的学习资料也比较多。\n","categories":["编程经验"],"tags":[]},{"title":"靠这几本算法书成功拿下大厂offer","url":"https://tanqingbo.cn/靠这几本算法书，成功拿下大厂offer！/","content":"在我还在上大学的时候，老师就跟我们反复强调算法的重要性，大多数的机构和顶尖大厂在面试的时候也会着重考察面试者的算法能力。\n所以对于程序员来说，手撕算法的能力一定要好好修炼。因此在这里我给大家整理了一份由易到难的算法学习书单，希望能对大家在学习算法和找工作的过程中有所帮助！\n1、《我的第一本算法书》这本书非常适合新手朋友们。里面没有枯燥的理论和复杂的公式，而是通过大量的步骤图帮助读者加深对数据结构和算法执行过程的理解，便于学习和记忆。将本书作为算法入门的第一步，是一个非常不错的选择。\n2、《趣学算法》本书从算法之美娓娓道来，没有高深的原理，也没有枯燥的公式，通过趣味故事引出算法问题，包含50多个实例及完美图解，结合学生提问，分析算法的本质，并给出代码实现的详细过程和运行结果。本书可作为程序员的学习用书，也适合从未有过编程经验但又对算法有强烈兴趣的初学者使用。\n3、《啊哈！算法》这本书是从以实际应用为出发点，通过幽默的语言配以可爱的插图来讲解算法。其中涉及的数据结构有栈、队列、链表、树、并查集、堆和图等；涉及的算法有排序、枚举、深度和广度优先搜索、图的遍历，当然还有图论中不可以缺少的四种最短路径算法、两种最小生成树算法、割点与割边算法、二分图的最大匹配算法等。\n4、《图解算法》这是一本像小说一样有趣的算法入门书，示例丰富，图文并茂，以让人容易理解的方式阐释了算法，旨在帮助程序员在日常项目中更好地发挥算法的能量。书中的前三章可以帮助你打下基础，余下的篇幅则主要介绍算的法广泛应用。\n5、《剑指offer》这本书大家一定如雷贯耳吧，基本上只要你是程序员就一定会用到这本书，书里面剖析了50个典型的程序员面试题，从基础知识、代码质量、解题思路、优化效率和综合能力五个方面系统整理了影响面试的5个要点，**是程序员找工作必备的一本算法书。\n6、《算法导论》这本书真的称得上是算法领域的“圣书”了，但是它适合有一定算法基础的人看，如果你真的把这本书里面的内容吃透了，那么恭喜你，年入百万不是梦！\n当然最好的算法学习方法还是要自己动手去实践，去刷题，书籍只能起到辅助的作用，下期我会给大家推荐几个程序员专门用来刷题的网站。\n以上推荐的这几本算法书大家可以根据自己的实际情况去阅读，只要你认真的去看了，然后动手实践了，进大厂肯定不是问题。\n","categories":["编程经验"],"tags":[]},{"title":"程序员必备的几个技能！看完你也是大神","url":"https://tanqingbo.cn/程序员必备的几个技能！看完你也是大神/","content":"如果你是程序员的话，\n肯定听过这样一段话：\n“只会写代码的是码农；\n学好数据库，基本能混口饭吃；\n在此基础上再学好操作系统和计算机网络，\n就能当一个不错的程序员。\n如果能再把组成原理、数据结构算法学通透，\n再加上丰富的实践经验，\n就能算是一个优秀的程序员工程师了。”\n也就是说，\n如果你想成为一名优秀的程序员，\n你至少需要学：\n数据库、操作系统、计算机网络、\n组成原理、算法等知识。\n📝下面按照这个顺序，\n依次给大家推荐一些教程和对应的学习书籍！\n1、数据库\n作为一个写代码的程序员，最终都是要处理数据，因此数据库算是必备的技能之一，如果是初学者的话，推荐《MySQL必知必会》这本书，更深入一点的话可以去看《MySQL技术内幕InnoDB存储引擎》。\n2、操作系统\n学习操作系统，推荐看《现代操作系统》这本书，国内很多高校的操作系统课都是采用的这根本书当教材，这本书最大的特点就是挑战了传统操作系统教材的权威，果断地删掉了和 “现代” 操作系统关系比较小的部分，真正把 “现代” 两个字体现得淋漓尽致。\n3、计算机网络原理\n计算机网络和计算机操作系统这两个“兄弟”是所有开发岗位都需要的，对于后端开发的同学来说，计算机网络的重要性不亚于语言基础，毕竟平时开发经常会和网络打交道，这里推荐《计算机网络自顶向下方法》这本书去学习，豆瓣评分接近满分，必看！\n4、组成原理\n无论是处于哪个阶段的同学，都需要了解计算机组成原理，推荐的书籍：《深入理解计算机系统》，学习这本书，你就会对计算机底层世界有一个宏观的认知，搞清楚计算机底层的工作原理，为什么它可以完成如此复杂的工作？最简单的“hello,word”程序是怎么运行的?\n5、数据结构与算法\n学会编程语言只能说明你会使用，但是想要用这门语言去处理具体的事情，那就需要学好算法，因为不管你是学习任何一门语言，都绕不过去算法这个门槛。企业招聘的时候也特别重视程序员的算法能力，\n这里推荐三本算法书供大家学习：《算法图解》、《算法导论》以及《剑指offer》，第一本适合入门，第二本适合进阶深入学习，第三本找工作必看。\n希望以上内容对你有帮助！\n","categories":["编程经验"],"tags":[]},{"title":"4种高效编程方法，帮你快速搞定编程！","url":"https://tanqingbo.cn/the-way-of-pragram/","content":"别人学的如鱼得水，可是我觉得编程好难？做到这4点，帮你快速搞定编程代码写不出来、程序越看越烦、编程真的好难啊，我是不是不适合这个专业？\n这可能是很多初学编程同学的心声。掌握着4种快速学习编程的方法，也许下一个计算机大神就是你。\n首先大家要明确一点，学习编程不是一个下午就能学会的事情，当我们在学习编程的时候，其实可以做很多事情来让自己学习变得更加容易、更加快速。\n首先，当你在阅读教材的时候一定要认真查看示例代码假如我是一个初学者，我第一次学习编程时候，通常我会先阅读代码示例，然后再看文字内容，确保看懂并理解每一个例子，理解这段代码所要做的工作，这样做可以有助于自己更深刻地理解这段代码的运行逻辑。\n第二、运行！修改！再运行 ！当我们阅读编程教程或者书籍时候，特别是初学者经常会遇到一种情况，就是看完示例代码之后就会觉得“这个我都明白了”。当然，有可能确实是你已经明白了，但是如果要求让你自己动手写一个出来，你可能就蒙圈了。\n因此强烈建议大家亲自去写一下运行一下！\n首先要将示例代码手动输入，记住一定要手动输入，不要只是复制和粘贴，因为通过手动输入代码，这个可以迫使我们注意到编程语言语法中的一些细节，比如每行代码后面是否都有分号，换行符是不是都正确。\n然后，编译和运行你刚刚输入的代码，看看是否有出错。\n最后，请试着修改你写的代码，从最简单的改变开始，比如修改输出的内容。多试几次你就会知道代码要怎么写了。\n第三、学会使用调试器一般编程语言的调试器都不复杂，试着先学习如何调试代码，这将对你理解和掌握这门编程语言有着很大的帮助。\n一开始的时候，可以先调试一些很简单的例子，比如这段C语言代码：\n你可以通过调试器看看当程序运行到第5行的时候，X的值是多少，然后接着看大括号里面y=5;这行代码有没有运行。\nint main(){\tint x;\tint Y;\tif (x&gt;4）//&lt;--这里x的值是多少？\t{\t\ty=5; //&lt;--这行代码执行了吗？\t}}\n\n有同学可能会问，为什么要学会使用调试器呢？因为调试器可以帮助我们快速的找到代码中BUG的精准位置。所以一定要熟练使用，因为我看到过很多人没有使用调试器，结果耗费了很多时间去寻找一些实际上显而易见的bug。\n第四、善于寻找学习资源现在的互联网这么发达，大家想要学习的任何技术都可以再网上找到对应的学习资源，所以大家在学习编程语言的同时，花些时间去网上了解下，看看有没有适合自己的网络教程，因为有时候你需要学习的技术学校并不一定教，或者只是很浅显的提了一下，这个时候就需要你自己去网上寻找对应的学习教程了。\n这边我也给大家推荐几个程序员经常逛的学习网站：\n1、B站\n这个网站最初是由游戏玩家带火起来的，但是里面也有特别多的程序员大佬入驻，你想要找的编程视频学习教程基本上都能在里面找到，而且都是免费的。\n2、CSDN\n这是一个专门为程序员提供的技术交流学习平台，以技术博客论坛为主，里面有超级多大牛博主入驻，各种技术帖子应有尽有，当然你也可以在CSDN上输出自己的技术博客文章，给有需要的人提供帮助。\n3、牛客网\n这个网站对找工作的同学来说价值非常大，里面能找到很多互联网大厂的面试经验帖子，各种知名的不知名的互联网公司的对应往年校招社招面试题库，可以刷到你手软，总而言之一句话：这是一个找工作必备的网站。\n4、GitHub\n这是一个开源的代码托管平台，上面托管了大量的优秀项目源码，你可以通过主题，榜单等方式在GitHub找到自己感兴趣的项目源码，通过多做一些项目，你就可以很快的提升自己的技术，从而进入到自己心仪的公司。\n此外，还有一个非常关键的资源，那就是我们身边的师兄师姐、前辈以及老师。如果遇到不懂的问题，且身边有这种资源的情况下，一定要去请教一下他们，这也是解决问题效率最高的一种方法。\n","categories":["编程经验"],"tags":["电子书下载"]},{"title":"如何做一个程序员而不是码农？","url":"https://tanqingbo.cn/be-a-programmer-instead-of-a-code-farmer/","content":"有句话怎么说来着：只会写代码的是码农；学好数据库，基本能混口饭吃；在此基础上再学好**操作系统和计算机网络**，就能当一个不错的程序员。\n如果能再把组成原理、数据结构/算法、编译原理学通透，再加上丰富的实践经验，就能算是一个优秀的程序员工程师了。\n所以如果你想学好计算机基础，成为一名优秀的程序员，你至少还需要学：数据库、操作系统、计算机网络、组成原理、数据结构与算法、编译原理等知识。\n下面按照这个顺序，依次给大家推荐一些比较经典的学习书籍和视频课程！\n1、数据库\n作为一个写代码的程序员，最终都是要处理数据，因此数据库算是必备的技能之一，如果是初学者的话，推荐《MySQL必知必会》这本书，更深入一点的话可以去看《MySQL技术内幕——InnoDB存储引擎》。这两本书的下载链接如下：\n\n链接：https://pan.baidu.com/s/1tFQznVIb4-kMNZYC6dJqvg\n提取码：rpob\n\n2、操作系统\n学习操作系统，推荐看《现代操作系统》这本书，国内很多高校的操作系统课都是采用的这根本书当教材，这本书最大的特点就是挑战了传统操作系统教材的权威，果断地删掉了和 “现代” 操作系统关系比较小的部分，真正把 “现代” 两个字体现得淋漓尽致。\n\n\n链接：https://pan.baidu.com/s/1vfpKtxoihNm0XfwbEo4mqg\n提取码：pkz3\n\n此外，可以结合哈工大李治军老师的操作系统课程一起看：\nB站连接：https://www.bilibili.com/video/BV1d4411v7u7\n\n3、计算机网络原理\n计算机网络和计算机操作系统这两个“兄弟”是所有开发岗位都需要的，不管你是 Java、C++还是测试。对于后端开发的同学来说，计算机网络的重要性不亚于语言基础，毕竟平时开发经常会和网络打交道，这里推荐《计算机网络自顶向下方法》这本书去学习！\n\n\n链接：https://pan.baidu.com/s/1SBIBusXfsSo1rZMdcdXVTg\n提取码：i6oh\n\n4、组成原理\n无论是处于哪个阶段的同学，都需要了结程序是什么、计算机的组成原理，推荐的书籍：《深入理解计算机系统》，学习这本书，你就会对计算机底层世界有一个宏观的认知，搞清楚计算机底层的工作原理，为什么它可以完成如此复杂的工作？为什么一个小小的cpu却又如此强大？最简单的“hello,word”程序是怎么运行的?当然，因为这本书包含很多概念，专业术语，读起来可能比较晦涩，大家也不必一口气读完，可以在学习整个计算机过程中慢慢去读，慢慢理解。\n\n\n链接：https://pan.baidu.com/s/1RoDN317X-C6izxY6CwuxTA\n提取码：iy8u\n\n5、数据结构与算法\n学会编程语言只能说明你会用这个语言，但是想要用这门语言去处理具体的事情，那就需要学好算法，因为不管你是Java编程爱好者、还是python的忠实粉丝，亦或觉得PHP才是这个世界最好的编程语言，都绕不过去算法这个门槛。企业招聘的时候也特别重视程序员的算法能力，这里推荐两本算法书供大家学习：《算法图解》与《算法导论》，第一本适合入门，第二本适合进阶深入学习。\n下载链接：\n\n链接：https://pan.baidu.com/s/1bDxJLci6kOy_iYsjcnHiWg\n提取码：sxi5\n\n6、编译原理\n计算机是只认识二进制的，但是我们平常开发中根本不会使用二进制进行开发，我们使用的都是 Java、C 、python这类的高级语言，每种语言都会经过一系列的转换才能被计算机识别，那么计算机到底是怎么做这项工作呢？推荐看《Compilers: Principles, Techniques, and Tools》。也就是编译器的原则、技术和工具。中文版的名字就叫《编译原理》。\n\n链接：https://pan.baidu.com/s/1Yum-wGoURvQ0w4vPLRPSVA\n提取码：7a0m\n\n希望以上内容对你有帮助！\n","categories":["编程经验"],"tags":[]},{"title":"被找事了！","url":"https://tanqingbo.cn/被找事了！/","content":"加过我微信好友的同学应该有发现，最近的一个多月，我每周都会开一场直播给大家答疑解惑，比如已经开过的直播主题有：\n\n程序员的晋级之路\n如何高质量度过大学四年？\n如何自学编程？\n\n【程序员的晋级之路】这个主题还邀请了阿里的P7大佬和大家一起交流，每场直播之后大家反馈都说收获很大，然后也有不少同学说自己即将面临毕业，目前特别的迷茫不知道该怎么办，能不能也开场直播聊聊毕业规划的事情。\n因为我知道我的公众号大学生的关注比例还是很高的，我自己也是从毕业生的阶段过来的，深知毕业生的迷茫与纠结，当年要是有人给我也指导一下，我也就不用走那么多的弯路了。\n因此做一场毕业规划的直播还是很有价值，但是每个人的毕业选择都不一样，有的人找工作、有的人考研/保研，还有的人考公或者出国。\n这些问题不是一场直播就能说的清，要不筹备一个毕业规划的系列直播吧？\n说干就干，于是我画了一张思维导图，基本涵盖了大家毕业时所面临的所有选择，以及每个选择所要注意的问题。\n\n毕业规划的系列直播计划分成6个主题，分别是：求职、考研、保研、考公、出国、个人成长。\n每个主题安排一场直播跟大家详细的聊一下，当然我不可能对每个主题都了解，所以这个系列的每一场直播我都会邀请一位经验丰富的大佬和大家一起来交流。\n预计每周一场，为了防止大家错过直播内容，建议大家可以加一下轮子工厂的专属直播群，在开播之前我会在群里提醒大家准时参加（如果群满了可以加我的微信：best_bobo2，我拽你进去）：\n\n另外，毕业规划系列直播的第一场：关于求职找工作，定于本周日晚上八点开始，我邀请了百度无人车部门的一位T6大佬来和大家面对面交流，直播大纲如下：\n\n搜集了一些关于找工作大家比较关心的问题，大家记得周日晚上8点准时来直播间收听，为了防止错过记得加群，也可以点击下放【预约】按钮进行预约。\n\n我在直播间等你！\n","categories":["技术以外"],"tags":[]},{"title":"设计模式重要吗？要怎么学呢？","url":"https://tanqingbo.cn/How-to-learn-design-patterns？/","content":"记得我第一次独立做一个项目的时候，当时没什么经验，开始之前也没有什么规划，想到需要啥功能就去实现啥功能，最后做到一半的时候发现进行不下去了。\n一会发现要给对象添加新属性，于是改对象、改构造函数、然后又发现数据库的表格设计的也不对，需要改数据库，添加新功能的时候，不仅要写新功能的代码，前面写的所有代码相应都要改一下……\n这就是吃了没有把设计模式学好的亏，其实我们把程序员分成两类，一种是懂设计模式，一种是不懂设计模式，不懂设计模式的程序员不管写了多少行代码，可能都体会不到编程真正的美。\n比如一个系统有好几种角色：老师、同学。工厂模式可以帮你实例化，就算未来可以能还有新的角色，也不用多添加或者改动原来的一行代码。\n给对象添加新功能，装饰模式帮你搞定，对象太大，想要提高响应速度，可以考虑用代理模式。\n你看设计模式就像是招式、套路一样，你在开发的过程中遇到的大多数问题都有对应的招式帮你解决，这样我们做起事情来就会轻松许多，将来别人来维护你以前写的代码也会更容易一些。\n基于这些原因，你应该知道学好设计模式对程序员有多重要了。\n设计模式就像是编程界的招式、套路一样，你在开发的过程中遇到的大多数问题都有对应的招式帮你解决。\n你可能觉得我巴拉巴拉说了一大堆，但是你自己真正在写代码的时候又是一脸蒙：为什么我写的代码用不到设计模式？究其原因是你的代码经验不够。\n想一下设计模式是怎么来的？\n上个世纪四个大男人搞了一个组合叫 GoF，并出版了一本书，这本书共收录了23种设计模式，后面逐渐被人熟知。这四个人从大量的代码实践中总结了一套方法论（写代码的套路），而我们作为一个在学校的学生或者刚工作的新人，可能连代码都写的少，怎么可能轻松快速地掌握这么多设计模式。\n所以说你学完了设计模式，但是还不会运用到日常的代码实践中，这个是很正常的，因为代码经验还不够。\n那还学不学？\n当然要学，因为面试的时候有可能会问到。设计模式的理论知识我们还是要打好基础，需要掌握这些知识点：\n\n设计模式的六大原则：单一职责、里氏替换、依赖倒置、接口隔离、迪米特法则、开闭原则\nUML 基础知识\n设计模式三大分类：创建型、结构型、行为型\n常用设计模式基本原理\n\n经典设计模式总共有23种（现在远不止23种了，还有一些变种），全部掌握难度太大了，我们只需要掌握一些常用的就好了，必须要掌握的我用小红旗已经标出来了。\n\n怎么学？\n网上关于设计模式的学习资料非常多，质量也是参差不齐，大家找的时候可要擦亮眼睛。\n之前我们学长跟我说过一句话，让我印象很深刻，他说：“看书要比自己到网上找教程要高效很多，书上的知识更成体系，作为一个初学者，把该方向的一本经典书看完，问题差不多就解决了95%。”\n在看书之前我还是推荐你熟悉一下 UML 的理论知识，因为你如果不懂 UML 那任何一本设计模式的书你都可能读不下去， UML 是设计模式的前提。\nUML 学习网站：\nhttps://www.w3cschool.cn/uml_tutorial/\n不要花太多时间学习 UML，简单理解入门即可。\n假设你已经入门 UML 了，那下面的这些书你可以考虑学习一下了：\n1、《Head First 设计模式》\n\n据我所知，不少高校用的教材就是这本书，这本书里，通过一些例子，让你快速带入到常见的设计问题，然后循序渐进的提出解决方案，提出对应的设计模式和设计原则，阅读难度低，而且理解起来很容易，非常推荐阅读。\n\n链接：https://pan.baidu.com/s/1Ean9-sIQcfGGFb9mTHQh1Q\n提取码：hpyi\n\n2、《大话设计模式》\n\n大话系列是国内非常经典的系列丛书，有众多粉丝。这本大话设计模式以对话的形式讲解知识，在当时可开创了先河。虽然书中有些例子比较牵强，但任然不失为一本入门的好书。\n\n链接：https://pan.baidu.com/s/1HXsNCTKEQsDhgAD_20nz_A\n提取码：dfyf\n\n3、《图解设计模式》\n\n图解系列是日本的一位作者写的，有一本图解 HTTP 非常经典，这本图解设计模式也是类似的风格。由于是翻译过来的，书中有些例子可能听起来比较奇怪，貌似翻译过来的技术书都有这个问题。\n\n链接：https://pan.baidu.com/s/1_C9j3HVuANTTWEmGBceqIQ\n提取码：aer0\n\n这几本书都要看吗？\n当然不是，我记得我们老师曾经说过：“作为一个新手，找一本该方向的书看完，问题差不多就解决了90%。”至于说看哪一本，你可以找对应的电子书，挑一个章节试读一下，符合你的胃口就选择这一本继续读下去，每一本书我都留了电子书下载地址。\n如果你已经有几年的编码经验，又想把代码写好，建议你多挑几本读读，吸收每本书的精华。\n","categories":["设计模式"],"tags":["设计模式"]},{"title":"如何自学编程？","url":"https://tanqingbo.cn/How-to-teach-yourself-programming/","content":"很多朋友问过我各种各样的问题，比如我现在准备开始自学编程？\n我想找一份程序员的工作，能给我一条建议或者去路线吗？\n这种问题的话，其实是很难回答的，因为编程语言分很多种，而每一种编程语言、每一种技术都有不同的学习路线，并且这个学习路线还要视你个人的基础而定，就因人而异的，真要聊起来没有几个小时聊不完。\n另外有些问题的话呢，很多人都问过，具有相当的普遍性。那么，对于这些问题的话，我专门建了一个社群，里面针对大家关心的问题我都写非常详细的解答，比如：\n\n小白入门计算机，学习路线是什么样的？\n计算机四大专业课该怎么学？\n编程语言怎么选？\n怎么利用GitHub精准搜索项目代码？\n求职简历怎么写？\n\n等等，一来是因为这些问题三言两语讲不清，二来很多朋友都有类似的问题，把这些问题集中整沉淀下来，大家直接去看，效率会更高。\n大家可以点击左下角的链接，了解这个社群的详情。\n下面的话呢，我们就正式今天的内容，在聊如何自学编程之前，首先要明确一点，你是否适合走编程之路。我总结了四个，你要打算走自学编程之路，必须要满足的前提条件。\n第一个有足够的时间；第二个有强的自控能力；第三具有高中以上的学历；第四，有基本的物质保障，如果你满足的四个条件，那么你是完全可以通过自学成长为一名软件开发者的。\n\n我们先从总体上面介绍一下自学编程的过程。我觉得如果你想自学编程的话大致可以分为这几个步骤：\n第一个步骤就是明确你的目的。\n孙子说，知彼知己百战不殆，明确你的目的这一点很关键的。因为不同的学习目的就会采用不同的这个学习策略和路线。\n一般自学编程的目的无非就是以下5个：\n\n然后我针对不同的目的分别详细说一下他们的学习策略和路径。\n1、为了考上这个计算机专的研究生。那么，这个目的的自学者的话，需要做两件事情。第一件事情就是啃下计算机专业的核心课程。因为你想考研究生的那个学校肯定会组织考试考查，所谓的核心专业课也就是我们常说的四大专业课：数据结构与算法、操作系统、计算机组成原理和计算机网络。这四大科目的学习方法可以参考下面这个教程：\nhttps://zhuanlan.zhihu.com/p/393723155\n第二件事情就是要熟练学习与掌握考研初试复试所用到那些编程语言，很多大学计算机专业，复试使用的是C、C++或者是java，所以你你一定熟练掌握这三门语言中的一门，另外，大多数学校上级复试考的是数据结构与算法，所以你除了把理论知识学好，平时的话一定要上机练习编程，可以找一些上级题目，平时进行一些自我模拟训练。 \n一般在牛客网上都能找到，注意一下时间因素，比如，你应该能够在两个小时之内使用指定的编程语言在指定的开发环境中完成4到5道数据结构与算法的编程题，因为上级复试很能看出一个考生的代码编写和程序调试的基本功，这一块一定要重视！\n总之，以考研为目标的自学编程，它的主要特点就是以应付研究生入学考试的初试和复试为目的，相对来说，比较单纯、简单。\n你只要掌握好考试的应试技巧，再收集一下报考院校的复试信息有针对性的准备一下就可以。\n2、为了能够在IT行业找到一份程序员的工作和自学以求职为目的的自学，关键是一定要弄清楚业界到底需要什么样的人才，然后有针对性地进行准备。\n这个基本思路就是你要先收集就业信息，你可以上招聘网站或者访问你想求职的公司的那个网站去了解这个用人单位的人才需求信息，然后自己做一个简单的统计分析。\n很多同学问，计算哪个方向比较火，其实自己去搜集信息对比一下就知道了，比别人告诉你靠谱多了，信息都是公开透明的。\n比如我要找软件开发这个岗位，我收集了n家公司的这个用人需求信息，其中有大公司和小公司，然后看他们招的这个软件开发岗位需要应聘者熟练掌握哪些技术，对于你所感兴趣的一个公司，再有针对性的进行这个深的了解，也可以多问自己啊。\n比如这个岗位要求的职业技能有哪些？目前我已经掌握了哪些？还有那些不会？\n这个人才信息搜集工作是极为重要的，对于求职为目的的自学者来说，它能够为你的自学拟定一个方向，明确应该培养哪些职业技能，具体学习哪些技术？\n另外，还有一个重点就是在这个自学的过程中，一定要主动的去做项目，最好能够参加一些商业项目，如果你的技术实力达不到或者没有这个机会，那么你就要自拟题目来开发个人的项目，可以去GitHub找项目，大家一定要记住，在求职之前，一定要完成一个能够代表你最高水平的作品，这个对于求职成功来说是非常关键的。\n当你把这个个人项目做完，你就会通过发简历啊，找人进行推荐啊等等各种方式。毛遂自荐，只要你真的具备了相应的职业技能，然后你耐心一点，多半都是能够找到工作的，要知道IT行业对于人才的需求一直旺盛，你只要是金子，就总能找到发光的机会。\n如果你不知道怎么通过GitHub找项目，也可以去我的社群看看，里面有一篇文章专门写了如何通过GitHub精准寻找项目源码。\n3、是为了应付日常工作以这种目的的自学受限可能比较大，因为要将真实的工作自动化并非一件简单的事情，但是这种自学也是收效最大的一种，因为他天生就是学以致用的。\n比如我自己就是这么干的，我们实验室之前老师要求统计每个同学每周的出勤率，必须待满多少个小时，因为每个同学每天来签到和签退的时间都不一样，如果手动统计就会很费时间，后来我就写了个程序员读取签到机器的数据，自动计算每个同学的出勤时间，这样子一来的话，事情就变得方便，省事可靠。\n对于那些并不打算转行的人来说，通过自学来掌握这个编程技术，然后用这些技术来改进自己的工作。这是一条光明大道，有助于你在这个工作中呃脱颖而出，因为你那些同事啊，多半想不到这么干。事实上就算他们想到了，你做不到，因为他们没有自学编程。\n那么，具体应该怎么做呢？下面我给出一些建议，你首先要注意收集各种信息，看一看这个国内外，你的这些同行们，他们是怎么样应用这些技术的，然后接着你数一下你自己的日常工作中，有哪些是可以通过主动地应用信息技术的成果，或者是工具和自动化的。\n软件开发的这个战场了，他并不全部都在IT行业，而是分布于几乎所有的正在被信息技术所改造的那些传统产业里头，这里面育着非常大的机遇。事实上我们已经看到很多这样的例子了，比如移动互联网技术成果和自行车产业的结合，导致共享单车横空出世，小黄车，小蓝车，迅速的占领了大街小巷，解决了人们那个出行最后一公里的危机，所以你可能确实不需要到IT行业淘金，因为你自己的那个行业在你自己的脚下可能就藏有一座金矿。\n4、对编程的强烈兴趣这是一种最自由，也最理想的自学形式。他要求有最大的外部环境的配合。这种目的的自学，它有可能培养出一个开发高手，出现一些创意十足的软件作品。这个里面的原因很简单，兴趣是学习的强大动力，好奇心则是各种发明发现的诱因。\n去除了功利性的这种学习和探索才是真正的学习和探索。那么，出于这个目的自学编程的人，他多半是衣食无忧，并且家境宽裕，它有着稳定的明朗的未来预期，所以才能有这种自由的而不是功利性的选择。\n这种情形的话，多数人并不具备，因为不常见，所以我们也就不再多说了。\n5、为了创新，创造和创业和自学为这种目的和自学的人，大多数都已经摆脱了菜鸟的级别，他们基本上都是雄心勃勃，意志坚定的。他们的一切行动都是以围绕着把这个项目做出来为目的，他们需要什么技术就去学什么技术？在这批人看来，技术是实现目标的工具和手段，学习技术不是目的，创新创造和创业才是目的。\n这种自学情况的话呢不算太多，但是我必须要指出，自学编程的高级阶段应该就是兴趣驱动的，或者是以创新创业创造为目的的。\n希望大家都能有机会进入这一阶段。\n到目前为止的话，我已经把五种自学的目的给大家简单的介绍了一遍，不管是哪一种目的，都是有类似之处的，如下图：\n\n通常都是从学习一种编程语言起步的，然后紧接着就开始学习特定领域的开发框架，之后是开始做项目。而学习框架也学习三个阶段：\n\n最初只需要掌握怎么样使用它，并且知道如何配置就够了，你就可以在实际项目中用起来了，比如你要是使用spring这么一个东西去开发java应用，你只需要知道你用哪一些jar包，并且知道怎么去配置这个参数，那就够了。\n但是你要想真正用好框架，你还需要认真的去看一些技术书籍，或者是技术视频才能比较深入的了解相应的开发框架的设计和运行原理，才能够解决在实际开发过程中所遇到的各种问题，这个就是框架学习的第二阶段。\n如果你想真正的精通这个框架，那么你还可以去阅读他的源码，把他的源码读懂弄清楚，这个开发框架也就给你彻底弄明白了。\n其实多数的软件开发框架学到第二阶段就够了，就足以应付日常开发的需求，第三阶段需要花费太多的时间。在有这个必要的时候，你再去研读源码。其实不管是哪个阶段，在开发实践中学习与把握这个框架都是一个很重要的事情。如果只看书不动手，不应用，那是绝对不可能学好的。\n","categories":["工具"],"tags":["网站","工具"]},{"title":"一分钟没了 1.4W 。。。","url":"https://tanqingbo.cn/一分钟没了 1.5W 。。。/","content":"大家好，我是厂长。\n最近这几天一直在忙着给大家送阿里云服务器，大家通过我的链接下单，然后我给你报销费用，就在昨天，微信上一天就发出去了1.4w红包，给大家报销了200多台服务器。\n\n帮助200多人白撸了一年的服务器：\n\n\n很多人可能会有疑问：为什么我可以免费给大家送服务器？\n这里要和大家解释一下，因为如果我推荐购买的服务器的人数超过一定数量，阿里云会给我奖励，所以相当于我花钱给大家报销服务器的费用，然后阿里云给我奖励，阿里云它自己也获得一个新用户，大家三赢。\n所以大家可以放心来参加这个活动，只要你在我这里下单了服务器，我肯定会给你报销，没有任何的套路，欢迎大家都来我这里白领服务器！\n\n至于一台服务器可以做什么，可以看看这篇文章。\n1024，我准备了 5 万！\n那如何免费领取服务器？\n很简单！\n1、添加我的微信，备注服务器。\n\n2、看朋友圈第一条动态进群，群公告有非常清晰的流程，几分钟搞定。\n3、购买成功后，发送订单号、阿里云 ID和下单时间 给我。\n4、每天晚上8-9点，我同意在群里给大家返现（因为白天有其他事情）。\n5、就这样。\n","categories":["技术以外"],"tags":[]},{"title":"服务器有什么用？","url":"https://tanqingbo.cn/服务器有啥用/","content":"当前正处在互联网时代，咱们经常接触的网站、直播、各自花哨的APP等应用很多运行在云平台上，而支撑这些应用的大多也是云服务器。\n哈哈.. 我觉得先说说云服务器能玩什么？ 简单列举下：\n1. 测试：对于计算机专业的学生来说，有一台测试服务器能干不少活。云服务器耐造，弹性伸缩方便，不像物理服务器还要受到硬件服务器影响。\n2. 个人网盘：我们讨论过这个问题。事实上，互联网上有很多不同的网盘，每一种都有自己的缺点。能自己建个网盘就爽了。网上有各种搭建网盘的教程。对于程序员来说，搭建一个网盘是很容易的。\n3. 建网站：租用云服务器建网站估计是目前用户使用最多的需求。我毕业时认识的一位软件大佬，用云服务器创建了一个个人博客，记录开发项目和经验，并在面试时直接展示给面试官。\n4. 小程序：自微信小程序上线以来，小程序已在各大平台上线。拥有小程序已经成为当今个人和企业展示的平台之一。使用微信等平台提供应用服务引流已成为越来越多企业的选择。与APP不同，小程序是轻量级的，因此部署单个云服务器完全可以。\n5. 搭建爬虫：网上有用的资料很多，但有用的资料很少。我应该怎么办？爬虫成为了解决这个问题的最好办法。您可以设置爬虫规则，轻松获取有用信息。现在很多创业公司都是根据爬虫和相关信息来爬取信息，这些信息再高价卖给其他公司。\n6. 其他应用：针对小型企业，构建常见的应用，包括ERP和HR软件。这些应用程序不需要过多的服务器配置。单个服务器就足够了。这对于企业来说也是一个非常好的选择。\n其实这个问题比较笼统。云服务器能做的事情太多了。网上有很多云服务器的实践案例。初学者可以按照教程一步一步来就可以了，尤其是各大云平台的官网帮助文档。案例多，资源丰富。\n例如，各大云平台的开发者实验室都是相当不错的新手体验区！\n阿里云实验室：\nhttps://edu.aliyun.com/lab/?source=5176.11533457&amp;userCode=28kqeewo\n腾讯云实验室：\nhttps://cloud.tencent.com/developer/labs/gallery?page=1&amp;fromSource=gwzcw.1293314.1293314.1293314&amp;cps_key=d543d0ed22c1474aaa6949df3eba981a\n那么说了这么多，哪家云服务器更好呢？\n国内阿里云、腾讯云作为国内一线云计算企业，两家业务重叠非常大，竞争激烈，所以经常推出官网活动吸引用户，下面简单梳理下两家服务器的优惠活动：\n腾讯在大促活动中云服务器：1核2G1M带宽低至74元/年，3年:219元；适合于中小企业搭建网站的轻量应用服务器。官方活动参考：\nhttps://curl.qcloud.com/1abJ47jT\n阿里云作为国内头部云平台，最早布局云计算，目前市场占有率在45%以上，它在大促中优惠力度比腾讯要大一点，突发性能型2核2G服务器，60元一年，180元三年。官方活动参考：\nhttps://www.aliyun.com/minisite/goods?taskPkg=1111ydsrwb&amp;pkgSid=2650&amp;recordId=967954&amp;userCode=gpvoce34\n另外悄悄说一嘴，今年我担任了阿里云的推广大使，有几百个免费用服务器的名额，需要的同学也可以点击下方链接领取，先到先得：\nhttps://www.yuque.com/docs/share/2ad1ebdf-dec9-460f-9904-75d80bc4bcc3?# \n就说这么多了！see you !\n","categories":["技术以外"],"tags":[]},{"title":"准备了10w！搞事！！","url":"https://tanqingbo.cn/准备了19w！搞事/","content":"大家好，我是厂长！\n老读者应该知道，在写公众号之前，我写了很长一段时间的博客，在博客上有了内容积累之后，后来才能很快的在知乎和公众号积累10多万粉丝，因为这些粉丝的关注和支持，我也慢慢赚到了一些钱，所以我也算是写博客的受益者。\n当时我还写了篇文章：写博客对程序员重要吗？\n而如果是自己搭建博客网站的话，肯定是需要用到服务器的，因此为了感谢大家对我的关注和支持，我决定给每一位关注我公众号的读者朋友送一台阿里云服务器。\n当然，我自己不可能这么有钱。能免费给大家送服务器也是因为我成为了阿里云推广大使，从朋友敖丙那里拿到了阿里云内部福利。\n现在，钱已经准备好了！就等大家一起搞事情了！\n\n活动期间有一款服务器是 60 元/年，只要你是新用户，并且通过我的链接下单购买了服务器，我会给每一个人返现 60 元，所以就相当于免费购买服务器一年。\n\n服务器可以用来做什么？\n\n搭建个人博客，放在简历上贼有面。\n搭建个人云盘，云存储一些重要的文件。\n放一些个人的项目比如你把自己简历上的个人项目放在服务器上，这样面试官通过公网 IP 就可以直接访问了。\n用于个人学习比如Linux以及各种软件/工具的安装，这样就可以不用在自己本地电脑折腾了。\n\n最后，再说下「11 月阿里云服务白piao活动」的事情。\n活动开始时间是 11 月 1 日，持续一整个月，白piao活动是针对新用户（没购买过服务器的），老用户是没办法参与的，不过你也可以拿家里的账号来参与活动。\n如果你不确认你是否符合新用户资格，可以先进群，活动开始我会放阿里云服务器的购买链接，如果你能以新人价购买服务器，那么你就符合新用户，具有返现资格。\n活动期间有一款服务器是 60 元/年，只要你是新用户，并且通过我的链接下单购买了服务器，我会给每一个人返现 60 元，所以就相当于免费购买服务器一年。\n当然，如果你想买其他型号的服务器，我一样也会返现 60 元。\n活动名额有限，想参与11月白piao活动的小伙伴，直接扫描下方二维码加群就可以了。\n\n xdm，冲呀！！\n","categories":["技术以外"],"tags":[]},{"title":"有哪些好看的日历可以买？","url":"https://tanqingbo.cn/有哪些好看的日历可以买？/","content":"1、知乎日历「知乎好问」对于经常逛知乎的朋友来说，知乎自己家出的日历绝对值得拥有啊！\n先给大家上几张图，自己感受一下：\n\n\n\n这本日历每翻开一页都是一个特别有趣的问题，每一个问题都是知乎从现有的问题库中精挑细选出来的，正面是问题，反面是回答，既有前沿的科普知识，也有脑洞大开的奇思妙想，还有触动内心的感动瞬间。\n\n不仅如此，除了内容生动有趣之外，每一页的插图也能看出来知乎团队确实在这上面花了不少心思，让你每日都有所获之外，还能放松你的心情！\n此外，日历的支架也很有质感，如果不放日历的花还能当书架或者桌面收纳用，不管是送朋友还是往自己书桌上一摆都倍有面！\n2、生财日历顾名思义，这是一本以赚钱为主题的日历，是由生财有术团队出品。\n\n介绍生财日历之前，要先介绍一下生财有术，应该有不少朋友听说过，可能还有朋友是生财有术的会员，主打的是「一个谈钱不伤感情的社群」，群里的会员会在社群里面分享自己生财的经验、探索过的项目以及对行业的认知等等，大家也会一起合作做一些项目。\n生财有术每一年都会发布一款生财日历，而这本日历则是过去一年里社群的缩影，内容全都取自于社群里沉淀下来的精华内容，集齐了365个赚钱路上的关键问题，你可以通过这本日历快速了解生财有术近一年时间的内容、一起探索过的项目、沉淀出的各行业经验，帮你你不错过各种潜在的可能赚钱的机会！\n\n我知道大家可能一聊到钱都会有一点点抵触，但是我们生活在一个需要花钱的社会，不赚钱不行，所以希望大家都能够谈钱不伤感情！\n3、神秘的程序员 周历《神秘的程序员 什么塑造了今天的编程世界：漫画编程历史大事件》是一本新颖的“风琴折”形式的文化周历，邮电出版社出版，精选了200年间56个改变编程世界的关键节点，兼顾广度和深度，贯穿多条技术领域的演化线索。\n\n这本日历适合程序员朋友们，我觉得作为一个码农，还是很有必要了解一下编程的前世今生，知道我们想在的互联网世界是怎么一步步发展来的，内容有点类似于吴军老师的《浪潮之巅》，但是这本日历是采用漫画的形式，内容更加轻松有趣！\n此外，日历的另一面是可自由发挥的书写页，可以当作备忘录或者事件清单来使用，有什么需要完成的事情或者新的编程想法都可以记在上面，提醒自己。\n","categories":["技术以外"],"tags":[]},{"title":"加班公司黑名单！！！","url":"https://tanqingbo.cn/加班公司黑名单！！！/","content":"大家好，我是厂长，祝大家周末愉快！\n最近啊，我突然收到了一份神秘的在线文档。\n这份文档汇集了各个行业、不同公司（基本上叫得上号的大公司都在列）的上班作息时间表以及薪资情况，甚至精确到了不同公司的不同部门作息情况以及工作氛围等信息。\n而且不仅限于互联网公司，有网友给它取了一个很别致的名字：加班公司黑名单！因为这些公司加班不加班，哪个城市、岗位加班多少，在这个表格中一目了然。如下图：\n外企公司：\n\n互联网IT公司：\n\n金融公司：\n\n还有各大公司校招薪资情况：\n\n这是本来是民间程序员发起的一个项目，针对目前包括互联网企业在内的各个企业加班盛行的现状，上线了一个在线作息编辑表格。\n但是没想到上线之后受到了超乎想象的关注，累计已经有几十万的浏览次数，上百人同时在线查看。\n随着文档的扩散，打工人们分享的信息已经不仅局限于互联网企业，还包含了金融行业，事业单位，建筑行业等各行各业企业部门的作息情况。\n有了这份表格，大家就能够清晰的了解到不同公司的薪资以及加班情况，为大家毕业找工作提供更好的支持！\n这个项目的线上地址如下：\n\nGithub地址：https://github.com/WorkerLivesMatter/WorkingTime\n\n不过由于这份表格信息过于敏感，线上的链接可能会随时被封，如果大家发现线上的表格打不开了，可以在公众号后台回复“表格”，我给你分享离线版的。\n","categories":["技术以外"],"tags":[]},{"title":"清华转学成电，真的牛逼！","url":"https://tanqingbo.cn/清华转学成电，真的牛逼！/","content":"最近知乎上有一个特别有意思的话题：如何看待清华材料专业学生转学到成电软工？\n\n乍一看这个消息，我还以为这个大佬是因为他在清华挂的科太多，被迫转学到成电了。\n因为清华可是站在金字塔塔尖的高校啊，无数学子求而不得的学习殿堂，大家都是挤破脑袋想要进去，很少有人考上了想要出来的。\n但是，当我仔细了解了一下之后，发现这位大佬还真不是因为挂科太多才想要转学的，人家在高二的时候因为信息学竞赛直接就报送清华了，但是具体不知道什么原因，去了清华之后读的却是与信息学一点关系都没有的材料专业。\n虽然是清华材料专业，但是转学到电子科大，至少在我看来这个决定真的太难了，全中国14亿人，他们可能没有听说过其他学校，但是一定知道清华和北大，在很多人看来，上清华北大几乎就约等于光宗耀祖，当年我保研的时候也想着要是能去清华就好了，可是人家根本没理我，后来我才去的哈工大。\n可仔细一想，这位大佬的决定其实也是非常的明智，现在知乎上天天有人在劝退材料专业，名副其实的天坑专业，就算有清华加成，毕业之后也不好找工作，而软件工程与计算机专业，现在在就业市场上可以说是当之无愧的宠儿，普通211、985高校的本科毕业生都能拿到30万+的年薪。\n与其在自己不感兴趣的天坑专业上浪费4年的时间，不如壮士断腕，转校去读自己喜欢的专业，搏一个更好的前程。\n当然，转校其实只适合他这种大佬级别的人操作，对多数的人来说并没有太大参考意义，他能够保送清华，自然是可以其他的选择，但是对于大多数的同学来说，能够考上普通本科就已经拼尽了全力。\n所以对于多数同学来说，如何把握好本科4年的时间，获得最大的成长才是最重要的事情，因此在这里我也给广大新入学的大一新生几点建议，希望能帮助你们尽快成长：\n1、在学校要学习校外很难获得的技能现在网上有很多公开课，大部分主讲人都是领域中的专家，课讲得也很好。如果学生们在大学里只是学习那些可以在课外能够以更低的成本学到的知识，那么上大学就没有什么必要了，或者说时间就利用得不是那么有效了。因此，在大学里就要学习校外学不到的东西，特别是那些很难自学的基础课程和专业知识。\n那么什么课程难以学习呢？像数学、统计、法律、会计、工程理论（比如计算机科学的算法课，电机工程领域的信号处理课）就属于这一类的课程。这些课程需要进行大量的练习，并且接受有丰富经验的教授指导，这些技能将来会在工作中发挥比较长期的作用。\n另外很多技能，即使在工作中没有使用，对生活也很有帮助，比如统计学。当你掌握了基本的统计学原理，在生活中才会对数据的大和小有些概念。\n2、学会写作很重要很多人认为，我不做记者，也不当作家，写作能力派不上用场。其实，不管你从事什么职业，都需要写作。能够将复杂而头绪非常多的想法用简单、平实、生动的语言表达出来，这是非常有用的。\n首先，在生活和工作中，有很多东西要写，包括提建议、写报告、简历和信件。比如写电子邮件可能是你与老板和同事沟通的主要途径。虽然很多人认为微信帮助通信，但是为了讲清楚问题，稍微正规一点的，效果更好一点的信件和短文更容易达到目的。\n其次，无论一个毕业生未来是工程师、律师、医生，还是一个商人，都需要有清晰的逻辑思维，善于写作的人说话会更有条理。\n写作也是一个需要在学校里练习的技巧，因为大家有时间，有指导，有需求，有练习的机会（要完成作业）。\n3、注重授课老师而不是课程名称很多学生很在意自己的成绩单上都列举了什么样的课程，其实除了少数前面提到的基础课和专业基础课是为今后进一步学习打基础外，剩下的大部分课程，走出大学后用不了两年，知识就过时了。\n如果遇到一位不好的老师，教得枯燥无味，即便去听课了，可能也会在睡觉，上课变成了自学，最后就算考试通过获得了学分，也对大家将来的学习和工作没有什么帮助。\n但是，从好的老师那里，你可以学到很多东西，它们不仅来自于课程本身，而且是一整套合乎逻辑的解决问题的思路，这些可以让你今后举一反三地学习新东西。\n我现在仍然记得本科教单片机的老师，虽然他上课讲的内容早就忘了，但是他上课常说的两条建议我至今仍然记得，他说作为一个大学生要去多旅游去看看这个世界，也一定要去更高等的学府瞧瞧，体验他们的学习氛围。\n4、多交流你的思想多和同学或者老师进行思想交流，这有两个目的，首先是通过交流不断更新自己的想法，毕竟学习的场所不仅仅是课堂。其次，也是更重要的一点，在校的年轻人有犯错误的权利，要好好利用这个权利。\n每一个人或多或少地有些错误的、别人不喜欢的想法，这些想法必须改正。而一种想法在说出来以前，你并不知道别人不喜欢，并不能意识到它可能伤害甚至激怒别人，给你带来大麻烦。当你走出校园后，如果犯了这样的错误，可能就不会被别人原谅，甚至惹来大麻烦，因为大家理所应当地把你当成熟的人来看待了。但是在学校里，别人会相对宽容一些。\n好了，最后祝大家都能在自己的赛道上扬帆起航，谋一个好的未来！\n","categories":["技术以外"],"tags":[]},{"title":"300万，啪，没了。。。。","url":"https://tanqingbo.cn/200万，啪，没了。。。。/","content":"前段时间看到一个新闻：一位苏州的大龄司机，为了讨好女主播，抵押了房产，向银行贷款300多万，前后为该女主播打赏了200多万。\n\n在打赏挥霍了200多万当了榜单大哥之后，这位苏州的司机提出想去重庆见见这位女主播。\n记者问他：见到了吗？\n他回答：见是见到了，不过啥也没干就分手了。\n有了这个教训之后，很多人可能会觉得，这位大哥应该会收手了，可是人家就不，300万没有挥霍完，之后的不久这位大哥又认识了另外一位女主播，给这位女主播投资了70多万做生意，结局当然也是亏光了。\n大哥这花钱的速度，从在苏州市有房有车瞬间变成赤贫了，接下来的生活估计也是非常的堪忧！\n看到这段新闻，让我想起了我自己的一段经历：之前有一段时间，因为经常一起去实验学习的几个小伙伴都毕业了，正好那段时间我感情还出了点问题，因此特别的抗拒学习，然后我在宿舍躺了半个多月没有出门，每天做的事情就是追剧玩游戏，像着了魔一样，感觉整个人陷进去出不来了。\n相信不少人都有过类似的经历，但是人的成长是一个不断修正、不断进化的过程，追求奶头乐并不可怕，但是如果你一直沉迷其中，并且无法自拔的话，那么反复几次低质量的人生肯定是没跑了。\n基于此，我结合我自身的经历，和大家简单分享几点，避免大家沉迷于奶头乐，一起成长：\n1、多看一些书我一直都觉得在不同的年龄阶段需要看不同的书。如果你上了大学，念了研究生，你课外阅读书单上仍然只有类似小说的故事类型的书，那你就该反省你自己了。小说可以看，但是也应该有意识的看一些与专业无关的对自己未来发展有用的书，毕竟你的个人能力是你各种能力的综合体现，如果一个人专业特别强，其他能力很弱，那他肯定也不行。\n所以看一些对自己以后发展有用的书是很有必要的。例如理财的书，理财知识老师上课不会教给你，但却是你的生存技能之一；例如一些经验类的书，它可以给我们一些深刻的启发，对拓宽我们的眼界有很大的作用，眼界宽了，面对某些事情的时候可能就不再迷茫。\n2、宁做凤尾，不做鸡头其实我要说的是环境的影响力，宁愿在优秀的人里面做倒数第一也不要在一堆废材里面做第一。如果你身边都是非常优秀的人，就算你啥也不干，你每天的耳濡目染也会让你涨不少见识。举个例子，我实验室有个朋友朋友喜欢理财，会经常研究股票国债的行情，我虽然没怎么研究，但是每天跟他一起吃饭交流，也大致摸清楚了一些门道。\n但是我见过有很多同学他们每天却在绞尽脑汁的想怎么多领几毛钱支付宝红包，有时我也能收到他们的红包码，我问他们为什么这么卖力的撸支付宝红包，他说身边的人都在撸支付宝红包啊，而且一天能赚十几块呢！先不说这十几块值不值的花精力去赚，消耗的人际关系成本也要比这贵很多啊。\n所以如果你没有考上一个好大学的话，我建议你去考个好一点学校的研究生，一个bat的offer和985研究生，我会更倾向于985的研究生，圈子和见识决定你的高度，而学校很大程度上决定你的圈子。\n3、要分得清楚什么是毒鸡汤，什么是对你有用的建议举个例子：有人经常在10楼活动，突然有一天，他来到了二楼，发现二楼的风景也不错，于是他写了一篇文章说2楼特别好，风景好、还不用努力往上爬。写完之后他又接着回到10楼生活，可是很多二楼的人看到之后却深以为然，觉得二楼的生活才是最完美的，于是继续混混沌沌，永远不知道二楼以外的世界是什么样子。\n想要识破这种毒鸡汤，就要努力提高自己的眼界，多看看书、多结交一些比自己更优秀的朋友、多出去走走…….见的世面多了，心里自然会有一杆秤，能衡量出哪些东西有毒，哪些东西对自己有帮助。\n4、做个敢于拒绝而且可以勇敢提出自己需求的人很多人在和他人相处，在出现意见不一致时，不敢表达自己的需求；怕给别人添麻烦；怕对方会不高兴；很少就自己的小问题向他人寻求帮助；把对方的需求置于自己之上………做一个这样的人不仅自己难受，有时候还不一定能取悦别人，费力不讨好。\n如果你是这种人的话，我的建议是可以稍微黑化一下自己，刻意锻炼自己表达需求的勇气和能力。如果与自己无关，或者理由充分，那就拒绝，不要害怕，毕竟勇敢不是无所畏惧，而是即使害怕，也依然去做。\n做到以上四点的话，相信我们都能够走出奶头乐的困局，并且拥有一个相对高质量的生活。\n今天就分享这么多，记得帮我“在看”和转发一下呀！\n","categories":["技术以外"],"tags":[]},{"title":"数据库重不重要？有没有什么书籍资料推荐？","url":"https://tanqingbo.cn/database-Mysql/","content":"前两天看到有朋友问：数据库重不重要？有没有什么书籍资料推荐？\n数据库的确是软件开发者需要掌握的一项“硬技能”，选书学习的时候最好避开那些通篇都在讲“发展史”的书籍，选择偏实践性的，否则花了半天时间看完书也不知道拿数据库怎么办。 回想我自己学习数据库的时候，也是读了很多各式各样的书，但真正能提高技能的不多。结合我自己的学习经历，给大家推荐6本真正能够优化你编程思路和方法的书，希望对大家有帮助！\n一、入门1、《Mysql必知必会》\n这本书是我数据库的入门书籍，虽然上大学的时候学校也开了数据库的课程，但是还是觉得这本书讲的比我们老师好，作者Ben Forta是世界知名的技术作家，很适合数据库入门的时候看，内容轻松，简单又实用。\n下载链接：\n\n链接：https://pan.baidu.com/s/1QPzyzUP53vxkSWxP2WOdqw提取码：xb4v\n\n2、《SQL查询的艺术》\n讲述数据库基础和SQL技巧详解，SQL查询的艺术 ，其中包含287个典型实例，涵盖常见SQL应用，都是程序员须学习和掌握的SQL。\n下载链接：\n\n链接：https://pan.baidu.com/s/1Z6tRvSdkE-IZwwDvTG3IzQ提取码：p3lm\n\n二、进阶1、《MySQL技术内幕——InnoDB存储引擎》\n每个行业都有几本被翻来翻去的“街书”，而本书就是MySQL的“街书”，该书目前已经有了三版。\n从源代码的角度深度解析了InnoDB的体系结构、实现原理、工作机制，并给出了大量最佳实践，能帮助你系统而深入地掌握InnoDB。注重实战，全书辅有大量的案例，可操作性极强。\n下载链接：\n\n链接：https://pan.baidu.com/s/1ob3p4Ihqf9KvZYWrzVso3w提取码：b625\n\n2、《深入浅出MySQL》\n这本书适合有一点点MYSQL使用经验的同学看，该书从数据库的基础、开发、优化、管理维护和架构5个方面对MySQL进行了详细的介绍，讲的不算特别深，但是足够我们使用了。\n下载链接：\n\n链接：https://pan.baidu.com/s/19H9QANUvh6y7Nc-jtPdd9g提取码：8att\n\n三、强化1、《高性能MySQL》\n主要讲解真实环境下如何使用MySQL的复制、集群和监控特性，揭示MySQL可靠性和高可用性的方方面面。此书定位于解决MySQL数据库的常见应用瓶颈，在保持MySQL持续可用性的前提下，挖潜各种提高性能的解决方案。非常厚的一本书，讲的太详细了，适合BDA阅读。\n下载链接：\n\n链接：https://pan.baidu.com/s/1RGX_aYJaDOczFyCoVnkkNA提取码：nodv\n\n","categories":["编程资料"],"tags":["电子书下载"]},{"title":"Java还是C++？","url":"https://tanqingbo.cn/Java还是C++？/","content":"其实不管你学哪一门语言，最终的目的都是为实际应用和找工作赚钱服务的。\n所以我先说一下这两门语言的应用场景以及市场的岗位情况吧！\n先说 C++这门语言主要是用来做一些底层开发以及一些对于性能要求比较高的业务或者场景下使用，比如要求响应速度更快场景等。\nC++在找工作的过程中，能够投递的岗位主要有 Linux/C++后台开发、嵌入式开发、游戏研发、服务器开发、编译器研发等。\n它能干的活其实不少，很多人都在担心学了C++找不到工作。。。说实话，还没到那个地步，虽然比不上Java岗位多，但也绝对不少的。\n再说说Java不管你信不信，Java是毫无争议的互联网第一语言。\n你看各种培训机构，Java培训广告满天飞。\n可以说我们现在能够尽情在互联网各种冲浪，Java这门语言可以说是居功至伟！！！\n就因为它能干的活实在是太多了！！！\n它可以做网站，可以搞Android客户端，还有就是做一些软件开发，甚至现在很火的大数据开发也可以用Java来做。\n学了Java，能干的活确实很多，这点你不得不承认，招的人也是最多的，岗位也是最多的。\n但，相应的，它也是最卷的，字节提前批第一天开放的时候投递Java后端开发的应届生是最多的。\nC++和Java到底选哪个？这两种语言：前者难学、难上手，但竞争小一些，内卷比Java好得多。\n后者好学一点，也比较容易上手学，但竞争大，内卷严重。\n你说学哪个，鱼与熊掌的关系罢了。\n看你自己了，这个没有最优的选择，看你是计算机科班出身，而且对C++有偏向性的话，那可以接着主要精力学习C++，\n因为C++可以帮你打下很结实的基本功，到时候如果你想要转学其它语言上手也会很快，\n其实编程语言里很多东西都是一样的。\n只是基本语法有点差别，把一门语言的思想掌握好了，其余的都不是事了\n学好一门编程语言就足够了，学好一门就足够你受用了。\n对了，说个去年我在牛客上看到的计算机专业就业统计报告的事情吧。\n去年校招，C++岗位简历的投递占比大概在秋招所有岗位的12%左右。\nJava岗位的投递简历数据量在秋招所有岗位的26%。\n2倍还不止了。。。\n看看今年的后端就知道Java有多么卷了，我是建议走C++的，虽说难上手一些，但至少没那么多人跟你卷。\n但是如果是个毕业生或者非科班转行的同学，我建议还是走Java吧。\n简单易上手，对于小白来说也比较友好，能找到的学习资料也多。\n不得不说一句，C++有时候真恶心。。。\nC++由于其语言特性导致它更加适合搞一些底层的东西，所以在学习C++很长的一段时间内，你所面临的都只是一个黑乎乎的命令框。\nC++小项目运行成功后给你带来的视觉感受没有Java所搭建出来的Web页面那么具有感染力。\n相应的，给你所带来的编程成就感远远比不上Java。\n","categories":["Java"],"tags":[]},{"title":"橙心优选，彻底凉了！","url":"https://tanqingbo.cn/橙心优选，凉凉了！/","content":"今天刷知乎的时候看到一个消息，让我还挺意外的：滴滴家的社区团购业务【橙心优选】裁员一半，最晚11月关闭全国业务。\n\n我对橙心优选的第一印象还停留在今天春节的补贴大战，互联网的补贴套路相信大家都已经熟悉了，先拼命砸钱拉新用户，然后再用各种办法加倍的割回来。\n当时橙心优选的拉新套路是：你拉一个新用户，并且这个新用户完成首单，就给你返15块钱。\n我因为在家无聊，还组织过楼下的大妈去地推，薅橙心优选的羊毛，后来因为我自己不做饭，就没怎么用过社区团购的应用了。\n直到最近我来北京自己租房做饭，才想起来这么个事，按理说社区团购目前正处于开疆拓土的阶段，就像几年前的电商一样，像我这样比较懒，又不喜欢去菜市场砍价的小年轻，线上买菜绝对是首选。\n可橙心优选为什么这么快就坚持不下去了呢？让我们来细看一下社区团购里面都有哪些大鱼就知道原因了：\n18年社区团购开始出现，19年批量资本下场，到20年一场疫情倒逼消费者居家买菜，奠定了社区团购主干道地位，接着凡是有点实力的大厂都来了，阿里、腾讯、美团、京东、拼多多纷纷下场搞社区团购，就连同程旅游都搞了一个同程生活想要来分一杯羹。\n可是有一个事实大家不得不承认，论资本实力和供应能力那些巨头们还是占很大优势的。\n腾讯京东投的兴盛优选，18年10月，A轮拿的融资额是数千万美刀；到今年2月的D轮，是30亿美刀。兴盛优选累计融资额在50亿美刀左右。\n阿里投的十荟团虽然不行了，但是阿里的盒马集市作为替代品，转入扩张。阿里的态度是：“对社区团购的投入不设上限”；\n线下老玩家美团肯定不会撒手，王兴今年8月的表态是：“美团优选将是我们最重要的领域”；\n多多买菜则是拼多多“电商业务的新延伸”。\n光看这架势就知道硝烟又多浓， 以上这几家多多少少都有些电商的基因，他们的用户和社区团购的用户还是有很多重合的。\n再来看橙心优选，它是滴滴家推出来的应用，滴滴觉得自己家有车，也能送菜。\n可是用手机打车的那波人和用手机买菜的那波人是同一批消费者吗？或者说这个重合度有多高。\n从一开始，橙心的路就很难，因为主营业务和买菜业务相差太远，它相当于是要从0开始培养买菜用户，干不过美团的外卖、也干不过盒马的线下消费和拼多多的低价电商。\n与其和以上这些老牌电商对手接着烧钱，还不如壮士断腕，砍掉这块业务，回到自己的主营业务烧死那帮第二梯队的网约车同行，没错，美团打车就在这个名单上！\n","categories":["技术以外"],"tags":[]},{"title":"Go语言学习资料汇总！","url":"https://tanqingbo.cn/Golang-book-recommend/","content":"之前写了一篇《Go语言学习路线指南》，适合新人入门的时候看，大神绕路，文章地址如下：\nhttps://tanqingbo.cn/Golang-learning/\n除了上面的学习指南，再补充一些学习资料如下：\n1、书籍《Go入门指南》是《The Way to Go》的中文译本，内容很详细，零基础开始的。 \n链接：https://pan.baidu.com/s/1M2EguQFO8wEpM6yjySvRiw  提取码：t6ni\n《Go Web编程》主要涉及Web开发相关内容，如何使用go开发web项目，包括：Web基础、表单、数据库、Session等。\n链接：https://pan.baidu.com/s/1-U69az5xOnOPLEw994FMrw   提取码：dvod\n《Golang 实战》从零基础开始，内容包含：数据库操作、beego框架、gin框架、高级应用等。\n链接：https://pan.baidu.com/s/1xJ6-I0Qqd00JStsblA64kg  提取码：33ra\n《Go 语言圣经》特别经典的一本书，学习Go语言必看。链接：https://pan.baidu.com/s/1BI35JoaiXdCZiB80CJl-yg  提取码：vimy\n《Go 语言高级编程》本书涵盖CGO、Go汇编语言、RPC实现、Web框架实现、分布式系统等高阶主题，针对Go语言有一定经验想深入了解Go语言各种高级用法的开发人员。对于刚学习Go语言的读者，建议先从《Go语言圣经》开始系统学习Go语言的基础知识。\n链接：https://pan.baidu.com/s/1qbRln2297kdwWhQrRUv_ow   提取码：5v1d\n2、Go标准库文档可以通过文档查询每个API的具体使用方式，是Golang开发者必备手册。\n\nGolang标准库文档 包含每个api的用法详解，golang开发必备api查询手册 链接：https://studygolang.com/static/pkgdoc/main.html\n《Go语言标准库》以示例驱动的方式讲解Golang的标准库。 链接: https://books.studygolang.com/The-Golang-Standard-Library-by-Example/\n\n3、更多教程\n《go语言教程》http://c.biancheng.net/golang/\nGo语言42章经 ：https://github.com/ffhelicopter/Go42\nGo2编程指南：https://github.com/chai2010/go2-book\nGo语言实战: 编写可维护Go语言代码建议：https://github.com/llitfkitfk/go-best-practice\nGo资源精选中文版：https://github.com/chai2010/awesome-go-zh\nGo夜读：https://github.com/developer-learning/reading-go\nGo 资源大全中文版：https://github.com/jobbole/awesome-go-cn\nGo 入门指南：https://github.com/Unknwon/the-way-to-go_ZH_CN\nGo 语言学习资料与社区索引：https://github.com/Unknwon/go-study-index\nGopher Reading List：https://github.com/enocom/gopher-reading-list\nbuild-web-application-with-golang：https://github.com/astaxie/build-web-application-with-golang\nGo 源代码：https://github.com/golang/go\nUber Go 语言代码风格指南：https://fivezh.github.io/2019/10/17/uber-go-style-guide/\n\n","categories":["Go语言"],"tags":["程序员"]},{"title":"Go 语言学习路线指南","url":"https://tanqingbo.cn/Golang-learning/","content":"不知道是不是有同学打算开始学习 Golang，确不知道如何开始，至少我开始学习的时候就是这种感觉，为了这个，我查询了很多的帖子和问答。网上的 Golang 资料虽然不多，但是也不少，这个我的一个学习路线，从简单内容开始，可以作为参考。\n第一步 Go 语言之旅刚入门Go语言的第一步，先去看看这个官方的入门教程，或者说只是一个大概了解的教程，它只介绍了一些简单的东西，并且没有太多的说明。不过这个教程支持在线执行代码，还是很不错的，这个时候你都不需要有本地的开发环境。\n\n不用想太多，现在就开始，把这个教程从头到尾看一遍，练习一遍，遇到不明白的地方也不要纠结，继续向后看就行了。\n官方： https://tour.golang.org\n第二步 开发环境这里也可以忽略不看，因为每一个教程都会介绍怎么配置环境\n操作系统个人推荐使用 Linux，可以使用 Ubuntu 或者 Fedora ，如果条件允许（不差钱） 也可以使用 Mac，当然使用 Windows 也是可以的，慢慢的就会知道 Windows 下做开发的纠结了。\n开发环境Go 的安装非常的简单，没有太多的依赖，如果是 Linux 下安装基本上下载一个二进制包，解压配置上一个环境变量、GOROOT 既可以了，具体的可以查看官方的安装方法： 安装文档教程\n开发工具可以选择一个自己喜欢的，个人建议要用个 IDE，我使用过 vim 、Sublime、Intellji idea ，最后发现还是 IDE 比较方便，尤其是代码追踪断点等。这个不纠结那种好，有人和我说 Sublime 和 vim 安装上插件也都可以，但是个人不推荐。\n直接点击下方链接便可以下载IDE：\n\n链接：https://pan.baidu.com/s/1NkDzn6AVGb2a6F6hUmum7Q提取码：fq5t\n\n第三步 看一套视频有人可能喜欢看视频，有人可能喜欢看文档，这个根据个人爱好去选择，个人建议要看一套视频并且只看一套就够了，毕竟看视频的效率还是比较低的，看完视频一些基础的知识点就可以掌握，并且会知道一些专有名字的读法。我以前学 PHP 的时候就从来没看过视频，导致很多名词的发音都是错的，经常被人嘲笑……，当然如果英文非常的好的同学就不用纠结了。\n网上 Golang 的视频不是很多，不过也有好多套，推荐 无闻的 Go 编程基础，这个是被 go.learnku.com 的 Summer整理优化过的，看起来的效果会比一些其他网站好一些。\n第四步 看一篇教程教程也有很多，看个人的喜好吧，推荐看 《Go 入门指南》 ，这个也是由 无闻 翻译 的 The Way to Go ，不过社区的版本对排版进行了优化并加入了后面没有翻译完的部分。\n\n《Go 入门指南》的pdf电子版我也已经整理好了，直接点击下方链接可以下载：\n\n链接：https://pan.baidu.com/s/19JPIrTjhu7QVYSOZ5_StXA提取码：20nr\n\n第五步 将标准库全部都过一遍至少要叫常用的全都看一遍，如 strings /strconv/http 等，如果有能力可以将它们都记住，如果记忆力不太好（像我这样）至少也要知道有什么，用到的时候通过手册可以快速找到。\n官方标准库： https://golang.org/pkg/\n中文版的标准库： https://studygolang.com/static/pkgdoc/main…\n极力推荐 https://github.com/astaxie/gopkg ，可以在学习的时候看这个，有关于标准库的详细说明和示例，学习起来会容易一些，等全都明白了要使用的时候可以去查看上面的文档。\n完成到这个时候，你肯定已经入门了，剩下就开始写自己的东西吧，比如写一个博客，或者去学习一个框架，不知道怎么继续去深造的话就去招聘网站上看看自己喜欢的企业都要求什么，招聘要求会什么就去学什么。\n有空也可以去刷一下： https://leetcode-cn.com/ ，用 go 做一遍实现，这对于你理解go语言以及找工作都很有帮助。新手可能刚开始刷leetcode可能无从下手，可以参考这本用go语言实现的《leetcode题解手册》，是阿里一位P8大佬撰写的。\n\n下载链接：\n\n链接：https://pan.baidu.com/s/1LcLvkXgGnguvu1OE49o6SQ密码: a8dt\n\n我也只能算是刚刚入门， 不是高手， 这是我学习的一个路线， 给新手一个借鉴。\n","categories":["Go语言"],"tags":["程序员"]},{"title":"终于，10w+了！","url":"https://tanqingbo.cn/10w+YYDS！/","content":"一晃「轮子工厂」这个号已经运营3年时间了，自运营以来，不管遇到任何突发情况，它都保持着每天一更的节奏，终于功夫不负有心人，在最近突破了10w+关注这个量级。\n\n这个成绩其实不值得炫耀，因为身边有很多朋友他们一年甚至半年就达到了10万这个量级。\n当然10w+读者的订阅也就意味着「轮子工厂」这个号算是活下来了，不会轻易被淘汰了，这主要归功于大家的支持和鼓励！\n所以今天和大家来聊下这一路走来的心路历程吧！\n1、缘起上大学的时候，我养成了一个很好的习惯，就是写博客，当时和实验室另外一个同学搭了一个博客网站，因为他当时正忙着准备找工作，我忙着准备保研，每天都要吸收消化很多东西，我们一合计，为什么不把学的东西整理一下写成博客呢？这样不仅能加深自己的理解还能分享给大家。\n后来写博客这个习惯一直保持着，写了一年多时间之后，在朋友的建议下，我把之前写过的博客都搬到知乎上来，在知乎上积累了一点点关注之后，又开始转战公众号，这才有大家现在所看到的「轮子工厂」这个号。\n之所以要提一下写博客这段经历，是因为它前期帮我积累了不少的内容，这样我在开始写知乎的时候才能迅速得到正反馈，这也是我能够坚持到现在的原因。\n不管做任何事情，正反馈都很重要的！\n2、涨粉公众号与知乎的内容推送机制完全不一样，在知乎，如果你的内容很优秀，系统会把它推荐给更多人，随着曝光量变多，你的关注人数自然也会增加，但是公众号不是这样的，在公众号上，系统只会把你的内容推送给关注过你的人，换句话说，你的内容想要被更多人看到，光靠质量还不行，你还需要让更多的人来关注你的公众号。\n这也就是大家经常听说的引流涨粉。有很多朋友问过我怎么给公众号快速涨粉，我也和很多做的比我好的朋友交流过涨粉的方法，最后发现其实没有什么快速涨粉的方法，最有效的方法就四个字：坚持+勤奋！\n如果你发现写知乎回答可以给公众号引流，那就坚持每天都写；如果自己的回答曝光量太低，那就努力提高回答的质量，然后一天写10个、20个回答。\n如果你发现这种引流的方法效果不行，那就想办法优化它，尝试各种方法找出最优解！\n如果你发现个人网站可以给公众号引流，那就从现在开始，去建你自己的网站，坚持输出内容，坚持每天SEO，让大家能在搜索引擎中找到你的网站内容。\n。。。。。。。\n我认识很多10w、20w+关注量的号主，为了保持粉丝的增长，他们现在仍然每天坚持写10多个有料知乎回答。\n所以想要快速的涨粉，没有什么捷径可走，只有多下笨功夫，然后一直坚持下去。\n3、初心不满大家说，我经常在思考一个问题，就是我做的事情是不是真的对大家有帮助。每次看到有人留言说“感谢，很有帮助”，我都会感到特别的开心。\n基于这样的初心，我每次在挑选推送的文章的时候，都会优先考虑，这篇文章是否对大家有用。此外大家私聊的问题我有时间也都会回答，但是肯定也有一些遗漏和回复不及时的情况，因为毕竟我微信上有接近两万的好友，每天要处理的信息也还是蛮多的。\n另外大家以后在向人请教问题的时候，我给个小小的建议，千万不要以：“在吗？”开头。有问题直接描述问题就好了，也不要问百度一下直接就能找到的问题，这样会暴露自己动手能力欠缺，有伸手党倾向。\n好了，就叨唠这么多，希望「轮子工厂」公众号能一直输出有用的东西，希望下一个10w+，大家依然还在！\n","categories":["技术以外"],"tags":[]},{"title":"搞了一个程序员成长晋级社群！","url":"https://tanqingbo.cn/搞了一个程序员成长晋级社群！/","content":"经常有朋友微信上问我，说自己刚接触编程，不知道从哪里开始学起？也有人问，说自己一个人埋头学了很久，但是依然没有摸到门道，对编程一知半解，怎么破？\n相信大部分编程初学者都会有这种疑惑，我也在微信上回答了很多次，后来我想，既然大部分初学者都有这种疑惑，那我不如建一个程序员晋级社群，把大家关心的问题都整理分享到里面，这样等下次再有朋友有相同的疑惑的时候，就可以直接让他去群里找对应的帖子就可以了。\n这不仅提高了我的效率，也可以给大家提供一个交流探讨的平台，一举两得！\n当然这个社群建好之后，我并没有第一时间通知大家，因为沉淀内容需要一段时间，我希望这个社群是真的能够帮助到大家的，所以在内容方面慎之又慎，现在这个社群已经初具规模，里面沉淀的内容包括但不限于：\n1、经验教程\n\n\n2、资源分享\n\n3、生活感悟&amp;读书笔记\n\n\n怎么加入？扫描下方的二维码，支付6.6元就可以直接加入了：\n\n之所以要设置一个小小的收费门槛，一是为了过滤掉不怀好意进来发广告的人，二来大家付出了一点点的成本也会更加珍惜社群里面的内容，毕竟分享这些内容我也是花了很多的心血，它值得被大家认真对待，门槛也不高，6.6元，不到一杯奶茶的钱。\n后续我仍然还会持续维护这个社群，他的价值只会原来越大！\n好了，期待你的加入，我们共同成长，加油！\n","categories":["计算机基础知识"],"tags":["电子书下载"]},{"title":"卧槽，上热门了！","url":"https://tanqingbo.cn/卧槽，上知乎热搜了！/","content":"之前在知乎写过一个回答「你当初是如何学会操作系统这门课程的？」，没想到意外收获了1400+赞同和6000+的收藏，还上了知乎的热门。\n\n想必确实是对很多人学习操作系统有帮助，所以我把它拿到公众号上面来分享给大家，以下是回答的原文：\n你当初是如何学会操作系统这门课程的？想要学好操作系统这门课程强烈推荐去听一下下面这两个老师的操作系统课程，保证不水，B站上都有完整的视频！\n1. 2020 南京大学 操作系统：设计与实现 (蒋炎岩) https://www.bilibili.com/video/BV1N741177F5南大的课质量真的硬，蒋炎岩老师讲的是真滴好啊，把晦涩的东西讲的也非常的通俗易懂，豁然开朗，很多同学都是慕名而来，看完这个也算上过南大的操作系统啦 哈哈哈。\n\n2. 操作系统（哈工大李治军老师） https://www.bilibili.com/video/BV1d4411v7u7个人觉得是 b 站上很不错的操作系统课程了，这门课的前几讲涉及 OS 启动，需要一点汇编知识，不过遇到不会的直接网上搜即可，大可不必因为汇编而被劝退；之后的内容如多进程、信号量、内存管理等讲得很好。\n\n当然我觉得想要学好操作系统，最好还是视频+经典教材一起看，老师的课程也是基于教材来讲的，先看视频，看不懂的地方再去翻教材查一下，这样学起来才能事半功倍，经典的操作系统教材也给大家推荐两本，文末可以直接下载电子版：\n1、《深入理解计算机系统》\n\n无论是处于哪个阶段的同学，这部书都是必备的。正如此书开篇作者所言“如果你全心投身学习这本书中的概念，完全理解底层计算机系统以及它对应用程序的理解，你会步上成为为数不多的大牛之路”。这是一本很基础的书，涵盖了计算机组成原理，操作系统，体系结构，网络编程，并行程序设计原理等课程的基础知识。\n学习这本书，你就会对计算机底层世界有一个宏观的认知，搞清楚计算机底层的工作原理，为什么它可以完成如此复杂的工作？为什么一个小小的cpu却又如此强大？最简单的“hello,word”程序是怎么运行的?当然，因为这本书包含很多概念，专业术语，读起来可能比较晦涩，大家也不必一口气读完，可以在学习整个计算机过程中慢慢去读，慢慢理解。\n2、《现代操作系统》\n\n国内很多高校的操作系统课都是采用的这根本书当教材，区别于其他的操作系统书，这本书最大的特点就是挑战了传统操作系统教材的权威，果断地删掉了和 “现代” 操作系统关系比较小的部分，真正把 “现代” 两个字体现得淋漓尽致。——以如日中天的 AArch64 作为底层机制，直通操作系统研究前沿，能对操作系统世界的架构作出宏观把控的，都是货真价实的干货。\n以上推荐的这两本书，直接在公众号对话框回复「操作系统」即可获取，如果对你有帮助的话，记得点个“在看”，顺便 转发 一下。\n\n","categories":["计算机基础知识"],"tags":["电子书下载"]},{"title":"那些让你起飞的计算机基础知识","url":"https://tanqingbo.cn/那些让你起飞的计算机基础知识/","content":"高畅，在谷歌工作，目前研究方向是计算机视觉和机器学习。\n他为了准备校招，刷了几百道算法题、研究了半年的LeetCode，凭着自己的努力，成为了当年的Offer收割机，包括字节跳动，快手，Google，百度，腾讯，阿里，Hulu。\n他把他的刷题经验进行总结，成了这本刷题笔记，火爆Github，短短时间内获得几千star!\n话不多说，让我们来看一下书的目录：\n\n\n他对知识点的讲解非常详细，比如这里的贪心算法，排版非常精美：\n\n\n相信大家凭着这份资料，也能够对校招中的算法了如指掌，很快拿到Offer。\n为了方便大家，我已经将开源电子书下载后上传到百度云盘，\n获取方式\n第 1 步：扫码关注「轮子工厂」公众号\n第 2 步：在「轮子工厂」后台，回复数字 115 即可获取资料\n▲回复「115」，获取PDF▲\n最近正是面试高峰期，我帮大家准备了一份2021年最新最全的《Java面试题及答案V4.0》一共有数百页，都是按专题总结复习。这套电子书涵盖了诸多后端技术栈的面试题和答案，相信可以帮助大家在最短的时间内复习Java后端的大多数面试题，从而拿到自己心仪的offer。\n截了张图，大家可以仔细查看左边的菜单栏，覆盖的知识面真的很广，而且质量都很不错。\n\n部分内容展示\n\n获取方式\n第 1 步：扫码关注「轮子工厂」公众号\n第 2 步：在「轮子工厂」后台，回复数字 337 即可获取资料\n▲回复「337」，获取PDF▲\n","categories":["编程资料"],"tags":["电子书下载"]},{"title":"《阿里巴巴Java开发手册》开放下载！！！","url":"https://tanqingbo.cn/alibaba-Java/","content":"之前阿里官方推出一套Java编程规范：《阿里巴巴Java开发手册(终极版)》，这套Java统一规范标准将有助于提高行业编码规范化水平，帮助行业人员提高开发质量和效率、大大降低代码维护成本。推出之后，在CSDN，InfoQ，知乎等网站引起广泛讨论，口碑收获颇丰。\n\n书籍总体框架\n阿里巴巴Java开发手册\n\n《阿里巴巴Java开发手册》的愿景是码出高效，码出质量。它结合作者的开发经验和架构历程，提炼阿里巴巴集团技术团队的集体编程经验和软件设计智慧，浓缩成为立体的编程规范和最佳实践。\n众所周知，现代软件行业的高速发展对开发者的综合素质要求越来越高，因为不仅是编程相关的知识点，其他维度的知识点也会影响软件的最终交付质量，\n比如，数据库的表结构和索引设计缺陷可能带来软件的架构缺陷或性能风险；单元测试的失位导致集成测试困难；没有鉴权的漏洞代码易被黑客攻击等。\n所以，本手册以开发者为中心视角，划分为编程规约、异常日志、单元测试、安全规约、MySQL数据库、工程结构、设计规约七个维度，每个条目下有相应的扩展解释和说明，正例和反例，全面、立体、形象地帮助到开发者的成长和团队代码规约文化的形成。\n从严格意义上讲，《阿里巴巴Java开发手册》超越了Java语言本身，明确作为一名合格开发者应该具备的基本素质，\n因此本手册适合计算机相关行业的管理者和研发人员、高等院校的计算机专业师生、求职者等阅读，希望成为大家如良师益友般的工作手册、工具字典和床头书。\n这本《阿里巴巴Java开发手册》高清电子版我也给大家准备好了，戳下面链接即可直接下载：\n链接：https://pan.baidu.com/s/1SBidek_X6JzJkVvOSvCq6A\n提取码：c41q\n","categories":["编程资料"],"tags":["电子书下载"]},{"title":"互联网赚钱机器---社群（视频号文案）","url":"https://tanqingbo.cn/社群！/","content":"嗨喽，大家好，我是谭庆波，今天想和大家聊一个话题叫：社群！首先大家要清楚一个概念： 有共同诉求、或者有共同的价值观的圈子才叫社群。举个例子： 跳广场舞的大妈就是一个社群，但在同一个商场的人，就不属于一个社群，因为前者有共同诉求，而后者没有。比如我要建一个程序员交流群，让程序员小伙伴都加进来，交流学习，这就是一个有价值的社群，但是我如果直接把乱七八糟的的人都拽进群，然后取名叫程序员交流群，那就不能叫社群，因为前者有共同的需求，后者没有，没有共同需求的人凑出来的群，任何价值都没有。\n那么清楚什么是有价值的社群之后，怎么打造一个有价值的社群从而变现呢？\n我们做社群最终的目的都是为了卖产品赚钱，但是人和产品是不可能成为朋友的，而人和人却可以，我们可以通过输出自己的价值，让社群的小伙伴信任你，成为你的朋友，从而为你买单。那怎样才能让大家信任你，然后购买你的产品呢？给大家分享一个案例：\n我们本地有家医院，挂号特别难，于是就有小伙伴专门建了一个群，去帮助群友抢号， 而且她还自学了一些医学知识，偶尔在群里分享。这个事她持续做了一年，满了4个挂号群！大家一定想不到她的本职工作是干嘛的，她是个保险经纪人，通过做这个利他的事情，为群友服务，最后群里有三分一的人在她这买了保险，相当于一年卖出去600多份保险，业内的人应该知道这个成绩有多厉害 。价值的输出，带来绝对的信任！而信任可以促进成交。\n更多关于社群的信息可以点击视频下方的链接，下期见！\n","categories":["技术以外"],"tags":[]},{"title":"互联网赚钱机器---社群","url":"https://tanqingbo.cn/互联网赚钱机器---社群/","content":"最近听了几节微信社群副业直播课，受益匪浅，我把内容整理了一下，分享给大家，建议大家认真看完，说不定能帮你打造出一门不错的副业出来：\n什么是社群？百度搜索一下可能有各种答案，但都是同一个意思：共利的圈子。\n什么是共利的圈子？有共同诉求、或者共同的价值观的圈子。举个例子，跳广场舞的大妈群体，就是一个社群，但在同一个商场的人，就不属于一个社群，因为前者有共同诉求，后者没有。\n比如说我们建个群，让爱听课的小伙伴主动来听课，就是一个社群。但是你直接拉群，乱七八糟什么样的人都往群里拉，然后只是给自己的群取一个听课群的名字，你的这个群就不叫社群。因为前者有共同诉求、价值观，都愿意学习，而后者没有。\n那么社群能干嘛？社群能赚钱。而且如果你有了社群思维，在互联网高速发展的今天，你一定会处处比人领先一步！\n逻辑思维：罗振宇用公众账号为载体，每天发布一条60秒语音，然后吸引了一帮有共需的人，最后卖给粉丝课程、商品……\n小红书网红博主：她们以小红书为载体，吸引对某个题材感兴趣的人成为粉丝，最后卖自己的商品给自己的粉丝。\n快手、抖音网红号：她们以短视频平台为载体，用不同类型的短视频内容吸引粉丝，从而通过将粉丝转化到微信成交，或者直接在短视频平台卖货给粉丝赚钱。\n那么说到以微信为工具的社群，我也给大家举个我身边的例子。\n我一个朋友，非常热爱手工花，2017年无意间拉了一个群，邀了身边为数不多喜欢花的朋友进群。\n经常在群里分享自己的手工花制作方法，那时候她纯属无意，就是一个单纯的爱好。\n然后群里的朋友们觉得她做的花真的好，漂亮。不自觉通过朋友圈转发。转发后，群友身边感兴趣的朋友进行询问，然后申请要到群里。\n就是这样，她持续做这件她最喜欢的事情，满了一个粉丝群，接下来是2群、3群……\n大家知道，我这个朋友一年赚多少钱吗？\n她卖手工花能赚多少我不知道，但光她在千聊开的一节课，收费400，我记得没错，应该有10万左右的播放量！\n分享这个案例，只是想让大家先思考一下，社群是什么，社群思维是什么？\n社群是什么？社群是一种营销方式。——是一种把顾客变成朋友（甚至粉丝）的过程，能不能把顾客（或者潜在代理）变成朋友这是很难的。\n因为人性本身就是利己的。你和顾客是因为利益和交易购买关系产生链接，你和你身边大多的陌生人只是一个头像的认知。和他们直接成为朋友是不可能的！\n但是他们可以通过你设置的场景、你的内容，和你产生链接，最终成为朋友。因为人和人可以成为朋友，但是人和产品，和项目不可能成为朋友。\n一个人最悲哀的不过于你微信有2000好友，而真正信任你的人没几个，就像你在沙漠中拥有一座金矿，纵使你看起来很富有，但是你连走出沙漠的机会也没有。\n对于我们很多普通人，可能没有专业的抖音团队，没有出众的文笔去写公众号文章，更没办法用专业的手法玩儿微信社群，但，我们每个人通过微信，都有一个自己的微信好友圈子。也就是我们所说的微信人脉圈。\n我们普通人可以通过微信＋微信群，来经营以自己为中心的社群。我将社群思维总结为以下几点：\n需求-流量-价值-成交\n1、需求比如我自己建了一个专注于程序员学习与成长的社区【晋级的程序员们】，里面专注分享程序员的各种学习资料和学习经验，供大家学习交流，那有需求的小伙伴们看到了就可以进来一起交流学习成长。\n\n你能提供需求，就有流量的入口，需求不一定是只有学习的需求。女性有爱美的需求，男人有好色的需求，老人有健康的需求，小孩有成长的需求，喜欢唱歌的人有想提升的需求……\n这个世界上有成千上万种需求，你能抓住哪个需求，就有可能能获得哪种流量。\n2、流量与价值流量和价值这两个要放在一起说，不知道大家发现没有，通过价值带来的流量，是及其精准的！什么流量速度快且精准？就像文章最开始讲的，有共同的诉求或者价值观的流量！所以，绝对的价值，一定可以打开你流量的入口！\n那怎么找到自己的价值呢？举个简单的例子，假如你是一个考过四六级大学生，那么你考四六级的经验还有整理的资料对没参加过四六级考试的人来说就是价值；如果你是个程序员，那你写代码的经验对于想学编程的人来说就是价值。就算你啥也不会。那你肯定玩过游戏，或者追过剧，玩游戏的人可以带小白升级，追剧的人可以给别人推荐好看的电视剧。这些都是价值，不存在一个没有价值的人。\n找到价值之后，接下来就是要持续输出你的价值，把有共同需求的人都吸引过来，加入你的社群。\n3、成交其实当以上三点你做好后，你发现你有了一个东西，叫IP。IP是什么？IP就是你在你好友圈，或者一个社群圈子的影响力！\n你有多大的影响力，直接决定着你的成交率！\n当然，成交需要技巧，这属于“术”的层面，但是无论你的技巧再高，如果你对某个人没有一丝影响力，你要去成交他，概率很低。\n原因很简单，因为别人不相信你！\n包括你身边最亲的人，你的兄弟姐妹、最好的哥们、战友、闺蜜。\n你如果在你最亲的人身上没有影响力，你做任何事情，第一个出来阻挡你的人反而恰恰就是他们。因为他们自认为了解你，对你有固有的认知。\n只要你去做和你原来行业无关的事情，他们就会觉得你不行。因为熟人会看你的结果，而陌生人才会看你的价值。\n往往很多熟人，在你真正改变了之后，他们才会相信，而往往成就你改变的，反而很多不是这些熟人。\n但当他们发现你改变之后，他们来了！来干嘛的？来借钱的，或者来找你帮忙的。\n所以也给大家一个建议，多去混一下陌生圈子，多认识一些朋友，多升级一下自己固有的圈层，多找到一些有共同价值观的好朋友。\n因为只有共利的人才能成就你，和你们熟不熟悉没有半毛钱关系。共情的人，没事喝喝酒就好了。\n所以，持续做利他的事，上天一定会在某个时候给你想要的一切，你要深信！\n最后给大家推荐一个社群工具：群有料。很多人对社群的理解就是一个微信群聊，但其实不是这样的，微信作为一个通讯工具，交流沟通可能很方便，但是无法做到内容沉淀，也看不到群成员的活跃数据，没有数据就不知道该如何调整策略，这对于一个做社群的人来说相当于两眼抓瞎，所以我是通过群有料来做社群的，同样是基于微信，但是它对内容沉淀很友善，大家可以反复观看社群里面以前沉淀下来的内容，此外还提供了很多社群管理工具，比如数据统计、抽奖、邀约榜等等，如果大家想要做社群的话强烈推荐大家使用群有料这个社群工具。\n","categories":["技术以外"],"tags":[]},{"title":"神书，一定要看！！！","url":"https://tanqingbo.cn/这本书一定要看！/","content":"最近又重新看了一遍《富爸爸穷爸爸》这本书，特别想推荐给大家。\n这本书是我在知乎和公众号上面安利过很多次的书，也影响了我之后的种种选择，比如做公众号、合理规划资产、理财、注册公司…….\n\n对我来说，这是价值特别大的一本书，每过一段时间我都会再重温一次。\n书里面提到了一个很重要的观点就是：「增加资产」和「减少负债」。所谓资产就是能够源源不断把钱放进你口袋的东西，而负债就是就是源源不断把钱从你口袋里拿走的东西。\n而增加资产无外乎就是这三种方式：打工、创业、投资。\n对于大部分人来说，都是选择的打工这条道路，创业其实也是打工，只不过是为自己打工而已。\n一开始提升打工的能力是「增加资产」最有效的方法，提升打工的能力换句话说就是提升专业能力、人际关系、职业素养等等。\n等「打工的能力」逐渐成熟、资金和经验也得到一定的积累，就可以将更多的精力放在提升自己「投资能力」上面。\n当自己的投资收益能够完全覆盖自己的日常开支的时候，也就是大家所说的财富自由状态。\n当然很多人会说投资有风险，理财就是割韭菜。\n这话其实没毛病，投资当然会有风险，这就好比成年人和三岁小孩开车一样，他们两开车上道都会有风险，但是成年人考过驾照，系统的学习过开车，并且有多年的开车经验，他开车上道虽然有风险，但是风险会降低很多。而三岁小孩开车就不一样了，99%的概率会翻车。\n而大部分人所说的投资就跟三岁小孩开车一样，没有花时间学过任何知识，直接拿着钱就冲进去了，这样不翻车才怪。\n接着再到「减少负债」。\n前面说过负债就是就是源源不断把钱从你口袋里拿走的东西。比如你买了房和车，每个月需要还贷款，那这就是负债。\n当然我们说的是减少负债，而不是不能有负债，买车如果其提供的便利性与损耗的金钱不对等，且地铁、滴滴已经足够便利的情况下，那这笔负债就属于不健康的负债了。但是如果是为了谈生意、为了节省时间精力，给自己创造更多的资产，那就是属于另外一个范畴了。\n除了车子，还有生活中其他很多东西，例如奢侈品、昂贵的鞋子、米其林等，这些随着你「增加资产」，你必定会忍不住剁手，同时开始「提升负债」。\n很多人就会掉入这个陷阱中，一边疯狂「提升资产」，一边疯狂「提升负债」，永远都达不到「财务自由」的状态。\n最重要还是要理清什么是「资产」，什么是「负债」，并进行合理的分配，对于普通人来说其实不需要都么精湛的技巧，只需要理清生活中这些概念，再职场道路上稳定发展，增加资产、减少负债，就都能过上不错的生活。\n当然我所写的只不过是书中的部分内容，真的推荐大家都去看一下《富爸爸穷爸爸》这本书，这本书的电子版也给大家整理好了，大家扫描下方二维码回复「富爸爸」就可以领取了！\n\n","categories":["技术以外"],"tags":[]},{"title":"自学计算机的建议！","url":"https://tanqingbo.cn/Suggestions-for-self-study-of-computers/","content":"如果真的是0基础入行计算机的话，建议先对这一行增加点背景知识了解，这方面目前最好的读书是吴军老师的《浪潮之巅》，见解非常独到。如果是想要根据时间线来了解一下的话，可以看一下《硅谷百年史》，了解背景知识看这两本书差不多就够了。\n然后接下来的一步比较重要，就是正式学习计算机专业知识，到这里很多人就会有困惑，自学，从哪里入手？上培训班，似乎很直接，但是很费钱；自己找书看，又不知道看哪些书。\n我个人的建议是看书、上课、和实践相结合，三管齐下，缺一不可。\n学编程最重要的就是要理论和实践想结合，两方面都需要兼顾好。不然，编程能力不会有真正提高。\n所以我从三个方面来讲一下，先是书籍推荐，再是网课选择，最后是练习平台。\n1、书籍推荐1.《深入理解计算机系统》（CSAPP）\n\n这是一本很基础的书，涵盖了计算机组成原理，操作系统，体系结构，网络编程，并行程序设计原理等课程的基础知识。无论是处于哪个阶段的同学，这部书都是必备的。正如此书开篇作者所言“如果你全心投身学习这本书中的概念，完全理解底层计算机系统以及它对应用程序的理解，你会步上成为为数不多的大牛之路”。\n\n链接：https://pan.baidu.com/s/1RoDN317X-C6izxY6CwuxTA\n提取码：iy8u\n\n2.关于编程语言\n到底哪种编程语言是世界上最好的语言是程序员永远无法达成一致的世界难题。我结合自身七年的学习经验以及针对当前社会的需求，给大家推荐三门编程语言（C++/Java/Python）以及相关的书籍。\n1）《C++ Primer》\n\n这是一本久负盛名的C++经典教程。无论是初学者入门，或是中/高级程序员提升，这本书都是不容置疑的首选！！！\n\n链接：https://pan.baidu.com/s/1qqAR6iqjur1sfmzeZjcrwg\n提取码：m6gx\n\n2）《Java编程思想》\n\n这本书赢得了全球程序员的广泛赞誉，即使是最晦涩的概念，在作者的文字和示例面前都迎刃而解。从Java的基础语法到最高级特性，这本书都可以指导你一步步的轻松的去理解和掌握！这本书小编我在大二学了一整年，学完之后真的完成了质的飞跃！亲身体验，非常推荐给大家！\n\n链接：https://pan.baidu.com/s/117eGadbs5iHCfmI29LEwEg\n提取码：du2r\n\n3）《Fluent Python》\n\n近两年我用的编程语言就是python。现在网络上对于python的教材真的是五花八门，内容过于重复和繁琐，对我们帮助并不大。关于这本书我可以很果断的说，这是世面上关于python最好的书！并且真是书的风格特别友好，读的时候你会感觉一个博学但是温柔的大叔再跟你侃侃而谈。\n\n链接：https://pan.baidu.com/s/1gKqdaNH2SpwRCv7PO3HAzw\n提取码：0z6v\n\n3.数据结构与算法分析\n掌握了最基本的编程语言，就该学习更高级的知识了，也是程序员核心知识——数据结构与算法分析。只有掌握了这些，才可能写的更好更高效的程序，才能将语言更好地用于实际问题的解决。当然，这部分知识也是比较难学的。接下来给大家推荐三本我认为非常好的三本相关书籍。\n1)《我的第一本算法书》\n这本书是京都大学一个计算机教授和朋友联合出品的动画讲解算法的App 所衍生出来的书籍，非常适合新手朋友们。里面没有枯燥的理论和复杂的公式，而是通过大量的步骤图帮助读者加深对数据结构原理和算法执行过程的理解，便于学习和记忆。将本书作为算法入门的第一步，是非常不错的选择。\n\n\n链接：https://pan.baidu.com/s/1r_lxqzfg7YTHvAEQhNJwnQ\n提取码：en9j\n\n2）《算法图解》\n这是一本像小说一样有趣的算法入门书，示例丰富，图文并茂，以让人容易理解的方式阐释了算法，旨在帮助程序员在日常项目中更好地发挥算法的能量。书中的前三章将帮助你打下基础，带你学习二分查找、大O表示法、两种基本的数据结构以及递归等。余下的篇幅将主要介绍应用广泛的算法。\n\n\n链接：https://pan.baidu.com/s/1GZEp8KI1Fm0U4Uek7BOWAw\n提取码：am4o\n\n3）《算法导论》\nemmmmm这本书真的是算“圣书”了，如果把它从头到尾看完并且搞明白了，那么恭喜你，月入百万不是梦！\n\n\n链接：https://pan.baidu.com/s/1Y1kXAyQsZO3MA_kgfa5Jog\n提取码：tl3x\n\n2、网课选择课程的话，最重要的就是下面六门课：\n\n数据结构与算法，\n计算机组成原理，\n计算机操作系统，\n计算机网络，\n数据库系统。\n\n上面的这六门课，无论你是将来找工作，读研，还是读博，都是最最重要的。而且学习的顺序就是上面的这样。\n1. 数据结构与算法\n推荐看MIT的算法课，教程用的是《算法导论》，这门算法则基本不涉及到语言层面，主要是算法层面，讲得很好。\nhttps://www.bilibili.com/video/av21620553\n\n组成原理与操作系统的话，强烈推荐去看下面这两位老师的课，B站上面有完整的视频，保证不水！\n1. ）2020 南京大学 操作系统：设计与实现 (蒋炎岩) https://www.bilibili.com/video/BV1N741177F5?p=1\n南大的课质量真的硬，蒋炎岩老师讲的是真滴好啊，把晦涩的东西讲的也非常的通俗易懂，豁然开朗，很多同学都是慕名而来，看完这个也算上过南大的操作系统啦 哈哈哈。\n\n2.） 操作系统（哈工大李治军老师） https://www.bilibili.com/video/BV1d4411v7u7?p=1\n个人觉得是 b 站上很不错的操作系统课程了，这门课的前几讲涉及 OS 启动，需要一点汇编知识，不过遇到不会的直接网上搜即可，大可不必因为汇编而被劝退；之后的内容如多进程、信号量、内存管理等讲得很好。\n\n3.）计算机网络微课堂 https://www.bilibili.com/video/BV1c4411d7jb?p=1\n这个网课惊艳的地方在于，老师的话语没什么废话，基本都是知识要点，更重要的是他动图非常多，他动图非常多，他动图非常多，他动图非常多！！！所以非常适合小白入门学习，不能再生动形象！\n\n3、最后来说说练习平台光学不练，计算机知识是学不会的。\n不管你是考研还是面试找工作，都一定会重点考查学生的动手能力，而动手能力主要考查的就是算法能力，所以大家一定要勤加训练！\nLeetCodeleetcode是现在找工作最热门的刷题网站了，\n但LeetCode现在题目也太多了，一共1300+了，而且一直在增加！！！\n全刷完没必要，也不高效，推荐看下面这个leetcode刷题笔记：\n\n这份笔记里面共包含作者刷LeetCode算法题后整理的数百道题，每道题均附有详细题解过程。很多人表示刷数据结构和算法题效率不高，甚是痛苦。\n有了这个笔记的总结，对校招和社招的算法刷题帮助之大不言而喻。\n离线版笔记下载地址：\n\n链接：https://pan.baidu.com/s/12VD7NnF2NJEgGsCoOIkNyw提取码：w31k\n\n4、一些建议1）在大家学习计算机相关知识的时候，一定要好好利用网络上的资源，好好利用百度和谷歌。有什么不会的直接上网搜，肯定会有很多优秀的博主为你排忧解惑。\n2）对于编程语言的学习，一定要多动手写代码，在实战中掌握。而且C++/Java/Python掌握一门就够了。大同小异，当你精通一门语言之后，如果想要学习其他语言，就会非常的快。\n3）学习数据结构和算法分析，一定一定要在看懂之后自己用自己喜欢的编程语言实现一遍，一定要亲自实现一遍呀！！！这一点太重要了。这样你就能很快的掌握而且再一次加强编程能力。\n","categories":["编程资料"],"tags":["电子书下载"]},{"title":"利用Windows11系统发布会，两天给公众号导流2000粉","url":"https://tanqingbo.cn/Windows11-2kfans/","content":"最近win11系统发布会的热度特别的火爆，相信有不少人都看过win11系统的发布会，就算没有看过也都在各个媒体账号上面看到过关于win11系统的介绍，它的具体功能我就不在这里赘述了，大家在微信上一搜就能找到非常详细的介绍。\n\n我主要是想分享一下我是怎么利用这波热度，两天给自己的公众号导流2000多粉的。\n6月24号晚上十点，微软举行了Windows11系统的发布会，发布会结束后，win11这个话题就在知乎热榜和微博热搜上躺了好几天，也就是说绝大多数人都知道微软发布了Windows新一代操作系统了，人都是有猎奇心理的，只要满足大家的猎奇心理，流量自然而然就来了。\n那么发布会结束之后，大家最关心的问题是什么呢？无非就是下面这两个：\n\n怎么判断我的电脑是否满足升级成为Windows11系统的条件？\n上哪去下载Windows11的系统镜像？\n\n基于这两个问题，我立刻去找来了检测自己电脑是否满足升级条件的工具以及Windows11预览版的系统镜像，然后准备了两篇文章，一篇是【教大家怎么检测自己电脑是否满足升级条件】的文章，然后在文章中引导大家去公众号领取检测工具；\n另外一篇是【介绍Windows11系统新功能】的文章，在文章中引导大家去公众号领取Windows11预览版系统镜像。\n在这个过程还发生了一个小插曲，就是微软官方提供的检测工具下载链接出问题了，通过官方渠道下载的工具大小是0k，而且无法运行，到这可能很多人都觉得第一个问题要凉了，但是其实换个角度想一下，这其实是一件非常有利于我的事情，官方的下载链接失效了，如果我还是能够提供官方检测工具，那么大家就只能到这里来下载，没有其他选择了，那么这个引流的效果将会更加显著的。\n至于怎么找到正常能用的检测工具，其实只要你搜索能力强一点，花点功夫，肯定都能找到。\n准备工作都做好之后，我把这两篇文章发到了 知乎上面去，但是这并没有完，文章发出去之后，我先观察了一下哪篇文章的访问量数据表现的更好一些，做内容的朋友都知道，如果一篇文章发出去之后访问量数据表现不错，那么换个账号再发一次，它同样会有不错的表现。\n最终是那篇教大家怎么检测自己电脑是否满足升级条件的文章访问量表现的更好，所以我又把这篇文章发到了我的另外三个知乎账号上面去，各种推广资源也都用上，比如知乎官方提供的内容自荐以及自定义推广。\n当然介绍win11新功能的那篇文章我也没有放弃，同样用我的另外3个账号发了一次，流量再小那也是有流量的，不能浪费，只不过推广资源有所倾斜，我把一些推广手段都用在了访问量数据表现更好的那篇文章上面了。\n经过这一通操作之后，我的公众号两天涨了2000多粉丝，到现在每天仍然还有不少粉丝陆陆续续过来。\n最后总结一下：\n\n互联网上的热点事件很多，但是如果能找到这些热点事件背后大众的需求，那么这些流量就有可能为自己所用；\n解决需求的过程中如果遇到了困难先别急着放弃，把握的好的话，也许会成为一个更大的机会；\n流量都是试出来的，很少一次见效，比如在这次引流过程中，我是准备了两篇文案，并且先观察了它们的表现，才决定发力推广哪一篇。\n\n","categories":["技术以外"],"tags":[]},{"title":"我去特斯拉试车了","url":"https://tanqingbo.cn/去特斯拉试车了/","content":"最近我去线下把几个钟意的新能源车品牌都体验了一下。\n前两天和大家分享了蔚来的线下试车体验，我去蔚来试车了。。。\n今天重点和大家来聊一下特斯拉！\n去特斯拉线下体验店的时候发现来看车的人还真不少，因为在去看特斯拉之前我先看了比亚迪汉EV，人流对比发现还是看特斯拉的人相对多一些。\n体验店里面只有两款车型：model 3和model Y，也是现在市场上最火爆的两款，至于model s和model X可能是由于太贵了，在体验店中没有看到。\n\n因为最近特斯拉的刹车失灵事件闹得沸沸扬扬嘛，所以当时我特意就这件事问了一下他们的导购，他们解释说，特斯拉作为一个年销量50多万台的汽车品牌，不可能连刹车都做不好，交通意外确实是有发生，但是其他品牌发生的交通意外不比特斯拉少，只不过媒体选择性报道了，因为媒体需要流量，报道特斯拉有流量，其他车没有流量，所以大家只看到了特斯拉。\n这个回答算是在我的意料之中，不过具体的技术细节我不太懂，就没有深究这个问题了，下面和大家分享一下我的具体感受：\n1、空间体验Model 3坐进去之后有一种拥挤的感觉，车顶距离头顶太近了，而且后排空间有点少，施展不开，不过好在它的整个车顶是一块透明的玻璃，视野良好，可以稍微缓解一下空间太少造成的压抑感。\n而Model Y的车内容空间就很宽敞，坐乘体验很棒，不过拿model Y和model 3对比空间，有点不公平，因为3是桥跑，Y是SUV，如果想要灵活的驾驶体验那就选3，需要经常带着家人出行，预算也充足的话那就选Y。\n在备用箱的设计上，得夸一下特斯拉，古往今来，汽车一般都只有一个后备箱，但是特斯拉不是这样的，它不止有后备箱，它还有前备箱，由于新能源车和燃油车构造不同，所以特斯拉在前面也挖了一个备用箱。\n\n这样的话，你的书包、零食、书籍工具啥的就可以塞前备箱里，省的你有什么东西就往副驾驶扔，解放你的副驾驶。\n2、关于电池一般来说，买新能源车最看重的就是它的电池，特斯拉在电池方面主要有两个亮点：一个是充电速度，另外一个是充电桩的数量。\n特斯拉的充电速度很快，超级充电桩10分钟可充100公里，半小时基本上充的七七八八了，最后10%的的电稍微会慢一些，不过我问他们工作人员，特斯拉会不会学蔚来建换点站，走换电的路子，这样几分钟就能换一个加满电的电池，速度更快。\n得到的答案是：不会，他们说特斯拉售量太多，换电的模式不适合特斯拉。虽然具体原因没有细说，不过我估计应该是成本的问题，据行业人士透露，一个换电站成本在800万元左右，而特斯拉年销量五六十万台，那肯定是需要海量的换电站才能满足市场需求，这可不是一比小的开销，而且充电本来就不是赚钱的买卖，搞不好分分钟亏得底裤都不剩。\n\n关于充电桩得数量，据官方数据显示，特斯拉已经在中国建成了超过620座超级充电站，5000多个超级充电桩，此外特斯拉兼容其它品牌的充电桩，也就是说可以用其它新能源车充电桩给特斯拉充电，但是其它品牌的车不能用特斯拉的超级充电桩。\n3、自动辅助驾驶前面聊的都是特斯拉的硬件部分，现在终于要聊它的智能部分了。自动辅助驾驶功能现在基本上是新能源车的标配，没有这个功能都不好意思叫自己新能源车。\n你想一下，当你忙碌了一天筋疲力尽了，下班却堵在路上进退两难，或者你需要开上千公里的长途，没有辅助驾驶功能的话真的会很难受，明明已经很累了，却还要聚精会神把控方向盘和油门，这也是很多人不愿意开车的原因。\n但是如果有辅助驾驶功能就可以把你的双手双脚解放出来了，你只需要设置好巡航速度，让车辆自动巡航就好了。\n特斯拉的辅助驾驶叫AutoPilot，简称AP，之前需要买完车之后再加3万块钱购买这个功能，现在好像购车免费赠送了。\n其实辅助驾驶功能，就是机器学习的结果，而机器学习主要就是看谁的数据更多、更全面，特斯拉在全球销量远超其它新能源车，采集的路况信息数据也更加的全面，所以在辅助驾驶方面，特斯拉的AutoPilot还是有一定优势的。\n当然，虽说特斯拉的销量多，咱们国产造车新势力的发展也丝毫不落后。\n在过去的5月，国产新能源三傻中，蔚来共交付6711台，同比增长95.3%；\n小鹏汽车共交付5686台，同比增长483%；\n理想汽车共交付4323台，同比增长101.3%；\n照这个发展速度，我相信国产新能源车和特斯拉正面刚的那一天应该很快就会到来！\n","categories":["技术以外"],"tags":[]},{"title":"阿里巴巴社招内推，团队直招！","url":"https://tanqingbo.cn/Ali-recruits/","content":"说正事，招人了！！！\n公司：阿里本地生活； 岗位： Java 后端（团队直招，名额超多）； 地点：上海\n大家都知道，我是计算机科班出身，身边有很多朋友在BAT这些大厂上班，前两天有个在阿里上班的朋友和我说，他们团队最近准备招人，而且名额超多，我知道后就问他能不能帮我内推一下，因为我这边可能有很多需要找工作的朋友，但是找不到内推的渠道。\n他听说后，非常爽快的就答应内推了，毕竟我这边的读者大多数都是计算机专业出身，而且还特别的优秀，这可比他直接上BOSS直聘上捞简历的效率要高多了。\n他现在在阿里的职位是P7，在他们团队应该也算是独当一面的leader，关于职位的成长空间、薪资福利这些问题都可以直接找他咨询。\n好了，下面正式介绍一下他们团队招聘的岗位以及要求，如果发现自己合适的话别忘了把简历砸过去！\n岗位描述负责电商类或金融类平台核心系统的的研发与建设\n岗位要求\n精通web编程、java基础扎实，熟练掌握spring、mybatis、mysql以及java中间件等；\n\n一年以上开发，具有一定的复杂业务系统架构，线上优化经验，有互联网电商或者金融级交易架构经验者优先；\n\n对本地生活或者电商行业有深入理解，优秀的沟通和团队协作能力，有在国内外一线互联网公司经历者优先；\n\n有良好的技术远景、有技术布道能力，有开源项目、技术分享经验者优先；\n\n我们希望你对本地生活、新零售等方向充满兴趣，致力于通过技术改变传统行业，服务广大消费者和商家。\n\n\n岗位优势双休，团队氛围好，定期团建；成长空间大，能够参与或主导核心系统的建设，同蚂蚁系/淘宝系深度合作。\n内推方式按照 「轮子-社招-姓名」 的标题格式 投递到邮箱 yonglun.ly@alibaba-inc.com\n微信咨询朋友微信：huayonglun，可实时向他追踪内推进度\n好了，如果你符合上面的要求，并且准备换个新的工作环境，别忘了投递简历啊！\n","categories":["技术以外"],"tags":["内推"]},{"title":"被录取了！","url":"https://tanqingbo.cn/被录取了/","content":"从小学到高中，我的学习成绩其实一直都不怎么好。\n就连高考的时候，分数也是特别的尴尬：比一本线高7分。我还记得当时我妈给我爸打电话说我考上一本的时候，我还特别的心虚，因为我只知道这个分数不一定能被一本录取。\n学习成绩不好倒不是我不努力学习，而是当时在那个环境下我已经尽了我最大的努力了。\n我小学是在我们村唯一一所学校上的，学校只有一栋教学楼加一个泥泞的操场，全校的师生加起来不超过80人，没有英语老师，其他的任课老师也是经常替换，因为没有人愿意来这个破地方上班。\n上初中的时候，我去了东莞的一所私立学校，因为我爸妈在这边打工，而家里又没有老人可以带着我上学，所以我爸妈只好把我带在身边，由于转学的原因，带来了一系列的问题，首先东莞的教育进度和湖南小农村的进度是不一样的，小学的时候我没有学过英语，等我来到这边上初中的时候，发现他们已经在学高级语法了。\n当时上英语课是我最大的噩梦，不仅听不懂，还特别害怕老师上课点我名回答问题。转学带来的第二个问题就是，身边的一切都是陌生的，全新的环境，以前的朋友没有一个在身边。\n等到我初二回到老家小镇上的时候，这两个问题又一次发生在我身上：教育进度不一样、以及全新且陌生的环境。\n这导致我在整个初中，不仅学习成绩不好，还特别没有存在感，印象特别深刻的是，毕业后有一次和几个朋友一起回初中的学校，遇到了一位教过我们的老师，那个老师挨个叫出了其他几位朋友的名字，到我这却变成了尴尬一笑。\n初中升学的时候也比较坎坷，我经历了三次升学考试，第一次是五科联考（就是只考语、数、外、物理、化学），没有考上，后来去参加市里面一所高中的自主招生，和我一起去参加考试的朋友录取了，我没有过线，最后是在中考的时候以压线的成绩考上了我们县里的一所重点高中。\n在我家那边，初中毕业之后基本上只有两种选择：\n\n考上重点高中，接着上学；\n没考上，工厂打工；\n\n那是我距离工厂打工最近的一次。\n考上高中后，阴差阳错当上了我们班的体育委员，后来又阴差阳错的加入了我们学校的体育队，现在回想起来我的求学历程还真是坎坷。\n因为在体育队需要花很多时间训练，学习成绩自然也很一般，记得高一的时候，有一次模拟考试，150分的英语试题，我考了3.5分。这对于当时的我来说好像也没觉得是什么大问题，我只不过是众多混的学子中的一个。\n转折点发生在高二的下学期，这学期发生了两件对我来说比较重要的事情，第一件事是我当上了班长，可能是由于前两年我当过体育委员，老师为了解放原来的班长，就任命我当班长了。老师可能没有想到，他的这个无意之举，却改变了我。\n前面说过，我在班上的存在感其实是很低的，基本上不被人关注，而班长恰恰是一个会被人关注的职位，我需要站在班级的前面去处理一些事情，任课老师有事也会第一时间问班长是谁。\n我突然发现这种被关注的感觉原来很好，我想要得到更多的关注，我不想让那些认识我的老师发现，原来我的成绩这么差，我想在成绩上面也得到大家的关注。\n于是我退出了体育队，开始专心学习，当然学习成绩不是说变好就能立刻变好的，这是一个很艰难的过程，尤其是我的英语成绩。\n学好英语的契机是李阳来我们学校做了一次演讲，这也是对我来说第二件比较重要的事情，现在回想起来，李阳他其实就是来卖课和卖教材的，当时他在演讲台上讲激情澎拜，我们在台下听的也是热血沸腾，好像只要买了他的英语教材，立刻就能走向人生巅峰一样。\n我们学校很多人都买了他的教材，我也不例外，这种卖货的方式虽然有些不妥，但是他的教材确实给我带来了很大的帮助，书上面把往年高考英语原题全部汇总了，并且每一种题型都有英语录音，这对于一个0基础不知道怎么发音的人来说太重要了，我跟着录音，把往年的高考题型都背了一遍，当时听力、完型、阅读、作文这些题型我都完完整整的背过，不认识的单词就先查字典，然后跟着录音念，知道怎么念了就开始背。\n虽然方法笨了一点，但是真的有效果，后来高考英语我考了100多分，其他成绩也没有拖后腿，总成绩比一本线高7分。\n这个分数很尴尬 ，在一本院校中基本没有选择的余地，我认真的查阅了很多填志愿的资料，当时准备填写的志愿都是省内的几所一本院校，专业选的是土木、船舶、园林这些专业。\n在高考志愿截至的前一日，我的语文老师跟我说，你可以填一所211冲一下，于是我查了全国所有211院校往年在湖南的录取分数线，最后锁定哈尔滨的东北林业大学，于是把第一志愿改成了东北林业大学，第一专业改成了计算机，选计算机是因为当时它的录取线最低，这样录取的概率大一些。\n最后的结果就是我被第一志愿的第一专业录取了，我很感谢当时我这个尴尬的分数，否则我现在可能就是在省内一所普通的院校、学着土木、园林这些专业，最后为了赚钱又自费去学计算机，或者戴着安全帽在工地摆弄仪器。\n上大学之后，便没有之前求学那么曲折了，我一直都是专业前几的排名，国奖国励都拿过，各种专业比赛的大奖也收获过不少，最后毕业的时候直接保送哈工大攻读博士研究生了。\n到现在我也算是有了一点点的积蓄和成绩，毫不夸张的说，我就是通过高考从农村走出来的，在阶级越来越固化的今天，我觉得读书仍然是大多数寒门学子为数不多改变命运的机会。\n虽然现在有很多人喷高考培养的都是应试教育者，高分低能，而且想要改变命运也不一定只有读书这一条路，尤其是现在流量网红兴起的时代。\n但是对于小农村乡镇的同学来说，他们没有那么多的资源、也没有更多接触信息的渠道，读书就是他们跨越阶层、向上流动最好的方式。\n","categories":["技术以外"],"tags":[]},{"title":"万字 Java 知识地图手册！","url":"https://tanqingbo.cn/Java-learing-map/","content":"我相信这些读者或多或少都有一些 Java 基础，但由于看不到全貌，学了一段时间很容易迷失。所以我在寻思着能不能写一个学习的地图或者路线，让读者能知道下一步该学什么，自己离大厂的 offer还有多远的距离。\n一个人最怕的不是路途遥远，而是看不到胜利曙光。我希望下面这篇文章能给你的学习之路带来一丝曙光，大家不妨试着读一下吧，如果有收获给我点个赞哟。\n\n温馨提醒：这篇文章写着写着就一万字了，建议大家关注后再收藏，以防走丢。\n\n这篇文章主要内容包括(干货满满)：\n\n学Java有哪些就业方向？\n数据结构和算法\n设计模式\n计算机基础\nJava 入门\nJava 高手进阶\n基础框架（SSM）\n微服务框架\n常用中间件\n数据库\n分布式架构\n必须掌握的工具软件\n学习资源网站列表汇总\n学习常见问题（FAQ）\n\n买一瓶可乐，泡一杯咖啡，lets go 学习~\n学Java有哪些就业方向？在介绍 Java 怎么学之前我给大家介绍一下学完了能干什么，因为有目标的学习才是最高效的。\n很多 Java 入门学习者对岗位或者方向的概念非常模糊，今天学安卓、后天学大数据，三心二意的学习势必造成技术不精，这就是面试官通常说的：这位面试者基础比较差。\n学习技术首先要认准一个方向专注下去，有了一定积累后再将自己的知识面扩宽，找到自己感兴趣的方向再沉下去学习，周而复始你就成为这个行业的专家了。\nJava 这门语言，在公司里根据分工不同衍生出了众多的岗位或者技术方向。\n我在 boss 直聘上搜索了 BAT 等大厂的岗位，目前有以下三类岗位非常热门：\n（1）安卓开发\n\n技能要求：\n\n熟悉 Android UI 开发非常熟悉，对 UI 架构有理解，并了解基础的 UI 交互知识;\n熟悉 Android 调试工具和方法，可以应付各种 Android 复杂问题;\n熟悉 Android Framework 层，有通过 Android 源码阅读定位问题的经验;\n\n\n（2）Java 后端开发\n\n技能要求：\n\n具备扎实的Java基础，对JVM原理有扎实的理解；对Spring、MyBatis、Dubbo等开源框架熟悉，并能了解它的原理和机制，具有大型分布式系统设计研发经验；\n熟悉基于Mysql关系数据库设计和开发、对数据库性能优化有丰富的经验；\n熟悉底层中间件、分布式技术（如RPC框架、缓存、消息系统等）；\n\n\n（3）大数据/数据仓库\n\n技能要求：\n\n熟悉Hadoop/Spark/sqoop/hive/impala/azkaban/kylin等大数据相关组件;\n精通sql及性能调优，熟练使用java、python、scala其中一种编程语言;\n掌握数据仓库 (DW) / OLAP /商业智能 (BI) /数据统计理论，并灵活的应用，具备大型数据仓库设计经验;\n\n\n这里只列举了三类比较热门的技术岗位，希望大家结合自己的经验思考一下方向。\n敲黑板：认清自己，找准方向，越早确定方向越容易成功！\n\n数据结构和算法学什么？\n有些同学可能要问了：我学 Java 的有必要学习算法吗？答案是：别无选择！\n国内互联网面试的流程逐渐在向国外靠拢，像字节跳动、BAT 等大厂，手撕算法题已经成为了必选动作。\n确实， Java 相对于 C、C++有着丰富的类库和三方框架，进入工作后大部分人都是在写业务代码，俗称 API boy 或者 Crud boy，算法看起来并不是那么重要，但是考算法真的是公司面试筛选人的低成本办法，如果你写出了算法并且通过了，要么你聪明要么你勤奋（刷题了）。\n所以不管你是学什么语言：C、C++、python、Java、GO，算法这一关你必须得过。数据结构和算法的面试核心知识点我已经列出来了，大家可以参考学习，逐个击破。\n\n栈与队列：先进先出、后进先出\n线性链表\n查找：顺序查找、二分查找\n排序：交换类、插入类、选择类\n树、二叉树、图：深度优先（DFS）、广度优先（BFS）\n递归\n分治\n滑窗\n三大牛逼算法：回溯、贪心、动态规划（DP）\n\n怎么学？\n最好或者最笨的方法就是刷题，强烈推荐力扣：https://leetcode-cn.com建议刷300题以上，要覆盖简单、中等、困难的题目。面试前要训练手感，不要生疏了，可以选保持每日或几日一题。\n在刷题之前我建议你看一些书：《漫画算法-小灰的算法之旅》\n\n如果你之前没有任何算法基础，这边书很适合你，可以补充数据结构和算法的基础知识，像什么是时间复杂度空间复杂度、查找、排序等。如果你有了一定基础了，建议你直接跳到最后面的算法实战部分。\n\n《剑指 offer》\n\n非常经典的一本书，学算法的人必刷。但是要注意了，这边书里面的题目是用 C++写的，如果你是 Java 开发人员可能会有点影响。但是要记住学习算法最关键的还是解题思路和方法，用什么语言实现是其次的，如果你时间比较多我是建议你用 Java 语言再实现一遍。\n\n《labuladong的算法小抄》\n\n非常推荐！这是一本很新的书，写书前作者在 Github 开源了一个项目，主要讲解 LeetCode 解题套路，Start 总数排名前40。在书的开头讲解了学习算法的基本思维和套路，建议看这边书的同时再配合 leetcode 刷题，疗效非常棒！\n\n《算法导论》\n\n要是不推荐这本书是不是显得我有点 low 了，这是一本科班出身的同学必看必学的经典大部头。国外大佬写的，国内翻译的经典之作，虽然是经典但是不建议刚入门算法的同学看，因为看了这本书你可能要放弃算法了，比较难看懂。建议有了一定基础再入手这边书。\n\n如果你觉得看书比较枯燥，可以推荐你看一些极客时间的专栏，不过是收费，但是质量非常高。《数据结构与算法之美》\n\n这个专栏是文字+语音，作者是王争，前 Google 工程师。他采用最适合工程师的学习方式，不拘泥于某一特定编程语言，从实际开发场景出发，由浅入深教你学习数据结构与算法的方法，帮你搞懂基本概念和核心理论，深入理解算法精髓，帮你提升使用数据结构和算法思维解决问题的能力。\n\n《算法面试通关40讲》\n\n这个专栏是视频，作者是覃超，前Facebook工程师。作者会用白板带你一步一步解题，层层深入一环扣一环，每一题还会用多种解题方法。我基本看完了，收获颇多。\n\nleetcode、书和极客专栏可以并行，学练结合，不要光看不练哦。\n设计模式学什么？\n金庸小说中牛叉的武功太多了，综合性最强的还是九阳真经，九阴真经分为上、下两卷，上卷为内功基础，下卷为武功招式，这些都是极负盛名的武学秘籍。\n那大家思考一下什么是武学秘籍？其实打开来开就是一些固定的招式，牢记这些招式并运用好就是绝顶高手了。\n回到编程上来，除了要写干净的代码（clean code），还要运用各种设计模式使代码可读性强、扩展性好、松耦合，这便是大家经常说的编码大牛。\n所以不管是学武功还是学编码，都是有一些固定的招式，也就是设计模式。\n说到设计模式很多同学可能会跳出来：这个我知道，就是单例模式、工厂模式……\n巴拉巴拉说了一堆，但是真正在写代码的时候又是一脸蒙：为什么我写的代码用不到设计模式？究其原因是你的代码经验不够。\n想一下设计模式是怎么来的？上个世纪四个大男人搞了一个组合叫 GoF，并出版了一本书，这本书共收录了23种设计模式，后面逐渐被人熟知。这四个人从大量的代码实践中总结了一套方法论（写代码的套路），而我们作为一个在学校的学生或者刚工作的新人，可能连代码都写的少，怎么可能轻松快速地掌握这么多设计模式。\n所以说你学完了设计模式，但是还不会运用到日常的代码实践中，这个是很正常的，因为代码经验还不够。\n那还学不学？当然要学，因为面试的时候有可能会问到。设计模式的理论知识我们还是要打好基础，需要掌握这些知识点：\n\n设计模式的六大原则：单一职责、里氏替换、依赖倒置、接口隔离、迪米特法则、开闭原则\nUML 基础知识\n设计模式三大分类：创建型、结构型、行为型\n常用设计模式基本原理\n\n经典设计模式总共有23种（现在远不止23种了，还有一些变种），全部掌握难度太大了，我们只需要掌握一些常用的就好了，必须要掌握的我用小红旗已经标出来了。\n怎么学？\n网上关于设计模式的学习资料非常多，质量也是参差不齐，大家找的时候可要擦亮眼睛。\n在看书之前我还是推荐你熟悉一下 UML 的理论知识，因为你如果不懂 UML 那任何一本设计模式的书你都可能读不下去， UML 是设计模式的前提。\nUML 学习网站：\nhttps://www.w3cschool.cn/uml_tutorial/\n不要花太多时间学习 UML，简单理解入门即可。\n假设你已经入门 UML 了，那下面的这些书你可以考虑学习一下了：\n《Head First 设计模式》\n\nHead First 是一个比较经典的系列丛书，有些人非常喜欢这种风格。这本书讲枯燥的设计概念讲解的生动有趣，作为一本入手书非常值得推荐。\n\n《大话设计模式》\n\n大话系列是国内非常经典的系列丛书，有众多粉丝。这本大话设计模式以对话的形式讲解知识，在当时可开创了先河。虽然书中有些例子比较牵强，但任然不失为一本入门的好书。\n\n《图解设计模式》\n\n图解系列是日本的一位作者写的，有一本图解 HTTP 非常经典，这本图解设计模式也是类似的风格。由于是翻译过来的，书中有些例子可能听起来比较奇怪，貌似翻译过来的技术书都有这个问题。\n\n《设计模式-可复用面向对象软件的基础》\n\n又是一本黑色大部头书，书的作者就是 GoF，大家都说经典。但是呢，经典归经典，读起来真的是晦涩难懂，对新人非常不优化，如果你想入门学习设计模式，这本书就不推荐了。不推荐为什么要说出来？经典的书如果不提，你们又要说我菜。（害）\n\n这几本书都要看吗？当然不是，如果你是在准备面试，我个人建议是读其中一本就够了。至于说看哪一本，你可以找对应的电子书，挑一个章节试读一下，符合你的胃口就选择这一本继续读下去。\n如果你已经有几年的编码经验，又想把代码写好，建议你多挑基本读读，吸收每本书的精华。\n计算机基础科班出身的同学对《计算机网络》和《操作系统》这两门课应该不会陌生，至于掌握了多少，你懂得，都是在考前一两周突击学习的，哈哈。\n现在大公司对于应届生的要求越来越高，计网和操作系统这两门课是必考的。那些拿了 SSSP Offer 的大牛计算机基础都非常扎实。\n（1）计算机网络\n学什么？\n计算网络的协议非常非常多，很多同学学完都一头雾水，或者仅仅懂一点 HTTP，但是真正要掌握的东西可不少：\n\nOSI 七层模型、TCP/IP五层模型\n常见网络协议：HTTP、TCP/IP、UDP\n网络安全：非对称加密、数字签名、数字证书\n网络攻击：DDOS、XSS、CSRF 跨域攻击\n\n怎么学？\n计算机网络面试有一道非常经典的面试题：说说你从URL输入到最终页面展现的过程。这一题可以覆盖大部分计网的知识点，可以从 DNS 解析到 HTTP、TCP/IP协议、物理层协议，一直到浏览器渲染页面，你技术功底有多深你就可以聊多深。希望大家学完了也能试着回答一下这个问题。\n推荐几本倍受好评的书：《网络是怎么连接的》\n\n这本书是一本日本作者写的。文章围绕着在浏览器中输入网址开始，一路追踪了到显示出网页内容为止的整个过程，图文并茂生动有趣，非常推荐！\n\n《图解 HTTP》\n\n也是一名日本作者写的。这本书对 HTTP 协议进行了全面系统的介绍，列举了很多常见通信场景及实战案例，相信读完会有恍然大悟的感觉。书很薄，几天就可以读完，强烈推荐！\n\n《TCP/IP详解卷1：协议》\n\n计算机网络的经典教材， 大部头书籍，很难啃。建议挑重点看。\n\n最后安利一款工具，学习网络必备的抓包神奇：wireshark，如果你学网络没抓过包，那基本等于白学了（有点严重）。\n（2）操作系统\n学什么？\n作为一名 Javaer 在平时的工作中可能不会直接跟操作系统打交道，因为 JVM 帮我们屏蔽了众多差异。但是要想学好 JVM，懂一点操作系统更有助于你深刻理解 JVM 工作原理。\nJava 学习者这部分的要求可以稍微放低，但是你如果是搞 C++的，那这部分可是你的重点。\n\n进程和线程的区别\n进程间的通信方式：共享内存、管道、消息\n内存管理、虚拟内存\n死锁检测和避免\n\n怎么学？\n想要精通操作系统难度非常大，但是在面试中你要能讲出一些具体的操作系统知识，面试官会对你刮目相看。\n推荐一些视频学习资料：\nB 站：麻省理工 MIT 6.828（无字幕）：\nhttps://www.bilibili.com/video/BV1px411E7ST \n操作系统（哈工大李治军老师）32讲（全）超清：\nhttps://www.bilibili.com/video/BV1d4411v7u7\n推荐书籍资料：\n《深入理解计算机系统 CSAPP》\n\n赫赫有名的 CSAPP，全称：Computer Systems：A Programmer‘s Perspective。科班同学的圣经，哈哈，黑色大部头书籍，难啃。\n\n《现代操作系统 （第3版）》\n\n操作系统领域的经典之作，因为是翻译过来的，遇到比较晦涩的先跳过，多读几遍才能消化。\n\nJava 入门学什么？\nJava 语言从诞生到现在已经有20多年了，从Tiobe排行榜上来看，Java 语言常年霸榜经久不衰，所以不要怕学完 Java 后突然不流行了，至少这几年Java 就业机会非常多。\n如果你有其他语言的基础，比如之前学过 C、C++等，那学起 Java 应该是非常容易的，也容易上手。如果你没有语言基础，又不想了解太底层的东西，那学 Java 还是不错的。至于说 python，光从语言层面上看，python 确实非常简单，估计你一周内就可以学会并且代码写的还不错，但是 Java 不一样，一周你只能简单了解一下语法，想写好代码几乎不可能。另外 Go 语言势头很猛，大家也可以关注一下。\n一般来说 Java 入门你需要掌握下面这些知识点：\n\n面向过程 VS 面向对象\n面向对象基本特征：封装、继承、多态\n访问控制符：private、default、protected、public\n数据类型：基本类型、引用类型\n控制流程：for、while、switch 等\n序列化\n异常处理（有点难度）\n泛型（有点难度）\n\n怎么学？\n如果你是零基础，建议你可以找一些 Java 入门的视频看一下，网上视频鱼龙混杂，大家注意甄别。推荐一个比较好的平台：B 站（https://www.bilibili.com/） 不是让你去看二次元的，里面有很多学习资源。（嘿哈）\n敲黑板啦：视频不要贪多，因为没有一个大牛是看视频看出来的。 看视频是别人将知识点往你脑袋里灌，最大的好处是能让你快速入门，如果你想学到更多，你需要的是自我学习，带有思考的自我学习。\n看书是一种高效的自我学习方式，推荐基本比较好的书：\n《Java 核心技术卷I》\n\n这本书建议作为Java 之旅的第一本书，涵盖的内容非常全，比起那些30天学会 Java 之类的书，这边书更加务实。书中有些章节其实不用看，比如Swing GUI 的直接略过，因为用 Java 写桌面端应用已经过时了。\n\n《阿里巴巴 Java 开发手册》\n\n大厂阿里巴巴出品的，这其实是一本 Java 编码规范，编码习惯从一开始就要养好。\n\n《Java 编程思想（Thinking In Java）》\n\n这是一本非常非常经典的书，你要问搞 Java 的人如果没听过这本书那算是白学了，哈哈。其实说实话这本书我试图看过几次，最终都没有看完，一个原因是它太厚了，另外我觉得讲得太啰嗦了，所以我现在拿来垫桌子，高度合适挺好的。所以呢，建议新人不要一开始看这边书，不然你会怀疑人生还没入门就放弃了，就把它当做编程圣经，等你后面有经验了拿起来再翻翻吧。\n\n敲黑板了：学习编程要有耐心，不要急于求成，要打好基础。也许你一个月两个月还在运行一些简单示例，这是正常的，多学习多思考。\nJava 高手进阶学什么？\n恭喜你终于Java 入门了，大牛和菜鸟的区别在于菜鸟永远止步于入门水平，而大牛已经找到新大陆了，翻过这几座山你离高手就不远了。\nJava 高手进阶需要掌握的东西非常非常多，这里列举一些核心知识点，必须全部掌握的。这是 Java 面试高频考点，也是传说中 Java 八股文的一部分，面好了进入下一面，面不好回家等消息。\n\nJava 集合类源码\n线程池\nJava 代理\nIO 模型\nJVM\nJava 并发编程（JUC）\n\n怎么学？\nJava 已经入门了，你都想进阶了，建议你不要再找视频看了，一边看书一边思考吧。\n《Effective Java》\n\n书中列举了很多编程建议，其实就是告诉怎样去写好代码，你需要从能写代码（入门）过渡到会写代码，这本书值得一看。如果你的编码经验比较少，那这边书你可以稍微往后延，因为看完了你可能没有感同身受。\n\n《Java8 实战》\n\nJava15 都出来了为什么还要学 Java8 ？因为现在很多公司都还停留在 Java8， Java8是继Java5之后改动很大的一个版本，得好好学。Java8之后的版本非常不给力，换一个 JDK 版本费时费力，收益也不明显，公司肯定不愿意动了。这边书将 Java8所有的新特性都详细讲解了，非常推荐。\n\n《深入理解 Java 虚拟机 第3版》\n\n周志明大神写的，非常非常经典，已经更新到第三版了。Java 虚拟机也就是 JVM，JVM 是Java 面试必考的知识，不懂这个直接回家等消息吧。这边书我看了很多遍，每次看完都有新的收获，墙裂建议大家看完。\n\n《Java 并发编程的艺术》\n\n这是一本专门讲解Java并发的书，涉及到各种锁、常见安全的集合类，基本就是将 JUC（java.util.concurrent包的简称）里所有的内容覆盖了一遍，看完你一定有收获。强烈推荐！\n\n上面推荐的几本书可能不太容易读懂，建议多读几遍。书中看不懂的地方可以在网上搜，多找一些优质的博客或者公众号看。\n至此 Java 语言特性基本学习完了，就算达不到高手的水平，你也在正轨上了。\n基础框架（SSM）学什么？\n学习 Java 语言特性可能比较枯燥，接下来可以学习基础框架动手做一些项目，比如 Java 领域非常流行的 Spring 框架，这就是为 Java 后端量身定做的，非常好用。\n在 spring 流行之前，还出现 Struts 这样流行的框架，后面由于种种原因还是被 Spring 打败了。\n大家在网上应该可以经常看到 SSM 的缩写，其实就是Spring+SpringMVC+MyBatis的缩写了。\n你需要掌握以下这些：\n\nSpring 全家桶（Spring、Spring MVC、Spring Boot）使用\nORM 框架（MyBatis、Hibernate）使用\nSpring 原理\nORM 框架原理\n\n怎么学？\n学习 SSM 框架最好是动手完成一个简单的项目，建议跟着视频并且把代码敲出来，一来熟悉项目的开发流程，也可以给自己带来成就感。\n敲黑板：阶段性成就感非常重要，没有这个很容易放弃学习，所以要不定时给自己定个小目标，加加鸡腿啥的。\n有很多新手在做项目的时候非常纠结界面，作为一个 Java 后端程序员，你又不是全栈开发，纠结这个干什么，我的建议：要么不要界面只写接口，要么自己动手写点 html，不需要美观，实现功能即可。\n跟着视频做完项目之后需要干什么？答案是：深入理解框架原理。会用框架并不代表你懂框架，作为一个有追求的程序员，懂原理是永远的必修课，谁让这一行太卷了呢，人无你有你最棒。\n推荐几本书：《Spring 基础内幕》\n\n首先声明一下这是一本讲解Spring 源码的书，不是教你做项目的书。如果需要深入理解 Spring 的技术原理，这是一本非常推荐的书。有点难啃，多读几遍。\n\n《MyBatis 技术内幕》\n\nMyBatis 是 ORM 框架的一种，在国内使用比较多，据说在国外喜欢用 Hibernate。这本书对 MyBatis 的使用和基本原理都介绍比较清楚了。\n\n敲黑板：技术更新迭代很快，抓住技术的本质才能与时俱进。\n关于基础框架这部分，大神们的学习方法是：使用框架 -&gt; 懂框架 -&gt; 造轮子。\n微服务框架学什么？\n近些年微服务架构非常火，究其原因是因为传统的单体架构和面向服务的架构逐渐不能满足互联网快速迭代的需求。微服务可以更容易提供持续继承和持续部署的能力，让产品更快速交付推向市场。\n面向服务的架构其实在五六年前就已经提出，期间经过了一段低潮期，泡沫散去后逐渐浮现了一些好用的框架，国外以 SpringCloud 为代表，国内以 Dubbo 为代表。\nspringCloud 和 Dubbo 有区别但是很多基本原理也是类似，大家学习的时候需要掌握技术的本质。下面列举一些核心知识点：\n\nDubbo框架\nSpringCloud框架\n服务注册与发现\n分布式服务链路追踪\n服务隔离、熔断、降级\n服务网关\n\n怎么学？\nspringCloud 和 Dubbo 在官网都有很详细的介绍文档：\n\nDubbo官网 http://dubbo.apache.org/ 可以切到中文版\nSpringCloud 官网 https://spring.io/projects/spring-cloud\n\n看官网技术文档大家可能会很懵，但这些确实是最权威的资料，也是一手的。\nSpringCloud 和 Dubbo 是这几年刚刚流行的技术，从目前看来相关书籍还是比较少，也缺少一些经典的书，我还是列几本，大家按需获取。\n《深入理解Apache Dubbo与实战》\n\nDubbo 最开始是阿里巴巴开源的，后面捐赠给Apache 了。建议大家读这本配合源码一起看。\n\n《Spring Cloud微服务实战》\n\n读这本书之前你最好先学习 spring 和 spring boot，不然会很懵。另外这本书是2017年出版的，稍微显旧，大家注意分辨新旧特性。\n\n如果技术网站和书籍还不能满足你，建议你去搜一些视频学习，这里不做推荐以免认为是广告。推荐搜索平台：B 站、慕课网、网易云课堂。\n敲黑板：微服务框架涵盖的内容非常多，也是有难点的技术，大家戒躁保持耐心。\n\n常用中间件学什么？\n最终用户并不直接使用中间件，换言之中间件不是大众消费类软件产品。但是在大公司里中间件是不可或缺的，它是支撑大型网站架构的一些基础的组件和服务，所以非常非常有必要学。\n\n小百科 中间件（Middleware）通常是指在一个大型分布式的系统中，负责各个不同组件（Component）/服务（Service）之间管理以及交互数据的。\n\n业界开源的优秀中间件非常多，通常会根据业务的需要在系统中引入若干，下面列举了一些常见的，都是必学的，非可选哈。\n\n缓存：Redis、Memcached（ 推荐 Redis）\n消息队列：Kafka、RocketMQ、RabbitMQ、ActiveMQ、ZeroMQ（推荐 Kafka）\n数据库中间件：ShardingSpere、Mycat\n\n怎么学？\n每个中间件涵盖的内容都非常多，要想学精需要大量时间。\nRedis 中文官方网站：\nhttp://www.redis.cn/\n当做字典学习 redis 常见命令\nKafka 官网：\nhttp://kafka.apache.org/\nShardingSpere 官网：\nhttp://shardingsphere.apache.org/index_zh.html\nMycat 权威指南在线 PDF 版：\nhttp://www.mycat.org.cn/document/mycat-definitive-guide.pdf\n推荐几本相关的书：《Redis 设计与实现》\n\n这时Redis 口碑比较好的一本书，书中详细讲解了 Redis 实现原理，如果你只是想学会怎么用，可以跳过一些章节。\n\n《深入理解Kafka：核心设计与实践原理》\n\n这本书既适合新手入门扫盲也适合高手进阶，想知道怎么用看前四章即可，想深入学习可以从第五章开始看，写的非常好，推荐学习！\n\n《分布式数据库架构及企业实践——基于Mycat中间件》\n\nMycat 相关的书非常少，这本书是16年写的，有些陈旧了，如果对 Mycat 非常感兴趣可以简单翻一翻，但是不是特别推荐。\n\n书看完了你还想深入学习，建议大家关注一下极客时间的两门课：胡夕：《Kafka核心技术与实战》，老师是Apache Kafka Committer，很专业。蒋德钧：《Redis核心技术与实战》\n不过课程是付费的，手头紧的建议慎重哈。免费资源网上也有，靠大家搜索了~\n中间件的学习是一个漫长的过程，不仅需要很多理论知识还需要实践经验。\n比如你学 Redis 的时候，要思考五种基本数据类型各自使用场景、布隆过滤器是什么原理、用 Redis 怎么实现分布式锁，带着问题去学习效率非常高。\n比如你学 Kafka 消息队列，要对比常见消息队列的优缺点、Kafka 为什么吞吐量高、Kafka 会不会丢消息以及怎么解决。\n比如你学数据库中间件，要想数据库为什么要分库分表、分库分表 ID 如果处理等等。\n数据库学什么？\n数据库非常重要，面试也是必考的，可以考的点非常多，可以考得很浅：问一下 SQL 使用，也可以考的很深：问索引和锁的实现原理。下面列了一些常见的知识点。\n\n数据库基本理论：范式、索引原理、数据库引擎\nSQL 基本语法\nSQL 调优，explain 执行计划\n数据库事务（ACID）\n数据库锁：乐观锁、悲观锁、表锁、行锁等\n\n怎么学？\n建议数据库零基础的同学还是要先学习一下数据库的基本理论，因为我看到很多人都是一上来就学 SQL ，最终也只是会用而已，到后面 SQL 调优的时候就很迷茫了。如果你只是想用一用数据库，这部分也可以跳过。\n关于原理部分有一本非常经典的教材《数据库系统概念》以供学习，经典书籍一般都比较难啃坑也比较厚，建议大家先看目录，挑重点看。大学学过这本书的可以直接跳过了。\n有了一些理论后就可以开始学习 SQL 语法了，这里推荐一本《MySQL 必知必会》，一边看书一边对着电脑敲。\n当然面试大厂肯定会问一下比较难的东西，你需要搞懂索引的原理、事务 ACID、锁，问数据库这些东西必考哦！\nMySQL 学习书籍清单：《数据库系统概念》\n\n经典数据库教材，理解一些基本原理，可略看。\n\n《MySQL必知必会》\n\nSQL 语法入门好书，推荐！\n\n《MySQL技术内幕 : InnoDB存储引擎》\n\n数据库进阶必看，理解存储引擎以及事务、锁、索引等原理。\n\n分布式架构学什么？\n分布式这一部分就是面试的加分项了，答好了面试官会觉得你技术功底深厚，答不好，只要你前面的基础还不错也能过。所以呢，作为一个有追求的技术人，千万不要放过加分的机会。\n分布式相关的内容非常多，下面列举几个在项目中或者面试中经常会遇到的知识点：\n\n分布式事务：两阶段提交（2PC）、补偿事务（TCC）\n分布式锁：基于关系型数据库（MySQL）、基于 Redis、基于Zookeeper\n分布式 ID：雪花算法（Snowflake）、美团 Leaf\n\n怎么学？\n这部分内容学好非常难，在很多书中都是轻轻带过，没有深入讲解原理，所以就不推荐书了。\n那怎么学呢？大家可以针对每个知识点到网上搜索优质的博客，后面我也会逐步更文讲解这些知识点，敬请期待，欢迎催更哟。\n必须掌握的工具软件工欲善其事，必先利其器。作为一个 Java 开发人员，你需要学习业界常用的软件，软件工具用得越熟你的编码效率越高，下班的时间可能越早（打工人太难了）。\n\nJava 最聪明的 IDE：IntelliJ IDEA （请放弃使用 Eclipse，我有一堆理由睡服你）\n地球上最好用的版本管理工具：Git\n经久不衰的依赖管理工具：Maven\nDocker\n\n这些软件你要是用不好，那只能说明…… 你再多学学吧。\n学习资源网站列表汇总（1）视频网站\n\nB站（推荐）：https://www.bilibili.com/\n网易云课堂：https://study.163.com/\n极客学院：https://www.jikexueyuan.com/\n慕课网：https://www.imooc.com/\n\n（2）专栏\n\n极客时间（推荐）：https://time.geekbang.org/\nGitchat https://gitbook.cn/\n\n（3）Github\n\nJava 知识地图（推荐）：https://github.com/smileArchitect/JavaMap\n\n（4）技术博客：\n\nCSDN 博客：https://blog.csdn.net/\n博客园：https://www.cnblogs.com/\n掘金社区（推荐）：https://juejin.cn/\nInfoQ：https://xie.infoq.cn/\n思否：https://segmentfault.com/\n开源中国：https://www.oschina.net/blog\n\n（5）搜索引擎：\n\n百度：https://www.baidu.com/\n谷歌：https://www.google.com/\n\n（6）知识问答：\n\n知乎（推荐）：https://www.zhihu.com/\nstackoverflow（推荐）：https://stackoverflow.com/\n\n（7）刷题：\n\n力扣（推荐）：https://leetcode-cn.com/\n牛客：https://www.nowcoder.com/\n\n（8）云笔记：\n\n石墨：https://shimo.im/\n语雀：https://www.yuque.com/\n有道云笔记：http://note.youdao.com/\n印象笔记：https://www.yinxiang.com/ 看个人习惯去选择，不推荐了。\n\n（9）在线画图：\n\nprocessOn：https://www.processon.com/\ndrawio：https://app.diagrams.net/ 各有特色，都推荐。\n\n学习常见问题（FAQ）学了容易忘怎么办？\n这是大家学习会遇到的头号大问题，怎么解决？重复学习。\n打个比方，假如你正在学习 spring 注解，突然发现了一个注解@Aspect，不知道干什么用的，你可能会去查看源码或者通过博客学习，花了半小时终于弄懂了，下次又看到@Aspect 了，你有点郁闷了，上次好像在哪哪哪学习，你快速打开网页花了五分钟又学会了。\n从半小时和五分钟的对比中可以发现多学一次就离真正掌握知识又近了一步。\n人的本性就是容易遗忘，只有不断加深印象、重复学习才能真正掌握，所以很多书我都是推荐大家多看几遍。哪有那么多天才，他只是比你多看了几遍书。\n推荐这么多书都要看完吗？\n当然不是！有一些书都是同类型的，作者写书的侧重点不一样，大家要学会挑重点看。\n拿到一本书，首先要把目录多看一遍，一般而言书的前几章都是介绍型的内容，如果你已经有了基础，可以直接跳到后面原理解析或者实战部分。\n需要学多久才能成为技术大牛？\n学习无止境！\n\n业界说法，通过不断努力学习，一到两年可以达到初级水平，三到四年达到中级水平，五年可以达到高级水平。\n实际上每个人的学习能力和精力不一样，时间参考意义不大。\n只要你在一个方向或领域有自己的建树，就可以叫你大牛；如果你在公司是技术骨干、技术专家、架构师，也可以称之为大牛。\n敲黑板：技术学习千万不要浮躁，谦卑一点多学一点，天外有天。\n\n现在 python、Go 语言很火，要不要直接学它们？\n不要纠结语言，语言只是工具。今天 Go 很火，明天会有其他语言。\n我有一个同学毕业去阿里写 Java，后面跳槽到深圳腾讯写 C++，现在又跳到字节跳动写 Go，在大佬面前这些语言只是语法不一样而已。\n所以建议大家打好基础，答应我一定打好基础。\n","categories":["Java"],"tags":[]},{"title":"梭哈200多万","url":"https://tanqingbo.cn/梭哈200多万/","content":"我有个习惯，就是每个月都会盘点一下各个账户的收益。\n昨天我去盘点了一下我的各个账户，发现这个月的投资套利收益竟然超过了3万多，这个收益还是有点开心的。\n\n其中黄金账户涨了近6个点，收益2.2w，黄金从去年3月份开始就一直加仓，中间被套牢了很长一段时间，最高回撤超过了10%，有一段时间日均亏损三四千，记得当时亏损的睡不着觉还发了条朋友圈，然后到今年5月份终于要回本的时候，有一种扬眉吐气的感觉。\n\n然后月初买了点有色金属期货ETF，赶在上涨之前做了次短线，吃了点小肉，还有一部分收益是打新申购京东物流的收益，这也是我今天想要说的重头戏。\n在聊打新之前，一定要交代一下公司发行股票的流程：公司在上市（IPO）发行股票之前，会先以特定价格流到一级市场里，大部分（90%）会卖给机构，小部分（剩下10%）会给散户申购。港股打新，其实就是以发行价对即将在香港上市的这些新股进行申购。 如果申购的人很多，那么僧多粥少，必然只有一部分人才能申购成功，即中签。\n中签之后便可以在上市的前一天暗盘中卖出，这算是一种风险较低的套利方式，当然如果你看好这家公司，也可以长期持有他们家中签的股票，博取更大的收益。\n而前面说的京东物流，就是最近在港股上市的公司，经常在京东买东西的同学应该知道，只要标了京东物流的商品，送货速度都贼快，差不多上午下单，下午就能给你送到。\n但是大家不知道的是，在2020年整个中国物流业产业陷入产能过剩，「三通一达」增速下滑至10%的情况下，京东物流在东哥的带领下逆势增长47%，唯一能和京东物流掰腕子的顺丰，去年的增速是37%。\n所以这么优质的公司赴港上市，我肯定也是去打新申购了，我准备了21个账户，融资240多万申购了560多手，最后中了6手，还算运气不错吧！\n\n昨天上市之前，暗盘上涨了30%，不过我没有出手，原因前面也说了，而且最近还有618购物节加持，长远来看应该还有不少涨幅，所以我选择长期持有。\n当然我还是要提醒一下，市场套利的骚操作虽然很多，但是建议大家还是不要轻易all in去买股票（零花钱玩玩可以），前段时间我不是说我第一次买股票梭哈十几万，结果一个月内暴跌30%嘛，暴跌30%，心态崩了 |  IT码农 (tanqingbo.cn)，但是买的黄金ETF，一年多时间最大回撤才10%，这个涨跌幅度大家自己对比一下。\n一年回撤10%我都有点受不了，一个月亏损30%更加刺激，大家自己掂量一下，就像那句话说的：因为认知不够和太懒的原因，我们错过了多少次倾家荡产的机会。\n虽然听起来有点冷幽默，但真是这样的。\n","categories":["技术以外"],"tags":[]},{"title":"卧槽，我的小破站爆了！","url":"https://tanqingbo.cn/卧槽，我的小破站爆了！/","content":"说件比较丢人的事，去年不是因为疫情的原因一直呆在家里嘛，然后忘记给自己的博客网站域名续费了，这导致整个网络都搜索不到我的博客内容。\n要知道我的网站一直坚持更新了5年多时间，记录了我这几年来的技术学习笔记以及个人成长经历，而且搜索引擎的权重还蛮高，经常能在搜索引擎中搜到我的网站内容，也就是说这个网站其实不需要怎么维护它就自带流量和影响力。\n但是现在域名没了，相当于前面那几年积累的影响力以及流量全没有了，当时一度有想抽自己的感觉。\n不过好在内容我有备份，吸取经验和教训之后我又重新买了一个域名去搭了一个新的网站，新的域名就意味着它没有在网络上留下任何的信息，也不会被任何的搜索引擎收录。\n一切又得重头再来，不过好在功夫不负有心人，我把原有的内容重新分类整理了一下，又新增了很多干货内容，经过几个月的维护，现在新的网站已经初具规模，而且渐渐的，网站上的内容也被很多朋友看到了，目前累计总访问量已经超12万！\n\n现在这个网站上不仅有各种技术文章和学习教程，还提供了程序员学习需要的各种书籍下载和工具推荐。\n点击导航栏上方的【电子书下载】可以找到我整理的几百本计算机电子书，基本上只要你想要找的专业书籍都能在上面找到，每一本都可以直接下载：\n\n数据结构与算法栏目中包含了大部分程序员需要的掌握的经典算法详解：\n\n具体内容就不一一列举了，大家可以自己上去看一下，点击右下角的阅读原文就可以跳转到我的网站，建议用电脑打开，体验更好一些。\n","categories":["技术以外"],"tags":[]},{"title":"暴跌30%，心态崩了","url":"https://tanqingbo.cn/暴跌30心态崩了/","content":"给大家分享一下我的股票投资经历吧！\n在我还没有办港卡之前，经常听到一个声音，就是港美股10年长牛，闭着眼睛买都能涨。\n在这之前我已经在基金市场通过基金定投赚了小十几万，我觉得凭着我这个经验，冲进港美股市场，怎么滴也能赚钱吧！\n于是我几番周折，搞定了香港银行卡，换了几万块钱港币，准备冲进股市大干一场。\n当时我选了3支股票，分别是：美团、B站、拼多多。做为一颗老韭菜，经验还是有一点点的，肯定不能上来就梭哈啊，先每支股票买几千块钱，观察一下它们的走势，然后再逢低加仓。\n我选的这几支股票也比较争气，买入没多久就迎来了大跌，单日跌幅接近10%，跌这么多还上了热搜呢！没见过大场面的我觉得这应该就是加仓的机会吧！\n\n于是我又赶紧换了几十万港币，除了用来打新的钱以外剩下的全都ALL IN了股票，果然不出意料，第二天就赚了2万多，卧槽，这操作感觉自己就是股神在世啊！\n再后来，B站在北邮校招面试，面试官歧视北邮同学，这个负面新闻在热榜上挂了好几天，具体情况可以看这篇文章B站向北邮道歉！,本来以为B站股票会跌，可是它不仅没跌，反而还涨了很多，虽然不知道为什么，但是很明显，这已经完全让我忘记了自己是个菜狗。\n当时我的股票账户累计收入一度超过4万块，这可是进入股市才一个多月的成绩。\n可是接下来就没这么香了，让我们来看这一连串的新闻：\n1、腾讯联合500多个艺人抵制影视剪辑视频内容，矛头直指B站；\n\n2、北京副局长体验骑手一天赚41元，美团被约谈；\n\n3、拼多多被消保委约谈；\n\n4、市场监管局对美团涉嫌垄断行为调查；\n\n写这篇文章的时候，我特意去梳理了一下最近的新闻，发现这些新闻好像故意针对我一样，只要是和互联网公司相关的负面新闻，全和我买的股票有关系，一个都没有错过。\n之后股票的走势就很显而易见了，我买的三只股票纷纷齐刷刷的下跌，到现在（5月18号），美团已经亏损25%、拼多多亏损20%、B站亏损10%，近20万现金流被牢牢套住。\n不过现在我已经老实多了，老老实实去补股票相关的知识，去关注市场行情、去关注政策变化。\n认知以外的钱就算你运气好赚到了，市场也会有一千种办法收割回来的。\n不过我还是建议男生去学着买股票，当然最终目的不是为了赚钱，而是要在这个过程中提升自己。看着股票的涨跌，不知道了，就会去学经济学，想寻找好的股票，就要去研究企业，于是就要去学统计学和管理学，看到很多财报，看不懂吧，就要去研究会计学，很多新闻专业词汇看不懂了吧，就要去研究金融，过程中感受到自己情绪诸多的变化，就要去研究心理学，在中国还要去学点政治学……\n学无止境，随着中国的发展，投资是每个人必然会涉及到的道路，何不早点开始。\n但是记住千万不要all in，拿一点点闲钱出来去学习就可以了。\n","categories":["技术以外"],"tags":[]},{"title":"哪本入门级的学习数据库的书最值得推荐？","url":"https://tanqingbo.cn/哪本入门级的学习数据库的书最值得推荐？/","content":"数据库的确是软件开发者需要掌握的一项“硬技能”，选书学习的时候最好避开那些通篇都在讲“发展史”的书籍，选择偏实践性的，否则花了半天时间看完书也不知道拿数据库怎么办。回想我自己学习数据库的时候，也是读了很多各式各样的书，但真正能提高技能的不多。结合我自己的学习经历，给大家推荐6本真正能够优化你编程思路和方法的书，希望能够帮到你，加油！\n一、入门1、《Mysql必知必会》这本书是我数据库的入门书籍，虽然上大学的时候学校也开了数据库的课程，但是还是觉得这本书讲的比我们老师好，作者Ben Forta是世界知名的技术作家，很适合数据库入门的时候看，内容轻松，简单又实用。\n2、《SQL查询的技术》讲述数据库基础和SQL技巧详解，SQL查询的艺术 ，其中包含287个典型实例，涵盖常见SQL应用，都是程序员须学习和掌握的SQL。\n二、进阶1、《MySQL技术内幕——InnoDB存储引擎》每个行业都有几本被翻来翻去的“街书”，而本书就是MySQL的“街书”，该书目前已经有了三版。\n从源代码的角度深度解析了InnoDB的体系结构、实现原理、工作机制，并给出了大量最佳实践，能帮助你系统而深入地掌握InnoDB。注重实战，全书辅有大量的案例，可操作性极强。\n2、《深入浅出MySQL》这本书适合有一点点MYSQL使用经验的同学看，该书从数据库的基础、开发、优化、管理维护和架构5个方面对MySQL进行了详细的介绍，讲的不算特别深，但是足够我们使用了。\n三、强化1、《MySQL技术内幕InnoDB存储引擎》看完上面几本书，你算是对MYSQL比较熟悉了，不过对于面试中常考的innodb引擎，还是推荐一下这本书，专门讲解innodb存储引擎相关内容，足够你学好innodb了。\n2、《高性能MySQL》主要讲解真实环境下如何使用MySQL的复制、集群和监控特性，揭示MySQL可靠性和高可用性的方方面面。此书定位于解决MySQL数据库的常见应用瓶颈，在保持MySQL持续可用性的前提下，挖潜各种提高性能的解决方案。非常厚的一本书，讲的太详细了，适合BDA阅读。\n上面推荐的基本书建议大家购买正版阅读，此外也给大家提供电子版的下载地址：\nhttps://tanqingbo.cn/CSBook010/\n","categories":["编程资料"],"tags":["电子书下载"]},{"title":"蔚来，牛逼！","url":"https://tanqingbo.cn/蔚来，牛逼！/","content":"不知道什么鬼，最近特别喜欢关注与新能源车相关的消息，这感觉就跟之前看手机发布会的感觉一样，经常就是：\n“卧槽，这功能我喜欢~”\n“这造型也太帅了吧！”\n然后自己也跑到线下体验过两款新能源车，分别是特斯拉和蔚来。\n从前面看，特斯拉model 3和model Y的造型差不多，科技感十足，是我喜欢的那种造型，但是平时在马路上看到model 3的时候，总感觉它有点发育不正常，看起来太小了。\n\n内饰方面的话，特斯拉的内饰是真的简洁，坐进去，里面除了一块屏幕之外，没有任何一个多余的按钮，喜欢简洁的人会特别喜欢特斯拉的这种内饰风格，但是对于不喜欢的人来说，可能会觉得有点简陋。\n\n因为当时在线下体验特斯拉的时候，没有导购员在旁边介绍，所以下回再找时间和大家细聊一下特斯拉，今天我们主要还是来聊一下蔚来。\n去线下体验蔚来算是巧合，当时正在长沙逛街，准备去吃小龙虾，碰巧那家小龙虾店要中午才开门，有碰巧旁边正好有一家蔚来体验店，于是我们就去体验了一下，简单和大家分享一下我的体验感受：\n1、坐乘体验我当时体验的是ES8这款车型，驾驶座位坐上去之后，它会自动根据驾驶人的身高体重调节座位和后视镜的位置，我当时坐上去之后就感觉座位自动调整了一下，科技感还是满足的。\n副驾驶女王座，活脱脱一个窄版芝华士沙发，可以一路躺着玩手机，空间特别大，基本上不会有乘坐的疲劳感。\n此外，因为ES8它是三排7坐的，第二排座位可以前后移动改善后排空间。\n\n不足的地方就是，感觉第三排车窗太小，有点拥挤的感觉，坐在第三排的人可能会有点闷。\n2、电池续航一般新能源车最贵的地方就是电池，所以其他品牌的汽车都把电池当作了汽车的卖点之一，和汽车做成了一体。\n而蔚来和大家不太一样，它走的是换电池的路子，所有的车都可以在他们的换电站换电池，这样做有什么好处呢？\n就是新能源车通常被人诟病充电太浪费时间了，汽油车两三分钟可以加满油，但是新能源车至少要一个多小时才能充满电，蔚来换电池的方式就解决了这个焦虑，电池没电之后直接给你换新电池，和加油的速度差不多。\n此外，蔚来还有每年12次免费加电服务，这个是比较吸引我的地方，就是比如你过年开车回老家走亲戚，而老家既没有充电站，也没有换电站，这个时候就会有没电的焦虑，甚至不敢开车回去。\n加电服务就是，不管你在哪个角落，只要车没电了，蔚来工作人员会立刻上门给你充电。\n当然这只是他们给我介绍的样子，具体服务体验还有待进一步考证。\n3、语音助手蔚来的语音助手叫：NOMI，取自英文 Know Me 的谐音。如果你用过小爱同学的话差不多就知道NOMI是啥样了。\n车上的绝大多数功能都可以通过NOMI来控制、比如：车窗、空调、音乐、导航等等，并且可以连续对话，不用每次对话前重新唤醒，这个还是比较难得的。\n当时体验的时候，各种对话衔接都比较流畅，但具体上路的情况就不得而知了，下次有时间的话，准备带着驾驶证再过去上路体验一下。\n\n最后最近这两年在街上看到蔚来的概率好像越来越大了，车的辨识度也很高，从众多车队里面开过来的时候，会明显感觉蔚来的颜值比周围的车高很多。\n\n值得一提的是，蔚来ET7明年也要开始交付了，从外形上来看，真的特别能打，并且率先使用了半固态电池，据说最高续航可达1000KM，大家可以期待一下。\n","categories":["技术以外"],"tags":[]},{"title":"微信Windows 3.3.0内测更新，电脑可以刷朋友圈了","url":"https://tanqingbo.cn/微信PC版3.3.0内测更新，电脑可以刷朋友圈了/","content":"刚过完五一，第一天上班是不是有点打不起精神啊！\n来，我告诉你一个好消息，你可以在电脑上摸鱼刷朋友圈了，激不激动！\n因为微信刚刚发布了Windows 3.3.0内测版本，这次内测带来了之前没有的一些新功能，大家期待已久的在电脑上刷朋友圈的功能也安排上了。（文末附内测版下载链接）\n\n虽说Mac端在一个多月前就已经可以刷朋友圈了，但是Mac端的用户毕竟是少数，大多数人的电脑使用的还是Windows系统，那本次Windows微信内测更新，带来了哪些新功能呢，下面就带大家来看一下。\n- 朋友圈\n终于，微信在Windiws微信3.3.0版本中，带来了浏览朋友圈的功能，也就是说你可以通过PC端微信刷朋友圈，上班时间摸鱼了。\n点击左侧的「朋友圈」图标，即可进入电脑端朋友圈页面，目前仅支持点赞、评论朋友圈好友动态，暂时无法发布动态。当朋友圈出现与自己相关的动态消息时，则会有消息数字提醒显示。\n\n- 搜一搜升级\nWindows微信内测更新后，改进了搜一搜功能，支持搜索公众号、小程序、表情、文章、朋友圈等内容，搜索下方还会推荐相关的热点。，这对于上班族群体来说，十分友好且方便。例如需要搜索某个公众号、小程序、视频号，之前则需要回到微信移动端，而现在则可以在电脑端实现。\n\n- 微信Windows 3.3.0内测版下载方式\n戳下方链接即可下载：\n微信Windows 3.3.0内测版下载地址！\n","categories":["技术以外"],"tags":[]},{"title":"卧槽，我被盗号了~","url":"https://tanqingbo.cn/卧槽，我被盗版了/","content":"事情是这样的，昨天下午，我正在一边摸鱼、一边发公众号的推文，在推文进行到最后一步的时候，我想在文章的底部插入我自己公众号的卡片，然后搜索了一下我自己公众号的名字，神奇的事情发生了！\n\n我搜索「轮子工厂」竟然出现了两个公众号，左边的公众号「轮子工厂：懂点技术，会讲故事，有点意思！」是我注册的，右边的公众号，虽然是用我的照片作的头像，还写着我名字【知乎大V→谭庆波】，但是我也是昨天才知道有这个号的存在。\n很明显我是被某个同行盗版了，然后我点进这个盗版账号的详细页面看了一下，发现这个账号去年12月1号就已经注册了。\n\n知道这个结果，我也是心头一惊，还不知道这家伙顶着我的名号干了什么坏事。于是我赶紧去把这个账号最近的文章看了一遍，发现这个账号所有的文章最终的目的都是为了给一个微信账号引流，每篇文章的末尾都用红色粗体字提醒大家加他的微信，于是我用小号去加了一下他的微信，搜出来的是一个叫：“星哥自媒体”的人，个性签名写着：专注于自媒体一对一教学。\n\n到这其实我已经差不多明白是怎么回事了，这个人应该是注册了不少这种盗版的公众号，比如我的公众号叫「轮子工厂」，他就注册一个公众号叫「轮子工厂丿」，然后用我的照片作头像，公众号的介绍也用我的介绍，这样就会让大家误以为这是我的公众号。\n因为我的号每天都会有不少的新增关注，有一部分人是通过微信搜索框搜索，然后再关注的，但是微信搜索框搜「轮子工厂」会出现两个号，如下图，第一个是我的号，第二个是盗版的号，一些不明所以的同学可能就会关注第二个号。\n\n说白了，他们的套路就是，先注册一批大V的盗版账号，因为这些大V本身就自带流量，这样就可以在微信上截流，白嫖这些大V的流量，然后再在公众号上面引导粉丝加微信，卖课程、割韭菜，可以说是非常坏了！\n其实要找到他们也很容易，盗版公众号的账号主体隶属于「阳春市盆很日用品」，用天眼查搜一下这个名字，发现他们的法人叫任望，详细地址也有。\n\n然后他们在文章中留下的微信号叫：星哥自媒体，通过百度搜索这个关键词又找到了他们的西瓜账号和B站账号。\n\n到这已经不想继续深挖了，我只想说，任何一门赚钱的生意一定都是建立在利他之上的，圈子其实很小，这种损人利己的方法，一旦被曝光，基本上也相当于被判了死刑，因为没有人会想和这种伙伴合作。\n也提醒大家一定要擦亮眼睛，我从来没有用自己的照片当作公众号和视频号的头像，也从来没有在介绍里面说自己是知乎大V，更不会收费教大家做自媒体，公众号「轮子工厂」请大家认准下面这个，除这个以外，其他都是盗版，谨防上当受骗。\n","categories":["技术以外"],"tags":[]},{"title":"长沙，其实挺好的！","url":"https://tanqingbo.cn/Changsha-really-fragrant/","content":"前两天和朋友在长沙去看了洋湖那边的房子，房价真的很友善，当然我不是现在要买房，还没有拿到购房资格，因为我本人就是湖南的，未来大概率会在长沙这边发展，所以先过来了解一下情况。\n今天主要想和大家聊一下我了解到的长沙！\n\n说到长沙，绕不开的一个话题就是长沙的房价，在新入选的15个新一线城市当中，长沙的GPD排第8，但是它的房价却稳居倒数第一。\n\n其他经济总量和长沙差不多的城市，房价至少是长沙的2-3倍，长沙均价最高的核心市区开福区，楼房均价1.1万，而远郊的浏阳区，均价更是低至7000元。7000是什么概念，很多五六线的小城市房价都快要破万了。虽说房价低不一定都是优点，但是对年轻人来说还是挺友善的。\n此外，长沙的教育和医疗在全国也是名列前茅的，3所985、4所211，国防科大和中南大学都是可以去争前10排名的。然后四大名校集团：长郡、雅礼、师大附中、一中，每个集团都很厉害，各自旗下的小学初中普遍不错，而且在全国每年保送清华北大的人数排名上，长沙的四大名校基本上都能进前十。\n\n医疗方面的话，在我国有一句经典的话：“北协和、南湘雅、东齐鲁、西华西”。这句话指的是，根据地域分布，代表我国医学最高水平的四所医学院：北京协和医学院、中南大学湘雅医学院、山东大学齐鲁医学院、四川大学华西医学院。\n而中南大学的湘雅医学院就是在长沙，年轻的时候可能不太能了解医疗资源的重要性，但是等人过了30岁，上有老下有小，身体不舒服的时候能随时看上优秀的医疗资源，心里就会安心很多。\n说了不少优点，长沙的缺点其实也不少，牛逼的科技公司几乎没有，工资也是偏低的，说个真事，因为我自己在长沙注册了个公司，然后就在某招聘平台发布了一则招实习生的信息，发布没多久，该平台的工作人员就给我打电话，说我填的薪资对实习生来说偏高了，建议修改，否则如果招到人最后没有开出这个工资会对公司的信用有影响。\n虽说工资偏低，但是在长沙1w-2w月薪的工作也还是能找到的。\n市内的交通也一般，交警管的好像不是很严，因为我当时是从湘潭叫顺风车去的长沙，司机就跟我们吐槽：在湘潭开车经常被贴罚单，长沙就很友善，很多车停在大马路边也不管。说着司机就准备超车，然后我提醒司机咱压实线了，他说这在长沙没事，然后“嗖”的一下就开过去了，特别逗。\n再一个就是，长沙的雨水是真的多，动不动就下雨，他们本地人说，一年有一半的时间都在下雨，夏天下雨、冬天也下雨，而且冬天下雨的时候还特别冷。\n当然一个城市不可能十全十美，有吸引人的地方，也会有很多槽点，只要这些槽点不足以动摇你大方向上的幸福，那就是一个很不错的选择。\n从这个角度上来说，我觉得长沙，其实还挺不错的，希望它越来越好！\n","categories":["技术以外"],"tags":[]},{"title":"小白第一次买笔记本电脑需要注意什么？","url":"https://tanqingbo.cn/Buying-computer-for-the-first-time/","content":"本文目录：\n一、购机之前按须知\n二、高性价比电脑推荐\n三、个人建议\n\n一、购机之前须知1、购机渠道\n作为一个新手小白，第一次买电脑的时候可能会纠结到底是在线上买还是线下买，线上不靠谱怎么办？线下的实体店会不会杀价？\n其实大可不必有这些纠结，都2021年了，在电子产品价格高度透明的今天，建议大家线上购机，不建议线下购机，个人推荐的购机渠道为：京东自营-&gt;天猫、苏宁官方旗舰-&gt;官方网站-&gt;品牌授权店。\n2、配置参数\n我们在网上购机的时候可以看到一大堆关于该电脑的配置参数，对于一个小白来说，可能看完了也分不清电脑的好坏，那么电脑的配置该怎么看呢？\n一般地，我们主要看一台笔记本电脑的这些配置参数：CPU、显卡、内存、硬盘、屏幕、尺寸等。\nCPU：也称中央处理器，目前市场上笔记本电脑搭载的CPU主要来自Intel和AMD两家，也就是我们常说的酷睿版（搭载Intel）和锐龙版（搭载AMD）。\nIntel（酷睿版笔记本电脑）主流的CPU型号是10代i5、10代i7和11代i5、11代i7。AMD（锐龙版笔记本电脑）主流的CPU型号是R5、R7和R9。\n由于锐龙版有补贴，同一型号的笔记本电脑，锐龙版要比酷睿版便宜，但是酷睿芯片集成程度高，在性能上要优于锐龙版。\n至于那个型号的CPU更好，这就要结合电脑的显卡、使用环境的等因素来综合考量了，不同型号的CPU测评性能排行榜如下：\n\n显卡：也就是我们通常说的GPU，也叫图形处理器。主要做图像和图形相关的运算工作，会帮CPU 分档一些负担，运算能力大于CPU，如果你经常玩游戏的话，那一定要选择自带显卡的笔记本电脑，否则体验会很不好。\n而显卡也分独立显卡和集成显卡，一般来说，集成显卡的性能比不上独立显卡，具体显卡的型号可参考：\n（1）目前轻薄本主流的显卡为MX350、MX450、锐炬显卡（为集显）和R5/R7集显。\n（2）目前高性能本和游戏本主流的显卡为GTX 1650、GTX 1650ti、GTX 1660等；RTX2060、RTX2070、RTX3060、RTX3070、RTX3080等。\n内存：笔记本的运行内存大小决定了你能同时运行多少个软件，以及运行的流畅度。16G的运行内存目前是主流，基本上能满足大部分的需求，如果你有特俗需求，比如要运行大型设计软件，或者是图像处理专业，需要做图像处理实验，就需要32G及以上的内存了。\n硬盘：是存放数据、资料等的空间，主流的是512G固态硬盘，现在笔记本电脑基本上都采用的是固态硬盘了，因为固态盘船宿速度更快，而且体积更小，保证电脑的轻薄度的同时还能提高性能。\n屏幕：现在笔记本电脑的屏幕普遍采用IPS技术，知道就行，比较重要的是以下几个指标：\n（1）**屏幕分辨率**：一般为1920×1080，高一点为2K、2.5K、3K、4K等。屏幕分辨率越高，显示的图像越清晰。\n（2）**屏幕刷新率**：一般为60Hz，高一点为90Hz、120Hz、144Hz、240Hz、300Hz等。刷新率越高，感受到的电脑屏幕画面越流畅。\n（3）**高色域**：代表着屏幕色彩的丰富度，色域越高越好。商家如果在商品介绍有“高色域”、“72%NTSC”、“100%sRGB”等关键词，说明它是高色域；如果没有说明，一般就是低色域。\n尺寸：如果你经常需要移动电脑，比如外出携带、或者出差用，建议选择13.3英寸和14英寸，如果你的电脑不怎么移动，经常在家、或者在宿舍用，那肯定是大一点的屏幕比较号，建议选择15.6英寸、16.1英寸或17.3英寸的。\n3、品牌及版本选择\n其实我个人觉得电脑的品牌没有好坏之分，只有适不适合你自己，有的品牌走的是极致性价比路线，那可能在外观和售后方面会打折扣，有的品牌可能各方面都做的很不错，那可能价格也会很贵，要看自己的取舍，对于小白，推荐选择联想、华硕、戴尔、惠普、华为等大厂品牌。实在追求性价比，可以考虑小米、神舟、宏碁等品牌。\n下面举几种目前常见的配置组合，供各位参考：\n（1）R5的版本：可以满足学生和办公族的日常使用，如office、简单cad、ps、视频剪辑等工作，价位不会很高。\n（2）R7、i5-1135G7锐炬显卡、i7-1165G7锐炬显卡、i5-1035G1+MX350的版本：目前主流轻薄本的低配版，可满足日常的办公office、cad、ps、简单视频剪辑等工作，偶尔玩玩如LOL、CSgo的游戏也可。\n（3）i5-1135G7+MX450、i7-1165G7+MX450的版本：目前轻薄本的主流配置，因为有独显MX450的存在，可以较高流畅运行如LOL、CSgo等中小型游戏，应对不复杂的ps、pr、ae等软件任务无压力。\n（3）R5/R7+GTX1650/GTX1650ti/rtx2060、i5/i7+GTX1650/GTX1650ti/rtx2060的版本：为目前游戏本的主流配置，也有一些高性能的设计师本，rtx2060可流畅运行各类大型的单机游戏和网游，流畅度与显卡型号有关；设计师常用如建模、3D MAX等软件可丝滑运行，其中锐龙版的多线程对建模更加有利。\n二、高性价比电脑推荐3000-4000元价位联想（Lenovo）小新AIR14\nhttps://item.jd.com/66461475751.html\n定位：轻薄本\n参数配置：处理器（R5-5500U）、显卡（独显）、100%sRGB高色域、分辨率（1920×1080）、内存（16G）、尺寸（14英寸）点评：联想小新系列在学生党中非常受欢迎，性能方面可以满足学生、上班族日常的办公、娱乐需求，诸如office、cad、简单ps等。外观上质感和手感兼具，续航优异，接口丰富，性价比超高。\n机械革命(MECHREVO)S3\nhttps://item.jd.com/100015604836.html\n定位：轻薄本\n参数配置：处理器（i5/i7-1135G7）、显卡（独显）、指纹识别、100%sRGB高色域、分辨率（1920×1080）、内存（16G）、尺寸（14英寸）\n点评：这款电脑可根据预算选配i5或者i7版本，搭载MX350系列显卡能满足理科学习和一般娱乐使用。机身内部可根据需要加装硬盘、使用100%sRGB屏幕，修图时也不会有色差，性价比超高。\n华硕Redolbook14 锐龙版\nhttps://item.jd.com/100015781264.html\n定位：轻薄本配置：处理器（R7-4700U）、显卡（独显）、分辨率（1920×1080）、100%sRGB高色域、内存（16G）、尺寸（14英寸）评价：14的尺寸十分便携，保持轻薄的同时又有够用的性能。对于做做ppt、码码字来说还是毫无压力的。微边框的设计再加上哈曼卡顿的调音对于追剧党来说也是十分畅爽的。\n4000元-6000元价位\n荣耀MagicBook Pro 2021\nhttps://item.jd.com/70129374835.html\n定位：轻薄本配置：处理器（i5）、显卡（MX350）、分辨率（1920×1080）、100%sRGB高色域、内存（16G）、尺寸（16.9英寸）评价：这款电脑的性价比一流，续航也十分给力，办公场景下的使用时间可达15小时，并且附带的充电器只有160g。指纹式登录的设计更加便捷，隐藏式的摄像头的设计也显得十分精巧。如果你使用的是华为/荣耀系的手机，多屏协同的功能也十分方便。性能上也中规中矩，办公使用毫无压力。\n联想小新air15 2021款\nhttps://item.jd.com/100008699547.html\n定位：轻薄本配置：处理器（R7-4800U）、显卡（集显）、分辨率（1920×1080）、100%sRGB高色域、内存（16G）、尺寸（15.6英寸）评价：这款电脑是非游戏本中为数不多的散热比较好的电脑之一，有三种使用模式可以切换，分别对应不同场景。并且电池较大，续航时间也不错，还支持快充。性能上保持着R7-4800U的搭配，屏幕上也是一块100%srgb的高色域屏幕，色彩鲜明。\n联想拯救者Y7000\nhttps://item.jd.com/100014929004.html\n定位：游戏本配置：处理器（I5-10200H）、显卡（独显1650Ti）、分辨率（1920×1080）、100%sRGB高色域、内存（16G）、尺寸（15.9英寸）评价：I5-10200H+1650Ti的显卡搭配可以流畅运行大部分专业软件和一些大型游戏。但对于想要电脑学习科研和LOL的工科专业同学来说，这款电脑的性能已经完全能满足了。此外100%sRGB的屏幕和杜比联合哈曼卡顿的调音给了这台电脑高素质的屏幕和音效，总而言之，这台电脑是一款入门级的全能选手。\n6000-10000元价位\n华硕(ASUS) 灵耀X双屏\nhttps://item.jd.com/100017970852.html\n\n定位：高性能轻薄本配置：处理器（I7-1165G7）、显卡（MX450独显）、分辨率（1920×1080）、100%sRGB高色域、内存（16G）、尺寸（14英寸）评价：采用双屏设计双触控设计，可以实现多窗口、多任务操作，一边摸鱼一边办公可能是很多打工人的理想，现在这一台设备就可以实现了。此外华硕为双屏操作开发了ScreenXpert2软件，可以实现桌面切换、快捷工具、手写等诸多功能。对于生产力应用，适配了Adobe全家桶（PS、PR、AE、AI）的专用工具栏，大大提升视频剪辑、图片处理的效率。\n华为MateBook X Pro 2021款\nhttps://item.jd.com/100017029028.html\n定位：高端轻薄本配置：处理器（I7）、显卡（锐炬独显）、分辨率（3K）、100%sRGB高色域、内存（16G）、尺寸（14英寸）评价：这款电脑有同样的i7+锐炬显卡的搭配，满足使用需求。华为系的生态加持让使用者能更加方便，出门电脑手机可以带一个充电器。此外，这款的电脑还搭载了一块3k的触摸全面屏，在同等价位的笔记本中并不多见。\n华硕天选\nhttps://item.jd.com/100010367173.html\n定位：游戏本配置：处理器（R7-5800H）、显卡（RTX3060独显）、分辨率（1920×1080）、屏幕刷新率（144Hz）、内存（16G）、尺寸（15.9英寸）评价：这款电脑搭载了AMD R9-4900的处理器和RTX2060的显卡，不但能满足专业软件的需求，流畅运行高画质下的大型游戏；甚至对一些中大型项目的有限元分析也能胜任此外，这台电脑还使用了一块144Hz刷新率的电竞屏幕，外观上还融入了机甲设计，对于游戏爱好者来说简直是福音。\n三、个人建议就像前面说的，没有绝对完美的电脑，不管多贵的电脑，都会有它的亮点和槽点，况且每个人买电脑的需求都不一样，你不能指望一款电脑能够满足所有人的需求。\n我们只需要在自己的预算范围之内，根据自己的使用需求，买到合理的机子就够了，如果你是新手，想省去一些不必要的售后麻烦，直接上京东自营购买就好了，一款电脑好评率在95%以上基本上就可以入手了。\n以上内容，不能面面俱到，欢迎留言交流探讨，如果对你有帮助，不妨点赞支持一下！\n","categories":["技术以外"],"tags":[]},{"title":"最成功的一次投资！","url":"https://tanqingbo.cn/The-most-successful-nvestment/","content":"大家好，我是厂长！\n说到投资，可能很多人第一反应就是股票、基金，但是厂长今天想聊的是另外一种投资，就是在读书学习上的投资。\n我一直都觉得读书是一件值得我们长期去投资的事情，而且这个事情必须坚持，不能心血来潮了看几个小时，然后就搁置很长一段时间不翻了，这样看了跟没看其实没有什么区别。\n今天主要想和大家分享几本这几年我看过的对我影响很大的非技术书籍。\n一说到非技术书籍，可能很多同学都会举手：非技术的书我也看啊，像玄幻、修真、言情类的小说，我一周就能看完一本。\n说实话，这些书我之前也看过不少，但是基本上看完就忘了，我觉得人在不同的时期是需要看不同的书籍的，因为不同的年龄、不同的经历，你所需要汲取的东西也是不一样的。\n所以今天给大家推荐几本对我影响很大的书，我不能保证这些书一定对你有用，我只能保证这些书我都看过，且对我产生了积极正面的影响。\n1、《平凡的世界》这本书对我有着特别的意义，每次我处于低谷的时候、或者没有动力学习工作的时候都会把这本书拿出来读一下，因为我觉得我就像书中的孙少平一样，因为多读了几本书，对外面的世界有着很大的向往，凭自己的努力和倔强，尽可能的去看到更大的世界，孙少平没有放弃，我也不应该放弃！\n当然它不止适合农村出来的孩子读，它适合每个人读，因为小说刻画了从建国初期到改革开放之后，中国社会演化的全过程，我知道不少高校在给学生寄录取通知书的时候还会顺便给他们寄一套《平凡的世界》，可见这本书影响之深！\n2、《富爸爸穷爸爸》我觉得这本书教会我最重要的三个能力就是，财商能力、独立思考能力和批判性思考能力，而这三种能力恰好学校都不会教，有时候我甚至会想，这可能不是巧合，而是教育设计的目的本身就是不希望我们掌握财商和独立思考的能力，只需要把我们培养成一个合格的齿轮，满足社会正常运转就可以了。\n所以，如果你掌握了这几种能力就有可能跳出别人给你设计好的道路，去做你自己想做的事情，也就是所谓的做自己。\n而且在这本书中还介绍了很多关于金钱的运转规律，绝对会颠覆你的认知，当你了解钱是如何运动的，你就有可能驾驭它，而不是为它打工。\n3、《小狗钱钱》这本书有点像是写给小孩看的童话书，用特别通俗易懂的原理给你介绍了股票、基金背后的原理，干货特别多。\n如果你以为是写个小孩子看的那你就错了，大人了看了一样会有很多收获。入门必读！\n4、《三体》这本书表面上是讲外星人入侵的故事，实际上是一本刻画人性的小说，大刘不仅懂世界历史，对人性也洞察的一清二楚，书里面每一个重大情节在人类历史上都能找到原型：\n罗辑发现黑暗森林法阻止了三体人的入侵，成为了救世主，可是没过多久他又被赶下了救世主的神坛；\n华盛顿建立美国成为国父，后来美国人发现华盛顿其实是黑人奴隶主，不配做美国人的国父，有没有发现和罗辑很像。\n三体人占领地球后，把人类全部赶去了太平洋中央的澳大利亚，剩下的领土全部归三体人所有；欧洲移民到美洲之后，把本土的印第安人全部赶去了贫瘠的德州，是不是一模一样！\n而且现在互联网行业特别推崇三体里面的黑暗森林法则，作为一家初创公司，必须深谙黑暗森林法则，才有可能在这丛林中活下来。所以推荐大家都去看看这本书，保证你有很多收获的。\n5、《见识》《见识》是吴军老师的书，虽然内容有点散碎，但是是他几十年的视野解读和感悟，干货满满。 看完之后会改变你的一些思维方式的，如果你没有看的话，那么强烈建议你去看一下。\n6、《邓小平时代》这本书我陆陆续续看了一年才看完，很厚的一本书，对我来说也是很宝贵的一本书，邓公以多年积累下的深广人脉和对体制超乎常人的把握，与阻碍改革者博弈，既不屈服于保守势力，也不完全妥协于民意。正是这些在当时看来想了也做不到，能做到也不敢做的事为沉睡了几百年的中国打开了通往世界之门。\n这本用了近一年的时间才看完的书，真的是久久的影响着我看问题的态度、以及看世界的眼光，强烈建议大家去看一下，给自己开开眼。\n7、《原则》本书的作者瑞·达利欧是世界上最大的对冲基金公司桥水的创始人，号称为金融界的乔布斯，书里面作者结合自身的经历给出了一些基本的做事方法和原则，他建议我们接受现实，从现实中寻找梦想，他认为可以实现的梦想才是好梦想。\n当然我不是说，大家看完之后就去照搬、复制作者的原则，而是在看完之后，看看有没有可以借鉴的地方，最终形成自己的做事原则。\n8、《周期》这是一本投资理财的书，霍华德·马克斯的著作。看完《小狗钱钱》可以看这本书进阶，任何事情都有周期，金融市场也不例外，而作者认为，在投资最重要的事情里面，周期肯定名列前茅。\n就连股神巴菲特，也会主动阅读他的作品：“我会第一时间打开邮件并阅读的就是霍华德·马克斯的备忘录。”\n最后我一直都觉得我的阅读量还算不错，不少类型的书都看过，以前喜欢看小说、现在慢慢喜欢看一些历史、科普类的工具书，因为在不同的年龄段、你经历的事情不一样，你要处理的事情也不一样，那么你要从书本中汲取的东西也不一样，所以我觉得在不同的年龄段是需要看不同的书的。\n以上内容我只是推荐了几本在某个特定时间段对我产生积极正面影响的书，如果你也有很喜欢的书，欢迎在留言区分享。\n现在对自己的每一份投资，都会在未来你的余额中体现！\n","categories":["技术以外"],"tags":[]},{"title":"B站向北邮道歉！","url":"https://tanqingbo.cn/B站向北邮道歉！/","content":"事情是这样的，前两天B站在北邮春招时候，被面试的同学曝出来面试官存在严重的歧视行为，而且还炫耀资产，据面试的同学称，这个面试官的迷惑言论包括但不限于：\n\n这个消息被曝光出来之后，瞬间就占领了知乎和微博的头版头条，很多同学都过来说，在面试的过程确实体验很不好，面试官不仅说教，还把自家研发的引擎吹上天，说自己早就财富自由，做游戏只是为了梦想。\n\n可能是因为热度越来越高，面试官当事人和B站官方都站出来对这次招聘事件进行了 回应，据面试官说因为招聘方安排的失误，面试大幅度延迟，学生等候了很久才安排面试，导致这个同学在面试的时候情绪就已经很不稳定了。\n然后这个同学提到自己拿到了两家大厂的offer，但是B站的视频面试没有通过，就质问面试官：“为什么大厂都给我offer了，小厂竟然不给？”这句话刺激到了这个面试官，于是该面试官就带着情绪对这个面试的同学进行了一番说教。\n面试官发帖承认自己有说教，并向这个同学道歉，但是否认了自己的炫富行为以及对这个学生的一系列指责：\n\n\nB站的官方账号也回复了，核心就下面几点：\n============\n一：当日发生了面试时间延迟，导致该同学面试体验不佳。\n二：面试员存在说教与争论等不职业行为，但不存在攻击北邮等言论。\n三：HR和面试员事后没有拉黑该同学和要求删帖。\n根据以上调查，公司确认本次招聘会存在安排欠妥、个别面试员表现不职业的问题，因此决定对本次招聘会的HR负责人和当事面试员进行严厉的批评和处罚。\n因这次事件给北邮同学造成了困扰，公司向所有北邮师生表示诚恳的歉意。\n============\n类似的招聘歧视，14年网易去华科招聘的时候也发生过，当时宣讲人说有两个架构师的职位华科的同学不用看了，那是给清华北大的同学准备的，这个言论当时也是引起了华科同学的群愤，不过幸好那个时候的互联网没有现在这个发达。\n\n\n刷知乎的时候，也看到有同学总结了自己的秋招的时候，各家大厂的面试体验，其中体验最好的是腾讯、阿里、字节这三家，体验与公司量级严重不符的是：小米和B站，可能这两家公司都属于高速发展阶段，在这种用户看不到的地方就没怎么花心思了。\n\n","categories":["技术以外"],"tags":[]},{"title":"算法刷题笔记，Java版终于来了！！！","url":"https://tanqingbo.cn/leetcode-Java/","content":"之前分享过一本谷歌大佬整理的leetcode刷题笔记 ，不过那本书里面的代码都是Go语言实现的，然后就有朋友留言说有没有用Java语言实现的leetcode题解答案。\n我找了很久，这不，今天终于让找到了Java版leetcode算法题解电子版：\n\n关于算法刷题的困惑和疑问经常听朋友们提及，这份笔记里面共包含作者刷LeetCode算法题后整理的数百道题，每道题均附有详细题解过程以及实现的代码。\n很多人表示刷数据结构和算法题效率不高，甚是痛苦，有了这个笔记的总结，对校招和社招的算法刷题帮助之大不言而喻，所以果断推荐给大家。\n\n\n\n需要刷题笔记PDF文档的小伙伴可以直接点击下方链接下载：\n\n链接：https://pan.baidu.com/s/1XpwHTtBPgMguav9FhpP9og提取码：k057 \n\n每天进步一点点\n慢一点才能更快\n加油！\n更多干货内容，可以去我的个人网站：https://tanqingbo.cn/CSBook001/\n最后，有用的话记得点赞支持一下，感谢！\n","categories":["数据结构与算法"],"tags":["算法"]},{"title":"五大常用算法之：分支限界法","url":"https://tanqingbo.cn/Branch-and-bound/","content":"一、基本描述  类似于回溯法，也是一种在问题的解空间树T上搜索问题解的算法。但在一般情况下，分支限界法与回溯法的求解目标不同。回溯法的求解目标是找出T中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。\n（1）分支搜索算法  所谓“分支”就是采用广度优先的策略，依次搜索E-结点的所有分支，也就是所有相邻结点，抛弃不满足约束条件的结点，其余结点加入活结点表。然后从表中选择一个结点作为下一个E-结点，继续搜索。\n   选择下一个E-结点的方式不同，则会有几种不同的分支搜索方式。\n  1）FIFO搜索\n  2）LIFO搜索\n  3）优先队列式搜索\n二、分支限界法的一般过程  由于求解目标不同，导致分支限界法与回溯法在解空间树T上的搜索方式也不相同。回溯法以深度优先的方式搜索解空间树T，而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树T。\n  分支限界法的搜索策略是：在扩展结点处，先生成其所有的儿子结点（分支），然后再从当前的活结点表中选择下一个扩展对点。为了有效地选择下一扩展结点，以加速搜索的进程，在每一活结点处，计算一个函数值（限界），并根据这些已计算出的函数值，从当前活结点表中选择一个最有利的结点作为扩展结点，使搜索朝着解空间树上有最优解的分支推进，以便尽快地找出一个最优解。\n  分支限界法常以广度优先或以最小耗费（最大效益）优先的方式搜索问题的解空间树。问题的解空间树是表示问题解空间的一棵有序树，常见的有子集树和排列树。在搜索问题的解空间树时，分支限界法与回溯法对当前扩展结点所使用的扩展方式不同。在分支限界法中，每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点。在这些儿子结点中，那些导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被子加入活结点表中。此后，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到找到所求的解或活结点表为空时为止。\n三、回溯法和分支限界法的一些区别  有一些问题其实无论用回溯法还是分支限界法都可以得到很好的解决，但是另外一些则不然。也许我们需要具体一些的分析——到底何时使用分支限界而何时使用回溯呢？\n回溯法和分支限界法的一些区别：\n  方法对解空间树的搜索方式    存储结点的常用数据结构   结点存储特性常用应用\n 回溯法深度优先搜索堆栈活结点的所有可行子结点被遍历后才被从栈中弹出找出满足约束条件的所有解\n 分支限界法广度优先或最小消耗优先搜索队列、优先队列每个结点只有一次成为活结点的机会找出满足约束条件的一个解或特定意义下的最优解\n","categories":["数据结构与算法"],"tags":["算法"]},{"title":"五大常用算法之：回溯算法","url":"https://tanqingbo.cn/Backtracking/","content":"1、概念   回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。\n  回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。\n   许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。\n2、基本思想  在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。\n​    若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。\n​    而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。\n3、用回溯法解题的一般步骤：  （1）针对所给问题，确定问题的解空间：\n​      首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。\n  （2）确定结点的扩展搜索规则\n  （3）以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。\n4、算法框架   （1）问题框架\n   设问题的解是一个n维向量(a1,a2,………,an),约束条件是ai(i=1,2,3,…..,n)之间满足某种条件，记为f(ai)。\n   （2）非递归回溯框架\n 1: int a[n],i; 2: 初始化数组a[]; 3: i = 1; 4: while (i&gt;0(有路可走)   and  (未达到目标))  // 还未回溯到头 5: { 6:     if(i &gt; n)                                              // 搜索到叶结点 7:     {    8:           搜索到一个解，输出； 9:     }10:     else                                                   // 处理第i个元素11:     { 12:           a[i]第一个可能的值；13:           while(a[i]在不满足约束条件且在搜索空间内)14:           {15:               a[i]下一个可能的值；16:           }17:           if(a[i]在搜索空间内)18:          {19:               标识占用的资源；20:               i = i+1;                              // 扩展下一个结点21:          }22:          else 23:         {24:               清理所占的状态空间；            // 回溯25:               i = i –1; 26:          }27: }\n\n\n\n​    （3）递归的算法框架\n​     回溯法是对解空间的深度优先搜索，在一般情况下使用递归函数来实现回溯法比较简单，其中i为搜索的深度，框架如下：\n 1: int a[n]; 2: try(int i) 3: { 4:     if(i&gt;n) 5:        输出结果; 6:      else 7:     { 8:        for(j = 下界; j &lt;= 上界; j=j+1)  // 枚举i所有可能的路径 9:        {10:            if(fun(j))                 // 满足限界函数和约束条件11:              {12:                 a[i] = j;13:               ...                         // 其他操作14:                 try(i+1);15:               回溯前的清理工作（如a[i]置空值等）;16:               }17:          }18:      }19: }","categories":["数据结构与算法"],"tags":["算法"]},{"title":"五大常用算法之：动态规划算法","url":"https://tanqingbo.cn/Dynamic-programming-algorithm/","content":"一、基本概念\n   动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。\n二、基本思想与策略\n   基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。\n   由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。\n   与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。\n\n三、适用的情况\n能采用动态规划求解的问题的一般要具有3个性质：\n  (1) 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。\n  (2) 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。\n  （3）有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）\n\n四、求解的基本步骤\n   动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。\n  初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态\n​            图1 动态规划决策过程示意图\n  (1)划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。\n  (2)确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。\n  (3)确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。\n  (4)寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。\n   一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。\n实际应用中可以按以下几个简化的步骤进行设计：\n   （1）分析最优解的性质，并刻画其结构特征。\n   （2）递归的定义最优解。\n   （3）以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值\n   （4）根据计算最优值时得到的信息，构造问题的最优解\n\n五、算法实现的说明\n  动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。\n   使用动态规划求解问题，最重要的就是确定动态规划三要素：\n   （1）问题的阶段 （2）每个阶段的状态\n   （3）从前一个阶段转化到后一个阶段之间的递推关系。\n   递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。\n   确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。\n​      f(n,m)=max{f(n-1,m), f(n-1,m-w[n])+P(n,m)}\n\n六、动态规划算法基本框架\n 1 for(j=1; j&lt;=m; j=j+1) // 第一个阶段 2   xn[j] = 初始值; 3  4  for(i=n-1; i&gt;=1; i=i-1)// 其他n-1个阶段 5   for(j=1; j&gt;=f(i); j=j+1)//f(i)与i有关的表达式 6      xi[j]=j=max（或min）{g(xi-1[j1:j2]), ......, g(xi-1[jk:jk+1])}; 8  9 t = g(x1[j1:j2]); // 由子问题的最优解求解整个问题的最优解的方案10 11 print(x1[j1]);12 13 for(i=2; i&lt;=n-1; i=i+1）15 {  17      t = t-xi-1[ji];18 19      for(j=1; j&gt;=f(i); j=j+1)21         if(t=xi[ji])23              break;25 }\n\n","categories":["数据结构与算法"],"tags":["算法"]},{"title":"五大常用算法之：贪心算法","url":"https://tanqingbo.cn/Greedy-Algorithm/","content":"一、基本概念： \n   所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。\n   贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。\n  所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。\n二、贪心算法的基本思路：\n  1.建立数学模型来描述问题。\n  2.把求解的问题分成若干个子问题。\n  3.对每一子问题求解，得到子问题的局部最优解。\n  4.把子问题的解局部最优解合成原来解问题的一个解。\n三、贪心算法适用的问题\n   贪心策略适用的前提是：局部最优策略能导致产生全局最优解。\n  实际上，贪心算法适用的情况很少。一般，对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可做出判断。\n四、贪心算法的实现框架\n  从问题的某一初始解出发；\n  while （能朝给定总目标前进一步）\n  { \n​     利用可行的决策，求出可行解的一个解元素；\n  }\n  由所有解元素组合成问题的一个可行解；\n五、贪心策略的选择\n   因为用贪心算法只能通过解局部最优解的策略来达到全局最优解，因此，一定要注意判断问题是否适合采用贪心算法策略，找到的解是否一定是问题的最优解。\n六、例题分析\n  下面是一个可以试用贪心算法解的题目，贪心解的确不错，可惜不是最优解。\n  [背包问题]有一个背包，背包容量是M=150。有7个物品，物品可以分割成任意大小。\n  要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。\n  物品 A B C D E F G\n  重量 35 30 60 50 40 10 25\n  价值 10 40 30 50 35 40 30\n  分析：\n  目标函数： ∑pi最大\n  约束条件是装入的物品总重量不超过背包容量：∑wi&lt;=M( M=150)\n  （1）根据贪心的策略，每次挑选价值最大的物品装入背包，得到的结果是否最优？\n  （2）每次挑选所占重量最小的物品装入是否能得到最优解？\n  （3）每次选取单位重量价值最大的物品，成为解本题的策略。\n  值得注意的是，贪心算法并不是完全不可以使用，贪心策略一旦经过证明成立后，它就是一种高效的算法。\n  贪心算法还是很常见的算法之一，这是由于它简单易行，构造贪心策略不是很困难。\n  可惜的是，它需要证明后才能真正运用到题目的算法中。\n  一般来说，贪心算法的证明围绕着：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的。\n  对于例题中的3种贪心策略，都是无法成立（无法被证明）的，解释如下：\n  （1）贪心策略：选取价值最大者。反例：\n  W=30\n  物品：A B C\n  重量：28 12 12\n  价值：30 20 20\n  根据策略，首先选取物品A，接下来就无法再选取了，可是，选取B、C则更好。\n  （2）贪心策略：选取重量最小。它的反例与第一种策略的反例差不多。\n  （3）贪心策略：选取单位重量价值最大的物品。反例：\n  W=30\n  物品：A B C\n  重量：28 20 10\n  价值：28 20 10\n  根据策略，三种物品单位重量价值一样，程序无法依据现有策略作出判断，如果选择A，则答案错误。\n","categories":["数据结构与算法"],"tags":["算法"]},{"title":"五大常用算法之：分治算法","url":"https://tanqingbo.cn/Divide-and-conquer-algorithm/","content":"一、基本概念\n  在计算机科学中，分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……\n  任何一个可以用计算机求解的问题所需的计算时间都与其规模有关。问题的规模越小，越容易直接求解，解题所需的计算时间也越少。例如，对于n个元素的排序问题，当n=1时，不需任何计算。n=2时，只要作一次比较即可排好序。n=3时只要作3次比较即可，…。而当n较大时，问题就不那么容易处理了。要想直接解决一个规模较大的问题，有时是相当困难的。\n\n\n二、基本思想及策略\n  分治法的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。\n  分治策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。\n  如果原问题可分割成k个子问题，1&lt;k≤n，且这些子问题都可解并可利用这些子问题的解求出原问题的解，那么这种分治法就是可行的。由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。\n\n三、分治法适用的情况\n   分治法所能解决的问题一般具有以下几个特征：\n\n该问题的规模缩小到一定的程度就可以容易地解决\n\n该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。\n\n利用该问题分解出的子问题的解可以合并为该问题的解；\n\n该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。\n\n\n第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；\n第二条特征是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用；、\n第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。\n第四条特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。\n\n四、分治法的基本步骤\n分治法在每一层递归上都有三个步骤：\n   step1 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；\n   step2 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题\n   step3 合并：将各个子问题的解合并为原问题的解。\n它的一般的算法设计模式如下：\n  Divide-and-Conquer(P)\n  \\1. if |P|≤n0\n  \\2. then return(ADHOC(P))\n  \\3. 将P分解为较小的子问题 P1 ,P2 ,…,Pk\n  \\4. for i←1 to k\n  \\5. do yi ← Divide-and-Conquer(Pi) △ 递归解决Pi\n  \\6. T ← MERGE(y1,y2,…,yk) △ 合并子问题\n  \\7. return(T)\n  其中|P|表示问题P的规模；n0为一阈值，表示当问题P的规模不超过n0时，问题已容易直接解出，不必再继续分解。ADHOC(P)是该分治法中的基本子算法，用于直接解小规模的问题P。因此，当P的规模不超过n0时直接用算法ADHOC(P)求解。算法MERGE(y1,y2,…,yk)是该分治法中的合并子算法，用于将P的子问题P1 ,P2 ,…,Pk的相应的解y1,y2,…,yk合并为P的解。\n\n五、分治法的复杂性分析\n  一个分治法将规模为n的问题分成k个规模为n／m的子问题去解。设分解阀值n0=1，且adhoc解规模为1的问题耗费1个单位时间。再设将原问题分解为k个子问题以及用merge将k个子问题的解合并为原问题的解需用f(n)个单位时间。用T(n)表示该分治法解规模为|P|=n的问题所需的计算时间，则有：\n T（n）= k T(n/m)+f(n)\n  通过迭代法求得方程的解：\n   递归方程及其解只给出n等于m的方幂时T(n)的值，但是如果认为T(n)足够平滑，那么由n等于m的方幂时T(n)的值可以估计T(n)的增长速度。通常假定T(n)是单调上升的，从而当          mi≤n&lt;mi+1时，T(mi)≤T(n)&lt;T(mi+1)。 \n六、可使用分治法求解的一些经典问题\n （1）二分搜索\n（2）大整数乘法\n （3）Strassen矩阵乘法\n（4）棋盘覆盖\n（5）合并排序\n（6）快速排序\n（7）线性时间选择\n（8）最接近点对问题\n（9）循环赛日程表\n（10）汉诺塔\n七、依据分治法设计程序时的思维过程\n   实际上就是类似于数学归纳法，找到解决本问题的求解方程公式，然后根据方程公式设计递归程序。\n1、一定是先找到最小问题规模时的求解方法\n2、然后考虑随着问题规模增大时的求解方法\n3、找到求解的递归函数式后（各种规模或因子），设计递归程序即可。\n","categories":["数据结构与算法"],"tags":["算法"]},{"title":"程序员必须掌握哪些算法？","url":"https://tanqingbo.cn/algorithm/","content":"上大学的时候，老师一直跟我们强调：“算法才是编程的灵魂”，由此可见算法到底有多重要，那么程序员应该要掌握哪些算法呢？\n下面我整理了一些个人觉得比较重要的且需要掌握的算法和数据结构，同时还整理对应的书籍和学习文章分享给大家，如果看完觉得有用的话记得双击点个赞哦，下面开始上干货：\n\n1、数据结构数据结构研究的内容就是如何按一定的逻辑结构，把数据组织起来，并选择适当的存储表示方法把逻辑结构组织好的数据存储到计算机的存储器里。一般学习算法都是先从数据结构开始学习，先根据实际问题确定数据结构，然后在数据结构的基础上进行算法设计。\n常见的数据结构有：\n\n栈（Stack）：栈是一种特殊的线性表，它只能在一个表的一个固定端进行数据结点的插入和删除操作。\n队列（Queue）：队列和栈类似，也是一种特殊的线性表。和栈不同的是，队列只允许在表的一端进行插入操作，而在另一端进行删除操作。\n数组（Array）：数组是一种聚合数据类型，它是将具有相同类型的若干变量有序地组织在一起的集合。\n链表（Linked List）：链表是一种数据元素按照链式存储结构进行存储的数据结构，这种存储结构具有在物理上存在非连续的特点。\n树（Tree）：树是典型的非线性结构，它是包括，2 个结点的有穷集合 K。\n图（Graph）：图是另一种非线性数据结构。在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对。\n堆（Heap）：堆是一种特殊的树形数据结构，一般讨论的堆都是二叉堆。\n散列表（Hash table）：散列表源自于散列函数(Hash function)，其思想是如果在结构中存在关键字和T相等的记录，那么必定在F(T)的存储位置可以找到该记录，这样就可以不用进行比较操作而直接取得所查记录。\n\n2、常用基础算法常用的基础算法包括：分治算法、贪心算法、动态规划算法、二分查找算法和分支界限算法等，下面列举每个算法的详细教程：\n五大常用算法之：分治算法\n五大常用算法之：贪心算法\n五大常用算法之：动态规划算法\n五大常用算法之：二分查找算法\n五大常用算法之：分支限界法\n3、排序算法排序算法最经典的莫过于八大排序算法了，分别是：插入排序、冒泡排序、选择排序、希尔排序、堆排序、归并排序、快速排序、桶式排序。\n排序算法很重要，考试和面试都会考察，而且是必考，我把八大排序算法的原理和代码都整理出来了，看下面这篇文章就够了：\n八大经典排序算法详解\n4、搜索算法搜索算法是利用计算机的高性能来有目的的穷举一个问题解空间的部分或所有的可能情况，从而求出问题的解的一种方法。 现阶段一般有枚举算法、深度优先搜索、广度优先搜索、剪枝算法、回溯算法等。\n搜索算法之：枚举算法\nDFS（深度优先搜索）和BFS(广度优先搜索)\n搜索算法之：剪枝算法\n搜索算法之：回溯算法\n5、树与图数据结构与算法——图最短路径\n数据结构与算法：三十张图弄懂「图的两种遍历方式」\n数据结构与算法——最小生成树\n几道和「二叉树」有关的算法面试题\n关键路径算法详解\n大话数据结构—多路查找树（B树）\n6、优秀的算法书《我的第一本算法书》这本书是京都大学一个计算机教授和朋友联合出品的动画讲解算法的App 所衍生出来的书籍，非常适合新手朋友们。里面没有枯燥的理论和复杂的公式，而是通过大量的步骤图帮助读者加深对数据结构原理和算法执行过程的理解，便于学习和记忆。将本书作为算法入门的第一步，是非常不错的选择。\n\n\n链接：https://pan.baidu.com/s/1r_lxqzfg7YTHvAEQhNJwnQ\n提取码：en9j\n\n2、《趣学算法》本书从算法之美娓娓道来，没有高深的原理，也没有枯燥的公式，通过趣味故事引出算法问题，包含50多个实例及完美图解，结合学生提问，分析算法本质，并给出代码实现的详细过程和运行结果。本书可作为程序员的学习用书，也适合从未有过编程经验但又对算法有强烈兴趣的初学者使用，同时也可作为高等院校计算机、数学及相关专业的师生用书和培训学校的教材。\n\n\n链接：https://pan.baidu.com/s/1gg4TXOat08UK-ZziBvCuWw\n提取码：l55p\n\n3、《啊哈！算法》《啊哈！算法》一切以实际应用为出发点，通过幽默的语言配以可爱的插图来讲解算法。其中涉及的数据结构有栈、队列、链表、树、并查集、堆和图等；涉及的算法有排序、枚举、深度和广度优先搜索、图的遍历，当然还有图论中不可以缺少的四种最短路径算法、两种最小生成树算法、割点与割边算法、二分图的最大匹配算法等。\n\n\n链接：https://pan.baidu.com/s/1PLMxdbqLcUmCUs0Ueb6ckA\n提取码：9yyz\n\n4、《图解算法》这是一本像小说一样有趣的算法入门书，示例丰富，图文并茂，以让人容易理解的方式阐释了算法，旨在帮助程序员在日常项目中更好地发挥算法的能量。书中的前三章将帮助你打下基础，带你学习二分查找、大O表示法、两种基本的数据结构以及递归等。余下的篇幅将主要介绍应用广泛的算法。\n\n\n链接：https://pan.baidu.com/s/1GZEp8KI1Fm0U4Uek7BOWAw\n提取码：am4o\n\n5、《剑指offer》这本书大家一定如雷贯耳吧，基本上只要你是程序员就一定会用到这本书，书里面剖析了50个典型的程序员面试题，从基础知识、代码质量、解题思路、优化效率和综合能力五个方面系统整理了影响面试的5个要点，是程序员找工作必备的一本算法书。\n\n\n链接：https://pan.baidu.com/s/1GD9yTglFZkn5n__965dKjA\n提取码：mas8\n\n6、《算法导论》这本书真的称得上是算法领域的“圣书”了，如果把它从头到尾看完并且搞明白了，那么恭喜你，年入百万不是梦！\n\n\n链接：https://pan.baidu.com/s/1Y1kXAyQsZO3MA_kgfa5Jog\n提取码：tl3x\n\n","categories":["数据结构与算法"],"tags":["算法"]},{"title":"2021年机械键盘选购指南","url":"https://tanqingbo.cn/2021机械键盘推荐/","content":"键盘是使用电脑一定需要的东西，尤其是对于学生来说，键盘的选择很重要，因为好的键盘可以大大提高打游戏和工作的快感！\n主流的键盘主要分为两类：机械硬盘与薄膜键盘。\n机械键盘目前很火热，因为LOL各种赛事各种宣传，还有游戏主播的推荐，实话实说，用机械键盘玩游戏，手感确实不一样。\n但是薄膜键盘仍然是大众的选择，因为薄膜键盘价格相对较低，使用的场景比较多，防水防潮，样式还好看。\n至于学生该买什么样的键盘，还是得根据你的使用场景来选择，比如在寝室可以选择青轴机械键盘，使用起来有霹雳吧啦的爽快感，但是在图书馆和实验室，你就要考虑一下别人的感受了，使用声音过大的键盘很容易引起别人的不满，应该选择正常的不太吵的键盘。\n机械键盘对轴的选择，一般认为\n\n办公：青轴＞红轴＞茶轴＞黑轴\n游戏：黑轴＞红轴＞茶轴＞青轴\n\n\n黑轴是游戏首选，黑轴直上直下，被公认为游戏机械键盘的不二之选。但是黑轴触发键程短，压力克数较大，手指劲道偏小的人用它打字久了可能稍累；\n青轴是打字神器，但是就个人使用而言，使用青轴键盘打字时间久了，感觉比薄膜键盘要累；\n茶轴属于兼顾的轴，茶轴对于青轴，段落感弱很多；对于黑轴，又不是直上直下。这样的手感很容易被用户接受，茶轴可以说是办公游戏都可以。\n红轴长适合时间文字输入，红轴可以视为轻量级的黑轴：和黑轴一样的直上直下，但是压克力数更小。此外红轴的手感轻盈，同样能照顾游戏和打字需求。\n提示：对于要入手的但是不知道买什么轴的同学，一般买青轴或茶轴。黑轴的压力大，红轴没什么特色。\n其次是关于键帽，目前市场上的键盘，一般有原厂和OEM两种高度的键帽，PBT和ABS两种材质的键帽。\n如果你是一个键盘新手，那么其实原厂和OEM高度的键帽手感差别都不大，买哪种都可以，所以本文不会提及键帽高度。\n但是在键盘的材质方面，建议大家对500元以下的键盘选择PBT材质的键帽，因为ABS材质的键帽用久了容易打油发光，影响美观。\n下面根据不同价位分别给大家推荐几款机械键盘供大家参考：\n200以内机械键盘这个价位适合机械键盘输入入门阶段，不适合手感要求高的同学。另外强烈建议，如果不缺10块20块钱的话，建议都去JD自营或者JD旗舰店去买，万一键盘出了什么问题，售后特别方便。\n\n惠普（HP）机械键盘GK100\n\nhp新品，青轴，键帽PBT材质，\n手感方面，全键无冲，有背光，全尺寸，\n在这个价位是非常不错的选择。\n[\n\n雷柏（RAPOO）V500PRO青轴\n\n手感方面，雷柏青轴打字贼爽，打游戏也爽，\n双色注塑PBT键帽，有背光，全尺寸，\n价格200以上，对得起这个价位！\n[\n\n达尔优（dareu）机械师合金版\n\n有黑白两种颜色，推荐购买黑色，主要是耐脏。\n土豪金基底配上黑色的按键，外观还是不错的，\n自带背光和呼吸灯，晚上打字不用开灯也可以正常操作。\n200-500价位机械键盘这个价位的键盘选择就多了，背光，无光，蓝牙，花里胡哨，该有的都有。\n简单来说就是神仙打架，无法全部列出，此区间推荐键盘仅代表我个人观点。勿杠！\n\n雷柏（Rapoo） V700RGB合金版 机械键盘\n\nPBT磨砂材质键帽，有一定的摩檫力，而且使用的时候不会沾染指纹，\n青轴RGB，金属铝合金上盖，打字和玩游戏都非常的流畅，\n而且像防滑脚垫、疏水孔、拔键器、抗磁环等这些也是应该有的都有\n在同等价位的产品中还是非常有竞争力的。\n[\n\nikbc机械键盘R300\n\ncherry轴，单色背光，pbt双色键帽。\n而且是悬浮设计，手感特别棒，体验比雷柏要好，\n不过价格稍贵，看自己的取舍！\n[\n\n雷蛇 Razer黑寡妇蜘蛛\n\n雷蛇经典键盘黑寡妇的RGB版本，雷蛇的RGB优势不必多说，如果其他设备为雷蛇全家桶，联动灯效真的非常的爽。\n轴体是青轴，键帽是ABS键帽，键帽方面有点遗憾，不过如果不喜欢的话，后期可以自己买一套PBT材质键帽换上。\n\n\nikbc87机械键盘（无背光）\n\n原厂cherry轴，青轴打起来很爽，全尺寸。\n而且键盘颜色有粉，绿，蓝，黄四个颜色，非常适合女孩子选购，\n键帽正刻侧刻可选，喜欢彩色外观的朋友可入。\n[\n\n海盗船 (USCORSAIR) K68 / K70\n\n选择海盗船K系列请一定要买RGB版本，买海盗船就是为了RGB灯，连接电脑驱动后可玩性极高，不想要灯或者想要单色灯的不建议买海盗船。\n有大手拖，用起来很舒服，而且防水，但是海盗船的大键手感偏差，购买前请认真考虑。\n[\n\n罗技（G）G610\n\n罗技的中端键盘，个人觉得算是品牌、价格、以及使用性等综合最优的选择，\n左上角有信仰LOGO，单色灯光，独立多媒体控制按键，非常推荐！\n结语个人认为大学生在选键盘上，不用追求高端键盘，如\n\n斐尔可（FILCO）\n\n\n罗技 Logitech G813\n\n这种键盘，对于学生来说有些奢侈，看主播们用就好。\n最后希望大家买到自己目标价位心仪的键盘。\n","categories":["技术以外"],"tags":[]},{"title":"2021年PSSD移动固态硬盘与SSD固态硬盘选购最新攻略（小白避坑指南）","url":"https://tanqingbo.cn/2021年固态硬盘选购最新攻略（小白避坑指南）/","content":"现在市面上的硬盘分两类，一是传统的由“盘片+刺头”构成的机械硬盘，一是新兴的由“闪存颗粒”构成的固态硬盘。\n机械硬盘由于受限于转盘转速与指针寻址的时间限制，读写速度一般在60~80M每秒左右，而固态硬盘是闪存颗粒和闪存控制器直接寻址的方式，读写速度平均大约在150-300M每秒，最大的速度能达到500M每秒。\n所以如果你想要快速开机、快速启动大型游戏，或者需要存放大文件，对传输速度和安全性都有要求的话，那固态硬盘肯定是刚需。\n但是，如果你对电脑的响应速度、和数据读取速度没有要求的话，那推荐首选机械硬盘，便宜又大碗。\n本文主要讨论的是固态硬盘的选购攻略，如果你已经决定好了想要购买固态硬盘，那么这篇文章对你肯定有帮助。\n固态硬盘的种类首先固态硬盘存储分两种，一种是PSSD，P表示portable；另一种是SSD，，即移动固态硬盘和固态硬盘。\n通常PSSD移动固态硬盘体积较小、便于携带，而且还具有传输速度快、传输稳定、容量大等特点，使用时需要用一根数据线连接电脑，硬盘的接口一般是Type-C，另一端就是常用的USB，或Type-C，即插即用，非常方便。（跟一般的移动机械硬盘接口不一样）\n\n现在市面上的移动固态硬盘，比较推荐的牌子有西部数据和三星。如果是办公用，并且喜欢有设计感的可以选西部数据的My Passport，喜欢高端线的、对数据安全有需求的可以选三星的T7。\n而SSD固态硬盘呢，是一直装在电脑机箱里面的，平时看不到，电脑直接读写的那种。SSD固态硬盘的选择非常多，所以购买的时候一定要注意，除了要看你自己电脑里面有没有适配的硬盘接口，物理空间多大，能不能放得下选购的硬盘之外，还要重视它的速度、安全性等。\n那么怎么挑选适合自己电脑的SSD固态硬盘呢？\n\n得看自己的主板，一些比较老的机子是没有用于接M.2的接口的，SATA是普遍都有的，现在的主板也都支持了M.2接口。\n再看你的预算范围\n看你的使用场景，优中选优。\n\n接下来，我会跟据不同固态硬盘的使用场景以及网友评价分别挑选几款PSSD移动固态硬盘和SSD固态硬盘推荐给大家，帮助大家避坑。\nPSSD移动固态硬盘推荐1、西部数据的 My Passport 移动固态硬盘\n西数这款移动固态硬盘外观设计非常出色，从造型上将移动固态硬盘一分为二，配色采用黑色和香槟色。在金属色的一半，保留了西数产品的传统图样，斜置的波纹十分有品质感，摸起来既有手感，又能保证传输时的散热需求。\n而且它相当轻便，只有40g，还不到一副无线耳机的重量。尺寸只有90x45x10mm，跟一张名片一般大小，不占空间又有手感，非常方便携带。\n另外，从速度上来说，这款移动固态硬盘传输速度在540MB/s，2秒传输一集美剧，4秒传输一部电影，日常使用绝对够了。\n\n另外，这个移动固态硬盘有512G、1T、2T的容量可以选择，日常使用512GB绝对够了。不管是移动办公、文件存档备份，还是个人存储或传输照片、游戏影视资料都不是问题。\n再加上西部数据这款产品内置WD Security软件，开启了密码保护功能，可以帮助我们加密文件，防止他人未经授权访问私密文件。此外，西部数据自带的备份工具，会自动给存入的资料备份，数据存储的安全性能上升了好几个level。非常适合办公场景下对设计有追求、对传输速度也有追求的人。\n2、三星 T7  移动固态硬盘\n这款硬盘，外壳采用金属来包裹固定的硬件，即使从2米的高空坠落，也可以减少数据损坏，保护数据安全。此外，这款移动固态硬盘内置安全选项，采用了AES 256位加密技术，除了密码解锁还能指纹识别，双重保障，更加安全。\n这个移动固态硬盘最大的优点在于它的传输速度。读写速度都在1000MB/s以上，是三星外置硬盘的9.5倍，性能堪比内装硬盘的高端线产品。\n这个速度意味着什么呢？7、8G的电视剧，几秒就可以传完了；几十G的视频或者项目工程文件，理论上不到1分钟就可以传输完毕。\n\n另外，它的兼容性也特别棒。T7 Touch和PC、Mac、Android等设备广泛兼容，产品包装里面也随附了两种数据线，分别是USB Type C-to-C和 Type C-to A的 ，也就是说不管你的设备是什么接口，都可以即插即用，可以说是非常方便了。\n所以如果你需要存放特别大的工程文件或者数据集，对传输速度和安全性都有要求的话，选三星 T7准没错。\n三、SSD固态硬盘推荐1、西数 SN750\n\n主控：闪迪20-82-007011主控芯片NVMe：NVMe 1.1标准 可兼容NVMe 1.2闪存：闪迪的64层堆叠BiCS 3D TLC顺序读取速度：3100MB/S\n\n西数的质量是没的说，这款采用闪迪20-82-007011主控芯片，三核心8通道设计同时采用闪迪64层叠堆BiCS 3D TLC配合海力士DDR4缓存颗粒，顺序读取速度：3100MB/S，持续读写速度相当厉害！适合游戏玩家、有影视剪辑需求、平面设计需求和需要跑程序、跑项目的用户选购。\n2、三星 970 PRO\n\n通道：PCIe Gen 3.0x4NVMe协议：NVMe 1.3协议闪存：三星V-NAND 2-bit MLC颗粒主控：三星自家Phoenix顺序读取速度：3500MB/S\n\n三星是固态界的一哥，是世界上最大的固态硬盘厂家，速度和稳定性都没得说。顺序读取速度：3500MB/S，只要你的电脑有这种卡的插口，答应我，换掉你的老机械盘好吗？对自己的电脑好一点。什么开机启动慢、软件启动慢、软件卡死、软件闪退，统统不是问题。开机飞快，软件游戏跑起来再不是问题，从此游戏不闪退、PS不死机。\n缺点就是稍微有一点点小贵，其他的真的没话可说。\n3、Intel 760P\n\n通道：PCIe 3.0 x4NVMe协议：NVMe 1.3协议闪存：英特尔二代3D TLC持续读取速度：3000MB/S\n\nIntel 760P不同容量的主控编号有区别，使用的是慧荣SM2262，8个闪存通道，每通道最大4CE，使用的是英特尔二代的3DTLC闪存，读取速度非常快。适合日常办公、平面设计需求和需要跑程序的用户选购。\n缺点：写的速度要比顶级的产品速度略低一些，SLC缓存性能中规中矩。\n4、闪迪 至尊高速系列\n\n通道：PCIe 3.0 x4主控：Marvell 88SS1093NVMe协议：NVMe 1.3协议持续读取速度：2500MB/S\n\n闪迪的这款产品采用的是Marvell 88SS1093的主控，它的性能突出在持续读写速度非常强。如果你有老电脑舍不得换或预算不够，可以考虑一下这款SSD固态硬盘，保证你也能用出新电脑的顺畅感。\n四、总结固态硬盘容量很重要，容量越大性能越好！\n此外，我给大家推荐的SSD固态硬盘都是M.2接口的，购买之前需要先确保自己电脑是否有M.2的接口。\n由于篇幅有限，我上面列举的款式也不是很全，如果有自己觉得不错的款式，可以评论告诉我，我会研究后及时加上去，或者你有什么款式想要对比，也可以放到评论区，我们一起聊一聊。\n","categories":["技术以外"],"tags":[]},{"title":"2021固态硬盘推荐 | 固态硬盘该怎么选？（小白购买指南）","url":"https://tanqingbo.cn/该如何选购固态硬盘？/","content":"固态硬盘其实分两种，一种是PSSD，一种是SSD固态硬盘，P表示portable，即移动固态硬盘和固态硬盘。\n移动固态硬盘具有体积小、携带方便、传输稳定的特点，在此之上，容量又非常的大，传输速度还很快。\n而SSD固态硬盘，是一直装在电脑机箱里面的，平时看不到，电脑直接读写的那种。\n\n求大神推荐一个性价比高的固态硬盘，我是平面设计师 应该装几个日常软件够用了吧，实在不行买个移动硬盘，请问下那个牌子的固态硬盘好？\n\n根据题主的需求，应该是想给自己的电脑配一个SSD固态硬盘，以便自己的电脑能够轻松完成设计工作，还能流畅运行一些日常的软件。此外要是能够再推荐一个移动固态硬盘（PSSD）那就更好了。\n没问题，这就给你安排上，先说安装在电脑里面的SSD固态硬盘。\nSSD固态硬盘目前市场上SSD固态硬盘的选择非常多，但是坑也不少，除了要看你自己电脑里面有没有适配的硬盘插口、物理空间多大、能不能放得下选购的硬盘之外，还要重视它的速度和安全性等。所以大家在购买的时候一定要注意。\n这里推荐的是闪迪至尊高速系列的SSD固态硬盘，也是闪迪的顶配了，基本可以等同蓝盘，性能绝对6。\n\n这张卡是M.2制式的NVMe卡，读取速度2400MB/s，写入速度1750MB/s，是普通传统的机械硬盘数倍不止。\n只要你的电脑有这种卡的插口，答应我，换掉你的老机械盘好吗？对自己的电脑好一点，什么开机启动慢、软件启动慢、软件卡死、软件闪退，统统不是问题。开机飞快，题主你的设计软件肯定能用的飞起，从此游戏不闪退、PS不死机。\n\n此外据其官方介绍说，该盘的闪存颗粒是按64层TCL方式排布，是现阶段高端产品线的主流方案。大厂的颗粒有保证，速度和稳定性在那里。如果你嫌移动固态硬盘太贵，性价比不够高，甚至可以自己买卡和壳，自己组一个移动硬盘也不是不行。\n闪迪至尊高速系列的SSD固态硬盘购买链接\n总之，这款SSD固态硬盘非常推荐游戏玩家、有影视剪辑需求、平面设计需求和需要跑程序、跑项目的用户选购。若是有老电脑舍不得换或预算不够的同学，也可以考虑只更换SSD固态硬盘，保证你也能用出新电脑的顺畅感。\nPSSD移动固态硬盘说完SSD固态硬盘，再来说一下PSSD移动固态硬盘，我们都知道，现在各种项目工程文件和素材越来越大，题主做设计肯定也需要存储和备份大量的设计素材，那么肯定还是要拥有一款用来备份数据和高速传输数据的移动固态硬盘比较好。\n通常移动固态硬盘体积较小，使用时需要一根数据线连接电脑。硬盘的接口一般是Type-C，另一端就是常用的USB、或Type-C，即插即用，非常方便。\n\n使用的时候，建议另一端也是Type C口，或者USB3.0以上，这样能保证移动固态硬盘的性能。\n现在市面上的移动固态硬盘，比较推荐的牌子有西部数据和三星。\n办公用，并且喜欢有设计感的可以选西数的My Passport。\n喜欢高端线的、对数据安全有需求的可以选三星的T7。\n西部数据的 My Passport 移动固态硬盘\n西数这款移动固态硬盘外观设计非常出色，从造型上将移动固态硬盘一分为二，配色采用黑色和香槟色。在金属色的一半，保留了西数产品的传统图样，斜置的波纹十分有品质感，摸起来既有手感，又能保证传输时的散热需求。黑与金两色相结合，低调又不失典雅，非常适合商务办公场景下对设计有追求、有品味的人。\n而且它相当轻便，只有40g，还不到一副无线耳机的重量。尺寸只有90x45x10mm，跟一张名片一般大小，不占空间又有手感，非常方便携带。\n另外，从速度上来说，这款移动固态硬盘传输速度在540MB/s，2秒传输一集美剧，4秒传输一部电影，日常使用绝对够了。\n\n此外，这个移动固态硬盘有512G、1T、2T的容量可以选择，日常使用512GB绝对够了。不管是移动办公、文件存档备份，还是个人存储或传输照片、游戏影视资料都不是问题。\n再加上西部数据这款产品内置WD Security软件，开启了密码保护功能，可以帮助我们加密文件，防止他人未经授权访问私密文件。此外，西部数据自带的备份工具，会自动给存入的资料备份，数据存储的安全性能上升了好几个level。\n西部数据(WD)移动硬盘高速外接USB3.0机械/SSD固态移动京东¥ 899.00去购买\n三星 T7 Touch时尚银 移动固态硬盘\n这款硬盘，外壳采用金属来包裹固定的硬件，即使从2米的高空坠落，也可以减少数据损坏，保护数据安全。此外，这款移动固态硬盘内置安全选项，采用了AES 256位加密技术，除了密码解锁还能指纹识别，双重保障，更加安全。\n这个移动固态硬盘最大的优点在于它的传输速度。读写速度都在1000MB/s以上，是三星外置硬盘的9.5倍，性能堪比内装硬盘的高端线产品。\n这个速度意味着什么呢？\n7、8G的电视剧，几秒就可以传完了；几十G的视频或者项目工程文件，理论上不到1分钟就可以传输完毕。\n\n另外，我还要夸夸它广泛的兼容性。T7 Touch和PC、Mac、Android等设备广泛兼容，产品包装里面也随附了两种数据线，分别是USB Type C-to-C和 Type C-to A的 ，也就是说不管你的电脑是什么USB接口，都可以即插即用，可以说是非常方便了。\n三星T7 Touch/T7移动硬盘 固态PSSD Type-c接口 NVMe高京东¥ 899.00去购买\n总之，如果你只是日常办公用，对设计感有点追求的话，选西数的My Passport肯定没错；如果你需要存放特别大的文件，对传输速度和安全性都有要求的话，推荐选三星 T7。\n总结固态硬盘已经逐渐成为市场主流，因其优越的读写速度和便携性、安全性，加上越来越亲民的价格，受到大家广泛的欢迎。\n而且现在移动办公的理念越来越被倡导，人们更需要一个稳定、可靠、便携的移动固态硬盘随身携带。所以根据自己的需求选择一个适合自己的固态硬盘准没错。\n最后，希望这个回答对你选购固态硬盘有所帮助！\n","categories":["技术以外"],"tags":[]},{"title":"编程学习，这些官网和官方文档你一定要收藏！","url":"https://tanqingbo.cn/Net-and-official-documents/","content":"毫无疑问，一项技术，最权威的文档一定是它的官方文档，所有的教程、书籍都是直接或者间接在官方相关文档的基础上完成。所以，编程学习，后面最好还是要看官网的。当然，官网大部分都是英文——其实配合一些翻译插件，没有想象中的那么难。\n1、Java\n地    址：Java|Oracle 、Java官方API\n简    介：这个不需要多介绍，Java官网和Java官方API。\n推荐指数：⭐⭐⭐⭐⭐\n\n\n2、Spring\n地    址：Spring\n简    介：毫无疑问Spring已经成为Java EE事实上的标准。\n推荐指数：⭐⭐⭐⭐⭐\n\n\n3、MySQL\n地    址：MySQL\n简    介：MySQL官网\n推荐指数：⭐⭐⭐⭐\n\n\n4、MyBatis\n地    址：mybatis中文文档\n简    介：国内最流行的Java持久层框架，而且幸运的是，MyBatis文档是有中文版的。\n推荐指数：⭐⭐⭐⭐\n\n\n5、Vue.js\n地    址：Vue.js\n简    介：国内最流行的前端SOP框架，Vue.js的文档是中文的。😀\n推荐指数：⭐⭐⭐⭐\n\n\n6、Linux\n地    址：Linux\n简    介：后端程序员必会的Linux.\n推荐指数：⭐⭐⭐⭐\n\n\n7、Git\n地    址：Git\n\n简    介：版本管理推荐用Git，同样有中文版本的文档。\n\n推荐指数：⭐⭐⭐⭐\n\n\n8、Dubbo\n地    址：Dubbo\n简    介：一款高性能的Java RPC框架，国内用的还是比较广泛，源于阿里，中文文档是有的。\n推荐指数：⭐⭐⭐⭐\n\n\n9、Redis\n地    址：Redis\n简    介：最流行的No SQL数据库。\n推荐指数：⭐⭐⭐⭐\n\n\n","categories":["工具"],"tags":["网站","工具"]},{"title":"有哪些程序员一定要知道的开源社区以及刷题网站？","url":"https://tanqingbo.cn/Open-source-community-and-rewriting-website/","content":"在学习的过程中，可以学习开源社区的优秀项目，也可以把自己的项目发布到开源社区。\n1、GitHub\n地    址: GitHub\n简    介：全球最大开源社区，被戏称为全球最大同性交友网站。\n推荐指数：⭐⭐⭐⭐⭐\n\n\n2、码云\n地    址: 码云\n简    介：可以看做GitHub的国内版，GitHub虽好，但GitHub服务器在美国，网络方面main一直是个问题，这种情况下，码云是个不错的替代者。\n推荐指数：⭐⭐⭐⭐\n\n九、面试刷题1、LeetCode\n地    址: LeetCode\n简    介：经典的刷题网站，主要是算法题。\n推荐指数：⭐⭐⭐⭐⭐\n\n\n2、LintCode\n地    址: LintCode\n简    介：和LeetCode类似\n推荐指数：⭐⭐⭐⭐\n\n\n3、牛客网\n地    址: 牛客网\n简    介：一个联网求职学习交流社区。\n推荐指数：⭐⭐⭐⭐\n\n\n","categories":["工具"],"tags":["网站","工具"]},{"title":"有哪些优秀的个人技术博客网站？","url":"https://tanqingbo.cn/Personal-technology-blog-site/","content":"1、美团技术团队\n地    址: 美团技术团队\n简    介：美团技术团队的博客，干货满满。\n推荐指数：⭐⭐⭐⭐⭐\n\n\n2、阮一峰的网络日志\n地    址: 阮一峰的网络日志\n简    介：大神阮一峰，博客风格真正做到深入浅出。\n推荐指数：⭐⭐⭐⭐⭐\n\n\n3、Spring Boot中文导航\n地    址: Spring Boot中文导航\n简    介：汇总了一些比较优秀的Spring Boot博客、开源作品等。\n推荐指数：⭐⭐⭐⭐\n\n\n4、Spring Cloud中文导航\n地    址: Spring Cloud中文导航\n简    介：汇总了一些比较优秀的Spring Cloud 博客、开源作品等。\n推荐指数：⭐⭐⭐⭐\n\n\n\n上面两个索引里已经有了一些比较优秀的个人博主的相关博客地址，所以里面出现的个人博客，后面就不再列出了。\n\n5、Web前端导航\n地    址: Web前端导航\n简    介：比较全的Web前端导航，包括 团队组织 、开发社区 、 前端门户、框架类库 等等网站的导航。\n推荐指数：⭐⭐⭐⭐\n\n\n6、Spring For All\n地    址: Spring For All\n简    介：目标是做最专业的的民间Sptng组织。\n推荐指数：⭐⭐⭐⭐\n\n\n7、廖雪峰的官方网站\n地    址: 廖雪峰的官方网站\n简    介：廖雪峰老师的网站，有一些不错的入门教程。\n推荐指数：⭐⭐⭐\n\n\n8、bugstack\n地    址: bugstack\n简    介：博主是京东架构师，产出非常丰富，包括框架、源码、设计模式等。\n推荐指数：⭐⭐⭐\n\n\n9、Java技术驿站\n地    址: Java技术驿站\n简    介：有很多不错的Java系列文章。\n推荐指数：⭐⭐⭐\n\n\n10、酷壳\n地    址: 酷壳\n简    介：可以了解陈皓，是个很有个性的人。\n推荐指数：⭐⭐⭐\n\n\n11、床长人工智能教程\n地    址: 床长人工智能教程\n简    介：不搞人工智能也可以看看，写的很有意思的教程，可以作为科普看看。\n推荐指数：⭐⭐⭐\n\n\n12、五分钟学算法\n地    址: 五分钟学算法\n简    介：有一些非常不错的数据结构、算法相关的内容。\n推荐指数：⭐⭐⭐\n\n\n13、犬小哈教程网\n地    址: 犬小哈教程网\n简    介：一些哈士奇的技术问答漫画很有意思。\n推荐指数：⭐⭐⭐\n\n\n15、原创技术大联盟\n地    址: 原创技术大联盟\n简    介：优秀的技术博主实在太多了，列不完，也看不完，这里有一个导航页，有上百个优秀博主的博客链接，感兴趣的按需去找吧。\n推荐指数：⭐⭐⭐\n\n\n","categories":["工具"],"tags":["网站","工具"]},{"title":"程序员必逛的国外技术博客社区！","url":"https://tanqingbo.cn/Foreign-technology-blog-community/","content":"1、Stack Overflow\n地    址: Stack Overflow\n简    介：全球最活跃的程序员技术问答交流社区，有人说程序员的所有问题都能在上面找到答案。\n推荐指数：⭐⭐⭐⭐⭐\n\n\n2、dev.io\n地    址: dev.io\n简    介：可以说是掘金的国外版。\n推荐指数：⭐⭐⭐⭐\n\n\n3、DZone\n地    址: DZone\n简    介：DZone.com是世界上最大的在线社区之一。\n推荐指数：⭐⭐⭐\n\n\n4、Bytes\n地    址: Bytes\n简    介：一个面向开发人员和IT专业人员的交流社区。\n推荐指数：⭐⭐⭐\n\n\n5、Google Developers\n地    址: Google Developers\n简    介：google开发社区。\n推荐指数：⭐⭐⭐\n\n\n","categories":["工具"],"tags":["网站","工具"]},{"title":"有哪些程序员经常逛的博客网站？","url":"https://tanqingbo.cn/coder-blog-website/","content":"1、csdn\n地    址：csdn\n简    介：最大的中文技术博客社区，内容最多，SEO做的也不错。\n推荐指数：⭐⭐⭐\n\n\n2、博客园\n地    址：博客园\n简    介：老牌中文技术博客社区，博客质量比较高，商业化气息也比较淡，之前广为诟病的UI风格也在今年进行了改进，自定义主题也让能让博客百花争艳。\n推荐指数：⭐⭐⭐⭐⭐\n\n\n3、掘金\n地    址：掘金\n简    介：UI做的最漂亮的中文技术博客社区，内容以前端和面试居多。\n推荐指数：⭐⭐⭐⭐\n\n\n4、简书\n地    址：简书\n简    介：并不是纯粹的技术博客社区，很多伤春悲秋的东西。\n推荐指数：⭐⭐⭐\n\n\n5、思否\n地    址：思否\n简    介：包含博客、问答的技术社区。\n推荐指数：⭐⭐⭐\n\n\n6、开源中国\n地    址：开源中国\n简    介：一个技术博客社区。\n推荐指数：⭐⭐⭐\n\n\n7、51CTO.COM\n地    址: 51CTO.COM\n简    介：一个IT技术网站。\n推荐指数：⭐⭐\n\n\n8、V2EX\n地    址: V2EX\n简    介：逼格很高，只支持谷歌邮箱登录。\n推荐指数：⭐⭐\n\n\n9、腾讯云社区\n地    址: 腾讯云社区\n简    介：腾讯云的开发者社区。\n推荐指数：⭐⭐⭐\n\n\n10、阿里云社区\n地    址: 阿里云社区\n简    介：阿里云的开发者社区。\n推荐指数：⭐⭐⭐\n\n\n11、开发者头条\n地    址: 开发者头条\n简    介：一个程序员分享平台。\n推荐指数：⭐⭐\n\n\n12、GitChat\n地    址:GitChat\n简    介：一个技术博客社区\n推荐指数：⭐⭐\n\n\n13、知乎\n地    址: 知乎\n简    介：知乎是个综合性的问答社区，但是聚集的程序员也比较多，有一些高质量的问答和专栏。\n推荐指数：⭐⭐⭐\n\n\n","categories":["工具"],"tags":["网站","工具"]},{"title":"程序员必看的视频教程网站！","url":"https://tanqingbo.cn/coder-videos-website/","content":"1、B站\n地    址：bilibili\n简    介：没错，bilibili也可以用来学习，除了番剧、鬼畜之外，b站同样有非常多的高质量的编程教学视频，搜索就行了。\n推荐指数：⭐⭐⭐⭐⭐\n\n\n2、慕课网\n地    址：慕课网\n简    介：比较不错的编程视频教学网站，可以找到比较体系的东西，当然，有些内容要花钱就是了。\n推荐指数：⭐⭐⭐⭐\n\n\n3、中国大学MOOC\n地    址：中国大学MOOC\n简    介：有很多名校的课程，当然不止CS。\n推荐指数：⭐⭐⭐⭐\n\n\n4、网易云课堂\n地    址：网易云课堂\n简    介：有一些计算机编程方面的视频教程。\n推荐指数：⭐⭐⭐\n\n\n5、实验楼\n地    址：实验楼\n简    介：IT技术课程网站。\n推荐指数：⭐⭐\n\n\n6、我要自学网\n地    址：（敏感词，自行百度）\n简    介：比较多的自学教程，有程序设计内容的分类。\n推荐指数：⭐⭐\n\n\n7、大学生自学网\n地    址：大学生自学网\n简    介：有一些计算机软件的大学课程。\n推荐指数：⭐⭐\n\n\n8、极客学院\n地    址：极客学院\n简    介：IT编程课程网站，付费内容居多。\n推荐指数：⭐⭐\n\n\n","categories":["工具"],"tags":["网站","工具"]},{"title":"程序员常用的电子书下载！","url":"https://tanqingbo.cn/E-book-download-commonly-used-by-programmers/","content":"1、IT码农网\n地 址：https://tanqingbo.cn/\n简 介：主要包括：计算机专业必读经典书籍下载、工具介绍和下载、各种编程语言教程、机器学习教程等\n推荐指数：⭐⭐⭐⭐⭐\n\n\n2、博文视点\n地 址：博文视点\n简 介：博文视点也是有一些好书的。\n推荐指数：⭐⭐\n\n\n3、书栈网\n地 址：书栈网\n简 介：电子书门类比较全，支持在线查看和下载。\n推荐指数：⭐⭐⭐⭐\n\n\n4、脚本之家\n地 址：脚本之家\n简 介：脚本之家电子书区有不少电子书\n推荐指数：⭐⭐⭐\n\n\n5、Java知识分享网\n地 址：Java知识分享网\n简 介：如网站名字，主要分享Java知识，电子书一般不会挂太久，删的比较快。\n推荐指数：⭐⭐⭐\n\n\n6、码农之家\n地 址：码农之家\n简 介：比较多的电子书\n推荐指数：⭐⭐⭐\n\n\n7、绿色资源网\n地 址：绿色资源网\n简 介：以软件下载为主，也有不少编程电子书，搜索就行了。\n推荐指数：⭐⭐⭐\n\n\n8、鸠摩搜书\n地 址：鸠摩搜书\n简 介：比较不错的图书搜索引擎。\n推荐指数：⭐⭐⭐\n\n\n9、计算机书籍控\n地 址：计算机书籍控\n简 介：有数百本编程电子书。\n推荐指数：⭐⭐\n\n\n10、淘链客\n地 址：淘链客\n简 介：可以搜索电子书下载链接。\n推荐指数：⭐⭐\n\n\n11、hello girl\n地 址：hello girl\n简 介：有不少电子书资源的网站。\n推荐指数：⭐⭐\n\n\n12、工联信息网\n地 址：工联信息网\n简 介：有很多优质的技术资料。\n推荐指数：⭐⭐\n\n\n13、it熊猫\n地 址：it熊猫\n简 介：有数百本技术书籍。\n推荐指数：⭐⭐\n\n\n14、极客图书\n地 址：极客图书\n简 介：可观的技术书籍资源。\n推荐指数：⭐⭐⭐\n\n\n15、搬书匠\n地 址：搬书匠\n简 介：可观的技术书籍资源。\n推荐指数：⭐⭐⭐\n\n\n16、ai books\n地 址：ai books\n简 介：比较多的开发技术图书。\n推荐指数：⭐⭐⭐\n\n\n17、爱分享电子书\n地 址：爱分享电子书\n简 介：比较多的计算机、软件书籍。\n推荐指数：⭐⭐\n\n\n","categories":["工具"],"tags":["网站","工具"]},{"title":"程序员常用的12个技术教程网站！","url":"https://tanqingbo.cn/12-technical-tutorial-sites/","content":"作为一个每天都泡在电脑面前的程序员来说，选对一些学习的地方、和大家交流的地方就显得尤为重要。\n当我们有问题的时候我们想第一时间解决，当我们想学习一门新技术的时候我们可以立马get教程，当我们想要学习资料可以第一时间下载。\n那么有哪些地方，可以快速的满足我们程序员的日常需求呢？别着急，这十几个程序员经常逛的技术教程网站可以帮你解决。\n1、http://how2j.cn\n地 址：how2j.cn\n简 介：一个Java全栈开发教程网站，内容全面，简洁易懂，非常适合入门。\n推荐指数：⭐⭐⭐⭐⭐\n\n\n2、IT码农网\n地 址：https://tanqingbo.cn/\n简 介：专注于程序员个人学习成长的网站，收集了和程序员学习相关的各种教程和资料，主要包括：计算机专业必读经典书籍下载、工具介绍和下载、各种编程语言教程、机器学习教程等。这都是花钱都买不到的财富！\n推荐指数：⭐⭐⭐⭐⭐\n\n\n3、w3cschool\n地 址：w3cschool\n简 介：前端和脚本语言为主的在线教程网站，前端的内容非常不错。\n推荐指数：⭐⭐⭐⭐⭐\n\n\n4、菜鸟教程\n地 址：菜鸟教程\n简 介：和w3cschool类似的在线教程网站，前端学习看这两个网站就够了。\n推荐指数：⭐⭐⭐⭐⭐\n\n\n5、易百教程\n地 址：易百教程\n简 介：内容比较全面的在线教程网站。\n推荐指数：⭐⭐⭐\n\n\n6、码农教程\n地 址：码农教程\n简 介：大量IT编程入门教程(JAVA, PHP, JAVASCRIPT, C, C++, HTML, CSS等)。\n推荐指数：⭐⭐⭐\n\n\n7、简单教程\n地 址：简单教程\n简 介：大量IT编程入门教程(前端、移动端、Java、.net等)。\n推荐指数：⭐⭐⭐\n\n\n8、Break易站\n地 址：Break易站\n简 介：比较多的编程教程(Java、前端、服务端部署等)。\n推荐指数：⭐⭐⭐\n\n\n9、C语言中文网\n地 址：C语言中文网\n简 介：以C语言为主，也包含数据结构、C++、Linux等。\n推荐指数：⭐⭐\n\n\n10、并发编程网\n地 址：并发编程网\n简 介：比较不错的技术网站，以Java为主，关注并发、NIO、JVM、框架等方面的内容。\n推荐指数：⭐⭐\n\n\n11、http://jenkov.com\n地 址：jenkov.com\n简 介：一个国外的技术网站，提供了非常不错的Java教程。\n推荐指数：⭐⭐⭐\n\n\n12、http://baeldung.com\n地 址：baeldung.com\n简 介：也是一个国外的技术网站，提供了非常不错的Java教程。\n推荐指数：⭐⭐⭐\n\n\n","categories":["工具"],"tags":["网站","工具"]},{"title":"原来 8 张图，就可以搞懂「零拷贝」了","url":"https://tanqingbo.cn/Zero-copy/","content":"前言磁盘可以说是计算机系统最慢的硬件之一，读写速度相差内存 10 倍以上，所以针对优化磁盘的技术非常的多，比如零拷贝、直接 I/O、异步 I/O 等等，这些优化的目的就是为了提高系统的吞吐量，另外操作系统内核中的磁盘高速缓存区，可以有效的减少磁盘的访问次数。\n这次，我们就以「文件传输」作为切入点，来分析 I/O 工作方式，以及如何优化传输文件的性能。\n\n\n正文为什么要有 DMA 技术?在没有 DMA 技术前，I/O 的过程是这样的：\n\nCPU 发出对应的指令给磁盘控制器，然后返回；\n磁盘控制器收到指令后，于是就开始准备数据，会把数据放入到磁盘控制器的内部缓冲区中，然后产生一个中断；\nCPU 收到中断信号后，停下手头的工作，接着把磁盘控制器的缓冲区的数据一次一个字节地读进自己的寄存器，然后再把寄存器里的数据写入到内存，而在数据传输的期间 CPU 是无法执行其他任务的。\n\n为了方便你理解，我画了一副图：\n\n可以看到，整个数据的传输过程，都要需要 CPU 亲自参与搬运数据的过程，而且这个过程，CPU 是不能做其他事情的。\n简单的搬运几个字符数据那没问题，但是如果我们用千兆网卡或者硬盘传输大量数据的时候，都用 CPU 来搬运的话，肯定忙不过来。\n计算机科学家们发现了事情的严重性后，于是就发明了 DMA 技术，也就是直接内存访问（*Direct Memory Access*） 技术。\n什么是 DMA 技术？简单理解就是，在进行 I/O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务。\n那使用 DMA 控制器进行数据传输的过程究竟是什么样的呢？下面我们来具体看看。\n\n具体过程：\n\n用户进程调用 read 方法，向操作系统发出 I/O 请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态；\n操作系统收到请求后，进一步将 I/O 请求发送 DMA，然后让 CPU 执行其他任务；\nDMA 进一步将 I/O 请求发送给磁盘；\n磁盘收到 DMA 的 I/O 请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向 DMA 发起中断信号，告知自己缓冲区已满；\nDMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用 CPU，CPU 可以执行其他任务；\n当 DMA 读取了足够多的数据，就会发送中断信号给 CPU；\nCPU 收到 DMA 的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间，系统调用返回；\n\n可以看到， 整个数据传输的过程，CPU 不再参与数据搬运的工作，而是全程由 DMA 完成，但是 CPU 在这个过程中也是必不可少的，因为传输什么数据，从哪里传输到哪里，都需要 CPU 来告诉 DMA 控制器。\n早期 DMA 只存在在主板上，如今由于 I/O 设备越来越多，数据传输的需求也不尽相同，所以每个 I/O 设备里面都有自己的 DMA 控制器。\n\n传统的文件传输有多糟糕？如果服务端要提供文件传输的功能，我们能想到的最简单的方式是：将磁盘上的文件读取出来，然后通过网络协议发送给客户端。\n传统 I/O 的工作方式是，数据读取和写入是从用户空间到内核空间来回复制，而内核空间的数据是通过操作系统层面的 I/O 接口从磁盘读取或写入。\n代码通常如下，一般会需要两个系统调用：\nread(file, tmp_buf, len);write(socket, tmp_buf, len);\n\n代码很简单，虽然就两行代码，但是这里面发生了不少的事情。\n\n首先，期间共发生了 4 次用户态与内核态的上下文切换，因为发生了两次系统调用，一次是 read() ，一次是 write()，每次系统调用都得先从用户态切换到内核态，等内核完成任务后，再从内核态切换回用户态。\n上下文切换到成本并不小，一次切换需要耗时几十纳秒到几微秒，虽然时间看上去很短，但是在高并发的场景下，这类时间容易被累积和放大，从而影响系统的性能。\n其次，还发生了 4 次数据拷贝，其中两次是 DMA 的拷贝，另外两次则是通过 CPU 拷贝的，下面说一下这个过程：\n\n第一次拷贝，把磁盘上的数据拷贝到操作系统内核的缓冲区里，这个拷贝的过程是通过 DMA 搬运的。\n第二次拷贝，把内核缓冲区的数据拷贝到用户的缓冲区里，于是我们应用程序就可以使用这部分数据了，这个拷贝到过程是由 CPU 完成的。\n第三次拷贝，把刚才拷贝到用户的缓冲区里的数据，再拷贝到内核的 socket 的缓冲区里，这个过程依然还是由 CPU 搬运的。\n第四次拷贝，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程又是由 DMA 搬运的。\n\n我们回过头看这个文件传输的过程，我们只是搬运一份数据，结果却搬运了 4 次，过多的数据拷贝无疑会消耗 CPU 资源，大大降低了系统性能。\n这种简单又传统的文件传输方式，存在冗余的上文切换和数据拷贝，在高并发系统里是非常糟糕的，多了很多不必要的开销，会严重影响系统性能。\n所以，要想提高文件传输的性能，就需要减少「用户态与内核态的上下文切换」和「内存拷贝」的次数。\n\n如何优化文件传输的性能？\n先来看看，如何减少「用户态与内核态的上下文切换」的次数呢？\n\n读取磁盘数据的时候，之所以要发生上下文切换，这是因为用户空间没有权限操作磁盘或网卡，内核的权限最高，这些操作设备的过程都需要交由操作系统内核来完成，所以一般要通过内核去完成某些任务的时候，就需要使用操作系统提供的系统调用函数。\n而一次系统调用必然会发生 2 次上下文切换：首先从用户态切换到内核态，当内核执行完任务后，再切换回用户态交由进程代码执行。\n所以，要想减少上下文切换到次数，就要减少系统调用的次数。\n\n再来看看，如何减少「数据拷贝」的次数？\n\n在前面我们知道了，传统的文件传输方式会历经 4 次数据拷贝，而且这里面，「从内核的读缓冲区拷贝到用户的缓冲区里，再从用户的缓冲区里拷贝到 socket 的缓冲区里」，这个过程是没有必要的。\n因为文件传输的应用场景中，在用户空间我们并不会对数据「再加工」，所以数据实际上可以不用搬运到用户空间，因此用户的缓冲区是没有必要存在的。\n\n如何实现零拷贝？零拷贝技术实现的方式通常有 2 种：\n\nmmap + write\nsendfile\n\n下面就谈一谈，它们是如何减少「上下文切换」和「数据拷贝」的次数。\nmmap + write在前面我们知道，read() 系统调用的过程中会把内核缓冲区的数据拷贝到用户的缓冲区里，于是为了减少这一步开销，我们可以用 mmap() 替换 read() 系统调用函数。\nbuf = mmap(file, len);write(sockfd, buf, len);\n\nmmap() 系统调用函数会直接把内核缓冲区里的数据「映射」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。\n\n具体过程如下：\n\n应用进程调用了 mmap() 后，DMA 会把磁盘的数据拷贝到内核的缓冲区里。接着，应用进程跟操作系统内核「共享」这个缓冲区；\n应用进程再调用 write()，操作系统直接将内核缓冲区的数据拷贝到 socket 缓冲区中，这一切都发生在内核态，由 CPU 来搬运数据；\n最后，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程是由 DMA 搬运的。\n\n我们可以得知，通过使用 mmap() 来代替 read()， 可以减少一次数据拷贝的过程。\n但这还不是最理想的零拷贝，因为仍然需要通过 CPU 把内核缓冲区的数据拷贝到 socket 缓冲区里，而且仍然需要 4 次上下文切换，因为系统调用还是 2 次。\nsendfile在 Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用函数 sendfile()，函数形式如下：\n#include &lt;sys/socket.h&gt;ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);\n\n它的前两个参数分别是目的端和源端的文件描述符，后面两个参数是源端的偏移量和复制数据的长度，返回值是实际复制数据的长度。\n首先，它可以替代前面的 read() 和 write() 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销。\n其次，该系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝。如下图：\n\n但是这还不是真正的零拷贝技术，如果网卡支持 SG-DMA（The Scatter-Gather Direct Memory Access）技术（和普通的 DMA 有所不同），我们可以进一步减少通过 CPU 把内核缓冲区里的数据拷贝到 socket 缓冲区的过程。\n你可以在你的 Linux 系统通过下面这个命令，查看网卡是否支持 scatter-gather 特性：\n$ ethtool -k eth0 | grep scatter-gatherscatter-gather: on\n\n于是，从 Linux 内核 2.4 版本开始起，对于支持网卡支持 SG-DMA 技术的情况下， sendfile() 系统调用的过程发生了点变化，具体过程如下：\n\n第一步，通过 DMA 将磁盘上的数据拷贝到内核缓冲区里；\n第二步，缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝；\n\n所以，这个过程之中，只进行了 2 次数据拷贝，如下图：\n\n这就是所谓的零拷贝（*Zero-copy*）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。\n零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。\n所以，总体来看，零拷贝技术可以把文件传输的性能提高至少一倍以上。\n使用零拷贝技术的项目事实上，Kafka 这个开源项目，就利用了「零拷贝」技术，从而大幅提升了 I/O 的吞吐率，这也是 Kafka 在处理海量数据为什么这么快的原因之一。\n如果你追溯 Kafka 文件传输的代码，你会发现，最终它调用了 Java NIO 库里的 transferTo方法：\n@Overridepublic long transferFrom(FileChannel fileChannel, long position, long count) throws IOException {     return fileChannel.transferTo(position, count, socketChannel);}\n\n如果 Linux 系统支持 sendfile() 系统调用，那么 transferTo() 实际上最后就会使用到 sendfile() 系统调用函数。\n曾经有大佬专门写过程序测试过，在同样的硬件条件下，传统文件传输和零拷拷贝文件传输的性能差异，你可以看到下面这张测试数据图，使用了零拷贝能够缩短 65% 的时间，大幅度提升了机器传输数据的吞吐量。\n\n数据来源于：https://developer.ibm.com/articles/j-zerocopy/\n另外，Nginx 也支持零拷贝技术，一般默认是开启零拷贝技术，这样有利于提高文件传输的效率，是否开启零拷贝技术的配置如下：\nhttp {...    sendfile on...}\n\nsendfile 配置的具体意思: \n\n设置为 on 表示，使用零拷贝技术来传输文件：sendfile ，这样只需要 2 次上下文切换，和 2 次数据拷贝。\n设置为 off 表示，使用传统的文件传输技术：read + write，这时就需要 4 次上下文切换，和 4 次数据拷贝。\n\n当然，要使用 sendfile，Linux 内核版本必须要 2.1 以上的版本。\n\nPageCache 有什么作用？回顾前面说道文件传输过程，其中第一步都是先需要先把磁盘文件数据拷贝「内核缓冲区」里，这个「内核缓冲区」实际上是磁盘高速缓存（*PageCache*）。\n由于零拷贝使用了 PageCache 技术，可以使得零拷贝进一步提升了性能，我们接下来看看 PageCache 是如何做到这一点的。\n读写磁盘相比读写内存的速度慢太多了，所以我们应该想办法把「读写磁盘」替换成「读写内存」。于是，我们会通过 DMA 把磁盘里的数据搬运到内存里，这样就可以用读内存替换读磁盘。\n但是，内存空间远比磁盘要小，内存注定只能拷贝磁盘里的一小部分数据。\n那问题来了，选择哪些磁盘数据拷贝到内存呢？\n我们都知道程序运行的时候，具有「局部性」，所以通常，刚被访问的数据在短时间内再次被访问的概率很高，于是我们可以用 PageCache 来缓存最近被访问的数据，当空间不足时淘汰最久未被访问的缓存。\n所以，读磁盘数据的时候，优先在 PageCache 找，如果数据存在则可以直接返回；如果没有，则从磁盘中读取，然后缓存 PageCache 中。\n还有一点，读取磁盘数据的时候，需要找到数据所在的位置，但是对于机械磁盘来说，就是通过磁头旋转到数据所在的扇区，再开始「顺序」读取数据，但是旋转磁头这个物理动作是非常耗时的，为了降低它的影响，PageCache 使用了「预读功能」。\n比如，假设 read 方法每次只会读 32 KB 的字节，虽然 read 刚开始只会读 0 ～ 32 KB 的字节，但内核会把其后面的 32～64 KB 也读取到 PageCache，这样后面读取 32～64 KB 的成本就很低，如果在 32～64 KB 淘汰出 PageCache 前，进程读取到它了，收益就非常大。\n所以，PageCache 的优点主要是两个：\n\n缓存最近被访问的数据；\n预读功能；\n\n这两个做法，将大大提高读写磁盘的性能。\n但是，在传输大文件（GB 级别的文件）的时候，PageCache 会不起作用，那就白白浪费 DMA 多做的一次数据拷贝，造成性能的降低，即使使用了 PageCache 的零拷贝也会损失性能\n这是因为如果你有很多 GB 级别文件需要传输，每当用户访问这些大文件的时候，内核就会把它们载入 PageCache 中，于是 PageCache 空间很快被这些大文件占满。\n另外，由于文件太大，可能某些部分的文件数据被再次访问的概率比较低，这样就会带来 2 个问题：\n\nPageCache 由于长时间被大文件占据，其他「热点」的小文件可能就无法充分使用到 PageCache，于是这样磁盘读写的性能就会下降了；\nPageCache 中的大文件数据，由于没有享受到缓存带来的好处，但却耗费 DMA 多拷贝到 PageCache 一次；\n\n所以，针对大文件的传输，不应该使用 PageCache，也就是说不应该使用零拷贝技术，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache，这样在高并发的环境下，会带来严重的性能问题。\n\n大文件传输用什么方式实现？那针对大文件的传输，我们应该使用什么方式呢？\n我们先来看看最初的例子，当调用 read 方法读取文件时，进程实际上会阻塞在 read 方法调用，因为要等待磁盘数据的返回，如下图：\n\n具体过程：\n\n当调用 read 方法时，会阻塞着，此时内核会向磁盘发起 I/O 请求，磁盘收到请求后，便会寻址，当磁盘数据准备好后，就会向内核发起 I/O 中断，告知内核磁盘数据已经准备好；\n内核收到 I/O 中断后，就将数据从磁盘控制器缓冲区拷贝到 PageCache 里；\n最后，内核再把 PageCache 中的数据拷贝到用户缓冲区，于是 read 调用就正常返回了。\n\n对于阻塞的问题，可以用异步 I/O 来解决，它工作方式如下图：\n\n它把读操作分为两部分：\n\n前半部分，内核向磁盘发起读请求，但是可以不等待数据就位就可以返回，于是进程此时可以处理其他任务；\n后半部分，当内核将磁盘中的数据拷贝到进程缓冲区后，进程将接收到内核的通知，再去处理数据；\n\n而且，我们可以发现，异步 I/O 并没有涉及到 PageCache，所以使用异步 I/O 就意味着要绕开 PageCache。\n绕开 PageCache 的 I/O 叫直接 I/O，使用 PageCache 的 I/O 则叫缓存 I/O。通常，对于磁盘，异步 I/O 只支持直接 I/O。\n前面也提到，大文件的传输不应该使用 PageCache，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache。\n于是，在高并发的场景下，针对大文件的传输的方式，应该使用「异步 I/O + 直接 I/O」来替代零拷贝技术。\n直接 I/O 应用场景常见的两种：\n\n应用程序已经实现了磁盘数据的缓存，那么可以不需要 PageCache 再次缓存，减少额外的性能损耗。在 MySQL 数据库中，可以通过参数设置开启直接 I/O，默认是不开启；\n传输大文件的时候，由于大文件难以命中 PageCache 缓存，而且会占满 PageCache 导致「热点」文件无法充分利用缓存，从而增大了性能开销，因此，这时应该使用直接 I/O。\n\n另外，由于直接 I/O 绕过了 PageCache，就无法享受内核的这两点的优化：\n\n内核的 I/O 调度算法会缓存尽可能多的 I/O 请求在 PageCache 中，最后「合并」成一个更大的 I/O 请求再发给磁盘，这样做是为了减少磁盘的寻址操作；\n内核也会「预读」后续的 I/O 请求放在 PageCache 中，一样是为了减少对磁盘的操作；\n\n于是，传输大文件的时候，使用「异步 I/O + 直接 I/O」了，就可以无阻塞地读取文件了。\n所以，传输文件的时候，我们要根据文件的大小来使用不同的方式：\n\n传输大文件的时候，使用「异步 I/O + 直接 I/O」；\n传输小文件的时候，则使用「零拷贝技术」；\n\n在 Nginx 中，我们可以用如下配置，来根据文件的大小来使用不同的方式：\nlocation /video/ {     sendfile on;     aio on;     directio 1024m; }\n\n当文件大小大于 directio 值后，使用「异步 I/O + 直接 I/O」，否则使用「零拷贝技术」。\n\n总结早期 I/O 操作，内存与磁盘的数据传输的工作都是由 CPU 完成的，而此时 CPU 不能执行其他任务，会特别浪费 CPU 资源。\n于是，为了解决这一问题，DMA 技术就出现了，每个 I/O 设备都有自己的 DMA 控制器，通过这个 DMA 控制器，CPU 只需要告诉 DMA 控制器，我们要传输什么数据，从哪里来，到哪里去，就可以放心离开了。后续的实际数据传输工作，都会由 DMA 控制器来完成，CPU 不需要参与数据传输的工作。\n传统 IO 的工作方式，从硬盘读取数据，然后再通过网卡向外发送，我们需要进行 4 上下文切换，和 4 次数据拷贝，其中 2 次数据拷贝发生在内存里的缓冲区和对应的硬件设备之间，这个是由 DMA 完成，另外 2 次则发生在内核态和用户态之间，这个数据搬移工作是由 CPU 完成的。\n为了提高文件传输的性能，于是就出现了零拷贝技术，它通过一次系统调用（sendfile 方法）合并了磁盘读取与网络发送两个操作，降低了上下文切换次数。另外，拷贝数据都是发生在内核中的，天然就降低了数据拷贝的次数。\nKafka 和 Nginx 都有实现零拷贝技术，这将大大提高文件传输的性能。\n零拷贝技术是基于 PageCache 的，PageCache 会缓存最近访问的数据，提升了访问缓存数据的性能，同时，为了解决机械硬盘寻址慢的问题，它还协助 I/O 调度算法实现了 IO 合并与预读，这也是顺序读比随机读性能好的原因。这些优势，进一步提升了零拷贝的性能。\n需要注意的是，零拷贝技术是不允许进程对文件内容作进一步的加工的，比如压缩数据再发送。\n另外，当传输大文件时，不能使用零拷贝，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache，并且大文件的缓存命中率不高，这时就需要使用「异步 IO + 直接 IO 」的方式。\n在 Nginx 里，可以通过配置，设定一个文件大小阈值，针对大文件使用异步 IO 和直接 IO，而对小文件使用零拷贝。\n","categories":["计算机基础知识"],"tags":["TCP/IP","网络"]},{"title":"知识付费里面装的是什么，没错，是韭菜！","url":"https://tanqingbo.cn/Understanding-of-paying-for-knowledge/","content":"我之前说过，知识付费这东西很重要，降低了学习门槛，还可以很好的过滤一些伸手党，但是为什么里面装的是韭菜呢？\n因为很多人（包括我自己）对于知识这东西都有个误区，不少人花了不少钱订阅了一些付费课程，知道了很多高大上的术语，什么认知升级、黑天鹅、降维打击、KOC、跨界创业、区块链…….都能说得头头是道，然而却什么事都没做成。\n我之前也是这样，一些专业术语张嘴就能说出来，以为自己很牛逼，但是后来发现知道这些东西并不能给我带来帮助，我们都进入了一个误区，以为看了知识就等于拥有了智慧，学了财务自由的课程就以为自己真的能财务自由了！太天真了！！！！\n没有实践作为支撑的知识都TM是在扯淡，理论知识学得再好，一上手写代码，全是bug，有人敢用你吗？空中楼阁搭的再好，终究只是幻影。\n现在针对知识付费的平台有很多，得到、知识星球、极客时间、知乎live……，各种五花八门的付费专栏，价格都不便宜，但又都想买，买了吴军的得到的专栏，又加入了张哥的知识星球，还有一些其它的星球也想加入，生怕自己错过什么关键的信息，就像小孩上补习班一样，怕自己输在职场的起跑线上！\n但是花钱买的这些知识，看完之后思考了吗？总结了吗？实践了吗？没有，我们只是看完了，然后换另一个心里安慰，看，我又学会了一个新的专有名词，厉害吧！\n其实成为韭菜的最大一个原因是我们自己缺少总结的习惯，把专栏中看的知识，分析总结，然后拿到工作和学习中去实践，这样才会慢慢转化成为自己的东西，否则自己钱也花了，然后啥也没学会，赖谁？\n我支持知识付费，虽然我买过没用的专栏，但我也确实从中获得了好处，我之前买了一个理财的知识星球，我按照星主的理财方法，现在理财收益已经超过了一万多。我也听朋友分享，他按照《富爸爸穷爸爸》里的方法，成功将负债变成资产。\n你看，是不是成为韭菜的关键在自己，所以请不要忘记自己知识付费的初衷，千万不要只是简单的看过，以为买了就是会了，自欺欺人要不得！\n","categories":["技术以外"],"tags":[]},{"title":"“双11”购物节的本质！","url":"https://tanqingbo.cn/The-essence-of-shopping-festival/","content":"双11，明明是单身狗的节日，现在却变成了掏空钱包的节日了，更惨的是钱包都掏空了依然没有对象，想想就难过。\n话说回来，如果你以为双11只是一个购物节，那你就错了。\n双11这一天的成交额一出来，也就指示了未来两个多月的股市走向，如果这一天业绩不好，阿里的股价肯定会大幅波动，不止阿里，一些大的商业品牌，在这一天的成交额也会影响他们未来的股价。\n其次，这一天的销售业绩表现，也反映了大家对未来经济有没有信心，如果大家觉得自己的收入稳定，职场上也没有什么风险，那肯定会多花钱，反之则不敢花钱，所以是不是职场寒冬，从双11这一天的销售业绩也能窥探一二。也正是这个原因，一些经济学专家和基金经理对购物节会特别关注。\n还一件特别有意思的事情不知道大家注意到没有，大分部的科技公司，他们的产品发布会都是定在11月以前，几乎没有哪一家公司会在11月以后再开发布会的。原因嘛，你们猜和双11购物节有没有关系？\n谷歌曾经和索尼、飞利浦合作开发过一款非常酷的电子产品，但是赶不及在购物节之前推出，公司就把它推迟到了第二年，结果第二年遇上了金融危机，公司干脆就砍掉了这个项目，它的负责人也被辞退了。\n你看，双11不仅绑架了顾客，其实它也绑架了公司。\n我知道，不管双11绑架了谁，你还是会准备好银子，守到12点，去抢你想要买的东西。\n我也是一样，真香！\n","categories":["技术以外"],"tags":[]},{"title":"以牙还牙、以硬碰硬、逢敌必亮剑","url":"https://tanqingbo.cn/Head-to-head/","content":"我最近学会了一个特别有用的知识，对付登门推销、校园霸凌、性骚扰等事件都很有用。\n不开玩笑，认真点，这是重点，考试要考啊！（难得写一篇讲道理的文章）\n开始之前先讲个故事：\n二战的时候，苏联和日本在中国内蒙一个叫 诺门坎的地方打了一场大战，这场战虽然名气不大，但是却影响了整个二战的格局，战争的结果是苏联几乎以2:1的损失，惨胜日本。\n当时的格局是这样的，德国正在欧洲磨刀霍霍，而日本只是在中国霍霍，还没有入侵苏联境内，按理说苏联的主要敌人应该是德国才对，但是斯大林却分散大量的兵力在中国和日本干了一战，斯大林为什么要这么做呢？活雷锋吗？\n当然不是，要讨论这个问题，那就得先来分析一下日本是一个什么样的敌人，在偌门坎战役之前，日本在中国采取的策略一直都是先干点坏事，看看中国人的反应，要是有便宜占，那就得寸进尺，无论是炸死张作霖，还是九一八事件占领东北，还是后来的卢沟桥事件都是这样的，用互联网的话来说就是“小步快跑，快速迭代”，拱一步，看一下，有甜头，再向前。\n所以，在日本打算北上入侵苏联的时候，也打算采用“小步快跑，快速迭代”的互联网战略，先试探一下，看看有没有甜头，斯大林深知日本人的调性，宁愿自己在欧洲战场暂时不利，也要调配重兵给日本人迎头痛击，在这场战争中，日本损失19000人，但是苏联损失了26000多人，可谓是损失惨重，但是赢了，强行把硬边界划出来了。\n这场战争导致的结果就是，日本东京董事局发现北上并没有甜头，于是砍掉了北上的项目，开始南下着重布局东南亚战场。后来斯大林和希特勒在莫斯科拼的快油尽灯枯的时候，斯大林大胆把20个亚洲师全部调回莫斯科，最终打败希特勒，也奠定了二战的胜局。也正是因为诺门坎之战把日本人打痛了，斯大林才敢冒这个险把亚洲师全部调回莫斯科。\n你看，诺门坎之战，苏联看似惨胜，但是放眼整个战局，苏联却是用很小的代价换来了巨大的战略利益。\n在生活中，我们也会经常遇到像日本这样的恶人，怎么对付呢？可以借鉴一下诺门坎之战中苏联的变现，让他们在第一次试探的时候就遇到强大的阻力，强行把硬边界划出来。\n校园霸凌可能就是从抢一块橡皮开始，性骚扰可能是从一次黄腔开始，这个时候其实一个反抗的眼神就能解决问题，但如果你不做，就会付出更大的代价。中国的九一八、卢沟桥事件就是血淋淋的例子。因此，面对恶人，要学会划出硬边界，不能给对方得寸进尺的机会。\n在博弈论中，经过计算机无数次模拟，发现只有一种策略是最优的，叫“以牙还牙”策略，如果对方发起挑衅，最好的策略就是以硬碰硬，逢敌必亮剑。\n","categories":["技术以外"],"tags":[]},{"title":"怎么判断一项技术是否靠谱？","url":"https://tanqingbo.cn/How-to-judge-whether-technologyisreliable/","content":"作为吴军老师的粉丝，我又来了分享吴军老师的东西了。\n吴军老师在《前言科技》里面分享了一个别有用的东西，就是如何判断一项技术是否靠谱？这对自己以后就业和职业规划都有帮助。\n那么判断一项技术靠不靠谱的通用准则是什么呢？是能量和信息。\n如果你判断不了技术演化的方向，那就抓住这两根线索。技术演化，总是向越来越高的能量使用效率，和越来越高的信息传输效率的方向走的。\n两年前，工信部的一位退休的老领导和吴军老师聊起当年邮电部变革的故事。\n他说，第一次变革是邮政和电信分家，绝大部分人都去邮政那一边。为啥？因为当时中国的电信规模还非常小，不普及。而邮政呢？家大业大历史久远。\n第二次变革是有线电话业务和移动通信业务分家，也是大家都去有线那边。原因一样，有线电话业务家大业大历史久远。\n但是今天回看这些人的选择，都错了。但问题是，每个人都只能根据自己当前看到的利弊得失来做选择啊？怎么能让身在局中的人有长远眼光呢？\n吴军老师说，有一条线索可以供大家参考，就是考虑信息和能量的关系。邮政这件事，单位能量传递的信息很低，邮递员跑半天，消耗那么高的能量才送一封信。\n有线电话这件事效率也不高，一根根线拉到家里，只传递每秒64比特的信息，效率也不高，即使安装了有线电话，升级服务的可能性也不大。\n移动通信就好很多了，这也是中国为什么农村有线电话发展不起来，而移动电话却很快普及的原因。\n根据这个原理，做人生选择的时候，就应该选择那些信息传递效率更高，能量使用效率更高的行业，就不会犯大错了。你看，如果穿越回当年，邮政部门的那些人要是有了这个方法论，重新选择一次，也许就有了超越当前局限的判断力了。\n","categories":["技术以外"],"tags":[]},{"title":"人生最重要的投资！","url":"https://tanqingbo.cn/The-most-important-investment-in-life/","content":"最近在读吴军老师《见识》这本书，已经是第二次读了，读完还是感觉收获满满，我把我整理的一些读书笔记分享给大家，以下是第一章的内容：\n1、这个世界没有欠你什么寒窗苦读只是一种读书态度，这种态度是好的，但是社会竞争是一种非常复杂的长期系统性的竞赛，它只能算是成功因素之一，和经济条件好、智商高、出身好、颜值高一样，都只是其中一个变量而已，然而命运却是多个变量互动的结果。 \n在任何的国家、任何时代、社会都是分层的，稍微好一点的社会上下层之间会有一个通道，让人员可以流动，向上流动的过程也就是我们所说的“逆袭”。不要期望一辈子能从第80层上升到前10层，每一代人能够努力向上挤几层就已经很好了，前华盛顿州长骆家辉，从他爷爷家到州长官邸只有100米距离，但是他们家却走了三代人的时间。\n2、人生最重要的投资对于年轻人来讲，对自己的投资和在职业上的进步，远比在股市上捞点钱或者向父母借钱买一套房子更为重要，也更为靠得住。此外，还有一个和投资自己同样重要的投资就是找一个好的配偶。\n\n巴菲特给女生的建议：\n找比自己更优秀的人；\n趁着年轻的时候把自己嫁出去。\n\n\n\n给男生的建议：\n聪明人会欣赏聪明人，而且只有聪明人才会欣赏聪明人。对于一个聪明的男生来说，他打动一个漂亮且聪明的女生要比打动一个漂亮但不聪明的女生要容易很多。\n母亲的智力水平对孩子的影响要比父亲大，所以如果男生希望自己的孩子比较聪明，最好找聪明的女生。\n一个人，特别是年轻的时候，可塑性很重要，虽说喜欢一个人就要包容她的缺点，但是包容一天可以，一年可以，包容一辈子还是很有难度的。\n\n给女生的建议：\n婚姻和恋爱不同，恋爱是激情，婚姻则是由两个人共同创造的舒适共同体，在那个共同体中，双方都将受益。\n世界上没有老实和不老实男生之分，只有对你好和对你不好的人，维持长久婚姻靠对方老实是没有用的，因为人的基因里都有好色的基因在里面，男生女生有一样。\n那么如何判断一个人是否对自己好呢？看他的婚姻观，看他是否认可夫妻之间的关系重要性要高于其它关系的重要性。此外还要看他有没有对你好的能力，这个能力不是看他有多少钱，而是看他未来的潜力，因为一辈子这么长，多少钱都能花完，但是潜力却可以创造更多的钱。\n能够发现一个男生的美德和未来的潜力很重要。\n\n3、让父母先成熟起来父母应该明白，自己生活的年代比子女早了30年，接受的是30年前的理念，代沟是一定存在的，而且30年前的婚恋观非常简单，他们那点成功的婚姻经验，放到现在其实参考价值并不大。\n父母是孩子最好的老师，孩子的观察能力非常强，父母身上哪怕有一点点坏的习惯，孩子很容易就学会。\n要想孩子将来成为精英，自己首先成为精英的父母。\n","categories":["技术以外"],"tags":[]},{"title":"靠这几本算法书，成功拿下大厂offer！","url":"https://tanqingbo.cn/10-algorithm-book/","content":"在我还在上大学的时候，老师就跟我们反复强调算法的重要性，大多数的机构和顶尖大厂在面试的时候也会着重考察面试者的算法能力。\n所以对于程序员来说，手撕算法能力一定要好好修炼。在这里我整理了一份由易到难的算法学习书单（附下载链接），希望能对大家在学习算法和找工作有所帮助！\n1、《我的第一本算法书》这本书是京都大学一个计算机教授和朋友联合出品的动画讲解算法的App 所衍生出来的书籍，非常适合新手朋友们。里面没有枯燥的理论和复杂的公式，而是通过大量的步骤图帮助读者加深对数据结构原理和算法执行过程的理解，便于学习和记忆。将本书作为算法入门的第一步，是非常不错的选择。\n\n\n链接：https://pan.baidu.com/s/1r_lxqzfg7YTHvAEQhNJwnQ\n\n提取码：en9j\n\n\n2、《趣学算法》本书从算法之美娓娓道来，没有高深的原理，也没有枯燥的公式，通过趣味故事引出算法问题，包含50多个实例及完美图解，结合学生提问，分析算法本质，并给出代码实现的详细过程和运行结果。本书可作为程序员的学习用书，也适合从未有过编程经验但又对算法有强烈兴趣的初学者使用，同时也可作为高等院校计算机、数学及相关专业的师生用书和培训学校的教材。\n\n\n链接：https://pan.baidu.com/s/1gg4TXOat08UK-ZziBvCuWw \n提取码：l55p \n\n3、《啊哈！算法》《啊哈！算法》一切以实际应用为出发点，通过幽默的语言配以可爱的插图来讲解算法。其中涉及的数据结构有栈、队列、链表、树、并查集、堆和图等；涉及的算法有排序、枚举、深度和广度优先搜索、图的遍历，当然还有图论中不可以缺少的四种最短路径算法、两种最小生成树算法、割点与割边算法、二分图的最大匹配算法等。\n\n\n链接：https://pan.baidu.com/s/1PLMxdbqLcUmCUs0Ueb6ckA \n提取码：9yyz \n\n4、《图解算法》这是一本像小说一样有趣的算法入门书，示例丰富，图文并茂，以让人容易理解的方式阐释了算法，旨在帮助程序员在日常项目中更好地发挥算法的能量。书中的前三章将帮助你打下基础，带你学习二分查找、大O表示法、两种基本的数据结构以及递归等。余下的篇幅将主要介绍应用广泛的算法。\n\n\n链接：https://pan.baidu.com/s/1GZEp8KI1Fm0U4Uek7BOWAw\n\n提取码：am4o\n\n\n5、《剑指offer》这本书大家一定如雷贯耳吧，基本上只要你是程序员就一定会用到这本书，书里面剖析了50个典型的程序员面试题，从基础知识、代码质量、解题思路、优化效率和综合能力五个方面系统整理了影响面试的5个要点，是程序员找工作必备的一本算法书。\n\n\n链接：https://pan.baidu.com/s/1GD9yTglFZkn5n__965dKjA\n\n提取码：mas8\n\n\n6、《算法导论》这本书真的称得上是算法领域的“圣书”了，如果把它从头到尾看完并且搞明白了，那么恭喜你，年入百万不是梦！\n\n\n链接：https://pan.baidu.com/s/1Y1kXAyQsZO3MA_kgfa5Jog \n提取码：tl3x \n\n","categories":["数据结构与算法"],"tags":["算法"]},{"title":"网络原理之TCP/IP、HTTPS详解","url":"https://tanqingbo.cn/Network-principle/","content":"谈一谈你对TCP/IP四层模型，OSI七层模型的理解？为了增强通用性和兼容性，计算机网络都被设计成层次机构，每一层都遵守一定的规则。\n因此有了OSI这样一个抽象的网络通信参考模型，按照这个标准使计算机网络系统可以互相连接。\n物理层：通过网线、光缆等这种物理方式将电脑连接起来。传递的数据是比特流，0101010100。\n数据链路层：首先，把比特流封装成数据帧的格式，对0、1进行分组。电脑连接起来之后，数据都经过网卡来传输，而网卡上定义了全世界唯一的MAC地址。然后再通过广播的形式向局域网内所有电脑发送数据，再根据数据中MAC地址和自身对比判断是否是发给自己的。\n网络层：广播的形式太低效，为了区分哪些MAC地址属于同一个子网，网络层定义了IP和子网掩码，通过对IP和子网掩码进行与运算就知道是否是同一个子网，再通过路由器和交换机进行传输。IP协议属于网络层的协议。\n传输层：有了网络层的MAC+IP地址之后，为了确定数据包是从哪个进程发送过来的，就需要端口号，通过端口来建立通信，比如TCP和UDP属于这一层的协议。\n会话层：负责建立和断开连接\n表示层：为了使得数据能够被其他的计算机理解，再次将数据转换成另外一种格式，比如文字、视频、图片等。\n应用层：最高层，面对用户，提供计算机网络与最终呈现给用户的界面\n\nTCP/IP则是四层的结构，相当于是对OSI模型的简化。\n\n数据链路层，也有称作网络访问层、网络接口层。他包含了OSI模型的物理层和数据链路层，把电脑连接起来。\n网络层，也叫做IP层，处理IP数据包的传输、路由，建立主机间的通信。\n传输层，就是为两台主机设备提供端到端的通信。\n应用层，包含OSI的会话层、表示层和应用层，提供了一些常用的协议规范，比如FTP、SMPT、HTTP等。\n\n总结下来，就是物理层通过物理手段把电脑连接起来，数据链路层则对比特流的数据进行分组，网络层来建立主机到主机的通信，传输层建立端口到端口的通信，应用层最终负责建立连接，数据格式转换，最终呈现给用户。\n说说TCP 3次握手的过程？建立连接前server端需要监听端口，所以初始状态是LISTEN。\n\nclient端建立连接，发送一个SYN同步包，发送之后状态变成SYN_SENT\nserver端收到SYN之后，同意建立连接，返回一个ACK响应，同时也会给client发送一个SYN包，发送完成之后状态变为SYN_RCVD\nclient端收到server的ACK之后，状态变为ESTABLISHED，返回ACK给server端。server收到之后状态也变为ESTABLISHED，连接建立完成。\n\n\n为什么要3次？2次，4次不行吗？因为TCP是双工传输模式，不区分客户端和服务端，连接的建立是双向的过程。\n如果只有两次，无法做到双向连接的建立，从建立连接server回复的SYN和ACK合并成一次可以看出来，他也不需要4次。\n挥手为什么要四次？因为挥手的ACK和FIN不能同时发送，因为数据发送的截止时间不同。\n那么四次挥手的过程呢？\nclient端向server发送FIN包，进入FIN_WAIT_1状态，这代表client端已经没有数据要发送了\nserver端收到之后，返回一个ACK，进入CLOSE_WAIT等待关闭的状态，因为server端可能还有没有发送完成的数据\n等到server端数据都发送完毕之后，server端就向client发送FIN，进入LAST_ACK状态\nclient收到ACK之后，进入TIME_WAIT的状态，同时回复ACK，server收到之后直接进入CLOSED状态，连接关闭。但是client要等待2MSL(报文最大生存时间)的时间，才会进入CLOSED状态。\n\n\n为什么要等待2MSL的时间才关闭？\n为了保证连接的可靠关闭。如果server没有收到最后一个ACK，那么就会重发FIN。\n为了避免端口重用带来的数据混淆。如果client直接进入CLOSED状态，又用相同端口号向server建立一个连接，上一次连接的部分数据在网络中延迟到达server，数据就可能发生混淆了。\n\nTCP怎么保证传输过程的可靠性？校验和：发送方在发送数据之前计算校验和，接收方收到数据后同样计算，如果不一致，那么传输有误。\n确认应答，序列号：TCP进行传输时数据都进行了编号，每次接收方返回ACK都有确认序列号。\n超时重传：如果发送方发送数据一段时间后没有收到ACK，那么就重发数据。\n连接管理：三次握手和四次挥手的过程。\n流量控制：TCP协议报头包含16位的窗口大小，接收方会在返回ACK时同时把自己的即时窗口填入，发送方就根据报文中窗口的大小控制发送速度。\n拥塞控制：刚开始发送数据的时候，拥塞窗口是1，以后每次收到ACK，则拥塞窗口+1，然后将拥塞窗口和收到的窗口取较小值作为实际发送的窗口，如果发生超时重传，拥塞窗口重置为1。这样做的目的就是为了保证传输过程的高效性和可靠性。\n说下浏览器请求一个网址的过程？\n首先通过DNS服务器把域名解析成IP地址，通过IP和子网掩码判断是否属于同一个子网\n构造应用层请求http报文，传输层添加TCP/UDP头部，网络层添加IP头部，数据链路层添加以太网协议头部\n数据经过路由器、交换机转发，最终达到目标服务器，目标服务器同样解析数据，最终拿到http报文，按照对应的程序的逻辑响应回去。\n\n\n知道HTTPS的工作原理吗？\n用户通过浏览器请求https网站，服务器收到请求，选择浏览器支持的加密和hash算法，同时返回数字证书给浏览器，包含颁发机构、网址、公钥、证书有效期等信息。\n浏览器对证书的内容进行校验，如果有问题，则会有一个提示警告。否则，就生成一个随机数X，同时使用证书中的公钥进行加密，并且发送给服务器。\n服务器收到之后，使用私钥解密，得到随机数X，然后使用X对网页内容进行加密，返回给浏览器\n浏览器则使用X和之前约定的加密算法进行解密，得到最终的网页内容\n\n\n负载均衡有哪些实现方式？DNS：这是最简单的负载均衡的方式，一般用于实现地理级别的负载均衡，不同地域的用户通过DNS的解析可以返回不同的IP地址，这种方式的负载均衡简单，但是扩展性太差，控制权在域名服务商。\nHttp重定向：通过修改Http响应头的Location达到负载均衡的目的，Http的302重定向。这种方式对性能有影响，而且增加请求耗时。\n反向代理：作用于应用层的模式，也被称作为七层负载均衡，比如常见的Nginx，性能一般可以达到万级。这种方式部署简单，成本低，而且容易扩展。\nIP：作用于网络层的和传输层的模式，也被称作四层负载均衡，通过对数据包的IP地址和端口进行修改来达到负载均衡的效果。常见的有LVS（Linux Virtual Server），通常性能可以支持10万级并发。\n按照类型来划分的话，还可以分成DNS负载均衡、硬件负载均衡、软件负载均衡。\n其中硬件负载均衡价格昂贵，性能最好，能达到百万级，软件负载均衡包括Nginx、LVS这种。\n说说BIO/NIO/AIO的区别？BIO：同步阻塞IO，每一个客户端连接，服务端都会对应一个处理线程，对于没有分配到处理线程的连接就会被阻塞或者拒绝。相当于是一个连接一个线程。\n\nNIO：同步非阻塞IO，基于Reactor模型，客户端和channel进行通信，channel可以进行读写操作，通过多路复用器selector来轮询注册在其上的channel，而后再进行IO操作。这样的话，在进行IO操作的时候再用一个线程去处理就可以了，也就是一个请求一个线程。\n\nAIO：异步非阻塞IO，相比NIO更进一步，完全由操作系统来完成请求的处理，然后通知服务端开启线程去进行处理，因此是一个有效请求一个线程。\n那么你怎么理解同步和阻塞？首先，可以认为一个IO操作包含两个部分：\n\n发起IO请求\n实际的IO读写操作\n\n同步和异步在于第二个，实际的IO读写操作，如果操作系统帮你完成了再通知你，那就是异步，否则都叫做同步。\n阻塞和非阻塞在于第一个，发起IO请求，对于NIO来说通过channel发起IO操作请求后，其实就返回了，所以是非阻塞。\n谈一下你对Reactor模型的理解？Reactor模型包含两个组件：\n\nReactor：负责查询、响应IO事件，当检测到IO事件时，分发给Handlers处理。\nHandler：与IO事件绑定，负责IO事件的处理。\n\n它包含几种实现方式：\n单线程Reactor\n这个模式reactor和handler在一个线程中，如果某个handler阻塞的话，会导致其他所有的handler无法执行，而且无法充分利用多核的性能。\n\n单Reactor多线程\n由于decode、compute、encode的操作并非IO的操作，多线程Reactor的思路就是充分发挥多核的特性，同时把非IO的操作剥离开。\n但是，单个Reactor承担了所有的事件监听、响应工作，如果连接过多，还是可能存在性能问题。\n\n多Reactor多线程\n为了解决单Reactor的性能问题，就产生了多Reactor的模式。其中mainReactor建立连接，多个subReactor则负责数据读写。\n\n","categories":["Java"],"tags":["TCP/IP","HTTPS","网络原理"]},{"title":"微信红包封面制作小程序开放，人人都可免费制作了！！！","url":"https://tanqingbo.cn/WeChat-red-envelope-cover/","content":"前段时间，天天在网上搜集各种红包封面，\n一直心心念念的想着，啥时候也能设计一款自己专属的红包封面，没想到机会这么快就来了。\n要知道，之前制作红包封面都要审核的\n非常耗时、也不一定审核通过。\n难度很大，对红包的封面素材要求很高。\n如果不是UI专业的，很难搞定。\n但是，这次，免费，且不需要审核！\n只有两个条件：\n1.开通视频号\n2.视频点赞数超过 10 个\n3.一张美美的照片，任何照片都可以\n制作微信红包封面视频教程如下：\n我简单制作了一个，预览效果如下 👇\n\n现在搜索：小程序「微信红包封面」，已经搜不到了，被很多假的小程序抢了流量。不要上当！\n\n可以扫描下方二维码，关注之后回复「封面」，我给你分享官方红包小程序入口：\n\n👆长按上方二维码 2 秒回复「封面」即可获取入口\n\n\n\n快去制作属于自己的红包封面吧。今年过年发红包就靠它了！\n安卓和苹果用户皆可以无门槛制作！！\n早就是优势！！！\n","categories":["技术以外"],"tags":[]},{"title":"港美股开户链接汇总","url":"https://tanqingbo.cn/Summaryof-HongKongStock-Account-Opening-Links/","content":"富图证券开户链接：专属开户链接：https://j.futunn.com/00235P\n邀请人牛牛号：22897263\n福利如下：\n\n老虎证券开户链接：专属开户链接：https://www.itiger.com/activity/forapp/welcome/#/?feature=Popup&amp;Page=Open&amp;group_id=634&amp;invite=LZGC01\n新人送豪，仅限通过上面专属链接首次开户入金3050美金（或24500港币）活动豪礼：①送一股小米1港币兑换权益！②再送10股小米股票！③再送200元股票抵扣券！④送1次美股首次打新必中权益 \n华泰证券开户链接：专属开户链接：https://gb.zhangle.com/views/new-customer-gift/index.htm?ciphertext=54be11edcf9771c6b8d73b9321bc26b49663c21c6b349ec38e2437ae96f85e0759c261490b45156eb273776aea133e2734743efa36417ea36b59ecb43dd57f4b\n通过上面专属链接开户福利如下：\n\n盈立证券开户链接：微信识别下方二维码开户：\n\n华盛证券开户链接：专属开户链接：https://hd.hstong.com/invite/2020/accept?invite=WDZ9D\n开户福利：\n1、30天美股LV1行情\n2、30天港股LV2行情 \n东方国际证券开户链接：专属开户链接：https://emisfed.dfcfs.com/page/liebianlottery0204.html?id=37670009207525376&amp;code=qglhawkvElk3XuiPDoKdtA%3D%3D&amp;_t=769483&amp;pkg=gjb\n打开链接，点击“抽奖”按钮即可开户：  \n富元证券开户链接：专属开户链接：https://sns.fyact.com/sunline/active/2019/official-friends-invite/?channelId=666&amp;utm_source=Web&amp;utm_medium=haoyouyaoqing&amp;invUserId=708016&amp;hashPath=invite/ \n开户福利：\n1、送热门股票\n2、最高2020元现金红包 \n雪盈证券开户链接：专属开户链接：https://www.snowballsecurities.com/activity/deposit-guide-2021q2?r=AF48C&amp;activity_code=A210301&amp;utm_medium=code&amp;utm_source=A210301\n尊嘉证券开户链接：专属开户链接：https://opt.investassistant.com/miningopt/roulette/index?channelopen=YQAPP&amp;hmsr=wechat&amp;hmpl=d4d373d9b55d93d5&amp;hmcu=YQAPP&amp;hmkw=&amp;hmci=&amp;share=430217&amp;miningfrom=wechat\n利弗莫尔证券开户链接：专属开户链接：https://www.jesselivermore.com/\n方德证券开户链接：专属开户链接：https://mobile.fdzq.com/inviteActivity/index.html#/share?invite_code=SI4EU&amp;activity_id=1021\n青石证券开户链接：专属开户链接：https://enstatine.bluestonehk.com/wap/event/inviteActivity_share.html?invite=314216&amp;activity=a210329604\n长桥证券开户链接：专属开户链接：https://activity.lbkrs.com/zh-CN/invite-friend/invite?type=share&amp;invite-code=896531&amp;channel=HM000001\n","categories":["技术以外"],"tags":[]},{"title":"百度的骚操作！","url":"https://tanqingbo.cn/Baidu-Sao-operation/","content":"最近几年，很多人都唱衰百度搜索引擎的流量，但其实大家不知道的是百度的流量一直都是呈上升趋势的。\n因为在过去，可能大家每天只能上网四五个小时，而现在是大家每天不上网的时间只有四五个小时。 上网的时间增加了，而在PC端大家有什么问题，仍然还是会第一时间去百度一下。 \n所以在这种情况下搜索引擎仍然是一个不错的流量池，厂长决定今天给大家分享一个利用个人网站薅百度流量变现的方法：\n我们都知道，大多数的内容平台都会被百度收录，为什么自己再搞一个技术门槛更高的个人网站去薅百度的流量呢？\n原因很简单，因为任何一家内容平台，都会对引流有各种限制，搞不好还会被封号，一不小心前面所有的积累全部作废，但是自己搭建的网站不依托任何一家平台，你使用任何引流的手段都没有关系，这就是个人网站的优势。 \n关于如何搭建个人网站，大家可以去搜一下：“如何使用hexo搭建个人网站？” 没有任何技术门槛，小白也能会。 \n那么具体怎么通过个人网站引流变现呢？ 首先确定网站的类型，很多人做内容是有什么内容就发什么内容，如果你想让你的网站获得搜索流量，这样做肯定不行。 \n首先，必须先确定网站的类型方向，比如你是学设计的，那就只分享和设计相关的内容，其他非相关的内容就不要往网站上发了，因为内容太乱会影响搜索引擎收录。 \n其次是标题，大家都知道，我们做公众号的时候，文章标题很重要，需要让读者看到标题就想点进去看一下。 \n做个人网站的时候，标题也很重要，但是这个标题不是给读者看的，是给搜索引擎看的，因为我希望我的标题可以包含所有的搜索场景。 \n举个例子： 比如，我在我的个人网站中发表了一篇文章，在文章中我整理了很多程序员学习需要的相关资料，而且还提供了下载方式。 \n那我给这篇文章起标题的时候，肯定不能起“程序员学习资料下载”这个标题。因为用户在搜索引擎搜索的时候，它可能搜的是：\n ”计算机专业电子书推荐“\n”IT类相关学习资料“\n“程序员学习资料”\n……….. \n当然还有很多种搜索的场景，但其实他们想要找的东西是一样的，如果我的标题是”程序员学习资料下载“，那么可能只有一个人能搜索到我的内容，还有很多用户就都流失掉了。 \n这种情况怎么办呢？ \n我采用的是ABC拓词法来给我的引流内容取标题。 还是上面那篇”程序员学习资料下载“的文章。 先拆分关键词，标题”程序员学习资料下载“可以拆分成”程序员“、”学习资料“、”下载“这三个关键词，分别对应ABC，再分别找出A、B、C至少三组近义词。\n比如：\n程序员的近义词：计算机专业、IT。\n学习资料的近义词：书籍、经典图书\n下载的近义词：汇总、分享 \n这样我们就一共找到了9个关键词，然后再将这9个关键词组成我们这篇文章的标题，那这篇文章的标题就变成了： \n”程序员学习资料下载_计算机专业书籍汇总__IT类经典图书分享“ \n这样不管用户在搜索引擎搜索的是什么关键词，都能找到我的这篇文章。 等用户找到这篇文章之后，引流的方法就比较多了，可以引导用户去公众号或者微信中获取提取码、也可以直接引导用户去公众号里面领取，就看大家的转化话术了。 \n但是需要注意的是，你的个人网站上一定要多发一些不是引流的干货文章，干货文章越多，你的网站在搜索引擎的权重也就会越高，搜索排名也会靠前一些，然后可以把你的引流文章的超链接插入到其他的干货文章里面，这样相当于是在告诉搜索引擎这篇引流文章很重要，它的搜索排名也就会更靠前一点。 \n当然想要获得更多搜索引擎的流量，可能还需要一点其他的seo技巧，这里就不再做过多的赘述！\n","categories":["技术以外"],"tags":[]},{"title":"微信8.0，四天引流1万粉，直接收入超1.5w块，间接收入至少翻10倍！","url":"https://tanqingbo.cn/wechat-fans/","content":"在微信10周年大会得第二天，微信发布了8.0版本，新增了不少功能，比如动态表情包、状态、悬浮窗改进等。\n但是新版本的微信最先是在ios系统上发布，也就是说只有苹果用户才能体验，安卓用户只能羡慕嫉妒恨。\n在这个背景下，我用内测版安卓微信8.0引流了1w多粉丝，4天带来的直接收入超1.5万块，间接收入至少翻10倍。\n下面给大家分享一下我是怎么引流变现的：\n在iOS系统发布微信8.0版本的第二天，我在朋友圈刷到有朋友分享了一个安卓微信8.0内测版本的下载链接，作为一个互联网人，我觉得这是一个非常不错的引流机会，因为当时微信8.0新功能在微博热搜和知乎热榜均位居榜首，而且各种KOL也发文介绍了微信的新功能，也就是说，几乎大部分用户都知道微信8.0的变化很大，新增了不少实用的功能，但是新版本只能ios用户体验，绝大多数安卓用户都心里痒痒的，羡慕嫉妒恨，这个时候，如果你能够提供安卓版本的微信8.0，绝对能引爆，因为相当于所有的媒体都在为微信8.0造势，但是安卓用户却体验不到。万事俱备，只欠东风！\n所以在我发现安卓内测版微信8.0下载地址之后，我在第一时间写了一篇关于微信新版本的文章，并且分享了安卓版本的下载地址，发布在我经常使用的两个平台：知乎和微信公众号。\n在知乎发文的时候我让大家去公众号回复关键字获取下载地址，在公众号发文的时候我让大家去我另外一个小号回复关键字获取下载地址。\n结果当天我的大号涨了2500多粉丝，小号涨了1000多粉丝，这个结果远超我的预期，没想到能涨这么多粉。\n但是晚上复盘的时候，我发现我太蠢了，这么多家内容平台，我为什么只在知乎和公众号上面发文呢？\n于是我又重新把文章整理了一下，发布到简书、CSDN、个人博客以及其他一些平台。\n结果第二天涨了3000多粉、第三第四天也分别平均每天涨了2000多粉，到今天是第五天了，安卓的应用商店已经正式上架了微信8.0版本，但是没关系，我已经通过利用iOS和安卓系统微信更新中间的时间差涨了1w多粉丝。\n由于我和广告主有新增自动回复和菜单栏广告合作，这新增的一万多粉丝给我带来的直接收入超1.5万块，此外关注过的用户以后还可以无限次成交，间接收益看个人的变现能力，无可限量！\n以后微信再更新版本的时候，可能iOS和安卓系统之间仍然有时间差，这种引流的方法可以仍然接着用，而且有了经验之后可以利用的更好。\n不止是微信，其他任何用户量比较大的应用，都可以用这么方式引流。\n","categories":["技术以外"],"tags":[]},{"title":"安卓微信 8.0 内测版来啦！（附下载链接）","url":"https://tanqingbo.cn/WeChat-80/","content":"今天安卓用户肯定是被嫉妒蒙蔽双眼的一天，因为微信 8.0 版本上线了，而且还更新了各种酷炫的功能，但是目前只能在IOS系统使用。\n别着急，我为大家找到了安卓微信 8.0 内测版本，文末可以下载，首先还是给大家介绍一下 8.0 都新增了哪些有趣的功能！\n- 新形态表情\n和此前的 2D 设计不同，微信 8.0 自带表情都采用更加立体的 3D 设计，并且部分表情的样式也发生了变化，其中大部分表情还有特殊动态效果，给大家看一下视觉效果：\n\n- 更丰富的上拉界面\n微信 8.0 版本丰富了上拉界面的显示内容，以往只显示收藏和常用小程序的内容，现在「最近看过的直播」「未看完的视频」「未看完的文章」等内容也会在这个页面下展示。\n\n- 全新的浮窗功能\n针对没看完的公众号文章，现在点击右上角弹出的菜单栏内可以使用新的「浮窗」功能。\n\n浮窗功能的入口在聊天列表顶部，点击或者向右滑动即可查看浮窗内的内容。\n\n- 全新的状态功能\n在个人信息页面下，新增了状态功能。点击后可以设置个人状态，目前有「美滋滋」「郁闷」等心情想法类、「忙」「摸鱼」等工作学习类、「打卡」「聚餐」等活动类，一共四大类二十一中状态可选。此外用户也可以选择「未知」的自定义类状态。\n\n状态功能可以自由添加图片、位置、话题、是否公开等选项。\n\n对于已经设置状态的用户，你可以在好友列表中查看好友状态，点击个人信息详情页还会进一步展示该状态详情。\n\n- 安卓版下载方式\n关注下方公众号，回复关键字「80」即可获取安卓版微信 8.0 下载地址：\n\n▲扫码回复「80」\n即可获取下载地址\n\n","categories":["技术以外"],"tags":[]},{"title":"《我想进大厂》之分布式事务篇","url":"https://tanqingbo.cn/Distributed-transaction/","content":"对于分布式事务，相信所有人都应该很了解，为什么会有分布式事务？无论是数据量导致的分库，还是现在微服务盛行的场景都是他出现的原因。\n这一篇内容还是避免不了俗套，主要的范围无非是XA、2PC、3PC、TCC，再最后到Seata。\n但是，我认为这东西，只是适用于面试和理论的了解，你真要说这些方案实际生产中有人用吗？\n有，但是会实现的更简单，不会套用理论来实现，大厂有大厂的解决方案，中小公司用框架或者压根就不存在分布式事务的问题。\n那，为什么还要写这个？\n为了你面试八股文啊，小可爱。\n事务要说分布式事务，首先还是从事务的基本特征说起。\nA原子性：在事务的执行过程中，要么全部执行成功，要么都不成功。\nC一致性：事务在执行前后，不能破坏数据的完整性。一致性更多的说的是通过AID来达到目的，数据应该符合预先的定义和约束，由应用层面来保证，还有的说法是C是强行为了ACID凑出来的。\nI隔离性：多个事务之间是互相隔离的，事务之间不能互相干扰，涉及到不同事务的隔离级别的问题。\nD持久性：一旦事务提交，数据库中数据的状态就应该是永久性的。\nXAXA（eXtended Architecture）是指由X/Open 组织提出的分布式事务处理的规范，他是一个规范或者说是协议，定义了事务管理器TM(Transaction Manager)，资源管理器RM(Resource Manager)，和应用程序。\n事务管理器TM就是事务的协调者，资源管理器RM可以认为就是一个数据库。\n\n2PCXA定义了规范，那么2PC和3PC就是他的具体实现方式。\n2PC叫做二阶段提交，分为投票阶段和执行阶段两个阶段。\n投票阶段\nTM向所有的参与者发送prepare请求，询问是否可以执行事务，等待各个参与者的响应。\n这个阶段可以认为只是执行了事务的SQL语句，但是还没有提交。\n如果都执行成功了就返回YES，否则返回NO。\n\n执行阶段\n执行阶段就是真正的事务提交的阶段，但是要考虑到失败的情况。\n如果所有的参与者都返回YES，那么就执行发送commit命令，参与者收到之后执行提交事务。\n反之，只要有任意一个参与者返回的是NO的话，就发送rollback命令，然后执行回滚的操作。\n\n2PC的缺陷\n\n同步阻塞，可以看到，在执行事务的过程当中，所有数据库的资源都被锁定，如果这时候有其他人来访问这些资源，将会被阻塞，这是一个很大的性能问题。\nTM单点问题，只要一个TM，一旦TM宕机，那么整个流程无法继续完成。\n数据不一致，如果在执行阶段，参与者脑裂或者其他故障导致没有收到commit请求，部分提交事务，部分未提交，那么数据不一致的问题就产生了。\n\n3PC既然2PC有这么多问题，所以就衍生出了3PC的概念，也叫做三阶段提交，他把整个流程分成了CanCommit、PreCommit、DoCommit三个步骤，相比2PC，增加的就是CanCommit阶段。\nCanCommit\n这个阶段就是先询问数据库是否执行事务，发送一个canCommit的请求去询问，如果可以的话就返回YES，反之返回NO。\n\nPreCommit\n这个阶段就等同于2PC的投票阶段了，发送preCommit命令，然后去执行SQL事务，成功就返回YES，反之返回NO。\n\n但是，这个地方的区别在于参与者有了超时机制，如果参与者超时未收到doCommit命令的话，将会默认去提交事务。\nDoCommit\nDoCommit阶段对应到2PC的执行阶段，如果上一个阶段都是收到YES的话，那么就发送doCommit命令去提交事务，反之则会发送abort命令去中断事务的执行。\n\n相比2PC的改进\n对于2PC的同步阻塞的问题，我们可以看到因为3PC加入了参与者的超时机制，所以原来2PC的如果某个参与者故障导致的同步阻塞的问题时间缩短了，这是一个优化，但是并没有完全避免。\n第二个单点故障的问题，同样因为超时机制的引入，一定程度上也算是优化了。\n但是数据不一致的问题，这个始终没有得到解决。\n举个栗子：\n在PreCommit阶段，某个参与者发生脑裂，无法收到TM的请求，这时候其他参与者执行abort事务回滚，而脑裂的参与者超时之后继续提交事务，还是有可能发生数据不一致的问题。\n那么，为什么要加入DoCommit这个阶段呢？就是为了引入超时机制，事先我们先确认数据库是否都可以执行事务，如果都OK，那么才会进入后面的步骤，所以既然都可以执行，那么超时之后说明发生了问题，就自动提交事务。\nTCCTCC的模式叫做Try、Confirm、Cancel，实际上也就是2PC的一个变种而已。\n实现这个模式，一个事务的接口需要拆分成3个，也就是Try预占、Confirm确认提交、最后Cancel回滚。\n对于TCC来说，实际生产我基本上就没看见过有人用，考虑到原因，首先是程序员的本身素质参差不齐，多个团队协作你很难去约束别人按照你的规则来实现，另外一点就是太过于复杂。\n如果说有简单的应用的话，库存的应用或许可以算做是一个。\n一般库存的操作，很多实现方案里面都会会在下单的时候先预占库存，下单成功之后再实际去扣减库存，最终如果发生了异常再回退。\n\n冻结、预占库存就是2PC的准备阶段，真正下单成功去扣减库存就是2PC的提交阶段，回滚就是某个发生异常的回滚操作，只不过在应用层面来实现了2PC的机制而已。\nSAGASaga源于1987 年普林斯顿大学的 Hecto 和 Kenneth 发表的如何处理 long lived transaction（长活事务）论文。\n主要思想就是将长事务拆分成多个本地短事务。\n如果全部执行成功，就正常完成了，反之，则会按照相反的顺序依次调用补偿。\nSAGA模式有两种恢复策略：\n\n向前恢复，这个模式偏向于一定要成功的场景，失败则会进行重试\n向后恢复，也就是发生异常的子事务依次回滚补偿\n\n由于这个模式在国内基本没看见有谁用的，不在赘述。\n消息队列基于消息队列来实现最终一致性的方案，这个相比前面的我个人认为还稍微靠谱一点，那些都是理论啊，正常生产的实现很少看见应用。\n基于消息队列的可能真正在应用的还稍微多一点。\n一般来说有两种方式，基于本地消息表和依赖MQ本身的事务消息。\n本地消息表的这个方案其实更复杂，实际上我也没看到过真正谁来用。这里我以RocketMQ的事务消息来举例，这个方式相比本地消息表则更完全依赖MQ本身的特性做了解耦，释放了业务开发的复杂工作量。\n\n\n业务发起方，调用远程接口，向MQ发送一条半事务消息，MQ收到消息之后会返回给生产者一个ACK\n生产者收到ACK之后，去执行事务，但是事务还没有提交。\n生产者会根据事务的执行结果来决定发送commit提交或者rollback回滚到MQ\n这一点是发生异常的情况，比如生产者宕机或者其他异常导致MQ长时间没有收到commit或者rollback的消息，这时候MQ会发起状态回查。\nMQ如果收到的是commit的话就会去投递消息，消费者正常消费消息即可。如果是rollback的话，则会在设置的固定时间期限内去删除消息。\n\n这个方案基于MQ来保证消息事务的最终一致性，还算是一个比较合理的解决方案，只要保证MQ的可靠性就可以正常实施应用，业务消费方根据本身的消息重试达到最终一致性。\n框架以上说的都是理论和自己实现的方式，那么分布式事务就没有框架来解决我们的问题吗？\n有，其实还不少，但是没有能扛旗者出现，要说有，阿里的开源框架Seata还有阿里云的GTS。\nGTS（Global Transaction Service 全局事务服务）是阿里云的中间件产品，只要你用阿里云，付钱就可以用GTS。\nSeata（Simple Extensible Autonomous Transaction Architecture）则是开源的分布式事务框架，提供了对TCC、XA、Saga以及AT模式的支持。\n那么，GTS和Seata有什么关系呢？\n实际上最开始的时候他们都是基于阿里内部的TXC（Taobao Transaction Constructor）分布式中间件产品，然后TXC经过改造上了阿里云就叫做GTS。\n之后阿里的中间件团队基于TXC和GTS做出了开源的Seata，其中AT（Automatic Transaction）模式就是GTS原创的方案。\n至于现在的版本，可以大致认为他们就是一样的就行了，到2020年，GTS已经全面兼容了Seata的 GA 版本。\n\n整个GTS或者Seata包含以下几个核心组件：\n\nTransaction Coordinator（TC）：事务协调器，维护全局事务的运行状态，负责协调并驱动全局事务的提交或回滚。\nTransaction Manager（TM）：控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议。\nResource Manager（RM）：控制分支事务，负责分支注册、状态汇报，并接收事务协调器的指令，驱动分支（本地）事务的提交和回滚。\n\n无论对于TCC还是原创的AT模式的支持，整个分布式事务的原理其实相对来说还是比较容易理解。\n\n事务开启时，TM向TC注册全局事务，并且获得全局事务XID\n这时候多个微服务的接口发生调用，XID就会传播到各个微服务中，每个微服务执行事务也会向TC注册分支事务。\n之后TM就可以管理针对每个XID的事务全局提交和回滚，RM完成分支的提交或者回滚。\n\n\nAT模式\n原创的AT模式相比起TCC的方案来说，无需自己实现多个接口，通过代理数据源的形式生成更新前后的UNDO_LOG，依靠UNDO_LOG来实现回滚的操作。\n执行的流程如下：\n\nTM向TC注册全局事务，获得XID\nRM则会去代理JDBC数据源，生成镜像的SQL，形成UNDO_LOG，然后向TC注册分支事务，把数据更新和UNDO_LOG在本地事务中一起提交\nTC如果收到commit请求，则会异步去删除对应分支的UNDO_LOG，如果是rollback，就去查询对应分支的UNDO_LOG，通过UNDO_LOG来执行回滚\n\n\nTCC模式\n相比AT模式代理JDBC数据源生成UNDO_LOG来生成逆向SQL回滚的方式，TCC就更简单一点了。\n\nTM向TC注册全局事务，获得XID\nRM向TC注册分支事务，然后执行Try方法，同时上报Try方法执行情况\n然后如果收到TC的commit请求就执行Confirm方法，收到rollback则执行Cancel\n\n\nXA模式\n\nTM向TC注册全局事务，获得XID\nRM向TC注册分支事务，XA Start，执行SQL，XA END，XA Prepare，然后上报分支执行情况\n然后如果收到TC的commit请求就执行Confirm方法，收到rollback则执行Cancel\n\n\nSAGA模式\n\nTM向TC注册全局事务，获得XID\nRM向TC注册分支事务，然后执行业务方法，并且上报分支执行情况\nRM收到分支回滚，执行对应的业务回滚方法\n\n\n总结这里从事务的ACID开始，向大家先说了XA是分布式事务处理的规范，之后谈到2PC和3PC，2PC有同步阻塞、单点故障和数据不一致的问题，3PC在一定程度上解决了同步阻塞和单点故障的问题，但是还是没有完全解决数据不一致的问题。\n之后说到TCC、SAGA、消息队列的最终一致性的方案，TCC由于实现过于麻烦和复杂，业务很少应用，SAGA了解即可，国内也很少有应用到的，消息队列提供了解耦的实现方式，对于中小公司来说可能是较为低成本的实现方式。\n最后再说目前国内的实现框架，云端阿里云的GTS兼容Seata，非云端使用Seata，它提供了XA、TCC、AT、SAGA的解决方案，可以说是目前的主流选择。\n","categories":["计算机基础知识"],"tags":["分布式"]},{"title":"Java垃圾回收的知识点都在这里了","url":"https://tanqingbo.cn/Knowledge-points-of-Java-garbage-collection/","content":"Java的垃圾回收老生常谈了，了解Java的GC对我们优化代码，设置参数性能调优有很大的帮助。\n特别是面试也经常会问到。\n本篇文章一次性帮你总结Java的垃圾回收知识点，主要围绕以下问题展开：\n\n1、为什么要有GC，哪些内存对象需要回收？对于一个Java开发者来说，了解过Java内存区域的都知道，Java内存区域分了堆、栈、程序计数器等等。\nJava的程序计数器，栈内存 ，他们随线程生，随线程灭，方法结束后内存也就回收了。\n\n一个字符串“abc”已经进入常量池，但是当前系统没有任何一个String对象引用了做“abc”的字面量，那么，如果发生垃圾回收并且有必要时，“abc”就会被系统移出常量池。\n常量池中的其他类（接口）、方法、字段的符号引用也与此类似。\n\n当Java虚拟机发现内存资源紧张的时候，就会自动地去清理无用变量所占用的内存空间，为我们的程序提升更高的性能。\n2、如何判断对象需要回收？一般常见的两种回收判断算法：\n2.1、 引用计数算法给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1。\n任何时刻计数器为0的对象就是不可能再被使用的。\n\n该方法实现简单，效率高，但是它很难它很难解决对象之间相互循环引用的问题。比如图中的 Object3 和Object4相互引用，引用计数不可能为0，虽然它们已经没有被Root引用了。\n所以，大多数jvm判断对象是否存活基本并没有采取该方法。\n2.2、可达性分析算法（根搜索算法）这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索,搜索所走过的路径称为引用链(Reference Chain)。\n当一个对象到GC Roots没有任何引用链相连时（不可达）则证明此对象是不可用的。\n\n要注意的是，不可达对象不等价于可回收对象，不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收。\n\n\n被认为GC Roots的有以下几种：\n\n虚拟机栈中引用的对象\n方法区中静态属性、常量引用的对象\nNative方法引用的对象\n\n3、如何回收（垃圾收集算法）？随着Java虚拟机的发展，jvm衍生出了很多种垃圾回收算法。\n1、标记-清除（Mark-Sweep）算法最基础的垃圾回收算法，分为两个阶段，标记和清除。\n标记阶段标记出所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。\n\n从图中我们就可以发现，该算法最大的问题是内存碎片化严重，后续可能发生大对象不能找到可利用空间的问题。\n2、复制算法（copying ）为了解决 Mark-Sweep 算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为相等大小的两块。\n每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉，如图：\n\n这种算法虽然实现简单，内存效率高，不易产生碎片，但是最大的问题是可用内存被压缩到了原本的一半。且存活对象增多的话，Copying 算法的效率会大大降低。\n3、标记-整理（Mark-Compact）算法结合了以上两个算法，为了避免缺陷而提出。标记阶段和  标记-清除（Mark-Sweep）算法 相同，标记后不是清理对象，而是将存活对象移向内存的一端。然后清除两端边界外的对象。\n\n直接清除边界的对象也不好，如果边界是老年代，每一次都被清除就很不合理。\n4、分代收集算法分代收集法是目前虚拟机（包括HotSpot VM）收集器都是采用该方法。\n\n对象将根据存活的时间被分为：新生代（Young Generation）、年老代（Old Generation）、永久代（Permanent Generation，也就是方法区），然后进行分代回收，分算法回收。\n新生代：对象被创建时，内存的分配首先发生在新生代（准确地说是Eden区，大对象（大于Eden空间）可以直接 被创建在年老代）\n新生代又划分为 Eden 区 + Survivor区 （Survivor区又分 from 和 to 区），大小分别占 80%，10%，10%。\nEden区是连续的内存空间，因此在其上分配内存极快。\n老年代：老年代存储的对象比新生代多，而且大对象也多。老年代用的算法是标记-整理算法。\n永久代（方法区）：1.8就没有了，只有元空间。常见的就是常量池、类信息等等。\n分代收集算法的GC过程：（1）在年轻代中，Eden区提供堆内存如果满了，Eden进行MinorGC，将存活的对象→from ，Eden区清空；\n（2）Eden区再次满， Eden 区和 from  区同时进行 Minor GC，把存活对象放入 to 区，Eden和from 同时清空；\n如果在to区中的对象仍然存活，则把对象标志 +1。\n（3）重复（2）的操作， 某些对象在反复 Survive 15 次后，或者Eden+from 的存活对象 &gt; to ，这些对象就只能放到老年代了，如果老年代放不下了，就进行Full GC）；\n（4）当 Old 区也被填满时，进行 Full GC，对 Old 区进行垃圾回收。\n\n可以通过参数 SurvivorRatio 手动配置 Eden 区和单个 Survivor 区的比例，默认为 8。可以通过参数–XX:SurvivorRatio 来设定，即将堆内存中年轻代划分为8:1:1\n\n4、垃圾回收器垃圾回收器是虚拟机不断发展产生的，不同的垃圾回收器使用不同的垃圾回收算法（下面讲到）\n以HotSpot VM来说，垃圾回收器大致分为七种类型：\n\n串行：Serial New收集器\n\n串行：Serial Old收集器\n\n串行：ParNew收集器\n\n并行：Parallel收集器\n\n并行：Parallel Old 收集器\n\n并发标记扫描CMS收集器\n\nG1收集器\n\n\n\n\n注：串行、并行 其它工作线程要暂停，并发不会。\n\njdk11中，发布最新的ZGC垃圾收集器。完全没有分代的概念，官方介绍是无空间碎片，时间可控，能超大堆收集。\n5、JAVA  四中引用类型 与 GC回收关系\n6、JVM常见参数设置合理的jvm参数对Java程序有至关重要的作用。\n\n基本设置：\n-Xms300m 起始内存（堆大小）设置为300m\n-Xmx 最大内存\n-Xmn 新生代内存\n-Xss 栈大小。就是创建线程后，分配给每一个线程的内存大小\n-XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4\n-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5\n-XX:MaxPermSize=n:设置持久代大小\n收集器设置\n-XX:+UseSerialGC:设置串行收集器\n-XX:+UseParallelGC:设置并行收集器\n-XX:+UseParalledlOldGC:设置并行年老代收集器\n-XX:+UseConcMarkSweepGC:设置并发收集器\n垃圾回收统计信息\n-XX:+PrintGC\n-XX:+PrintGCDetails\n-XX:+PrintGCTimeStamps\n-Xloggc:filename\n并行收集器设置\n-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。\n-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间\n-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)\n并发收集器设置\n-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。\n-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。\n\n7、查看垃圾回收器java -XX:+PrintCommandLineFlags -version\n\nWindows：\nC:\\Users\\HaC&gt; java -XX:+PrintCommandLineFlags -version-XX:InitialHeapSize=266928960 -XX:MaxHeapSize=4270863360 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGCjava version \"1.8.0_131\"Java(TM) SE Runtime Environment (build 1.8.0_131-b11)Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)\n\nLinux：\n[root@GZSB-CJB-SHH1-14-GEMINI-0 ~]# java -XX:+PrintCommandLineFlags -version-XX:InitialHeapSize=261339776 -XX:MaxHeapSize=4181436416 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC java version \"1.8.0_131\"Java(TM) SE Runtime Environment (build 1.8.0_131-b11)Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)\n\n可以看到是使用了 UseParallelGC\n还可以使用 jmap -heap 进程id 命令查看收集器，还可以查看新生代、老年代的空间大小。\n[root@VM_0_12_centos ~]# jmap -heap 19505Attaching to process ID 19505, please wait...Debugger attached successfully.Server compiler detected.JVM version is 25.171-b11using thread-local object allocation.Garbage-First (G1) GC with 1 thread(s)Heap Configuration:   MinHeapFreeRatio         = 40   MaxHeapFreeRatio         = 70   MaxHeapSize              = 268435456 (256.0MB)   NewSize                  = 1363144 (1.2999954223632812MB)   MaxNewSize               = 160432128 (153.0MB)   OldSize                  = 5452592 (5.1999969482421875MB)   NewRatio                 = 2   SurvivorRatio            = 8   MetaspaceSize            = 21807104 (20.796875MB)   CompressedClassSpaceSize = 1073741824 (1024.0MB)   MaxMetaspaceSize         = 17592186044415 MB   G1HeapRegionSize         = 1048576 (1.0MB)Heap Usage:G1 Heap:   regions  = 256   capacity = 268435456 (256.0MB)   used     = 66499440 (63.41880798339844MB)   free     = 201936016 (192.58119201660156MB)   24.772971868515015% usedG1 Young Generation:Eden Space:   regions  = 18   capacity = 74448896 (71.0MB)   used     = 18874368 (18.0MB)   free     = 55574528 (53.0MB)   25.35211267605634% usedSurvivor Space:   regions  = 1   capacity = 1048576 (1.0MB)   used     = 1048576 (1.0MB)   free     = 0 (0.0MB)   100.0% usedG1 Old Generation:   regions  = 46   capacity = 58720256 (56.0MB)   used     = 46576496 (44.41880798339844MB)   free     = 12143760 (11.581192016601562MB)   79.31929997035435% used34372 interned Strings occupying 3886072 bytes.\n\nGarbage-First (G1) GC with 1 thread(s) ，可以看到是使用了 G1 垃圾收集器。Eden Space、Survivor Space、G1 Old Generation分别说明了Eden区、Survivor区、老年代的大小。\n\n常用的命令行工具还有：jps、jstat、jinfo、jmap、jstack。而更多的可视化工具如jconsole、visualVM等暂不介绍，大家有兴趣请参阅相关文档。查看新生代内存占用、老年代内存占用、其他区内存占用和GC等四大方面的指标。\n\n8、小结\n判断是否需要回收内存的算法：引用计数法、可达性分析算法（根搜索算法）\n\n垃圾回收算法分为 标记-清除、复制、标志-整理、分代收集算法 4种。\n\n垃圾回收器 目前分为7种类型,按类型可分串行，并行，并发标记，G1。小数据量和小型应用，使用串行垃圾回收器即可；\n对于对响应时间无特殊要求的，可以使用并行垃圾回收器和并发标记垃圾回收器。对于heap可以分配很大的中大型应用，使用G1垃圾回收器比较好，进一步优化和减少了GC暂停时间，避免用户在使用有顿挫的感觉。\n\n没有最好的垃圾回收器，每一种垃圾回收器有自己的回收算法甚至是几种算法一起用，对新生代和老年代又可以分开回收。\n\n\n\n推荐阅读：\n8张图 带你理解Java内存区域\nJava内存模型及GC原理(Java内存分配、GC基本原理)\nJava内存模型是个啥？\n\n","categories":["Java"],"tags":["算法","垃圾回收"]},{"title":"本文把TCP/IP讲绝了！","url":"https://tanqingbo.cn/TCPIP-detailed/","content":"\n一、TCP/IP模型TCP/IP协议模型（Transmission Control Protocol/Internet Protocol），包含了一系列构成互联网基础的网络协议，是Internet的核心协议。\n基于TCP/IP的参考模型将协议分成四个层次，它们分别是链路层、网络层、传输层和应用层。下图表示TCP/IP模型与OSI模型各层的对照关系。\n\nTCP/IP协议族按照层次由上到下，层层包装。最上面的是应用层，这里面有http，ftp 等等我们熟悉的协议。而第二层则是传输层，著名的TCP和UDP协议就在这个层次。第三层是网络层，IP协议就在这里，它负责对数据加上IP地址和其他的数据以确定传输的目标。第四层是数据链路层，这个层次为待传送的数据加入一个以太网协议头，并进行CRC编码，为最后的数据传输做准备。\n\n上图清楚地表示了TCP/IP协议中每个层的作用，而TCP/IP协议通信的过程其实就对应着数据入栈与出栈的过程。入栈的过程，数据发送方每层不断地封装首部与尾部，添加一些传输的信息，确保能传输到目的地。出栈的过程，数据接收方每层不断地拆除首部与尾部，得到最终传输的数据。\n\n上图以HTTP协议为例，具体说明。\n二、数据链路层物理层负责0、1比特流与物理设备电压高低、光的闪灭之间的互换。数据链路层负责将0、1序列划分为数据帧从一个节点传输到临近的另一个节点,这些节点是通过MAC来唯一标识的(MAC,物理地址，一个主机会有一个MAC地址)。\n\n\n封装成帧: 把网络层数据报加头和尾，封装成帧,帧头中包括源MAC地址和目的MAC地址。\n透明传输:零比特填充、转义字符。\n可靠传输: 在出错率很低的链路上很少用，但是无线链路WLAN会保证可靠传输。\n差错检测(CRC):接收者检测错误,如果发现差错，丢弃该帧。\n\n三、网络层1、IP协议IP协议是TCP/IP协议的核心，所有的TCP，UDP，IMCP，IGMP的数据都以IP数据格式传输。要注意的是，IP不是可靠的协议，这是说，IP协议没有提供一种数据未传达以后的处理机制，这被认为是上层协议：TCP或UDP要做的事情。\n1.1 IP地址在数据链路层中我们一般通过MAC地址来识别不同的节点，而在IP层我们也要有一个类似的地址标识，这就是IP地址。\n32位IP地址分为网络位和地址位，这样做可以减少路由器中路由表记录的数目，有了网络地址，就可以限定拥有相同网络地址的终端都在同一个范围内，那么路由表只需要维护一条这个网络地址的方向，就可以找到相应的这些终端了。\nA类IP地址: 0.0.0.0127.0.0.0B类IP地址:128.0.0.1191.255.0.0C类IP地址:192.168.0.0~239.255.255.0\n1.2 IP协议头\n这里只介绍:八位的TTL字段。这个字段规定该数据包在穿过多少个路由之后才会被抛弃。某个IP数据包每穿过一个路由器，该数据包的TTL数值就会减少1，当该数据包的TTL成为零，它就会被自动抛弃。\n这个字段的最大值也就是255，也就是说一个协议包也就在路由器里面穿行255次就会被抛弃了，根据系统的不同，这个数字也不一样，一般是32或者是64。\n2、ARP及RARP协议ARP 是根据IP地址获取MAC地址的一种协议。\nARP（地址解析）协议是一种解析协议，本来主机是完全不知道这个IP对应的是哪个主机的哪个接口，当主机要发送一个IP包的时候，会首先查一下自己的ARP高速缓存（就是一个IP-MAC地址对应表缓存）。\n如果查询的IP－MAC值对不存在，那么主机就向网络发送一个ARP协议广播包，这个广播包里面就有待查询的IP地址，而直接收到这份广播的包的所有主机都会查询自己的IP地址，如果收到广播包的某一个主机发现自己符合条件，那么就准备好一个包含自己的MAC地址的ARP包传送给发送ARP广播的主机。\n而广播主机拿到ARP包后会更新自己的ARP缓存（就是存放IP-MAC对应表的地方）。发送广播的主机就会用新的ARP缓存数据准备好数据链路层的的数据包发送工作。\nRARP协议的工作与此相反，不做赘述。\n3、ICMP协议IP协议并不是一个可靠的协议，它不保证数据被送达，那么，自然的，保证数据送达的工作应该由其他的模块来完成。其中一个重要的模块就是ICMP(网络控制报文)协议。ICMP不是高层协议，而是IP层的协议。\n当传送IP数据包发生错误。比如主机不可达，路由不可达等等，ICMP协议将会把错误信息封包，然后传送回给主机。给主机一个处理错误的机会，这 也就是为什么说建立在IP层以上的协议是可能做到安全的原因。\n四、pingping可以说是ICMP的最著名的应用，是TCP/IP协议的一部分。利用“ping”命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障。\n例如：当我们某一个网站上不去的时候。通常会ping一下这个网站。ping会回显出一些有用的信息。一般的信息如下:\n\nping这个单词源自声纳定位，而这个程序的作用也确实如此，它利用ICMP协议包来侦测另一个主机是否可达。原理是用类型码为0的ICMP发请求，受到请求的主机则用类型码为8的ICMP回应。\n五、TracerouteTraceroute是用来侦测主机到目的主机之间所经路由情况的重要工具，也是最便利的工具。\nTraceroute的原理是非常非常的有意思，它收到到目的主机的IP后，首先给目的主机发送一个TTL=1的UDP数据包，而经过的第一个路由器收到这个数据包以后，就自动把TTL减1，而TTL变为0以后，路由器就把这个包给抛弃了，并同时产生 一个主机不可达的ICMP数据报给主机。主机收到这个数据报以后再发一个TTL=2的UDP数据报给目的主机，然后刺激第二个路由器给主机发ICMP数据 报。如此往复直到到达目的主机。这样，traceroute就拿到了所有的路由器IP。\n\n六、TCP/UDPTCP/UDP都是是传输层协议，但是两者具有不同的特性，同时也具有不同的应用场景，下面以图表的形式对比分析。\n\n面向报文\n面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。\n面向字节流\n面向字节流的话，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。\n关于拥塞控制，流量控制，是TCP的重点，后面讲解。\nTCP和UDP协议的一些应用\n\n什么时候应该使用TCP？当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。\n什么时候应该使用UDP？当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。\n七、DNSDNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。DNS协议运行在UDP协议之上，使用端口号53。\n八、TCP连接的建立与终止1、三次握手TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。\n\n第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；\n第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态； \n第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。\n\n为什么要三次握手？\n\n为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。\n具体例子：“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。\n于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”\n2、四次挥手当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。\n\n第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；\n第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；\n第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。\n为什么要四次分手？TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。\n为什么要等待2MSL？MSL：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。原因有二：\n\n保证TCP协议的全双工连接能够可靠关闭\n保证这次连接的重复数据段从网络中消失\n\n第一点：如果主机1直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致主机2没有收到主机1最后回复的ACK。那么主机2就会在超时之后继续发送FIN，此时由于主机1已经CLOSED了，就找不到与重发的FIN对应的连接。所以，主机1不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。\n第二点：如果主机1直接CLOSED，然后又再向主机2发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达主机2，由于新连接和老连接的端口号是一样的，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。\n九、TCP流量控制如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。\n利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。\n设A向B发送数据。在连接建立时，B告诉了A：“我的接收窗口是 rwnd = 400 ”(这里的 rwnd 表示 receiver window) 。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意，TCP的窗口单位是字节，不是报文段。假设每一个报文段为100字节长，而数据报文段序号的初始值设为1。大写ACK表示首部中的确认位ACK，小写ack表示确认字段的值ack。\n\n从图中可以看出，B进行了三次流量控制。第一次把窗口减少到 rwnd = 300 ，第二次又减到了 rwnd = 100 ，最后减到 rwnd = 0 ，即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。B向A发送的三个报文段都设置了 ACK = 1 ，只有在ACK=1时确认号字段才有意义。\nTCP为每一个连接设有一个持续计时器(persistence timer)。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口控测报文段（携1字节的数据），那么收到这个报文段的一方就重新设置持续计时器。\n十、TCP拥塞控制发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。\n发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。\n慢开始算法：\n当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。因此，较好的方法是 先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。\n通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。\n\n每经过一个传输轮次，拥塞窗口 cwnd 就加倍。一个传输轮次所经历的时间其实就是往返时间RTT。不过“传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。\n另，慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd=1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。\n为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量。慢开始门限ssthresh的用法如下：\n\n当 cwnd &lt; ssthresh 时，使用上述的慢开始算法。\n当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。\n当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。拥塞避免\n\n拥塞避免\n让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。\n\n无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送 方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。\n这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。\n如下图，用具体数值说明了上述拥塞控制的过程。现在发送窗口的大小和拥塞窗口一样大。\n\n2、快重传和快恢复快重传快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。\n\n接收方收到了M1和M2后都分别发出了确认。现在假定接收方没有收到M3但接着收到了M4。\n显然，接收方不能确认M4，因为M4是收到的失序报文段。根据 可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。\n但按照快重传算法的规定，接收方应及时发送对M2的重复确认，这样做可以让 发送方及早知道报文段M3没有到达接收方。发送方接着发送了M5和M6。接收方收到这两个报文后，也还要再次发出对M2的重复确认。这样，发送方共收到了 接收方的四个对M2的确认，其中后三个都是重复确认。\n快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必 继续等待M3设置的重传计时器到期。\n由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。\n快恢复与快重传配合使用的还有快恢复算法，其过程有以下两个要点：\n\n当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。\n与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为 慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。\n\n推荐阅读：计算机网络体系与参考模型\n计算机网络五层协议中的第一层–物理层\n计算机网络之局域网搭建\n","categories":["计算机基础知识"],"tags":["TCP/IP","网络"]},{"title":"Java内存模型是个啥？","url":"https://tanqingbo.cn/Java-memory-model/","content":"Java内存模型（Java Memory Model，JMM）是Java虚拟机规范定义的，用来屏蔽掉Java程序在各种不同的硬件和操作系统对内存的访问的差异。\n常常和Java内存区域混淆，这是两个不同的概念。\nJava内存区域是指 JVM运行时将数据分区域存储 ，简单的说就是不同的数据放在不同的地方。通常又叫 运行时数据区域。\n参考上一篇：8张图 带你理解Java内存区域\n1、为什么要有Java内存模型？简单的说是屏蔽硬件的差异。\n\nJava虚拟机规范中试图定义一种Java内存模型来屏蔽掉各种硬件和操作系统的内存访问差异。——《深入理解Java虚拟机》\n\nJava程序运行在不同配置的服务器上，CPU和内存的配置都不一样，如何保证数据的一致性，就需要Java内存模型了，定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。\nCPU和内存是不直接通讯的，因为两者的运行效率是不一样的，为了提高效率，计算机引入高速缓存来充当介质。在多核CPU中，每个CPU都拥有自己的缓存，那同一个数据，在CPU各自的高速缓存中，以及内存中，可能就不一致了。\n为了解决这一问题，又引出了缓存一致性协议（MESI）。在读写时要根据协议进行操作，来维护缓存的一致性。\n\nMESI的详解可参考：https://www.cnblogs.com/yanlong300/p/8986041.html\n\n\nCPU和内存这么复杂，在写Java程序的时候， 跨平台部署，都要考虑底层的硬件差异，程序员肯定不干啊，那这时候，就出现了Java内存模型，充当一个媒介。\n2、Java内存模型介绍Java虚拟机带来的Java内存模型，定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。\n站在Java程序员的角度：Java内存模型规定了不同线程如何以及何时可以看到其他线程写入共享变量的值以及如何在必要时同步对共享变量的访问。\n\n\n每个处理器内核拥有私有的高速缓存，JMM 中每个线程拥有私有的本地内存\n\n这里说的 主内存、工作内存 和Java中堆、栈、方法区不是同一个概念，这两者没有什么关系。在系统内存架构中并没有栈（stack）、堆（heap）这种概念，只有寄存器（register）、缓存（cache）、主内存(RAM、Main Memory)。\n如果要强行联系，你可以把Java中的堆当成主内存，栈当成工作内存。\n堆中的变量如果在多线程中都使用，就涉及到了堆和不同虚拟机栈中变量的值的一致性问题了。\n\n主内存：java虚拟机规定所有的变量都必须在主内存（RAM）中产生，为了方便理解，可以认为是堆区。可以与前面说的物理机的主内存（RAM）相比，只不过物理机的主内存（RAM）是整个机器的内存，而虚拟机的主内存是虚拟机内存中的一部分。\n工作内存：java虚拟机中每个线程都有自己的工作内存（JMM抽象出来的），该内存是线程私有的为了方便理解，可以认为是虚拟机栈。可以与前面说的高速缓存相比。线程的工作内存保存了线程需要的变量在主内存中的副本。虚拟机规定，线程对主内存变量的修改必须在线程的工作内存中进行，不能直接读写主内存中的变量。不同的线程之间也不能相互访问对方的工作内存。如果线程之间需要传递变量的值，必须通过主内存来作为中介进行传递。\n\n理论上说Java所有的 栈 和 堆 都存储在物理主内存中，但随着CPU运算其数据的副本可能被缓存或者寄存器 持有\n3、内存交互大致流程：\n\n线程1和线程2都有主内存中共享变量x的副本，初始时，这3个内存中x的值都为0。线程1中更新x的值为1之后同步到线程2主要涉及2个步骤：\n\n1、 线程1把线程工作内存中更新过的x的值刷新到主内存中。\n2、 线程2到主内存中读取线程1之前已更新过的x变量。\n\n大致流程看着是挺简单的，工作内存同步回主内存之类的实现细节，其实也不复杂，主要是通过以下8种操作指令完成的，而且这8个操作必须是原子性的。\n\nlock(锁定):作用于主内存的变量，一个变量在同一时间只能一个线程锁定，该操作表示这条线程独占这个变量\nunlock(解锁):作用于主内存的变量，表示这个变量的状态由处于锁定状态被释放，这样其他线程才能对该变量进行锁定\nread(读取):作用于主内存变量，表示把一个主内存变量的值传输到线程的工作内存，以便随后的load操作使用\nload(载入):作用于线程的工作内存的变量，表示把read操作从主内存中读取的变量的值放到工作内存的变量副本中(副本是相对于主内存的变量而言的)\nuse(使用):作用于线程的工作内存中的变量，表示把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时就会执行该操作\nassign(赋值):作用于线程的工作内存的变量，表示把执行引擎返回的结果赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的字节码指令时就会执行该操作\nstore(存储):作用于线程的工作内存中的变量，把工作内存中的一个变量的值传递给主内存，以便随后的write操作使用\nwrite(写入):作用于主内存的变量，把store操作从工作内存中得到的变量的值放入主内存的变量中。\n\n\n如上图所示，把一个变量数据从主内存复制到工作内存，要顺序执行 read 和 load；\n而把变量数据从工作内存同步回主内存，就要顺序执行 store 和 write 操作。\n4、并发内存模型上述提到的内存交互过程，在多线程并发情况下，数据就会有非一致性问题。\n以上述例子来说，线程1、线程2同时向主存取值x，x初始值为0，同时加1，线程1更新x的值为1之后，写到主存；线程2还没拿到x的最新值，又加1，把1又回写主存，就样就会有脏数据。\n并发模型为了解决这一问题，设计了三个特性：\n\n原子性\n由Java内存模型来直接保证原子性的变量操作包括read、load、use、assign、store、write这6个动作，虽然存在long和double的特例，但基本可以忽略不计，目前虚拟机基本都对其实现了原子性。\n如果需要更大范围的控制，lock和unlock也可以满足需求。lock和unlock虽然没有被虚拟机直接开给用户使用，但是提供了字节码层次的指令monitorenter和monitorexit对应这两个操作，对应到java代码就是synchronized关键字，因此在synchronized块之间的代码都具有原子性。\n注意：volatile并不能解决原子性问题。\n\n可见性\n可见性是指一个线程修改了一个变量的值后，其他线程立即可以感知到这个值的修改。正如前面所说，volatile类型的变量在修改后会立即同步给主内存，在使用的时候会从主内存重新读取，是依赖主内存为中介来保证多线程下变量对其他线程的可见性的。\nJava最常用的就是提供volatile保持可见性，synchronized和final也可以实现可见性。synchronized关键字是通过unlock之前必须把变量同步回主内存来实现的，final则是在初始化后就不会更改，所以只要在初始化过程中没有把this指针传递出去也能保证对其他线程的可见性。\n\n有序性\n有序性从不同的角度来看是不同的。单纯单线程来看都是有序的，但到了多线程就会跟我们预想的不一样。\n可以这么说：如果在本线程内部观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句说的就是“线程内表现为串行的语义”，后半句指的是“指令重排序”现象和主内存与工作内存之间同步存在延迟的现象。\n保证有序性的关键字有volatile和synchronized，volatile禁止了指令重排序，而synchronized则由“一个变量在同一时刻只能被一个线程对其进行lock操作，串行操作”来保证。\n\n\n\n5、总结Java内存模型定义了线程和内存间的抽象关系，在硬件的体现就是cpu核线程，高速缓存和主存间的关系。在并发情况下，Java通过引入synchronized和volatile解决 可见性、有序性 问题。\n\n推荐阅读：\n8张图 带你理解Java内存区域\nJava内存模型及GC原理(Java内存分配、GC基本原理)\nJava垃圾回收的知识点都在这里了\n\n","categories":["Java"],"tags":["算法","内存模型","垃圾回收"]},{"title":"最近线上发生的两个坑爹的BUG！","url":"https://tanqingbo.cn/online-BUG！/","content":"最近由于在技改，发生了不少问题，虽然都是比较简单的问题，但是应该实际中还是有不少人碰到过，这些问题看似很简单，但是你绝对应该踩过。\n==和equals关于==和equals区别，我相信稍微做过一两年开发的同学都应该很清楚，可是，然而，这个坑在很多开发的时候仍然频繁出现，为什么？因为有时候有的同学认为没什么区别，就用==吧，然而，一些意外总是如期而至。\n不久前，由于线上RPC框架切换，我们就发生了一点小问题。\n本来，线上的接口是这样定义的：\n\n然后，接口查询中使用到了一个枚举类型，根据id获取枚举值，只不过这里使用的是==号来判断。\n\n调用方的写法：\n\n本来，这个代码在线上跑了两年了，一点问题没有，怎么就突然不行了呢？\n但是，切换框架之后，这个接口报错了，当时我也看了这个地方半天，猜测是这里的问题，但是想了想貌似又不应该啊。\n结果最后发现，原来的RPC框架传输中使用的是valueOf，从缓存中取值，加上自动装箱拆箱，判断可以通过。但是，新的框架使用的是new Byte()，所以这个老代码就永远无法通过了，因为这是一个新的对象。\n看看这个测试的结果。\n\n后面，通过安装Alibaba Java Coding Guidelines插件统一扫描所有代码，还又发现了一个坑爹的问题。\n这个写法又不太一样，这个枚举只是单纯的把code成员变量定义成了byte基础类型，不是包装类型。这样，代码用==判断又都OK了。\n\n想象一下，因为是基础数据类型，拆箱后==判断当然是通过的。\n还有更奇葩的写法，成员变量是Byte包装类型，getEnumByCode(byte code)这里用的又是基础类型，当然，这种写法也能判断通过。\n\n所以，心累… …\n最后，我想再补充一下关于基础数据类型缓存的知识。能用==判断的原因也都是依赖于缓存的原因。\n\n\n\n数据类型\n包装类型\n缓存类型\n缓存值范围\n\n\n\nbyte\nByte\nByteCache\n-128~127\n\n\nshort\nShort\nShortCache\n-128~127\n\n\nint\nInteger\nIntegerCache\n-128~127\n\n\nlong\nLong\nLongCache\n-128~127\n\n\nchar\nCharacter\nCharacterCache\n0~127\n\n\n最后，奉劝大家一句，千万，千万，在项目中判断包装数据类型都用equals，因为就算这段代码你很确信现在是对的，然而鬼都不知道后面会发生什么！不要抱有侥幸心理。\n日志打满项目技改上线后不久，发现接口成功率直接跌0（跌0的告警监控必须得有，不然死都不知道怎么死的）。排查了很久，看其他都是正常的，最后发现GC耗时狂增，登录服务器一看，居然是硬盘被打满了。\n\n然后果断去看日志，因为我们的硬盘实际上很小，先怀疑日志，果不其然，日志炸了。通过ls -lht查看文件大小。\n\n通过rm -rf删除后发现硬盘空间并没有释放。正常情况下是不会出现这个问题的，但是如果文件被锁定或者有另外的进程在向文件写数据的话就会有问题了。\n在Linux中，一个文件在文件系统中存放包含两个部分：\n\n指针部分：指针位于文件系统的meta-data中，在将数据删除后，这个指针就从meta-data中清除了。\n数据部分：而数据部分存储在磁盘中。\n\n像上面的情况，虽然我们删除了service.log，但是由于进程锁定，指针部分没有从meta-data中删除，所以也就看到存储空间没有释放的问题。\n解决办法有两种：\n\n使用lsof -n |grep delete查看什么进程在写service.log，通过命令发现是我们的java进程在一直写文件，然后通过后台工具直接重启应用，重启之后发现恢复正常。\n清空日志文件，执行命令echo \"\"&gt;/service.log，这个方法可以立刻释放磁盘空间，进程继续写入日志也不会受到影响。\n\n","categories":["Java"],"tags":["JVM"]},{"title":"3D Unet 实验笔记","url":"https://tanqingbo.cn/3D-Unet-Experiment-notes/","content":"\n\n\n\n3D Unet3D卷积代码解释def conv3d(name, in_layer, ksize, out_channels, padding='SAME', in_channel=0):name：每一层的名字in_layer：上一层的输出，本层的输入ksize：卷积核大小padding：卷积方式W = tf.get_variable(name + 'W', shape=[ksize[0], ksize[1], ksize[2], in_channel, out_channels],dtype=tf.float32,initializer=tf.truncated_normal_initializer(0.0, 0.01))shape：新变量或现有变量的形状或者维度。大小为3*3*3*in_channel*out_channelstf.truncated_normal_initializer：截取的正态分布，均值为0，方差为0.01out_channels：输出的维度，in_channel：输入的维度。上面代码是初始化权值wb = tf.get_variable(name + 'b', shape=[out_channels], dtype=tf.float32, initializer=tf.constant_initializer(0.1))初始化偏差btf.constant_initializer：常量初始化函数，0.1初始化3D卷积层主要经历了如下几个步骤：初始化过滤器W和偏差b过滤器w对输入数据卷积，之后再dropout（其实dropout就是随机将一些节点置0）dropout的输出加上偏差b之后再通过batch_normalization层，最后通过relu函数。l2_loss = tf.contrib.layers.l2_regularizer(0.003)(W)&nbsp;返回一个执行L2正则化的函数，正则项系数为0.003.关于正则化的解释可以参考《统计学习》13页。tf.add_to_collection('l2_loss', l2_loss)&nbsp;将正则化项放到'l2_loss' &nbsp;列表里面。&nbsp;tf.add_to_collection是把多个变量放入一个自己y用引号命名的集合里，也就是把多个变量统一放在一个列表中。tf.get_collection与之相反，是从列表中取出所有元素，构成一个新的列表。&nbsp; &nbsp;3D反卷积代码解释with tf.name_scope(name + 'op'):output_shape = tf.stack([in_shape[0], in_shape[1] * 2, in_shape[2] * 2, in_shape[3] * 2, out_channels])deconv = tf.nn.conv3d_transpose(in_layer, W, output_shape, strides=[1, 2, 2, 2, 1], padding=padding)bias = tf.nn.relu(tf.nn.bias_add(deconv, b))in_shape[1] * 2, in_shape[2] * 2, in_shape[3] * 2&nbsp;反卷积一次，size要变大两倍。out_channels：输出的通道数。每做一次反卷积，通道数减半。网络结构placeholder，占位符，在tensorflow中类似于函数参数，运行时必须传入值。conv1_1 = conv3d('conv1_1', X, [3, 3, 3],root_layers, padding=\"SAME\") # batch_size*512*512*64conv1_2 = conv3d('conv1_2', conv1_1, [3, 3, 3], root_layers, padding='SAME') # 融合层1 512*512*64512*512是数据块的大小，有一维数据块大小没写出来。64是通道数。root_layers=64flat_labels = tf.reshape(tf.one_hot(Y, CLASSES), [-1, CLASSES])简单解释一下什么是one_hot，one-hot code也称独热码，通常用于分类任务中作为最后的FC层的输出。在机器学习中对于离散型的分类型的数据，需要对其进行数字化，比如说对性别这一属性，只有男女两种值，用数字化表达，指定男性为0，女性为1，那么一个特征向量(1,0,1),转换成独热码（one_hot）就变成([1,0],[0,1],[1,0])。loss_map = tf.nn.softmax_cross_entropy_with_logits(logits=flat_logits, labels=flat_labels)解释在下面的图片：损失函数w = tf.reduce_mean(Y)W[0] = wW[1] = 1-wclass_weights = Wweight_map = tf.multiply(flat_labels, class_weights)weight_maps = tf.reduce_sum(weight_map, axis=1)weighted_loss = tf.multiply(loss_map + loss1 + loss2, weight_maps)做图像分割的时候，loss是所有点交叉熵求和，这样所有的点权重都是一样的，这样很不合理，因为不可能图像的前景和背景一样大，如果一张图像就10个像素是前景，如果1：1权重训练的时候很容易被忽略所以增加点交叉熵的权重项可以让训练的时候都关注一下这些前景很小的点。classweight就是统计金标准中正负样本比例算的，比如 10个正样本 100个负样本，那就给正样本10倍权重flat_labels&nbsp;是金标准转换成one_hot码之后的结果，如果是前景点值为[1,0],背景点值为[0,1].&nbsp; 而class_weights[0]是正样本比值，class_weights[1]是负样本比值，所以weight_map = tf.multiply(flat_labels, class_weights)&nbsp;是由金标准计算出来的权重map。&nbsp;&nbsp;&nbsp;tf.multiply(loss_map + loss1 + loss2, weight_maps)&nbsp;，计算loss的时候加入了DSN机制，可以加速收敛。#计算模型准确度pre_img = tf.argmax(pre, -1) #返回最大的那个数值所在的下标。ans = tf.equal(pre_img, Y) #tf.equal(A, B)是对比这两个矩阵或者向量的相等的元素，如果是相等的那就返回True，反正返回False，返回的值的矩阵维度和A是一样的acc = tf.reduce_mean(tf.cast(ans, tf.float32)) #tf.cast(ans, tf.float32) 原来x的数据格式是bool， 那么将其转化成float以后，就能够将其转化成0和1的序列。&nbsp; &nbsp;这个函数的计算公式为：rates = tf.train.exponential_decay(learning_rate, global_, decay_steps, decay_rate, staircase=True)decayed_learning_rate=learining_rate*decay_rate^(global_step/decay_steps)&nbsp;&nbsp;其中，rates为每一轮优化时使用的学习率；&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;learning_rate为事先设定的初始学习率；&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;decay_rate为衰减系数；&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;decay_steps为衰减速度。而tf.train.exponential_decay函数则可以通过staircase(默认值为False,当为True时，（global_step/decay_steps）则被转化为整数) ,选择不同的衰减方式。数据读取改成了DSN的那个数据读取方式，Data_Generator.py\n \n\n\n","categories":["图像处理与机器学习"],"tags":["机器学习","深度学习","医疗图像"]},{"title":"论文笔记：条件对抗网络用于图像到图像的转换（Image-to-Image）","url":"https://tanqingbo.cn/Conditional-confrontation-network/","content":"1、摘要\n研究条件对抗网络作为图像到图像转换问题的通用解决方案。网络不仅学习从输入图像到输出图像的映射，还学习了用于训练该映射的损失函数。这使得可以用相同的方法解决传统上需要不同损失函数的问题。这项工作表明我们可以在不用手动设计损失函数的情况下获得合理的结果。\n\n2、介绍\n我们将图像到图像的转换定义为一个场景到另一个场景的转换，如图一的input与output所示，在传统上，每一个转换任务都需要单独训练一个机器模型，尽管这些模型的最终目的都是一样的：从像素预测像素。而本文的目标是为所有这些像素转换问题开发一个通用框架。\n\n\n\n卷积神经网络（CNNs）成为各种图像预测问题背后的共同主力。 但仍需要进行大量的手工操作来设计有效的损失函数。 使用CNN针对不同的问题，需要手动设计不同的损失函数，例如，输出清晰，逼真的图像…..这是一个开放的问题，通常需要各种不同的专业知识。\n如果我们只能指定一个高级目标，然后自动学习适合于这一目标的损失函数，那将是非常可取的。这也就是生成性对抗网络（GAN）所做的事情。GAN可以自动学习损失函数去区分输出图像时真实的还是伪造的，所以它可以应用于传统上需要非常多不同类型的损失函数的大量任务。\n本文的主要贡献是证明在有各种各样的问题上，conditional GANs produce reasonable results. 我们的第二个贡献是提供一个足以取得良好结果的简单框架，并分析几个重要架构选择的影响。\n图像条件模型已经从法线贴图[54]，未来帧预测[39]，产品照片生成[58]以及稀疏注释[30,47]的图像生成中解决了图像预测问题。\n我们的框架不同之处在于没有任何特定应用程序。这使我们的设置比大多数其他设置简单得多。在生成器(generator)和判别器(discriminator)几个架构的选择中，生成器基于U-net网络，判别器选择卷积PatchGAN分类器，仅在图像块的比例下惩罚结构。\n\n3、方法\nGANs是生成模型，可以学习从随机噪声向量z到输出图像y，G : z -&gt; y。相反，条件GANs学习从观察图像x和随机噪声向量z到y的映射，G : {x; z} -&gt; y.对生成器G进行训练以产生输出，使这个输出与对抗训练过的判别器产生的“真实”图像无法区分，D，经过训练，尽可能地检测生成器的“fakes”。 训练过程如图二所示：\n\n\n3.1 目标\nconditional GAN的目标方程可以表示为：\n\n\n\n其中G试图最小化这个目标，而D试图最大化目标形成对抗。\n\n\n\n为了测试discriminator的重要性，我们还比较了一个无条件变量，其中discriminator没有观察量x，公式如下：\n\n\n\n以前的方法发现将GAN objective与更多传统的loss混合是有益的，例如L2距离。discriminator的工作保持不变，但是generator的任务不仅是fool the discriminator，而且还要接近L2意义上的ground truth output。 我们还探索了这个选项，使用L1距离而不是L2，因为L1鼓励减少模糊：\n\n\n\n最终我们的目标函数变成：\n\n\n\n如果没有随机噪声向量z，网络仍然可以学习从x到y的映射，但会产生确定性输出，因此无法匹配delta函数以外的任何分布。 过去的条件GAN已经意识到了这一点并且除了x之外还提供了高斯噪声z作为generator的输入。\n对于我们的最终模型，我们仅以dropout的形式提供噪声，在训练和测试的时候应用我们generator的多个层，尽管存在dropout噪音，但我们观察到网络输出中只有轻微的随机性。 设计产生高随机输出的条件GAN，从而捕获它们建模的条件分布的完整熵，是当前工作留下的一个重要问题。\n\n3.2 网络结构\n网络结构在论文Unsupervised representationlearning with deep convolutional generative adversarialnetworks的网络结构的基础上微调。generator和discriminator采用的都是convolution-BatchNorm-ReLu的形式。包含了下面主要讨论的功能。3.2.1 Generator with skips\n要求输入与输出大致对齐，shape大小一样，基于这个考虑设计generator的架构，为了给generator提供一种信息瓶颈的方法，按照U-net的方式进行跳转连接。U-net原理可参考论文笔记：Unet用于医学图像分割的卷积网络\n\n3.2.2 马尔可夫鉴别器（PatchGAN）\n众所周知，L2损失在图像生成问题上产生模糊结果，见图4。 虽然这些损失不能鼓励高频脆度，但在许多情况下它们仍能准确地捕获低频。 对于这种情况的问题，我们不需要一个全新的框架来强制低频率的正确性。 L1已经做好了。\n这促使限制GAN鉴别器仅模拟高频结构，依赖于L1项来强制低频正确性（方程4）。为了模拟高频，将我们的注意力限制在局部图像块中的结构就足够了。因此，我们设计了一个鉴别器结构，我们将其称为PatchGAN，它只对补丁规模的结构进行惩罚。该鉴别器试图鉴别图像中的每个N*N贴片是真实的还是假的。我们在图像中对这个鉴别器进行了卷积处理，平均所有响应以提供D的最终输出。\nN可以比图像的完整尺寸小得多，并且仍然可以产生高质量的结果。这是有利的，因为较小的PatchGAN具有较少的参数，运行得更快，并且可以应用于任意大的图像。这种鉴别器有效地将图像建模为马尔可夫随机场.3.3 Optimization and inference\n为了优化网络，遵循论文Generative Adversarial Nets\n中的标准方法：我们固定D的参数然后在G上交替执行梯度下降。如原始GAN论文中提到的一样，我们不是最小化log(1-D(x;G(x; z))而是最大化logD(x;G(x; z))。我们使用minibatch SGD并应用Adam优化器，学习率设为0:0002,动量参数β1 = 0.5, β2 = 0.999.\n在预测时，我们以与训练阶段完全相同的方式运行generator。 这与通常的协议不同之处在于我们在测试时应用了dropout，并且我们在test batch上应用了batch normalization，而不是训练批次的汇总统计数据。 当批量大小设置为1时，这种batch normalization的方法被称为instance normalization。 并且已被证明在图像生成任务中有效[53]。 在我们的实验中，我们根据实验使用1到10之间的批量大小。\n\n4、Experiments\n实验部分主要讲用了哪些数据集，做了哪些对比试验，结果分析以及一些评估标准。就不一一详细写出来了。\n\n5、总结\n总的来说，我个人觉得这篇文章的只是给Generative Adversarial Nets多找了几个应用场景，为图像到图像的转换的转换提供了一个通用的框架，局部像素处理，平均所有块响应以提供D的最终输出以及平均所有响应以提供D的最终输出。是个很好的创新点。\n此外看这篇文章之前需要GAN网络的基础。可以先看一下论文Generative Adversarial Nets\n，或者先看一下李宏毅教授讲解GAN网络的视频。我记得是在他的机器学习课程的第18节，在微信公众号：轮子工厂  后台回复：机器学习，可获取李宏毅教授整套机器学习视频。\n\n","categories":["图像处理与机器学习"],"tags":["机器学习","深度学习","医疗图像"]},{"title":"DSN分割肝脏实验总结","url":"https://tanqingbo.cn/DSN-segmentation-liver-experiment-summary/","content":"前言\n本实验采用3D深度监督网络（DSN）对肝脏进行分割，因为使用3D的肝脏数据进行分割可以很好的体积上下文信息。\nDSN的大致学习过程是：基于CNN，为了应对梯度消失和模型辨别能力问题，在隐藏层加入一些额外的监督来抵消梯度消失的不利影响。具体而言，使用一些额外的反卷积层来扩展一些低级和中级特征向量。然后使用softmax层来获得用于计算分类误差的dense预测(监督层的预测)。利用从这些分支预测和最后输出层得到的梯度，可以有效地减轻梯度消失的影响。\ndeeply- supervision 的优点包括：\n能够减轻梯度爆炸或梯度消失，收敛速度更快（辅助 loss 将误差直接注入中间层，有点类似于 resnet 的机制，不同的是 loss 来源不同 ）;\n辅助 loss 起到 regularization 的作用.\n\n\n\n\n详情可参见这篇文章《论文解读：Deeply-Supervised Nets》和《论文笔记：3D Deeply Supervised Network for Automatic Liver Segmentation from CT Volumes》\n\n数据问题one_hot处理\n在开始训练DSN网络之前要对数据进行一些预处理，首先将标签数据转成0 1值，即前景的像素值为1，背景的像素值为0。因为再算loss的时候，要将金标准标签转成one_hot值，想把标签处理成0 1方便做**one_hot处理。**\n简单解释一下什么是one_hot，one-hot code也称独热码，通常用于分类任务中作为最后的FC层的输出。在机器学习中对于离散型的分类型的数据，需要对其进行数字化，比如说对性别这一属性，只有男女两种值，用数字化表达，指定男性为0，女性为1，那么一个特征向量(1,0,1),转换成独热码（one_hot）就变成([1,0],[0,1],[1,0])。\n\n内存不足问题\n因为3D肝脏数据，数据量庞大，如果一次性把整组的数据都加载进去可能导致计算内存不足的问题，所以在训练之前需要减少训练数据的size，本实验中将所有的数据都转换成了[16,512,512]大小。\n还有也是因为内存不足的问题，再加载数据的时候用到了yield迭代器，需要注意的是，它yield是一个类似 return 的关键字，迭代一次遇到yield时就返回yield后面的值。重点是：下一次迭代时，从上一次迭代遇到的yield后面的代码开始执行。详细理解yield可以参考文章《彻底理解python中的yeild》\n\n代码解读\n网络的架构大致如下：layers = [['block0', [['conv', [9, 9, 7, 1, 8], [1, 1, 1, 1, 1], 'SAME', 0.7]]],          ['block1', [['conv', [9, 9, 7, 8, 16], [1, 1, 1, 1, 1], 'SAME', 0.7],                      ['maxpool', [1, 2, 2, 2, 1], [1, 2, 2, 2, 1], 'SAME']]],          ['block2', [['conv', [7, 7, 5, 16, 32], [1, 1, 1, 1, 1], 'SAME', 0.7]]],          ['block3', [['conv', [7, 7, 5, 32, 32], [1, 1, 1, 1, 1], 'SAME', 0.7],                      ['maxpool', [1, 2, 2, 2, 1], [1, 2, 2, 2, 1], 'SAME']], ],          ['block4', [['conv', [5, 5, 3, 32, 32], [1, 1, 1, 1, 1], 'SAME', 0.7]]],          ['block5', [['conv', [1, 1, 1, 32, 32], [1, 1, 1, 1, 1], 'SAME', 0.7]]],          ['block6', [['deconv', [3, 3, 3, 32, 32], [1, 2, 2, 2, 1], 'SAME']]],          ['block7', [['deconv', [3, 3, 3, 2, 32], [1, 2, 2, 2, 1], 'SAME']]],          ]\n在['block0', [['conv', [9, 9, 7, 1, 8], [1, 1, 1, 1, 1], 'SAME', 0.7]]]中，[9, 9, 7, 1, 8]表示卷积核的大小为[9,9,7],当前深度为1，卷积核的深度为7.SAME表示在卷积之前加了padding是特征图在卷积前后特征不变。0.7是dropout系数。\n\n整理并给出代码\n代码地址：https://github.com/tqb4342/DSN\n\n","categories":["图像处理与机器学习"],"tags":["机器学习","深度学习","DSN","医疗图像"]},{"title":"keras+TensorBoard实现训练可视化","url":"https://tanqingbo.cn/keras+TensorBoard/","content":"keras+TensorBoard实现训练可视化# 引入Tensorboardfrom keras.callbacks import TensorBoard\ttbCallBack = TensorBoard(log_dir='./logs',  # log 目录                 histogram_freq=0,  # 按照何等频率（epoch）来计算直方图，0为不计算#                  batch_size=32,     # 用多大量的数据计算直方图                 write_graph=True,  # 是否存储网络结构图                 write_grads=True, # 是否可视化梯度直方图                 write_images=True,# 是否可视化参数                 embeddings_freq=0,                  embeddings_layer_names=None,                  embeddings_metadata=None)\tmodel.fit(...inputs and parameters..., callbacks=[tbCallBack])\n\n通过引入tensorboard加入了回调函数的功能。 它将在训练期间运行并输出可用于张量板的文件。如果您想要在训练的过程中可视化，请在terminal终端输入  tensorboard --logdir=./logs \n\n然后在浏览器中访问http://localhost:6006\n\n\n\n完整代码如下：\n由keras/examples/mnist_mlp.py示例代码修改:\n\nfrom __future__ import print_functionimport kerasfrom keras.datasets import mnistfrom keras.models import Sequentialfrom keras.layers import Dense, Dropoutfrom keras.optimizers import RMSprop# 引入Tensorboardfrom keras.callbacks import TensorBoardbatch_size = 128num_classes = 10epochs = 20# the data, split between train and test sets(x_train, y_train), (x_test, y_test) = mnist.load_data()x_train = x_train.reshape(60000, 784)x_test = x_test.reshape(10000, 784)x_train = x_train.astype('float32')x_test = x_test.astype('float32')x_train /= 255x_test /= 255print(x_train.shape[0], 'train samples')print(x_test.shape[0], 'test samples')# convert class vectors to binary class matricesy_train = keras.utils.to_categorical(y_train, num_classes)y_test = keras.utils.to_categorical(y_test, num_classes)model = Sequential()model.add(Dense(512, activation='relu', input_shape=(784,)))model.add(Dropout(0.2))model.add(Dense(512, activation='relu'))model.add(Dropout(0.2))model.add(Dense(num_classes, activation='softmax'))model.summary()model.compile(loss='categorical_crossentropy',              optimizer=RMSprop(),              metrics=['accuracy'])tbCallBack = TensorBoard(log_dir='./logs',  # log 目录                 histogram_freq=0,  # 按照何等频率（epoch）来计算直方图，0为不计算#                  batch_size=32,     # 用多大量的数据计算直方图                 write_graph=True,  # 是否存储网络结构图                 write_grads=True, # 是否可视化梯度直方图                 write_images=True,# 是否可视化参数                 embeddings_freq=0,                  embeddings_layer_names=None,                  embeddings_metadata=None)history = model.fit(x_train, y_train,                    batch_size=batch_size,                    epochs=epochs,                    verbose=1,                    validation_data=(x_test, y_test),                    callbacks=[tbCallBack])score = model.evaluate(x_test, y_test, verbose=0)print('Test loss:', score[0])print('Test accuracy:', score[1])","categories":["图像处理与机器学习"],"tags":["机器学习","深度学习","医疗图像"]},{"title":"你确定真的要转学计算机吗？","url":"https://tanqingbo.cn/Transfer-to-computer-major/","content":"\n最近有一种感觉，好像全世界所有的人在转学计算机，大家熟悉的呆博，本科学电子的，来哈工大之后转了计算机的研究生，他的那些没读计算机研究生的同学，现在也在刷Java后端的书，准备找一个后端工程师的岗位。更夸张的是前两天在朋友圈看一个信息：哈工程船舶专业的博士报培训班，要转行从事软件开发工作，要知道哈工程船舶专业在上轮评估中全国排第一。\n确实，现在的计算机专业真的很吃香，尤其是人工智能浪潮刚来，做算法的工资更是高到可怕，很多本科生都拿着20w+的年薪，研究生30~40w+的年薪也很正常，呆博还拿到过45w+的offer呢！这些数据确实是事实，但是还有另外一个事实：80%的高新岗位被20%的人拿走了！什么意思呢？就是计算机的应届生拿40W+的年薪确实是事实，但是这些高薪岗位都被那几所计算机名校的学生拿走了，跟你半毛钱关系都没有。华为应该是大部分同学可望而不可及的目标，非985的同学连简历筛选都过不了，可是我身边找工作的同学和我说，只要是你是工科名校出身的男生，管你学成啥样都能去。可能你觉得不合理，但是从企业的角度来说却很合理：与其花大量的成本在一堆不优秀的人里面挑优秀的人，不如用很少的成本把大部分都比较优秀的这一堆人招走。错过你，人家一点都不遗憾！\n抛去这些最高与最低薪资不谈，我也去了解了一下大部分应届程序员的工资，大概在4-8k/月左右，所以对于非计算机专业毕业想转计算机的同学来说，做为没有接受过系统训练的非科班生，可以自己估算一下自己值这个区间的哪个数字，是否符合你的预期，为了这个数字放弃自己的头发是否真的值得。\n对于想要跨考计算机研究生的同学，我也有几点建议给你：\n如果你的实力不是超级强，那么学历真的特别特别重要。最好能考到985，如果时间成本允许，可以接受复读。我有一朋友在一本读自然语言处理的研究生，最后自学转成了java后台，因为身边没有人会自然语言处理，老师也不会。如果你不想有这种经历的话，那就考到一所好的学校去吧！\n努力真的很重要，不断学习新技术的能力更重要。IT行业是技术更新最快的行业，我本科时候用的spring现在已经被人说成老古董了，现在最流行的深度学习网络，其实也就是这几年提出来的，你看技术更新如此之快，如果你不能保持持续学习的能力，第一个淘汰的肯定是你。\n有自己的主见很重要。别随大流，不要看着别人都转计算机了，那我也转吧！还是前面说的那句话：80%的高新岗位被20%的人拿走了，要是成为不了这20%，对编程也不感兴趣的话，那就别难为自己了，头发很重要，放过自己吧！IT不值得。\n\n\n\n","categories":["技术以外"],"tags":["计算机","求职"]},{"title":"论文笔记：3D Deeply Supervised Network for Automatic Liver Segmentation from CT Volumes","url":"https://tanqingbo.cn/3D-Deeply-Supervised-Network-for-Automatic-Liver-Segmentation-from-CT-Volumes/","content":"前言\n本文提出3D DSN对3d的肝脏数据进行分割，采用完全卷积架构，有效的执行端到端学习和推理，此外条件随机场（CRF）来获得更加精细的分割。\n通常统计变形模型最流行和成功的分割方法，该方法利用形状先验信息、强度分布以及边界区域信息来描述肝脏的特征和划定界限。但是这些方法过度的依赖人工，或者没有利用3D空间信息，因此如何利用体积上下文信息，提取强大的高级特征来自动分割肝脏一直都为解决。\n为了充分利用空间信息，提出了3D CNN，尽管3D CNN没有端到端训练，而且数据有限且存在风险，但依然大量的激励研究者去深入研究3D CNN在医学图像领域的应用。\n本文采用3D DSN分割，并用条件随机场（CRF）执行轮廓修正，得到最终的结构。\n\n方法\n3D DSN的架构如图1所示。 主流网络由11层组成，即6个卷积层，2个max pooling层，2个反卷积层和1个softmax层。 通过第三层和第六层涉及深层监督机制，如灰色虚线框所示。\n\n\n\n为了对体积数据中的空间信息进行充分编码，我们DSN中的所有层都以3D格式构建，如图1所示。3D卷积层和3Dmax pooling层交替堆叠来连续提取中间特征。\n每个卷积层中使用的内核的数量和大小如图1所示。我们设计相对较大的内核大小，以形成适合肝脏识别的接收领域。所有max pooling层都使用2 * 2 * 2的内核。经过几个阶段的下采样后，特征体积的尺寸逐渐减小，并且比gt_mask的尺寸小得多。在这方面，我们开发3D反卷积层以将这些粗糙feature map桥接到密集概率预测（即变为原来的尺寸大小）。反卷积的时候卷积核大小是333（正向卷积核大小见上图），方向的是尺寸双倍放大。此外反向卷积核在训练的过程中学习得来。\n\n深层监督的学习过程\n3D网络的学习过程可以认为是提速二分类误差最小化问题，在优化的过程中一个挑战就是：梯度消失，这使得早期层中的损失反向传播无效。这种问题在3D情况下可能更严重，并且不可避免地会降低收敛速度并降低模型的辨别能力。为了应对这一挑战，我们利用注入一些隐藏层的额外监督来抵消梯度消失的不利影响。\n具体而言，我们使用一些额外的反卷积层来扩展一些低级和中级特征向量。然后使用softmax层来获得用于计算分类误差的dense预测(监督层的预测)。利用从这些分支预测和最后输出层得到的梯度，可以有效地减轻梯度消失的影响。\n令wl为l层的权重，W = (w1;w2; …;wL)为主流网络的权重，p (ti | xi;W)表示体素xi属于ti类的概率(softmax function输出)，则最后一个输出层的负对数似然损失如下：\n\n\n\n其中X表示训练集，从第d层引入深度监督，用Wd =(w1;w2; …;wd)表示主流网络第d层的权重。使用w^d表示将第d层特征桥接到dense预测(监督层的预测)的权重，深度监督的辅助损失如下：\n\n\n\n最后，我们采用标准反向传播，通过最小化以下总体目标函数来学习权重W和所有w^d：\n\n\n\n其中ηd是ζd的平衡权重，在学习的过程中衰减。D是具有深层监督的所有隐藏层的索引集。 上面公式中第一项对应于最后一层的输出预测， 第二项来自深层监督，提高了网络的识别能力，加快了收敛速度，第三项是权重衰减正则化，λ是权衡超参数。在每次训练迭代中，网络的输入是一个大的体积数据（见图1），并且同时进行来自不同损耗分量的误差反向传播。\n\n使用条件随机场(CRF)进行轮廓修正\n尽管3D DSN可以生成高质量的概率图，但是如果仅使用阈值概率，则模糊区域的轮廓有时可能是不精确的。 因此，我们进一步采用图形模型来细化分割结果。 考虑到网络已经充分考虑了3D空间信息，我们在横向平面上利用了完全连接的CRF模型，该模型具有高分辨率。 该模型解决了如下能量函数：\n\n\n\n第一项是指体素xi被分配标签yi的概率对数， 具体而言，p^（yi|xi）被初始化为来自3D DSN的最后层和分支概率预测的加权平均值，计算公式如下：\n\n\n\nE(y)中的第二项是pairwise potential,其中f(yi; yj)=1 if yi != yj and 0 otherwise;∮(xi; xj)通过采用灰度值I和双边位置s来结合局部外观和平滑度，如下：\n\n\n\n使用训练集上的网格搜索来优化一元势中的恒定权重τd和成对势中的参数μ1; μ2; θα; θβ; θγ。。\n\n实验\n使用MICCAI-SLiver07 [6]数据集（20组训练和10组测试）。\n实施细节。我们的3D DSN是通过Theano库实现的。我们从头开始训练网络，权重是从高斯分布（μ= 0;σ= 0:01）初始化的。学习率初始化为0.1，每50个epochs除以10。深度监督平衡权重初始化为0.3和0.4，每十个epochs衰减5％。\n\n参考\n论文：3D Deeply Supervised Network for Automatic Liver Segmentation from CT Volumes\n\n","categories":["图像处理与机器学习"],"tags":["机器学习","深度学习","DSN","肝脏分割"]},{"title":"论文解读:深度监督网络 Deeply-Supervised Nets","url":"https://tanqingbo.cn/Deeply-Supervised-Nets/","content":"前言\n深度监督网络（DSN）可以提高隐藏层学习过程的直接性和透明度。本文注意力集中在卷积神经网络（CNN型）架构的三个方面：\n\n（1）影响中间层的透明度具有整体分类; \n（2）学习特征的辨别力和稳健性，特别是在早期阶段; \n（3）面对消失的“梯度”训练有效性。\n\n\n为了解决这些问题，我们在每个隐藏层引入伴随目标函数，以及输出层的整体目标函数（与分层预训练不同的集成策略）。我们还使用随机梯度方法扩展的技术分析我们的算法。\n\nDSN的核心思想是为隐藏层提供集成的直接监督层，而不是仅在输出层提供监督，并将此监督传播回早期层的标准方法。我们通过为每个隐藏层引入伴随目标函数来提供这种集成的直接隐藏层监督;这些伴随目标函数可以被视为学习过程中的附加（软）约束。\n\n使用来自随机梯度方法的分析技术来研究限制性设置，其中并入伴随目标函数直接导致提高的收敛率。这种综合深度监督的优势是显而易见的：\n\n（1）对于小型训练数据和相对较浅的网络，对于分类准确性和学习特征问题，深度监督可以提供强大的“正规化”；\n（2）用于大型训练数据和更深层次的网络深度监控使得利用极深度网络可以通过改善其他有问题的收敛行为来使的性能增益提升。\n\n\nDSN的主要特征是通过伴随目标对深度监督进行综合编制，在最简单的情况下，其形式几乎与输出层的目标函数相同，如下公式所示：\n\n\n\n\n但是在初始化和重新调整的时候过度的使用这种分层预训练容易导致过拟合。\n我们注意到我们DSN的方法独立于averaging [22]，drop-connect [17]和Maxout [10]等技术; 因此，我们如果将DSN与这些技术相结合可能会使分类误差大大减少。\n\nDeeply-Supervised Nets\nDSD是在现有的CNN基础上提出来的，在隐藏层引入了分类器（SVM或Softmax）。DSN提出的动机\n一般来说，在较多的特征上训练判别分类器比在较少的特征上训练判别分类器的性能要更好，如果讨论的特征是深层网络中的隐藏层特征，意味着使用这些隐藏层特征图训练的判别分类器的性能可以作为这些隐藏层特征图的质量好坏的评判标准（我猜论文应该是表达这个意思）。\n我们还期望这种深度监督可以缓解消除“渐变”的常见问题。我们通过将“伴随”分类输出与每个隐藏层相关联来引入我们的额外深度反馈。实证结果表明了伴随目标的以下主要特性：\n（1）它是一个特征正则化的类型，它导致测试误差的减少，而不一定减少训练误差;\n（2）它导致改进的对流性能行为，需要更少的手动调整（特别是对于非常深的网络）。\n\n\n\n公式\n将一个分类与每个隐藏层相关联。 对应的权重表示为：\n\n\n\n为了便于参考，我们将总体提目标函数定义为：\n\n\n\n其中P(W)为输出层的目标函数，定义如下：\n\n\n\n隐藏层伴随目标函数如下：\n\n\n\n在上述公式中，w(out)表示输出层权重，那么我们的总体目标函数F(W)就可以表示为：\n\n\n\n我们使用SGD训练DSN模型，梯度W遵循传统的CNN模型，加上来自隐藏层直接监督的梯度;我们还使用伴随目标归零，如下所述，我们将（与输出层相关）称为总损失，将称为伴随损失。在L2SVM中这些都是预测误差的损失。\n出来学习卷积核和权重W之外，我们在每个隐藏层包含了一个额外的目标，与该层的良好标签预测相关联，这个额外的目标强烈支持在每个隐藏层上具有辨别力和敏感性的特征。\n注意：对于每一个，w(m)取决于Z(m)(Z(m)表示中间层的输出),而Z(m)又取决于第一到m层。\n在训练过程中经常被送到零;这意味着产生良好的输出层分类的总体目标不会从根本上改变，而且这个目标可以作为一种正则化或作为判别特征的代理。在公式（4）中我们追求这种伴随目标归零的一种方法是设置一个阈值γ（超参数）。一旦每个隐藏层的伴随损失低于阈值，它就会消失（我理解的是伴随目标函数不再工作），不再有助于学习过程中的梯度更新（见上述的公式4便可知）。第m个平衡参数αm表示输出目标与相应的伴随目标之间的权衡。\n伴随目标归零的另一种方法是使用简单的衰减函数，例如αm × 0.1 × (1 − t/N) → αm强制F(W)的第二个项在一定次数的迭代后消失，其中t是当前迭代步数，N是总迭代步数。我们从这两种方法中获得了可观的初步结果;\n最先进的基准测试结果表明，深度监督方法不会显示有害的过拟合：如图（2.c）所示，而CNN和DSN的训练误差最终接近于零，DSN 显示出较低的测试误差，因此证明了其优于标准CNN的优势。\n\n随机梯度下降视图（Stochastic Gradient Descent View）\n深度神经网络中的目标函数是高度非凸函数，这一特征导致当前缺乏对DL框架的清晰数学/统计分析。 一种常见的方法是通过将注意力仅限于局部凸性所处的环境来提高可追溯性。 在这里，我们遵循这个例子，假设我们的目标函数是λ-strongly局部凸的，并遵循随机梯度下降的分析技术[3]。\nλ-strongly 凸函数F(W)定义如下(对W if ∀ W,W′ ∈ W and any subgradient g at W)：\n\n\n\n令W⋆为最优解，假设凸函数设置中存在E[∥WT −W⋆∥2]和E[F(WT ) − F(W⋆)]的上界。或者说在凸函数设置中存在E[F(WT ) − F(W⋆)]的上界。在这个基础上我们试着去理解目标函数的收敛性，图一(b)大致可以说明E[∥WT −W⋆∥2]假设特征。 在[19]中，给出了具有局部凸函数的M-估计量的收敛速度，其具有成分损失和规则化项。\n\n\n\n定义：用Sγ(F) = {W | F(W) ≤ γ}表示γ-sublevel集合，在这里等价于F(W) ≡ P(W) + Q(W).\n接下来论文中是证明Sγ(F) = {W | F(W) ≤ γ}于F(W) ≡ P(W) + Q(W)等价的过程，我把这部分过程省略了。\n\n实验\n文章中在四个数据集上评估我们提出的DSN：MNIST，CIFAR-10，CIFAR-100和SVHN。还使用ImageNet来评估DSN在大型数据集上的行为。\n使用小批量大小为128且固定动量为0.9的SGD求解器。学习率和体重衰减因子的初始值由评估集确定。\n我们还包含两个丢失率为0.5的丢失层。 卷积层上的伴随目标被强制反向传播去指导误分类的相关层。我们提出的DSN框架并不难以训练，也没有采用特定的工程技巧。\nDSN可以配备不同类型的分类目标功能;我们考虑L2SVM和softmax，并显示DSN-L2SVM和DSN-Softmax性能超过相应的CNN-L2SVM和CNN-Softmax方法，如图2.a所示，在小型训练数据体系中，性能提升更为明显（见图（2.b））;这可能部分减轻了DL需要大量训练数据的负担。\n\n\n\n总的来说，我们在所有四个数据集上都观察到了最新的分类错误。所有结果都是在没有aver- aging（我的理解是没有均值化）的情况下实现的[22]，这可以进一步提高分类精度。\n\n我们的DSN方法可以与许多现有的CNN类型方法结合使用。总体而言，如前所述：对于小型训练数据和相对较浅的网络，DSN起到强大的“正规化”的作用;对于大型训练数据和非常深的网络，DSN使训练过程变得方便，\n\n\n总结\n这篇论文首次提出 deeply -supervision 的做法，文章的 motivation 基于这样的观察： 如果 features 越 discrminative , 那么 classifier 的性能就越好 。\n\n文章还提到 deeply- supervision 的优点包括：\n\n能够减轻梯度爆炸或梯度消失，收敛速度更快（辅助 loss 将误差直接注入中间层，有点类似于 resnet 的机制，不同的是 loss 来源不同 ）\n\n辅助 loss 起到 regularization 的作用 （我猜应该是超参 λ起得作用）\n\n作者可视化了第一卷积层学到的feature map, 发现比普通 CNN 学到的特征更加 intuitive（论文提到了这一现象，但没有给出解释，后面几层特征图的特点也没有提及）.\n\n\n\n文章里的辅助分类器为 SVM。\n\n\n\n后记\n论文后面的内容都是对数据集合实验精度的介绍，我没有详细写了。\npaper下载：http://arxiv.org/abs/1409.5185\ncode 和prototxt文件下载：https://github.com/s9xie/DSN\n\n参考\nDeeply-Supervised Nets\n简书：月牙眼的楼下小黑 论文阅读：《Deeply-Supervised Nets》\n\n","categories":["图像处理与机器学习"],"tags":["机器学习","深度学习","深度监督网络"]},{"title":"常见医疗扫描图像处理步骤","url":"https://tanqingbo.cn/Medical-scan-image-processing/","content":"一、数据格式1.1 dicom\nDICOM是医学图像中的标准文件，这些文件包含了诸多元数据信息（比如像素尺寸），此处以kaggle Data Science Bowl数据集为例：data-science-bowl-2017,数据列表如下：\n\n\n\n后缀为 .dcm。\n每个病人的一次扫描CT(scan)可能有几十到一百多个dcm数据文件(slices)。可以使用 python的dicom包读取，读取示例代码如下:dicom.read_file('/data/lung_competition/stage1/7050f8141e92fa42fd9c471a8b2f50ce/498d16aa2222d76cae1da144ddc59a13.dcm')\n其pixl_array包含了真实数据。slices = [dicom.read_file(os.path.join(folder_name,filename)) for filename in os.listdir(folder_name)]slices = np.stack([s.pixel_array for s in slices])\n1.2 mhd格式\nmhd格式是另外一种数据格式，来源于(LUNA2016)[https://luna16.grand-challenge.org/data/]。每个病人一个mhd文件和一个同名的raw文件。如下:\n\n\n\n一个raw通常有几百兆，对应的mhd文件只有1kb。mhd文件需要借助python的SimpleITK包来处理。SimpleITK 示例代码如下:import SimpleITK as sitkitk_img = sitk.ReadImage(img_file)img_array = sitk.GetArrayFromImage(itk_img) # indexes are z,y,x (notice the ordering)num_z, height, width = img_array.shape        #heightXwidth constitute the transverse planeorigin = np.array(itk_img.GetOrigin())      # x,y,z  Origin in world coordinates (mm)spacing = np.array(itk_img.GetSpacing())    # spacing of voxels in world coor. (mm)\n需要注意的是，SimpleITK的img_array的数组不是直接的像素值，而是相对于CT扫描中原点位置的差值，需要做进一步转换。\n\n1.3 查看CT扫描文件软件\n一个开源免费的查看软件 mango\n\n\n二 dicom格式数据处理过程2.1 处理思路\n首先，需要明白的是医学扫描图像其实是三维图像，使用代码读取之后查看不同的切面的切片(slices),可以从不同轴切割。\n\n\n\n如下图展示了一个病人CT扫描中，其中部分切片slices：\n\n\n\n其次，CT扫描图是包含了所有组织的，如果直接去看，看不到任何有用的信息，需要做一些预处理，预处理中一个重要概念是仿射剂量，衡量单位为HU(Hounsfield Unit),下表是不同放射剂量对应的组织器官：\n\n\nHounsfield Unit = pixel_value * rescale_slope + rescale_intercept\n\n一般情况rescale slope = 1, intercept = -1024。\n上表中肺部组织的HU数值为-500,但通常是大于这个值，比如-320、-400。挑选出这些区域，然后做其他变换抽取出肺部像素点。\n\n2.2 先载入必要的包# -*- coding:utf-8 -*-'''this script is used for basic process of lung 2017 in Data Science Bowl'''import globimport osimport pandas as pdimport SimpleITK as sitkimport numpy as np # linear algebraimport pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)import skimage, osfrom skimage.morphology import ball, disk, dilation, binary_erosion, remove_small_objects, erosion, closing, reconstruction, binary_closingfrom skimage.measure import label,regionprops, perimeterfrom skimage.morphology import binary_dilation, binary_openingfrom skimage.filters import roberts, sobelfrom skimage import measure, featurefrom skimage.segmentation import clear_borderfrom skimage import datafrom scipy import ndimage as ndiimport matplotlib#matplotlib.use('Agg')import matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d.art3d import Poly3DCollectionimport dicomimport scipy.miscimport numpy as np\n2.3 将厚度加入到元数据\n如下代码是载入一个扫描面，包含了多个(slices)，我们仅简化的将其存储为python列表，数据集中每个目录都是一个扫描集(一个病人)。有个元数据域丢失，即Z轴方向上的像素尺寸，也即切片的厚度，所幸，我们可以用其他值推测出来，并加入到元数据中。\n\n# Load the scans in given folder pathdef load_scan(path):    slices = [dicom.read_file(path + '/' + s) for s in os.listdir(path)]\t#对一个病人的所有slices进行排序，x指的是一个slice。slice里面有好多属性，\t#有一个是ImagePositionPatient.按照他的这个属性进行对这些slices排序，方便我们组三维rendering。\t#imageOrientationPatient表示的是当前图像的第一行在空间中的三维方向向量与第一列的三维方向向量。    slices.sort(key = lambda x: int(x.ImagePositionPatient[2]))    try:        slice_thickness = np.abs(slices[0].ImagePositionPatient[2] - slices[1].ImagePositionPatient[2])    except:        slice_thickness = np.abs(slices[0].SliceLocation - slices[1].SliceLocation)  #SliceLocation：表示的图像平面的相对位置。    for s in slices:        s.SliceThickness = slice_thickness   #切片厚度    return slices\n2.4 灰度值转换为HU单元\n首先去除灰度值为-2000的pixl_array(pixl_array包含了真实数据),CT扫描边界之外的灰度值固定为-2000(dicom和mhd都是这个值)。第一步设定这些值为0，当前对应为空气(值为0).\n回到HU单元，乘以rescale比率并加上intercept(存储在扫描面的元数据中)。(Hounsfield Unit = pixel_value * rescale_slope + rescale_intercept).def get_pixels_hu(slices):    image = np.stack([s.pixel_array for s in slices])    # Convert to int16 (from sometimes int16),    # should be possible as values should always be low enough (&lt;32k)    image = image.astype(np.int16)    # Set outside-of-scan pixels to 0    # The intercept is usually -1024, so air is approximately 0    image[image == -2000] = 0    # Convert to Hounsfield units (HU)    for slice_number in range(len(slices)):        intercept = slices[slice_number].RescaleIntercept  #Intercept        slope = slices[slice_number].RescaleSlope  #Rescale        if slope != 1:            image[slice_number] = slope * image[slice_number].astype(np.float64)            image[slice_number] = image[slice_number].astype(np.int16)        image[slice_number] += np.int16(intercept)    return np.array(image, dtype=np.int16)\n可以查看病人的扫描HU分布值情况：first_patient = load_scan(INPUT_FOLDER + patients[0])first_patient_pixels = get_pixels_hu(first_patient)plt.hist(first_patient_pixels.flatten(), bins=80, color='c')plt.xlabel(\"Hounsfield Units (HU)\")plt.ylabel(\"Frequency\")plt.show()\n2.5 重采样\n不同扫描面的像素尺寸，粗细粒度是不同的，这不利于我们进行CNN任务，我们可以使用同构采样。\n一个扫描面的像素区间可能是[2.5,0.5,0.5],即切片之间的距离为2.5mm。可能另外一个扫描面的范围是[1.5,0.725,0.725]。这可能不利于自动分析。常见的处理方法是从全数据集中以固定的同构分辨率重新采样，将所有的东西采样为(1,1,1).def resample(image, scan, new_spacing=[1,1,1]): # scan是load_scan函数返回的结果    # Determine current pixel spacing    spacing = map(float, ([scan[0].SliceThickness] + scan[0].PixelSpacing))    spacing = np.array(list(spacing))    resize_factor = spacing / new_spacing    new_real_shape = image.shape * resize_factor    new_shape = np.round(new_real_shape)   #返回浮点数x的四舍五入值。    real_resize_factor = new_shape / image.shape    new_spacing = spacing / real_resize_factor    image = scipy.ndimage.interpolation.zoom(image, real_resize_factor, mode='nearest') #使用所请求顺序的样条插值来缩放数组。    return image, new_spacing# 现在重新取样病人的像素，将其映射到一个同构分辨率 1mm x1mm x1mm。pix_resampled, spacing = resample(first_patient_pixels, first_patient, [1,1,1])\n使用matplotlib输出肺部扫描的3D图像方法。可能需要一两分钟。def plot_3d(image, threshold=-300):    # Position the scan upright,    # so the head of the patient would be at the top facing the camera    p = image.transpose(2,1,0)  #将扫描件竖直放置    verts, faces = measure.marching_cubes(p, threshold) #Liner推进立方体算法来查找3D体积数据中的曲面。    fig = plt.figure(figsize=(10, 10))    ax = fig.add_subplot(111, projection='3d')    # Fancy indexing: `verts[faces]` to generate a collection of triangles    mesh = Poly3DCollection(verts[faces], alpha=0.1)  #创建3Dpoly    face_color = [0.5, 0.5, 1]    mesh.set_facecolor(face_color)  #设置颜色    ax.add_collection3d(mesh)    ax.set_xlim(0, p.shape[0])    ax.set_ylim(0, p.shape[1])    ax.set_zlim(0, p.shape[2])    plt.show()# 调用函数plot_3d(pix_resampled, 400)\n打印函数有个阈值（threshold）参数，来打印特定的结构，比如tissue或者骨头。400是一个仅仅打印骨头的阈值(HU对照表)，如下图：\n\n\n2.6 输出一个病人scans中所有的slicesdef plot_ct_scan(scan):    '''            plot a few more images of the slices    :param scan:    :return:    '''    f, plots = plt.subplots(int(scan.shape[0] / 20) + 1, 4, figsize=(50, 50))    for i in range(0, scan.shape[0], 5):        plots[int(i / 20), int((i % 20) / 5)].axis('off')        plots[int(i / 20), int((i % 20) / 5)].imshow(scan[i], cmap=plt.cm.bone)\n\n\n此方法的效果示例如下:\n\n\n2.7 数据标准化处理\n归一化处理：\n当前的值范围是[-1024,2000]。而任意大于400的值并不是处理肺结节需要考虑，因为它们都是不同反射密度下的骨头。LUNA16竞赛中常用来做归一化处理的阈值集是-1000和400.以下代码：\n\n\n\nMIN_BOUND = -1000.0MAX_BOUND = 400.0def normalize(image):    image = (image - MIN_BOUND) / (MAX_BOUND - MIN_BOUND)    image[image&gt;1] = 1.    image[image&lt;0] = 0.    return image\n\n\n0值中心化：\n简单来说就是所有像素值减去均值。LUNA16竞赛中的均值大约是0.25.\n不要对每一张图像做零值中心化（此处像是在kernel中完成的）CT扫描器返回的是校准后的精确HU计量。不会出现普通图像中会出现某些图像低对比度和明亮度的情况PIXEL_MEAN = 0.25def zero_center(image):    image = image - PIXEL_MEAN    return image\n\n\n\n\n\n三 mhd格式数据处理过程\nmhd的数据只是格式与dicom不一样，其实质包含的都是病人的扫描，处理MHD需要借助SimpleITK这个包，处理思路详情可以参考Data Science Bowl2017的toturail Data Science Bowl 2017.需要注意的是MHD格式的数据没有HU值，它的值域范围与dicom很不同。\n我们以LUNA2016年的数据处理流程为例。参考代码为: LUNA2016数据切割.3.1 载入必要的包import SimpleITK as sitkimport numpy as npimport csvfrom glob import glob  #用它可以查找符合自己目的的文件import pandas as pd# glob方法返回所有匹配的文件路径列表（list）；该方法需要一个参数用来指定匹配的路径字符串，# 其返回的文件名只包括当前目录里的文件名，不包括子文件夹里的文件。file_list=glob(luna_subset_path+\"*.mhd\")  ####################### Helper function to get rows in data frame associated# with each filedef get_filename(case):\t# 如果你想要为一个定义在函数外的变量，那么你就得告诉Python这个变量名不是局部的，而是 全局 的。    global file_list    for f in file_list:        if case in f:            return(f)## The locations of the nodesdf_node = pd.read_csv(luna_path+\"annotations.csv\")df_node[\"file\"] = df_node[\"seriesuid\"].apply(get_filename)  #调用get_filename函数，并函数参数为df_node[\"seriesuid\"]df_node = df_node.dropna() #将所有含有nan项的row删除####### Looping over the image files#fcount = 0for img_file in file_list:    print \"Getting mask for image file %s\" % img_file.replace(luna_subset_path,\"\")    mini_df = df_node[df_node[\"file\"]==img_file] #get all nodules associate with file    if len(mini_df)&gt;0:       # some files may not have a nodule--skipping those        biggest_node = np.argsort(mini_df[\"diameter_mm\"].values)[-1]   # just using the biggest node        node_x = mini_df[\"coordX\"].values[biggest_node]        node_y = mini_df[\"coordY\"].values[biggest_node]        node_z = mini_df[\"coordZ\"].values[biggest_node]        diam = mini_df[\"diameter_mm\"].values[biggest_node]\n3.2 LUNA16的MHD格式数据的值\n一直在寻找MHD格式数据的处理方法，对于dicom格式的CT有很多论文根据其HU值域可以轻易地分割肺、骨头、血液等，但是对于MHD没有这样的参考。从LUNA16论坛得到的解释是，LUNA16的MHD数据已经转换为HU值了，不需要再使用slope和intercept来做rescale变换了。此论坛主题下，有人提出MHD格式没有提供pixel spacing(mm) 和 slice thickness(mm) ，而标准文件annotation.csv文件中结节的半径和坐标都是mm单位，最后确认的是MHD格式文件中只保留了体素尺寸以及坐标原点位置，没有保存slice thickness。即，dicom才是原始数据格式。\n\n3.4 坐标体系变换\nMHD值的坐标体系是体素，以mm为单位（dicom的值是GV灰度值）。结节的位置是CT scanner坐标轴里面相对原点的mm值，需要将其转换到真实坐标轴位置，可以使用SimpleITK包中的 GetOrigin() GetSpacing()。图像数据是以512x512数组的形式给出的。\n坐标体系变换如下：\n\n\n\n相应的代码处理如下：\nitk_img = sitk.ReadImage(img_file)img_array = sitk.GetArrayFromImage(itk_img) # indexes are z,y,x (notice the ordering)center = np.array([node_x,node_y,node_z])   # nodule centerorigin = np.array(itk_img.GetOrigin())      # x,y,z  Origin in world coordinates (mm)spacing = np.array(itk_img.GetSpacing())    # spacing of voxels in world coor. (mm)# np.rint(a) 各元素四舍五入v_center = np.rint((center-origin)/spacing)  # nodule center in voxel space (still x,y,z ordering) \n\n在LUNA16的标注CSV文件中标注了结节中心的X,Y,Z轴坐标，但是实际取值的时候取的是Z轴最后三层的数组(img_array)。\n\n下述代码只提取了包含结节的最后三个slice的数据，代码参考自 LUNA_mask_extraction.py\n\n\ni = 0for i_z in range(int(v_center[2])-1,int(v_center[2])+2):    mask = make_mask(center,diam,i_z*spacing[2]+origin[2],width,height,spacing,origin)    masks[i] = mask    imgs[i] = matrix2int16(img_array[i_z])    i+=1np.save(output_path+\"images_%d.npy\" % (fcount) ,imgs)np.save(output_path+\"masks_%d.npy\" % (fcount) ,masks)\n\n3.5 查看节点\n以下代码用于查看原始CT和结节mask。其实就是用matplotlib打印上一步存储的npy文件。import matplotlib.pyplot as pltimgs = np.load(output_path+'images_0.npy')masks = np.load(output_path+'masks_0.npy')for i in range(len(imgs)):    print \"image %d\" % i    fig,ax = plt.subplots(2,2,figsize=[8,8])    ax[0,0].imshow(imgs[i],cmap='gray')    ax[0,1].imshow(masks[i],cmap='gray')    ax[1,0].imshow(imgs[i]*masks[i],cmap='gray')    plt.show()    raw_input(\"hit enter to cont : \")\n接下来的处理和DICOM格式数据差不多，腐蚀膨胀、连通区域标记等。\n\n参考信息\n灰度值是pixel value经过重重LUT转换得到的用来进行显示的值，而这个转换过程是不可逆的，也就是说，灰度值无法转换为ct值。只能根据窗宽窗位得到一个大概的范围。 pixel value经过modality lut得到Hu，但是怀疑pixelvalue的读取出了问题。dicom文件中存在（0028，0106）（0028，0107）两个tag，分别是最大最小pixel value，可以用来检验你读取的pixel value 矩阵是否正确。\n\nLUT全称look up table，实际上就是一张像素灰度值的映射表，它将实际采样到的像素灰度值经过一定的变换如阈值、反转、二值化、对比度调整、线性变换等，变成了另外一 个与之对应的灰度值，这样可以起到突出图像的有用信息，增强图像的光对比度的作用。\n\n\n","categories":["图像处理与机器学习"],"tags":["机器学习","深度学习","医疗图像"]},{"title":"论文笔记：基于3D卷积神经网络的人体行为识别(3D Convolutional Neural Networks for Human Action Recognition)","url":"https://tanqingbo.cn/3D-Convolutional-Neural-Networks-for-Human-Action-Recognition/","content":"摘要\n当前很多人体行为识别分类器都是基于从原始图像上手工提取的特征，本文提出的3D CNN能够直接从原始输入中提取特征，通过执行3D卷积在监控视频中从时间和空间维度提取特征，将高级功能模型规范化，并结合各种不同模型的输出，进一步提高3D CNN的性能。在机场的监控视频中，该方法相比于传统的方法，取的了卓越的性能。\n\n介绍\n现实的环境的监控视频背景杂乱、遮挡等原因，在识别之前会对视频中的某些情况作出某些假设（假设在现实环境中很少存在），然后遵循两步原则：\n\n计算原始视频帧的特征；\n基于获得的特征学习分类器；\n\n\n而然在实际场景中，很少知道哪些特征对手头任务很重要，因为特征选择高度依赖问题。特别是对于人类动作识别，不同的动作类别在其外观和运动模式方面可能显得截然不同。\n\n深度学习模型是一类可以通过从低级特征构建高级特征来学习特征层次结构的机器。这种学习机可以使用有监督或无监督的方法进行训练。\n\nCNN主要用于2D图像，本文探讨将CNN用于视频中人体动作的识别，一种容易想到的方法是将视频的每一帧视为静止图像，并用CNN来识别单个帧的级别动作，但这种方法没有考虑多个连续帧的编码运动信息。为了有效的结合视频中的运动信息，文章提出可以在CNN卷积层中执行3D卷积，以便捕获沿空间和时间维度的辨别特征。3D CNN架构可以从相邻的视频帧生成多个信息通道，并在每个通道中分别执行卷积和下采样，通过组合来自视频通道的信息获得最终特征表示。为了进一步提升3D CNN模型的性能，我们建议增加模型，辅助输出计算为高级运动特征，并集成各种不同架构的输出进行预测。\n\n本文贡献：\n\n本文应用3D卷积运算从视频数据中提取空间和时间特征以进行动作识别。这些3D特征提取器在空间和时间维度上操作，从而捕获视频流中的运动信息；\n开发了基于3D卷积特征提取的3D卷积神经网络架构（CNN），该CNN架构从相邻视频帧生成多个信息通道，并在每个通道中分别执行卷积和下采样。通过组合来自所有通道的信息获得最终的特征表示；\n建议通过增加具有高级运动特征的输出来规范3D CNN模型；\n建议通过组合各种不同3D CNN架构的输出来提高模型的性能。\n\n\n\n3D卷积神经网络\n在二维CNN中，卷积应用于2D特征图，仅从空间维度计算特征。当利用视频数据分析问题的时候，我们期望捕获在多个连续帧编码的运动信息。为此，提出在CNN的卷积进行3D卷积，以计算空间和时间维度特征， 3D卷积是通过堆叠多个连续的帧组成一个立方体，然后在立方体中运用3D卷积核。通过这种结构，卷积层中的特征图都会与上一层中的多个相邻帧相连，从而捕获运动信息。如下图所示，一个feature map的某一位置的值是通过卷积上一层的三个连续的帧的同一位置的局部感受野得到的。\n\n\n\n要注意的是，3D卷积核只能从cube中提取一种类型特征，因为在整个卷积的过程中卷积核的权值都是一样的的（共享权值），都是同一种卷积核，上图中同一颜色的连线表示相同的权值。因此我们可以采用多种卷积核来提取多种特征。\n对于CNNs，有一个通用的设计规则就是：在后面的层（离输出层近的）特征map的个数应该增加，这样就可以从低级的feature map组合产生更多类型的特征。\n\n3D CNN架构\n基于上述的3D卷积，可以设计出各种CNN架构。在上下文中，我们描述了为了描述了为TRECVID数据集中的人为动作识别开发的3D CNN架构，如图所示：\n\n\n\n文中的3D CNN架构包含一个硬连线hardwired层、3个卷积层、2个下采样层和一个全连接层。每个3D卷积核卷积的立方体是连续7帧，没帧patch大小是60x40；\n在第一层，我们应用了一个固定的hardwired的核去对原始的帧进行处理，产生多个通道的信息，然后对多个通道分别处理。最后再将所有通道的信息组合起来得到最终的特征描述。这个hardwired层实际上是编码了我们对特征的先验知识，这比随机初始化性能要好。\n每帧提取五个通道的信息，分别是：灰度、x和y方向的梯度，x和y方向的光流。其中，前面三个都可以每帧都计算。然后水平和垂直方向的光流场需要两个连续帧才确定。所以是7x3 + (7-1)x2=33个特征maps。\n\n\n\n然后我们用一个7x7x3的3D卷积核（7x7在空间，3是时间维）在五个通道的每一个通道分别进行卷积。为了增加feature map个数（实际上就是提取不同的特征），我们在每一个位置都采用两个不同的卷积核，这样在C2层的两个特征maps组中，每组都包含23个特征maps。23=(7-3+1)x3+(6-3+1)x2，前面那个是：七个连续帧，其灰度、x和y方向的梯度这三个通道都分别有7帧，然后水平和垂直方向的光流场都只有6帧。54x34是(60-7+1)x(40-7+1)。\n\n在紧接着的下采样层S3层max pooling，我们在C2层的特征maps中用2x2窗口进行下采样，这样就会得到相同数目但是空间分辨率降低的特征maps。下采样后，就是27x17=(54/2)*(34/2)。\n\nC4是在5个通道中分别采用7x6x3的3D卷积核。为了增加特征maps个数，我们在每个位置都采用3个不同的卷积核，这样就可以得到6组不同的特征maps，每组有13个特征maps。13=((7-3+1)-3+1)x3+((6-3+1)-3+1)x2，前面那个是：七个连续帧，其灰度、x和y方向的梯度这三个通道都分别有7帧，然后水平和垂直方向的光流场都只有6帧。21x12是(27-7+1)x(17-6+1)。\n\nS5层用的是3x3的下采样窗口，所以得到7x4。所以本文中，空间维度上卷积后的尺寸变化可以通过下图很直观的表现出来：\n\n\n\n\n到这个阶段，时间维上帧的个数已经很小了，在这一层，我们只在空间维度上面卷积，这时候我们使用的核是7x4，然后输出的特征maps就被减小到1x1的大小。而C6层就包含有128个feature map，每个特征map与S5层中所有78（13x6）个特征maps全连接，这样每个特征map就是1x1，也就是一个值了，而这个就是最终的特征向量了，共128维。\n经过多层的卷积和下采样后，每连续7帧的输入图像都被转化为一个128维的特征向量，这个特征向量捕捉了输入帧的运动信息。输出层的节点数与行为的类型数目一致，而且每个节点与C6中这128个节点是全连接的。如下图：\n\n\n\n在这里，我们采用一个线性分类器来对这128维的特征向量进行分类，实现行为识别。\n\n模型中所有可训练的参数都是随机初始化的，然后通过在线BP算法进行训练。\n\n\nModel Regularization（模型规范化）\n3D CNN模型的输入被限制为一个少的连续视频帧（论文中取的是7帧），因为随着输入窗口大小的增加，模型需要训练的参数也会增加。但是呢，很多人的行为是跨越很多帧的。\n因此，在3D CNN模型中，有必要捕捉这种高层的运动信息。为了达到这个目的，我们用大量的帧来计算运动特征，然后把这些运动特征作为辅助输出去规则化3D CNN模型。\n对于每一个需要训练的行为，我们提取其长时间的行为信息，作为其高级行为特征。这个运动信息因为时间够长，所以要比CNN的输入帧的立方体包含的信息要丰富很多。然后我们就迫使CNN学习一个非常接近这个特征的特征向量。这可以通过在CNN的最后一个隐层再连接一系列的辅助输出节点，然后训练过程中，使提取的特征更好的逼近这个计算好的高层的行为运动特征向量。如下图所示：\n\n\n\n高级行为辅助特征的提取过程是先在原始的灰度图像上计算稠密sift描述子，然后通过这些sift描述子和运动边缘历史图像（MEHI）组合构造bag-of-words特征作为高级行为辅助特征（我也还不太懂bag-of-words特征，可以自己查一下）。如下图：\n\n\n\n因为灰度图保留了外观信息，运动边缘历史图像（MEHI）只关心形状和运动模式，所以可以提取这两个互补的信息作为两个连续帧的局部特征bag。MEHI 的计算见上图右，先简单的计算两帧间的差分，这样就可以保留运动信息，然后对其执行一次Canny边缘检测，这样可以使得观测图像更加清楚简洁。最终的运动边缘图像就是将历史的这些图像乘以一个遗忘因子再累加起来得到。具体的构造需要参考更多的论文了。\n\nModel Combination(模型组合)\n不同的3D CNN模型在不同的应用环境下性能不一样，一种自适应的方法就是构造多个不同模型，然后对一个特定的输入，每个模型都做出预测，然后组合这些模型的预测得到最后的决策。\n本文中，我们构造多个不同的3D CNN模型，因此它可以从输入捕捉潜在的互补信息，然后在预测阶段，每个模型都针对一个输入得到对应的输出，然后再组合这些输出得到最终的结果。\n\nModel Implementation(模型实现)\n在本实验中，所有的子采样层都是最大子采样，用于训练规范化模型的整体代价函数是有真实的行为类的误差和高层特征的辅助输入代价项的线性加权得到，，权值分别是1和0.005，模型的所有参数都是随机初始化，然后通过diagonal Levenberg-Marquardt方法来优化训练。\n\n疑问\n在3D CNN网络架构中，S5层13*2@7x4经过7x4的卷积核卷积之后为什么会出处128个feature map，有了解的同行可以给我解答一下，谢谢啦！\n\n参考\n论文原文：3D Convolutional Neural Networks for Human Action Recognition\nCSDN-zouxy09：基于3D卷积神经网络的人体行为理解\nCSDN-karen17：深度学习文章阅读2–3D Convolutional Neural Networks for Human Action Recognition\n\n","categories":["图像处理与机器学习"],"tags":["机器学习","深度学习","CNN"]},{"title":"论文笔记：图像数据增强之弹性形变（Elastic Distortions）","url":"https://tanqingbo.cn/Data-enhancement-elastic-deformation/","content":"前言\n我们都知道，深度学习的成功的原因主要有两点：\n\n当前计算机的计算能力有很大提升；\n随着大数据时代的到来，当前的训练样本数目有很大的提升。\n\n\n然而深度学习的一大问题是，有的问题并没有大量的训练数据，而由于深度神经网络具有非常强的学习能力，如果没有大量的训练数据，会造成过拟合，训练出的模型难以应用。因此对于一些没有足够样本数量的问题，可以通过已有的样本，对其进行变化，人工增加训练样本。\n\n对于图像而言，常用的增加训练样本的方法主要有对图像进行旋转、移位等仿射变换，也可以使用镜像变换等等，这里介绍一种常用于字符样本上的变换方法，**弹性变换算法(Elastic Distortion)**。\n\n该算法最先是由Patrice等人在2003年的ICDAR上发表的《Best Practices for Convolutional Neural Networks Applied to Visual Document Analysis》。本文主要是对论文中提出的弹性形变数据增强方法进行解读。\n\n\n插播一下双线性插值的定义\n双线性插值，顾名思义就是两个方向的线性插值加起来（这解释过于简单粗暴，哈哈）。所以只要了解什么是线性插值，分别在x轴和y轴都做一遍，就是双线性插值了。\n线性插值：两个点A，B，要在AB中间插入一个点C（点C坐标在AB连线上），就直接让C的值落在AB的值的连线上就可以了。如A点坐标(0,0),值为3，B点坐标(0,2)，值为5，那要对坐标为(0,1)的点C进行插值，就让C落在AB线上，值为4就可以了。\n但是如果C不在AB的线上肿么办捏，所以就有了双线性插值。如下图，已知Q12，Q22，Q11，Q21，但是要插值的点为P点，这就要用双线性插值了，首先在x轴方向上，对R1和R2两个点进行插值，这个很简单，然后根据R1和R2对P点进行插值，这就是所谓的双线性插值。\n\n\n1、仿射变换\n仿射变换是最常用的空间坐标变换的方法之一，具体定义可参考冈萨雷斯的《数字图像处理第三版》50页。论文中是如下解释仿射变换的：\n将仿射变换应用于图像，新像素的位置是由原始位置确定的，Δx(x,y)=1，Δy(x,y)=0代表向右移一个单位，Δx(x,y)= αx, Δy(x,y)= αy代表像素点由原点位置进行缩放。\n上面说明了如何计算变换之后每个像素点的坐标，下图说明了如何应用位移字段来计算每个像素的新值（其实就是双线性插值的方法）：\n\n\n\n假设A是原点(0,0),而数字3,7,5,9是图像要转换的灰度等级，坐标分别为(1,0),(2,0),(1,-1),(1,-2),A的位移由Δx(0,0) = 1.75 and Δy(0,0) = -0.5给出，如箭头所示。通过评估原始图像的位置（1.75，-0.5）处的灰度级来计算新（扭曲）图像中的A的新灰度值。用于评估灰度级的简单算法是原始图像的像素值进行“线性插值”。尽管可以使用其他插值方案（例如，双三次和B样条插值），但双线性插值是最简单的插值方法之一，并且适用于以所选分辨率（29×29）生成附加的扭曲字符图像。\n先水平插值，然后垂直插值，完成评估。箭头结束的位置在3,5,7,9的方格内，这样我们先计算箭头相对于它结束的方格的坐标。在这种情况下，它相对于正方形方格中的坐标是（0.75,0.5），假设该正方形的原点是左下角（也就是灰度值为5的点）。在此示例中，水平插值为：3 +0.75×(7-3)= 6;垂直插值为：8 +0.5×(6-8)= 7，因此A的新像素值为7.\n对所有像素都进行了类似的计算。在给定图像之外的所有像素位置都假定有一个灰度值。\n\n2、弹性形变\n仿射变换改善了在MNIST数据集上的实验结果，但是实验在弹性形变后的数据集上取得了最好的结果。那么什么是弹性形变呢？\n首先创建随机位移场来使图像变形，即Δx(x,y) = rand(-1,+1)、Δy(x,y)=rand(-1,+1),其中rand(-1,+1)是生成一个在(-1,1)之间均匀分布的随机数，然后用标准差为σ的高斯函数对Δx和Δy进行卷积，如果σ值很大，则结果值很小，因为随机值平均为0.如果我们将位移场标准化（达到1的范数），则该字段接近常数，具有随机方向。\n如果σ很小，则归一化后该字段看起来像一个完全随机的字段（如图2右上角所示）。\n对于中间σ值，位移场看起来像弹性变形，其中σ是弹性系数。然后将位移场乘以控制变形强度的比例因子α。 在我们的MNIST实验（29x29输入图像）中，产生最佳结果的值是σ = 4和α= 34。\n将经过高斯卷积的位移场乘以控制变形强度的比例因子α，得到一个弹性形变的位移场，最后将这个位移场作用在仿射变换之后的图像上，得到最终弹性形变增强的数据。作用的过程相当于在仿射图像上插值的过程，最后返回插值之后的结果。\n关于高斯卷积的原理可以参考这篇文章：高斯卷积滤波\n如果文章看完文章，还是不太懂弹性形变数据增强的原理的话，可以结合代码一起看，下面是参考代码，我都有注释。\n\n3、参考代码# -*- coding:utf-8 -*-\"\"\"@author:TanQingBo@file:elastic_transform.py@time:2018/10/1221:56\"\"\"# Import stuffimport osimport numpy as npimport pandas as pdimport cv2from scipy.ndimage.interpolation import map_coordinatesfrom scipy.ndimage.filters import gaussian_filterimport matplotlib.pyplot as plt\t\t# Function to distort image  alpha = im_merge.shape[1]*2、sigma=im_merge.shape[1]*0.08、alpha_affine=sigmadef elastic_transform(image, alpha, sigma, alpha_affine, random_state=None):    \"\"\"Elastic deformation of images as described in [Simard2003]_ (with modifications).    .. [Simard2003] Simard, Steinkraus and Platt, \"Best Practices for         Convolutional Neural Networks applied to Visual Document Analysis\", in         Proc. of the International Conference on Document Analysis and         Recognition, 2003.\t\t\t\t     Based on https://gist.github.com/erniejunior/601cdf56d2b424757de5    \"\"\"    if random_state is None:        random_state = np.random.RandomState(None)    shape = image.shape    shape_size = shape[:2]   #(512,512)表示图像的尺寸\t\t\t\t    # Random affine    center_square = np.float32(shape_size) // 2    square_size = min(shape_size) // 3    # pts1为变换前的坐标，pts2为变换后的坐标，范围为什么是center_square+-square_size？    # 其中center_square是图像的中心，square_size=512//3=170    pts1 = np.float32([center_square + square_size, [center_square[0] + square_size, center_square[1] - square_size],                       center_square - square_size])    pts2 = pts1 + random_state.uniform(-alpha_affine, alpha_affine, size=pts1.shape).astype(np.float32)    # Mat getAffineTransform(InputArray src, InputArray dst)  src表示输入的三个点，dst表示输出的三个点，获取变换矩阵M    M = cv2.getAffineTransform(pts1, pts2)  #获取变换矩阵    #默认使用 双线性插值，    image = cv2.warpAffine(image, M, shape_size[::-1], borderMode=cv2.BORDER_REFLECT_101)    # # random_state.rand(*shape) 会产生一个和 shape 一样打的服从[0,1]均匀分布的矩阵    # * 2 - 1 是为了将分布平移到 [-1, 1] 的区间    # 对random_state.rand(*shape)做高斯卷积，没有对图像做高斯卷积，为什么？因为论文上这样操作的    # 高斯卷积原理可参考：https://blog.csdn.net/sunmc1204953974/article/details/50634652    # 实际上 dx 和 dy 就是在计算论文中弹性变换的那三步：产生一个随机的位移，将卷积核作用在上面，用 alpha 决定尺度的大小    dx = gaussian_filter((random_state.rand(*shape) * 2 - 1), sigma) * alpha    dy = gaussian_filter((random_state.rand(*shape) * 2 - 1), sigma) * alpha    dz = np.zeros_like(dx)  #构造一个尺寸与dx相同的O矩阵\t\t\t\t    # np.meshgrid 生成网格点坐标矩阵，并在生成的网格点坐标矩阵上加上刚刚的到的dx dy    x, y, z = np.meshgrid(np.arange(shape[1]), np.arange(shape[0]), np.arange(shape[2]))  #网格采样点函数    indices = np.reshape(y + dy, (-1, 1)), np.reshape(x + dx, (-1, 1)), np.reshape(z, (-1, 1))    # indices = np.reshape(y+dy, (-1, 1)), np.reshape(x+dx, (-1, 1)), np.reshape(z, (-1, 1))\t\t\t\t    return map_coordinates(image, indices, order=1, mode='reflect').reshape(shape)\t\t\t\t# Define function to draw a griddef draw_grid(im, grid_size):    # Draw grid lines    for i in range(0, im.shape[1], grid_size):        cv2.line(im, (i, 0), (i, im.shape[0]), color=(255,))    for j in range(0, im.shape[0], grid_size):        cv2.line(im, (0, j), (im.shape[1], j), color=(255,))\t\t\t\tif __name__ == '__main__':    img_path = 'E:/liverdata/nii/png/img'    mask_path = 'E:/liverdata/nii/png/label'    # img_path =  '/home/changzhang/ liubo_workspace/tmp_for_test/img'    # mask_path = '/home/changzhang/liubo_workspace/tmp_for_test/mask'\t\t\t\t    img_list = sorted(os.listdir(img_path))    mask_list = sorted(os.listdir(mask_path))    print(img_list)\t\t\t\t    img_num = len(img_list)    mask_num = len(mask_list)\t\t\t\t    assert img_num == mask_num, 'img nuimber is not equal to mask num.'\t\t\t\t    count_total = 0    for i in range(img_num):        print(os.path.join(img_path, img_list[i]))   #将路径和文件名合成一个整体        im = cv2.imread(os.path.join(img_path, img_list[i]), -1)        im_mask = cv2.imread(os.path.join(mask_path, mask_list[i]), -1)\t\t\t\t        # # Draw grid lines        # draw_grid(im, 50)        # draw_grid(im_mask, 50)\t\t\t\t        # Merge images into separete channels (shape will be (cols, rols, 2))        im_merge = np.concatenate((im[..., None], im_mask[..., None]), axis=2)\t\t\t\t        # get img and mask shortname        (img_shotname, img_extension) = os.path.splitext(img_list[i])  #将文件名和扩展名分开        (mask_shotname, mask_extension) = os.path.splitext(mask_list[i])\t\t\t\t        # Elastic deformation 10 times        count = 0\t\t\t\t        while count &lt; 10:            # Apply transformation on image  im_merge.shape[1]表示图像中像素点的个数            im_merge_t = elastic_transform(im_merge, im_merge.shape[1] * 2, im_merge.shape[1] * 0.08,                                           im_merge.shape[1] * 0.08)            # Split image and mask            im_t = im_merge_t[..., 0]            im_mask_t = im_merge_t[..., 1]\t\t\t\t            # save the new imgs and masks            cv2.imwrite(os.path.join(img_path, img_shotname + '-' + str(count) + img_extension), im_t)            cv2.imwrite(os.path.join(mask_path, mask_shotname + '-' + str(count) + mask_extension), im_mask_t)\t\t\t\t            count += 1            count_total += 1        if count_total % 100 == 0:            print('Elastic deformation generated {} imgs', format(count_total))            # # Display result            # print 'Display result'            # plt.figure(figsize = (16,14))            # plt.imshow(np.c_[np.r_[im, im_mask], np.r_[im_t, im_mask_t]], cmap='gray')            # plt.show()\n\n\n关于map_coordinates函数原理的参考文章：Python/Scipy插值（map_coordinates）\n\n参考\n论文原文：Best Practices for Convolutional Neural Networks Applied to Visual Document Analysis\nMingChaoSun-CSDN：高斯卷积滤波\nPython/Scipy插值（map_coordinates）\n\n","categories":["图像处理与机器学习"],"tags":["机器学习","深度学习","弹性形变","图像数据"]},{"title":"论文笔记：Unet用于医学图像分割的卷积网络(UNet Convolutional Networks for Biomedical Image Segmentation)","url":"https://tanqingbo.cn/UNet-Convolutional-Networks-for-Biomedical-Image-Segmentation/","content":"摘要\n本文中提出了一种网络结构的训练策略，它依赖于充分利用数据增强技术来更高效的使用带有标签的数据。在U-Net结构中，包括一个捕获上下文信息的收缩路径和一个允许精确定位的对称拓展路径。这种方法可以使用非常少的数据完成端到端的训练，并获得最好的效果。\n\n介绍\n卷积网络的典型用途是分类任务，其中图像的输出是单个类别标签。 然而，在许多视觉任务中，尤其是在生物医学图像处理中，期望的输出应该包括定位，即，应该将类标签分配给每个像素。（也就是分割）\n\nCiresan等人用滑动窗口取像素像素周围的局部区域俩训练网络，训练数据远远大于训练图像的数量。 \n\n本文提出一种新的完全卷积网络，即U-Net网，主要思想是在收缩网络的后面补充一个与前面类似的网络，其中池化运算符由上采样运算符替换。因此，这些层增加了输出的分辨率。为了定位，从收缩路径的高分辨率特征与上采样输出相结合。然后，连续卷积层可以学习基于该信息组装更精确的输出。\n\n作者提出U-Net的本意是将其用于医学图像分割，在以往的CNN中，想将其用于医学图像存在两个困难：\n\n通常CNN都是应用于分类，生物医学图像更关注的是分割以及定位的任务；\nCNN需要获取大量的训练数据，而医学图像很难获得那么大规模的数据。\n\n\n以往解决上面两点困难的方法是使用滑窗的方法，为每一个待分类的像素点取周围的一部分邻域输入。这样的方法有两点好处，首先它完成了定位的工作，其次因为每次取一个像素点周围的邻域，所以大大增加了训练数据的数量。但是这样的方法也有两个缺点，首先通过滑窗所取的块之间具有较大的重叠，所以会导致速度变慢；其次是网络需要在局部准确性和获取上下文之间进行取舍。因为更大的块需要更多的池化层进而降低了定位的准确率，而小的块使网络只看到很小的一部分上下文。\n\n\nU-Net\n在本文中，作者修改并扩展了FCN网络结构，使它在使用少量的数据进行训练的情况下获得精确的分割结果，具体结构示意图如下所示：\n\n\n\n在上图中，每一个蓝色块表示一个多通道特征图，特征图的通道数标记在顶部，X-Y尺寸设置在块的左下边缘。不同颜色的箭头代表不同的操作。图的左半部分是收缩路径，右半部分是扩展路径。\n其中需要注意的是，每经过一次上采样都会将通道数减半，再与收缩路径对应的特征图进行拼接。在拼接之前进行 crop 是必要的(例如在上图中，6464大与5656，为了使这两个特征图能够顺利拼接，取6464中间部分5454的大小，然后拼接)，因为两者的尺寸并不相同（主要是因为 valid conv 造成的）。最后一层使用1 X 1大小的卷积核，将通道数降低至特定的数量（如像素点的类别数量）。\n网络对于输入的大小也是有要求的。为了使得输出的分割图无缝拼接，重要的是选择输入块的大小，以便所有的2 X 2的池化层都可以应用于偶数的 x 层和 y 层。一个比较好的方法是从最下的分辨率从反向推到，比如说在网络结构中，最小的是32 X 32，沿着收缩路径的反向进行推导可知，输入图像的尺寸应该为572×572。 \n\nFCN与U-net的区别\nFCN的主要思想是使用连续的层补充通常的收缩网络，在判别输出的位置添加上采样层，这些层增加了输出层的分别率，为了定位。来自于收缩路径的高分别率与上采样输出相结合，基于这个信息，一个连续的卷积层可以学习组装更精确的输出。（关于FCN详细内容可以参考我的上一篇文章：论文笔记：用于语义分割的全卷积网络 （fully convolutional networks for semantic segmentation））\n而U-net与FCN的不同在于，U-net的上采样依然有大量的通道，这使得网络将上下文信息向更高层分辨率传播，作为结果，扩展路径与收缩路径对称，形成一个U型的形状（如上图所示）。 网络没有全连接层并且只是用每一个卷积层的有效部分。\n\nOverlap-tile\n作者在文中介绍了一种Overlap-tile策略，使得任意大小的输入图像都可以获得一个无缝分割，因为输出的分割图它包含的像素点，它们的周围像素点（上下文）都出现在了输入图像中，因此使用Overlap-tile策略对数据进行预处理是有必要的。\nOverlap-tile策略的过程具体如下所示：\n\n\n\n上图是针对任意大小的输入图像的无缝分割的 Overlap-tile 策略。如果我们要预测黄色框内区域（即对黄色的内的细胞进行分割，获取它们的边缘），需要将蓝色框内部分作为输入，如果换色区域在输入图像的边缘的话，那么缺失的数据使用镜像进行补充。如上图左边图像所示，输入图像周围一圈都进行了镜像补充。\n\n因为进行的是valid卷积，即上下文只取有效部分，可以理解为padding为0，卷积之后的图像尺寸会改变，所以需要取比黄色框大的图像来保证上下文的信息是有意义的，缺失的部分用镜像的方法补充是填充上下文信息最好的方法了。这种方法通常需要将图像进行分块的时候才使用。\n\n那么为什么要对图像分块，不输入整张图像呢？因为内存限制，有的机器内存比较小，需要分块输入。但比之前的滑窗取块要好很多，一方面不用取那么多块，另一方面块之间也没有那么大的区域重叠。通过Overlap-tile 策略可以将图像分块输入，否则的话就只能对图像进行 resize 了，但是这样会降低输入图像的分辨率。\n\n此外，如果数据不够的话可以应用弹性形变，对数据进行增强，增加数据量，这允许网络可以学习到这种形变的不变形，并且并不要求带有原始预料库进行到这样的变化（指弹性形变）。\n\n\n细胞分割\n进行细胞的分割，另一种挑战是同一类物体的分类，如下图所示：\n\n\n\n上图是用DIC（二次干涉对比）显微技术记录的玻璃上的 HeLa 细胞。其中图 (a) 是原始图像；图 (b) 是基于 gt 的分割覆盖。其中不同的颜色表示不同的 HeLa 细胞示例。图 (c) 是生成的分割掩膜，其中白色部分是前景，黑色部分是后景；图 (d) 是像素级损失权重图，使得网络强制学习边缘像素。\n 为了解决这个问题，作者使用加权损失，对于位与细胞接触部分的像素加大权重，如图 (d) 中的红色的部分。\n\nTraining（训练）\n作者使用caffe框架，并采用带动量的SGD方法，其中动量的值设为 momentum=0.99。动量设这么大的原因是这样可以使用大量先前看到的训练样本确定当前最优步骤的更新(因为动量的原理就是用先前很多步的状态确定下一步的方向)。相比于大的batchsize，作者喜欢大的input tiles（指的是over-tile）中的那种图像块，因此我们可以将一个batch缩小为一个单张图片的输入。\n能量函数通过结合交叉熵损失函数的最后特征图上的像素级 soft-max 值来计算，通常多分类问题用soft-max函数作为输出，二分类问题用sigmoid函数作为输出，其中 soft-max 的计算方法如下：\n\n\n\n其中 αk(x)代表在位置 x 处的像素在特征图中的第 k 层的激活值，其中 x∈Ω，，Ω⊂Z^2 ，即 x 属于空间 Ω，而空间 Ω是整数集合Z^2的子集。K 是像素点的类别总数，p_k(x)是近似最大函数。这里面的定义和我们平时使用的 sift-max 是一样的。损失函数是交叉熵损失函数，或者也可以成为 log-likelihood，具体如下所示\n\n\n\n其中需要注意的是这里使用的是加权的损失函数，对于每一个像素点有着自己的权重，这点可以在上面的细胞图中看到。\n\n我们通过预先计算权重图来获得每一个像素在损失函数中的权值，这种方法补偿了训练数据每类像素的不同频率，并且使网络更注重学习相互接触的细胞的边缘。\n\n分割边界使用形态学运算，特征图的计算方法如下：\n\n\n\n\n其中的 w_c是用于平衡类别频率的权重图，d_1是该像素点到最近的细胞边界的距离；d_2是该像素点到第二近的细胞边界的距离。在我们的实验中，将 w0设置为10，将σs设置为大约 5 个像素。\n权值的初始化对于模型的正确训练起着很大的作用，一个好的初始化应该保证网络中的每一个特征图有近似的单位方差。在这里使用服从标准差为√2/N      的高斯分布来进行初始化（实际上就是 He normal），其中的 N 代表着一个神经元的传入节点的数目，比如说某一个卷积层，他的卷积核的大小为 3×3，通道数是 64，那么 N=9×64=576。Data Augmentation（数据增强/扩充）\n当只有少量训练样本的时候，对于让网络学习到所需的不变形和鲁棒性来说，数据增强是必要的。\n显微镜图像一般需要旋转平移不变性，弹性形变和灰度值变化鲁棒性。训练样本的随机性变形似乎是训练之后少量标注图像的分割网络的关键。\n此外在本文中，早收缩路径的最后加入了Drop-out，隐式的加强了数据增强。\n\n总结\n本文提出了很多数据预处理的技巧，有较强的实用性。\n\n本文的创新点\n提出了U-net这种网络结构。它同时具备捕捉上下文信息的收缩路径和允许精确定位的对称扩展路径，并且与FCN相比，U-net的上采样过程依然有大量的通道，这使得网络将上下文信息向更高层分辨率传播。\nOverlap-tile 策略，这种方法用于补全输入图像的上下信息，可以解决由于现存不足造成的图像输入的问题。\n使用随机弹性变形进行数据增强。\n使用加权损失。预先计算权重图，一方面补偿了训练数据每类像素的不同频率，另一方面是网络更注重学习相互接触的细胞间边缘。\n\n但是上面的这些创新点并不适合所有任务，比如说对刚体进行分割，那么久很难通过弹性变形对数据进行增强。\n本文学到的一些实用的技巧\n因为使用了 valid conv ，所以采用 Overlap - tile 策略补充图像，其中空白的部分用镜像的方法进行补充；\n因为有池化层，因此要保证输入的图像在经过每一次池化的时候都要是边长偶数。这点与一般的卷积神经网络不同，因为一般的网络会使用 padding ，这样会保证卷积前后的大小不变，但是 valid conv 会使卷积后的尺寸变小，所以要特别注意输入图像的尺寸。一个比较好的方法是从最小分辨率出发沿收缩路径的反方向进行计算，得到输入图像的尺寸。\n预先计算权重图，以此计算后面的加权损失函数；\n加权损失的权重中有一部分是经验值，因此对于不同的任务可以进行调整（只是理论上可以进行调整，并没有试验过）；\n使用标准差为√2/N的高斯分布来进行权值初始化，其中需要注意的是，对于不同的卷积层，N 的大小也是不同的。\n在收缩路径的最后部加入了 dropout ，隐式地加强了数据增强。\n\n一些疑惑\n为什么加入 dropout 后可以对数据进行增强？\n反卷积（上采样）的具体过程是怎么样的？\n弹性形变数据增强具体是如何对数据增强的？\n\n参考\n论文原文：U-Net: Convolutional Networks for Biomedical Image Segmentation\nCSDN-独孤呆博：论文精读及分析：U-Net: Convolutional Networks for Biomedical Image Segmentation\n\n","categories":["图像处理与机器学习"],"tags":["机器学习","深度学习","Unet"]},{"title":"论文笔记：用于语义分割的全卷积网络 （fully convolutional networks for semantic segmentation）","url":"https://tanqingbo.cn/fully-convolutional-networks-for-semantic-segmentation/","content":"介绍\n通常CNN网络在卷积层之后会接上若干个全连接层，将卷积层产生的特征图（feature map）映射成一个固定长度的特征向量，以AlexNet为代表的经典CNN结构适合图像级的分类和回归任务，因为最后得到整幅图像的的数值描述，比如AlexNet的ImageNet模型输出一个1000维的向量表示输入图像属于每一类的概率(softmax归一化)。\n例子：AlexNet网中输入是下图中猫的图片，输出的结果是一个向量，表示输入图像属于每一类的概率，其中“tabby cat”这一统计概率最高。\n\n\n\n而在本文中建立了一种可以接受任意大小图像，并输出与输入等大小的图像的全卷积神经网络，在文章中作者定义了全卷积神经网络（FCN）的空间结构，解释了FCN在空间密集型预测任务上的应用并且给出了他与之前其他网络之间的联系，之后通过迁移学习的方法进行微调（finetune），以此来完成所需要的分割任务。此外作者还定义了跳跃结构，通过结合来自于深的、粗糙层的语义信息和来自浅、细层的表征信息来产生准确和精细的分割。\n\n相关工作\n卷积网络在识别领域前进势头很猛，卷积网不仅在全图式的分类上有所提高，在结构化输出的局部任务上也取得了进步。包括检测目标边框、关键点预测和局部通信的进步。\n\n在以往的分割方法中，主要有两大类缺点：\n\n基于图像块分割的效率低，往往需要前期或后期处理；\n语义分割面临在语义和位置的内在张力问题：全局信息解决的是什么。局部信息解决的是在哪里。\n\n\n为了解决上面这两个问题，本文主要有三个创新点：\n\n将分类网络结果重新解释为全卷积神经网络结构，这里面具体包括两点，一个是全连接层转化为卷积层，还有就是通过反卷积进行上采样。\n使用迁移学习的方法进行 finetune ，因为很明显通过第一点可知可以将 VGG 这类有预训练权重的分类网络重新解释为 FCN\n使用跳跃结构使得，使得深的粗的语义信息可以结合浅的细的表征信息，产生准确和精细的分割。\n\n\n以往的方法主要有以下的缺点：\n\n限制容量和感受野的小模型；\n分块训练；\n超像素投影的预处理，随机场正则化、滤波或局部分类；\n对于密集输出采用输入移位和输出交错的方法；\n多尺度金字塔处理；\n饱和双曲线正切非线性；\n集成\n\n\n基于 FCN 的方法没有以上缺点。\n传统的基于CNN的分割方法：为了对一个像素分类，使用该像素周围的一个图像块作为CNN的输入用于训练和预测。这种方法有几个缺点：一是存储开销很大。例如对每个像素使用的图像块的大小为15x15，然后不断滑动窗口，每次滑动的窗口给CNN进行判别分类，因此则所需的存储空间根据滑动窗口的次数和大小急剧上升。二是计算效率低下。相邻的像素块基本上是重复的，针对每个像素块逐个计算卷积，这种计算也有很大程度上的重复。三是像素块大小的限制了感知区域的大小。通常像素块的大小比整幅图像的大小小很多，只能提取一些局部的特征，从而导致分类的性能受到限制。\n\n\n\n全连接网络（fully convolutional networks，FCN）\n好了，本文的重点终于要出来了。前面说通常CNN在接收图片输入时，输出是一个向量，代表图像属于哪一类的概率，而在FCN可以接受任意尺寸的输入图像，采用反卷积层对最后一个卷积层的feature map进行上采样, 使它恢复到输入图像相同的尺寸，从而可以对每个像素都产生了一个预测, 同时保留了原始输入图像中的空间信息, 最后在上采样的特征图上进行逐像素分类。如下图：\n\n\n\n可以看到在最后得输出层的通道数为21，但这不是最后得分割结果，取21个通道中像素值所属类别概率最大的那个值作为每个位置像素的分类结果，即上图中最右边的图。\n\nCombining what and where（结合“是什么”和“在哪里”）\n虽然上述方法取得较好的结果，但是分割结果看起来依旧很粗糙，所以采用跳跃连接结构对分割进行细化，即结合最后预测层和具有更小步长的跨层信息，该方法结合了精细层和粗糙层，让模型能做出遵从全局结构的局部预测。如下图：\n\n\n\n通过一个16像素步长层预测。我们增加了一个1*1的卷积层在pool4的顶部来产生附加的类别预测。我们将输出和预测融合在conv7（fc7的卷积化）的顶部以步长32计算，通过增加一个2×的上采样层和预测求和（见上图）。我们初始化这个2×上采样到双线性插值，但是允许参数能被学习，最后，步长为16的预测被上采样回图像，我们把这种网结构称为FCN-16s。FCN-16s用来学习端到端，能被最后的参数初始化。这种新的、在pool4上生效的参数是初始化为0的，所以这种网结构是以未变性的预测开始的。这种学习速率是以100倍的下降的。\n上面是原文叙述的原话，我没怎么看懂，不过我理解的过程是这样的：第一行的 pool4 画了一个箭头直接指向第二行的 pool4，这不是直接拿过来用，而是在第一行的 pool4 上面增加一个 1x1 的卷积层使其与conv7之后的feature map的通道数相同。之后将 conv7 进行两倍的上采样，这里采用双线性插值的方法（实际上是反卷积），插值的权重是可学习的。然后将第二行的 pool4 与 2x conv7 相加，在进行 16 倍的上采样（反卷积）就可以得到最后的结果。这里 1x1 的卷积初始化为 0，保持其原来的分割结果，注意哦，不是随机初始化，而是初始化为0，然后通过学习更新这个卷积核即 FCN-16s。我理解的，上采样的过程都是使用双线性插值的方法进行初始化的。使用类似的方法可以得到 FCN-8s。\n注：上面的conv7表示经过conv7卷积之后的feature map。\n实验结果如下：\n\n\n\n由实验结果可以发现，FCN-8S的效果最好，当上采样的步长降低到8时，效果已经不是很明显了，即收益递减，可以不用融合更多浅层特征了。\n\n实现细节查看源码的时候，发现首层的pad值为100，为什么要令pad=100呢？\n\n100像素输入填充可确保网络输出可与给定数据集中任何输入大小的输入对齐。\n至于为什么可以，我们可以看下下面的推导过程。假设是一般的VGG16结构,第一个卷积层只pad 1，并且假设输入图片的高度是h，根据我们的卷积公式：\n\n\n\n由于在VGG中缩小输出map只在池化层，所以下面我们忽略卷积层，计算公式如下：\n\n\n\n很明显，feature map的尺寸缩小了32倍，接下来是卷积化的fc6层，如下图：\n\n\n\n注意fc6层中，pad=0,kernel_size=7,所以计算公式与前面6层稍有不同。\n接下来还有两个卷积化的全连接层,fc7以及score_fr，但他们都是1*1的卷积核，对输出的尺寸并不会有影响，所以最终在输入反卷积之前的feature map尺寸就是(h-192)/2^5.\n推导到这里pad 100的作用已经很明显了，如果不进行padding操作，对于长或宽不超过192像素的图片是没法处理的，而当我们pad 100像素之后:\n\n\n\n这样就解决了以上问题，但是毋庸置疑，这会引入很多噪声。同样这样的输出会使得上采样得到的图像与输入图像不等大，所以以计算必要的精确 offset参数 并消除这种填充量。\n\n文章的创新点与不足创新点\n实际上理解好这篇文章，只需要理解好一下三点即可\n将分类网改写为用于分割的像素点分类网。具体的包括两个方面，即将全连接层改写为卷积层，和使用反卷积完成上采样的过程；\n使用跳跃连接的结构，将深的粗糙的信息与浅的精细的信息相结合，产生准确和精细的分割；\n使用微调进行实验。 \n\n\n\n缺点\n在这里我们要注意的是FCN的缺点：   (1) 分割结果不够精细。进行8倍上采样虽然比32倍的效果好了很多，但是上采样的结果还是比较模糊和平滑，对图像中的细节不敏感。   (2) 是对各个像素进行分类，没有充分考虑像素与像素之间的关系。忽略了在通常的基于像素分类的分割方法中使用的空间规整（spatial regularization）步骤，缺乏空间一致性。\n\n参考\n论文原地址：fully convolutional networks for semantic segmentation\nCSDN-独孤呆博：论文精读及分析：Fully Convolutional Networks for Semantic Segmentation\nCSDN-Colie-Li：用于语义分割的全卷积网络 （fully convolutional networks for semantic segmentation）\n博客园-代码初学者：全卷积网络 FCN 详解\n\n","categories":["图像处理与机器学习"],"tags":["机器学习","深度学习","全卷积网络"]},{"title":"关于简历修改的一些问题--如何制作一份让HR满意的简历？","url":"https://tanqingbo.cn/Resume-revision-suggestions/","content":"最近恰逢秋招，身边很多朋友都跟我抱怨说，简历投出去了不少，可是很多都是石沉大海，没有了回音。于是就急的不行，纷纷跑过来请教简历制作大法。\n话说为啥问我这个没找过工作且非人力资源专业的人呢？我啥也不懂啊，于是便向我的某知名外企HR朋友请教。\n她说，你的朋友有时间去了解你，可是HR没有，顶多给你一分钟的展示时间。如果你的简历内容明确，精致表现，能够快速让HR了解到你的特点和优势，那么这份简历就是出色的，赢面也就更大。\n杨澜说过，没有人有义务必须透过连你自己都毫不在意的邋遢外表去发现你优秀的内在，对简历来说也适用。\n所以检验一份好的简历的标准就是看HR是否看了就想约你面试。那么怎样在写简历的时候都有哪些坑需要我们去避开的呢？我的这位HR朋友说，她在看了几千份简历后，很多人的简历都存在以下几个问题：\n问题一：一份简历从头用到尾不同的岗位有不同的岗位需求，因此每投一个岗位、一个公司，简历都要经过修改，我想这应该是常识吧。可是我的朋友听我说这句话的时候，她只回了我两个字：呵呵！\n你看，就是会有这么不走心的同学，所以如果你的简历总是频频被刷，那就赶紧反省一下自己是否偷懒了。毕竟老是被刷，你心里应该有数了。\n问题二：简历过于繁琐由于HR每天需要审阅大量的简历，查看你的个人简历的时候可能只花了很短的时间就决定是否召见你，所以一页纸的简历效果是最好的。朋友说她亲眼看过一份超三页纸的简历在她老大手里没超过2秒就直接next one了。\n一些人在写简历的时候习惯把所有个人资料都罗列上（政治面貌、健康状况、血型、星座、婚姻状况等）。这样不仅使简历啰嗦冗长，一些个人信息还可能成为获得面试机会的障碍，可以说是“偷鸡不成蚀把米”。\n问题三：求职照太过随意都说这是个看脸的世界，HR也不例外。 朋友说她有一次看到有人直接拿用自拍的头像来作为简历照片，也是很勇敢了！！\n所以，敲黑板划重点了，简历上一定要放有职业感的照片，如果没有，那就花几十块钱去照相馆拍一张，那种学校打印店10块钱拍一次的那种证件照还是别拿出来了。\n简历制作的一些小技巧在千篇一律的简历面前，一点小心思有时候说不定就能有大惊喜。朋友她总结了一下之前见到过的心思小技巧，拿来分享给大家！\n不要用表格式模板，看起来千篇一律，显得死板；过多的框框给人一种束缚感。\n也不建议采用密集文字式模板，过多文字使得简历看上去不清晰。\n死得快型选手\n看简历都想录用型选手\n▲用结果强调工作经验\n\n个人工作经历过程很重要，但是结果才是最能体现你个人能力的证明。因此，在描述自己的工作经验时，一定要写上结果来证明你的能力。\n\n▲关键词突出醒目\n\n个人简历的外表一定要醒目，重点可以使用斜体、大写、下划线、首字突出或箭头等标示出来。\n\n▲定位精准\n\nHR一般很忙的，如果不能很快找到想要的信息，你就很可能变成谢谢参与了。因此，每个人都要为自己的简历精准定位，突出重点。\n\n▲字句文法不能出错\n\nHR一般很讨厌个人简历中有错别字，没有之一。所以简历写完之后记得全面检查一遍。\n\n▲简历命名一目了然\n\nHR每天招的职位很多，直接在文件命名的时候就能准确传递重要信息，给HR省不少功夫。很多不省心的求职者，非得让HR打开邮件下载简历才能看到你的基本信息。如没有特殊要求，简历文件命名一般是姓名+投递职位+地区，这样HR对你的印象分就不会低。\n\n我一直都觉得，如果一个人琢磨的话，不知道要撞多少回南墙，也不一定能找的到出路，但如果有一个人能带你一下，说不定能起到打通任督二脉的效果，帮你瞬间缩短探索的时间和试错的成本。\n希望以上内容对你有用！\n","categories":["技术以外"],"tags":["简历","求职"]},{"title":"基于pandas的数据预处理总结","url":"https://tanqingbo.cn/pandas-data-preprocessing/","content":"\n参加kaggle数据挖掘比赛，就第一个赛题Titanic的数据，学习相关数据预处理以及模型建立，本博客关注基于pandas进行数据预处理过程。包括数据统计、数据离散化、数据关联性分析。引入包和加载数据\n\nimport pandas as pdimport numpy as nptrain_df =pd.read_csv('../datas/train.csv')  # train settest_df  = pd.read_csv('../datas/test.csv')   # test  setcombine  = [train_df, test_df]\n\n\n函数的含义print(train_df.columns.values)  # 查看表格数据中的属性名字\n\n\n\n输出：\n\n['PassengerId' 'Survived' 'Pclass' 'Name' 'Sex' 'Age' 'SibSp' 'Parch' 'Ticket' 'Fare' 'Cabin' 'Embarked']#查看object属性数据统计情况print train_df.describe(include=['O'])  \n\n\n\n统计Title单列各个元素对应的个数\n\nprint train_df['Title'].value_counts() \n\n\n\n属性列删除\n\ntrain_df = train_df.drop(['Name', 'PassengerId'], axis=1)  \n\n\n\n缺省值处理\n直接丢弃缺失数据列的行\n\nprint df4.dropna(axis=0,subset=['col1'])  # 丢弃nan的行,subset指定查看哪几列 print df4.dropna(axis=1)  # 丢弃nan的列\n\n\n\n采用其他值填充\n\ndataset['Cabin'] = dataset['Cabin'].fillna('U') dataset['Title'] = dataset['Title'].fillna(0) \n\n\n\n采用出现最频繁的值填充\n\nfreq_port = train_df.Embarked.dropna().mode()[0]dataset['Embarked'] = dataset['Embarked'].fillna(freq_port)\n\n\n\n采用中位数或者平均数填充\n\ntest_df['Fare'].fillna(test_df['Fare'].dropna().median(), inplace=True)test_df['Fare'].fillna(test_df['Fare'].dropna().mean(), inplace=True)\n\n\n\n数值属性离散化，object属性数值化\n创造一个新列，AgeBand，将连续属性Age切分成5份\n\ntrain_df['AgeBand'] = pd.cut(train_df['Age'], 5)print(train_df[['AgeBand', 'Survived']].groupby(['AgeBand'], as_index=False).mean().sort_values(by='AgeBand',ascending=True))\n\n\n\n输出：\n   AgeBand  Survived\t0  (-0.08, 16.0]  0.550000\t1   (16.0, 32.0]  0.337374\t2   (32.0, 48.0]  0.412037\t3   (48.0, 64.0]  0.434783\t4   (64.0, 80.0]  0.090909\n\n\n\n\n\n\n其它代码：\n\n查看切分后的属性与target属性Survive的关系\ntrain_df[['FareBand', 'Survived']].groupby(['FareBand'], as_index=False).mean().sort_values(by='FareBand', ascending=True)\n\n\n建立object属性映射字典title_mapping = {\"Mr\": 1, \"Miss\": 2, \"Mrs\": 3, \"Master\": 4, \"Royalty\":5, \"Officer\": 6}dataset['Title'] = dataset['Title'].map(title_mapping)\n\n\n\n\nDataFrame()函数功能\n\nmodels = pd.DataFrame({\t'Model': ['Support Vector Machines', 'KNN', 'Logistic Regression',\t\t\t  'Random Forest', 'Naive Bayes', 'Perceptron',\t\t\t  'Stochastic Gradient Decent', 'Linear SVC',\t\t\t  'Decision Tree'],\t'Score': [acc_svc, acc_knn, acc_log,\t\t\t  acc_random_forest, acc_gaussian, acc_perceptron,\t\t\t  acc_sgd, acc_linear_svc, acc_decision_tree]})print(models.sort_values(by='Score', ascending=False))\n\n\n\n\n输出：\n   Model  Score3               Random Forest  86.648               Decision Tree  86.641                         KNN  84.060     Support Vector Machines  83.502         Logistic Regression  81.267                  Linear SVC  79.465                  Perceptron  78.794                 Naive Bayes  76.886  Stochastic Gradient Decent  76.77\n\n\n\n\n","categories":["图像处理与机器学习"],"tags":["机器学习","深度学习","pandas"]},{"title":"新年首发！！！实用资源","url":"https://tanqingbo.cn/msb-source/","content":"新的一年给大家送上新年第一份资料\n所有资料都是精心整理过的，非常实用！\n这份资料包括：\n1 、100 多套找工作必备简历模板\n\n2、 Adobe CC所有软件安装包＋ office 软件与教程\n\n3 、毕业论文从开题到答辩的全攻略\n\n4 、100 多本计算机专业必读经典书籍\n\n扫描下方二维码，加微信，备注「礼包」即可免费领取上述所有资料，手慢无！\n\n👆长按上方二维码 2 秒礼包「礼包」即可获取资料","categories":["编程资料"],"tags":[]},{"title":"袁世凯和他的北洋","url":"https://tanqingbo.cn/YuanShikai-and-his-Beiyang/","content":"　　或许每个朝代的结束都不是一下子就能彻底终结，就像东汉末年的乱世、明朝末年南京的弘光小朝廷。清朝的终结也是经历了一波三折，在民国的时候经历了袁世凯和张勋的复辟才算彻彻底底的结束。在不了解这段历史之前，我会觉得袁世凯和张勋就是个十恶不赦的大恶人，为了自己个人的利益，几乎中断了中国共和的进程。然而事实真的是这样吗？\n　　今天我就试着来和大家来分享一下这段民国有趣的复辟历史吧！\n袁世凯和他的北洋　　故事应该从袁世凯就任民国大总统说起，为什么孙中山发动革命，最后当上民国总统的人却是袁世凯呢？要解释这个问题首先得解释一下清朝北洋大臣这个官位，因为袁世凯就是当时清朝的北洋大臣。北洋大臣本来是清政府为了讨好洋人而专门设置的官位，顾名思义，北方负责洋人事物的大臣就叫北洋大臣，后来到了清朝末年，清政府为了更好的跪舔洋人，导致北洋大臣的权利越来越大，几乎独掌朝中得军政大权，一人之下，万人之上。袁世凯当时就处在这样得位置上，清朝几乎所有的军权都掌握在他得手上，当时有名的军阀像冯国璋、段祺瑞、吴佩孚、张勋等人都是袁世凯的部下。孙中山所领导的革命军根本不可能是袁世凯的对手，既然打不过那就谈判吧！但是谈判需要有筹码啊，于是在革命军拼死占领南京之后，孙中山就对袁世凯说，咱们谈谈吧！袁世凯也是个明白事理的人，他深知清朝政府确实没有把中国统治好，共和说不定是个更好的选择。于是他便对孙中山说，推翻清政府我是赞同的，但是有个条件，谁让皇帝下台，谁就当民国的大总统。孙中山没办法，一咬牙就答应了，谁让自己实力不如人家呢。\n　　让皇帝下台对于接触权利核心的袁世凯来说简直易如反掌，一回到北京没过多久就把皇帝赶下台了，按照之前的约定袁世凯便顺理成章的做起了民国的大总统，但是孙中山在和袁世凯做权利交接的时候，孙中山做了一个小动作，这也为袁世凯后来的复辟埋下了祸根。之前打下南京的时候，孙中山和南方各省的代表一起为民国制定了一部宪法，名字叫做《中华民国临时政府组织大纲》，当时孙中山对这部宪法还是很满意的，因为里面明确规定总统的权利很大，远大于责任内阁，革命这么多年终于当上了总统，如果权利不大，他当然不愿意了。但是后来把总统让给袁世凯的时候，为了制约袁世凯，他和参议院又重新制定了一部新的宪法《中华民国临时约法》，里面规定虽然总统的权利很大，但是责任内阁的权利也很大，由于《临时约法》制定的比较仓促，并没有明确说明到底谁的权利更大。但是袁世凯好像并不是很在意这些，欣然的接受了这部宪法，既然让我当上了总统，那其他的都好说。\n　　之后中国便走上了轰轰烈烈的共和道路，在袁世凯当政的时期，中国出现了短暂的复兴现象，其实在当时的那个时期，我相信大家心中应该都怀着一种把中国建设的更好的理想，袁世凯也不例外，他也希望中国更好，希望自己能名垂青史。如果事情一直这么顺利的发展下去的话，说不定他真的能带领着中国慢慢走向富强，因为袁世凯他真的是一个特别有能力的人，他是从底层慢慢爬上来的，会带兵打仗、做过外交大臣，懂外交、督建过铁路，懂经济。总的来说，他就是一个全能形人才，了解中国的国情，知道怎么才能让中国这个庞然大物高效的运转起来，不像孙中山那帮人，只懂得喊三民主义，对中国国情，经济建设等一概不知，这个可以参考共产党早期执政时期中国的的经济发展状况。高晓松曾在他的《晓说》里面说，如果当时只有一个人能让中国富强起来的话，那么这个人肯定是袁世凯，可见袁世凯的能力确实非常出众。所以在他最初执政的那几年，确实做了很多利国利民的好事，比如建立警署、督办铁路、发展新军、重视教育，建立了北洋大学等一批不错的学校，使民国最初的那几年中国的GDP增长了不少。而且他还促成中国历史上唯一一次全民选举，但也正是这次选举间接的断送了这大好的形式，选举的结果为国民党当选中国的第一大党，掌管内阁，当时国民党的领导是宋教仁，他觉得责任内阁的权利应该大于总统，一些国家大事应该都由内阁说了算，总统只负责盖章就行了，恰好宪法上也没有明确规定到底谁的权利大，这样一整袁世凯就不乐意了，原来共和是这样玩的啊？我辛辛苦苦推翻清政府，为建设共和出了这么多力，到头来这共和跟我没多大关系了。一开始袁世凯还想跟黄教仁商量着来，但是宋教仁根本不吃这一套，他把袁世凯甩在一边公开在媒体面前发表各种言论，畅谈自己的政治理想和承若颁发各种政策。时间一久袁世凯就彻底怒了，老子好歹也是一代枭雄，军阀的老大，走过的路比你走过的桥还多，竟然被你这个书生瞧不起，妈的！袁世凯越想越气愤，于是他做了一个决定，一个错误的决定：他让人刺杀了宋教仁。我觉得这也是军阀的一大缺点，以为把人杀了，事情解决了，然而事情根本没有这么简单。\n　　宋教仁一死，中国又开始变得混乱了，国会议员和国民党都开始闹事，袁世凯的亲信和儿子便趁机蛊惑袁世凯，让他称帝。袁世凯也觉得与其让这帮没有治国经验的人瞎折腾，不如把权利都收到自己手里来，于是他做了第二个错误的决定：自己当皇帝。说袁世凯复辟其实也不太准确，因为他并不打算照搬清朝的制度，而是想学英国的君主立宪制。但是他错估了中国当前的形势，全国上下辛辛苦苦办了五六年的共和，现在你突然想推翻这一切，要当皇帝，大家当然不乐意了，于是袁世凯一下就成了舆论的众矢之的，他的王朝没撑多久就被推翻了，下台之后的袁世凯没过多久就病死了。如果真有死不瞑目这一说法的话，我相信袁世凯应该是死不瞑目，辛辛苦苦推翻清政府，大力发展经济和教育，最后却落得一世骂名。客观的讲，虽然袁世凯在位的时候没做过什么惊天动力的大事，就连推翻清政府都是孙中山挑的头，但他确实为中国的发展做过很多实实在在的贡献，不能因为一次复辟而抹掉他所做的一切。\n黎元洪和张勋的发迹史　　袁世凯死后继任民国大总统的人是黎元洪，黎元洪也是一代传奇人物，在甲午战争的时候，他在“广甲”号上服役，后来“广甲”号被日本人打没之后，他逃到湖北投靠了当时的两江总督张之洞。由于黎元洪留过学，还当过海军和陆军，他的才识很受到了张之洞的赏识，让他创办军校，督办新军。当时很多有名的将领都是从黎元洪创办的军校里面毕业的，通过军校，黎元洪的势力慢慢壮大起来，张之洞死后，黎元洪便顺利成章的接替了他的位置。后来孙中山在南方闹革命的时候，同样接受过西方教育的黎元洪便不遗余力的支持孙中山。由于当时的湖北省真的非常的有钱，这些钱就都被黎元洪当成了革命的活动经费。他每天不停的给各个省的巡抚和布政使发电报，承诺他们，只要同意脱离清政府，宣布独立，就给你们省打钱。没想到还真有几个省同意了黎元洪的请求，宣布独立。所以说革命能成功，黎元洪应该是功不可没，不管是后来孙中山当总统还是袁世凯当总统，黎元洪都是副总统，可见大家对黎元洪的功劳还是挺认可的。在袁世凯死后，黎元洪的副总统终于熬成了正的。\n　　就在黎元洪受到张之洞赏识的时候，张勋的运气也不错，他在袁世凯的手下干活，袁老大给他安排了一个特别好的差事，至少在他自己看来这是一个号差事。当时八国联军打进北京，慈禧带着光绪皇帝跑了，后来签完《辛丑条约》之后，皇帝和太后回来，袁老大给张勋安排的好差事就是做好皇帝和太后的回銮工作，对于一个文盲出身的张勋来说，这可不得了啊，因为做回銮工作就意味着有机会面见圣上，这对于一个老百姓出身的人来说，简直就是祖上积德啊，所以他特别重视这个工作，袁世凯见回銮工作做的不错就直接让张勋来负责皇城的护卫工作，官职是紫禁城护卫总指挥，这个工作他也做的非常出色，并且还多次受到皇帝和太后的夸奖。对于张勋这样的大老粗来说，一辈子追求的就是这种皇恩浩荡的感觉，现在终于感受到了。所以后来民国的时候，他也总是怀念大清的好，民国之后都流行剪辫子，当全国的辫子都减的差不多的时候，只有张勋的部队里还都留着辫子，史称“辫子军”。他一辈子也没能转过这个弯来，始终都觉得清政府就是比民国好，其实这事也不怪他，因为他从小就习惯了皇权下的忠孝仁义，小时候给人家看大院、后来遇上战乱入伍打战，靠着军功一路爬到了现在，根本没有人告诉他民国到底是个什么东西，所以就算民国已经办了六年了，但他仍然想象着有一天能够重新回到清朝的统治，中国的老百姓已经在皇权的统治下生活几千年，虽然有不好的时候，但是大部分时候大家都还是能够幸福的生活的，恰好当时的民国又特别混乱，共和6年多时间了，中国依旧比较混乱，所以他觉得只要重新回到清朝的统治，一切又会重新变得好起来的，他坚信。\n　　虽然在这一点上张勋很不开窍，但是他的为人真的特别好，同系的其他北洋军阀们到他的地盘有办什么事情的时候，他都服务的特别周到，又是给钱、又是请戏班唱戏，所以军阀们要是有个什么聚会啥的都乐意来张勋的地盘来举办，恰好他又年长大家几岁，大家都尊称他一声老大哥，他自己也真的把自己当成了军阀们的老大哥，每次聚会的时候他都喜欢在酒桌上和大家自己的政治理想，梦想着有一天重回大清的统治。每当这个时候酒桌上的其他兄弟都会随声附和，说只要老大哥你带头复辟，我们都支持你。这给了张勋很大的自信，可是酒桌上的话又怎么能信呢？而且张勋老大哥你在偏远的徐州，距离权利中心十万八千里远，实力比你强的军阀也有很多，那轮得到你来复辟啊。可是历史就是这么调皮，机会很快就来了。\n　　黎元洪当总统的时候，跟他搭档的人是段祺瑞，段祺瑞是袁世凯的老部下，在北洋军阀当中也很有威信。一开始两人搭档的很好，民国看起来又要恢复生机了，在度过一段不长不短的蜜月期之后，一件事的发生打破了这个局面：一战爆发了。美国人跑过来对段祺瑞说，你们中国来参战吧！如果你们来参战的话，我就给你钱，还给你们提供经济上的扶持。段祺瑞拍脑门子想了一下，觉得这是个好事啊，不仅能得到美国的帮助，如果打赢了的话还能从德国手里收回青岛。于是他就去找黎元洪商量说，我们对德国宣战吧！黎元洪听了之后坚决不同意，因为中国当时的陆军大部分都是在德国军官的教导下成长起来，而且配的装备也都是德军装备，让这样的部队去和德军打，不是去送死吗？而且中国现在的局面还没完全稳定，根本没有经济实力来支撑这么一场大战，所以黎元洪死都不同意。但段祺瑞也比较倔强，一定要对德开战，既然你不同意，那我就撇开你自己干，反正你也管不了我（这就是孙中山后来修改宪法的后果）。这样做之后，两个人就彻底撕破脸皮了，黎元洪一怒之下就解除了段祺瑞的总理职务，但是黎元洪似乎低估了段祺瑞的威信，段祺瑞被解除总理之后，国务委员们也都纷纷递交辞呈，各地的军阀也都相继宣布独立，不听中央号令，但在这些军阀里面也有个例外，有一个军阀没有宣布独立，这个奇葩的例外就是张勋，不是因为他不想通电独立，而是他根本就没有资本去宣布独立，他虽然是安徽省的总督，却带着部队在江苏省的徐州呆着，为什么呢？因为安徽省在他的好兄弟倪嗣手里，不知道是不是因为打不过人家还是什么原因，张勋也没有太追究这件事情，就安心的待在徐州逍遥。所以他的军阀兄弟们相继在其他省份都宣布独立的时候，他就非常尴尬的没有附和了。但是远在中央的黎元洪却不这么看，黎元洪认为张勋是深明大义，国之柱石，而且据说张勋还是军阀们的老大哥，那么只要把他请到北京来，一定能震住当前的局面。相信黎元洪他自己都被这个英明的想法感动了，于是他立刻电召张勋率部队进京调停，以防不测。\n　　张勋做梦也没想到会收到一条这样的命令，幸福来的太突然了，只要带着部队进京，他就有机会把清朝的皇帝重新请出来，让中国重回到大清的统治了，加上之前在酒桌上他的兄弟们跟他说的话，使他变得更加自信了，他觉得只要率部队进京，他梦想和报复就能马上实现。\n　　于是张勋便乐呵呵的把部队带进了北京城，事情比他想象的还要顺利，很快他就控制了黎元洪，并把十来岁的傅仪请出来，对他说，皇上，咱复辟了，天下又是您的了。复辟之后张勋做的第一件事就是给自己封了个官职：直隶总督兼北洋大臣。这可是当年偶像袁世凯当过的官职啊，没想到有朝一日我张勋也能坐到这个位置上，人生真的是太美好了。可是张勋你做了直隶总督兼北洋大臣，你的那些兄弟能安心当你手下吗？叫你一声老大哥只是尊敬你的为人，要是真把自己当老大的话那可是要吃亏的啊，当年你的偶像袁世凯复辟都没有成功，你张大个子又怎么会成功呢？首先起来反抗就是他当年在酒桌上的那些兄弟，张大个子你算哪根葱啊？还想当我们的上司，啥也不说了，兄弟们一起上吧！本来张勋的实力就不行，现在这么多人一起来反抗他，那就更加招架不住了， 没过两天就被打扒下了。但是那些军阀们对战败的张勋也还算客气，没有真正要了他的性命，让他带着财产和家眷回天津当寓公去了。\n　　经过张勋这么一闹，中国就再也没有人真心的想要办共和了。想来还是觉得挺可惜的，中国的共和之路就这么断送在了张勋这个奇葩的人物手中。\n　　但后来又释然了，我想每一个朝代的结束，都不是一下子就能终结的吧，就像宋朝灭亡之前还整出一个南宋来。明朝的崇祯皇帝在煤山殉国之后明朝也没有真正的终结，而是在南京办了一个弘光小朝廷之后才算彻底结束。要是从从这个角度想的话，那么因为袁世凯和张勋的复辟而导致中国的共和之路中断就不觉得那么可惜了，这是历史规律，规律不可违抗。\n","categories":["技术以外"],"tags":[]},{"title":"Kaggle初学者五步入门指南，七大诀窍助你享受竞赛","url":"https://tanqingbo.cn/Kaggle5-step-guide/","content":"Kaggle 是一个流行的数据科学竞赛平台，已被谷歌收购，参阅《业界 | 谷歌云官方正式宣布收购数据科学社区 Kaggle》。作为一个竞赛平台，Kaggle 对于初学者来说可能有些难度。毕竟其中的一些竞赛有高达 100 万美元的奖金池和数百位参赛者。顶级的团队在处理机场安全提升或卫星数据分析等任务上拥有数十年积累的经验。为了帮助初学者入门 Kaggle，EliteDataScience 近日发表了一篇入门介绍文章，解答了一些初学者最常遇到的问题。机器之心对这篇文章进行了编译介绍，另外也增加了一些机器之心之前发过的文章作为补充资源。\n\n一些初学者会犹豫要不要参加 Kaggle 竞赛，这并不让人奇怪，他们通常有以下顾虑：\n\n我该如何开始？\n我要和经验丰富的博士研究者比赛吗？\n如果没有获胜的机会，还值得参与吗？\n这就是数据科学吗？（如果我在 Kaggle 上表现不好，我在数据科学领域还有希望吗？）\n未来我该如何提升我的排名？\n\n\n如果你有其中任何问题，你就看对了文章。在这篇指南中，我们会解读上手 Kaggle、提升技能和享受 Kaggle 所需要了解的一切。\n\n\nKaggle vs.「经典的」数据科学\n首先，我们要清楚了解：\nKaggle 竞赛和「经典的」数据科学有一些重要的不同之处，但只要你以正确的心态接触它，就也能收获有价值的经验。\n\n\n\nKaggle 竞赛\n本质上，带有奖金池的竞赛必须满足一些标准：\n\n问题必须困难：竞赛不应该是一个下午就能解决的任务。为了得到最好的投资回报，主办公司会提交他们最大最难的问题。\n解决方案必须新：要赢得最新的竞赛，你通常需要进行扩展研究、定制算法、训练先进的模型等等。\n表现必须能比较：竞赛必须要决出优胜者，所以你和其他对手的解决方案必须要被评分。\n\n\n\n「经典的」数据科学\n相对而言，日常所用的数据科学并不需要满足这些标准。\n\n问题可能简单。实际上，数据科学家应该尽力确认易于实现的成果：可以快速解决的富有成效的项目。\n解决方案可以是成熟的。大多数常见任务（比如探索分析、数据清理、A/B 测试、经典算法）都已经有了已得到证明的框架。没必要重新发明轮子。\n表现可以是绝对的。即使一个解决方案只是简单地超越了之前的基准，那也非常有价值。\n\n\nKaggle 竞赛鼓励你竭尽所能，而经典数据科学则推崇效率和最大化的业务效果。\n\n\nKaggle 竞赛值得参加吗？\n尽管 Kaggle 和经典数据科学之间存在差异，但 Kaggle 仍然是一种很好的入门工具。\n\n每个竞赛都是独立的。无需设置项目范围然后收集数据，这让你有时间专注其它技能。\n\n练习就是实践。学习数据科学的最好方法是在做中学。只要没有每场竞赛都获胜的压力，你就可以练习各种有趣的问题。\n\n讨论和获胜者采访很有启发性。每个竞赛都有自己的讨论板块与获胜者简报。你可以窥见更有经验的数据科学家的思考过程。\n\n\n怎样入门 Kaggle？\n接下来，我们将给出一个按步进行的行动规划，然后慢慢上升到 Kaggle 竞赛中。第一步：选择一种编程语言\n\n首先，我们推荐你选择一种编程语言，并坚持使用。Python 和 R 在 Kaggle 和更广泛的数据科学社区上都很流行。\n如果你是一个毫无经验的新手，我们推荐 Python，因为这是一种通用编程语言，你可以在整个流程中都使用它。\n\n参考：数据科学领域 R vs Python：http://elitedatascience.com/r-vs-python-for-data-science如何为数据科学学习 Python：http://elitedatascience.com/learn-python-for-data-science深度 | R vs Python：R 是现在最好的数据科学语言吗？业界 | 超越 R，Python 成为最受欢迎的机器学习语言\n\n第二步：学习探索数据的基础加载、浏览和绘制你的数据（即探索性分析）的能力是数据科学的第一步，因为它可以为你将在模型训练过程中做的各种决策提供信息。\n如果你选择了 Python 路线，那么我们推荐你使用专门为这个目的设计的 Seaborn 库。其中有高层面的绘图函数，可以绘制许多最常见和有用的图表。\n\n参考：Seaborn 库：https://seaborn.pydata.org/Python Seaborn 教程：http://elitedatascience.com/python-seaborn-tutorial资源 | 2017 年最流行的 15 个数据科学 Python 库\n\n第三步：训练你的第一个机器学习模型在进入 Kaggle 之前，我们推荐你先在更简单更容易管理的数据集上训练一个模型。这能让你熟悉机器学习库，为以后的工作做铺垫。\n关键在于培养良好的习惯，比如将你的数据集分成独立的训练集和测试集，交叉验证避免过拟合以及使用合适的表现评价指标。\n对于 Python，最好的通用机器学习库是 Scikit-Learn。\n\n参考：Scikit-Learn 库：http://scikit-learn.org/stable/Python Scikit-Learn 教程：http://elitedatascience.com/python-machine-learning-tutorial-scikit-learn7 天应用机器学习速成课：http://elitedatascience.com/只需十四步：从零开始掌握 Python 机器学习（附资源）教程 | Kaggle CTO Ben Hamner ：机器学习的八个步骤\n\n第四步：解决入门级竞赛现在我们已经准备好尝试 Kaggle 竞赛了，这些竞赛分成几个类别。最常见的类别是：\nFeatured：这些通常是由公司、组织甚至政府赞助的，奖金池最大。Research：这些是研究方向的竞赛，只有很少或没有奖金。它们也有非传统的提交流程。Recruitment：这些是由想要招聘数据科学家的公司赞助的。目前仍然相对少见。Getting Started：这些竞赛的结构和 Featured 竞赛类似，但没有奖金。它们有更简单的数据集、大量教程和滚动的提交窗口让你可以随时输入。Getting Started 竞赛非常适合初学者，因为它们给你提供了低风险的学习环境，并且还有很多社区创造的教程：https://www.kaggle.com/c/titanic#tutorials\n第五步：比赛是为了更好地学习，而不是赚钱有了上面的基础，就可以参与到 Featured 竞赛中了。一般来说，为了取得好排名，通常需要远远更多的时间和精力。\n因此，我们建议你明智地选择参与项目。参加竞赛能帮你深入到你希望长期参与的技术领域中。\n尽管奖金很诱人，但更有价值（也更可靠）的回报是为你的未来事业所获得的技能。\n享受 Kaggle 的小诀窍最后，我们将介绍几个参与 Kaggle 的最受欢迎的诀窍，希望能帮你享受你的 Kaggle 时光。\n诀窍 1：设置循序渐进的目标如果你曾经玩过什么让人上瘾的游戏，你就知道循序渐进的目标的重要性。那就是好游戏让人着迷的诀窍。每一个目标都要足够大，以便带来成就感；但也不能太大，不然无法实现。\n大多数 Kaggle 参与者都没赢过任何一场竞赛，这完全正常。如果把获胜作为第一个里程碑，你可能会失望，尝试几次之后可能就会失去动力。循序渐进的目标会让你的旅程更加愉快。比如：\n提交一个超越基准解决方案的方案\n\n在一场竞赛中进入排名前 50%\n在一场竞赛中进入排名前 25%\n在三场竞赛中进入排名前 25%\n在一场竞赛中进入排名前 10%\n赢得一场竞赛！这种策略让你可以一路衡量你的进展和进步。\n\n诀窍 2：查阅得票最多的 kernelKaggle 有一个非常厉害的功能：参与者可以提交 kernel，即用于探索一个概念、展示一种技术或分享一种解决方案的短脚本。\n当你开始一场竞赛或感觉进步停滞时，查阅受欢迎的 kernel 或许能给你带来灵感。\n诀窍 3：在论坛中提问不要害怕问「愚蠢的」问题。\n提问能遇到的最糟糕的事情是什么？也许你会被忽视……仅此而已。\n另一方面，你能得到很多回报，包括来自经验更丰富的数据科学家的建议和指导。\n诀窍 4：独立发展核心技能开始的时候，我们建议你独自工作。这将迫使你解决应用性机器学习流程中的每一步，包括探索性分析、数据清理、特征工程和模型训练。\n如果过早地和人组队，你就可能会错失发展这些基本技能的机会。\n诀窍 5：组队以拓展你的极限虽然太早组队不好，但在未来的比赛中组队让你能向其他人学习，进而拓展你的极限。过去的许多获胜者都是团队，这让他们可以结合彼此的知识共同施展力量。\n此外，一旦你掌握了机器学习的技术技能，你就可以与其他可能比你有更多领域知识的人合作，进一步扩展你的机遇。\n诀窍 6：记住 Kaggle 可以成为你的垫脚石记住，你不一定要成为一个长期的 Kaggle 人。如果发现你不喜欢这种形式，也没什么大不了的。\n实际上，许多人在做自己的项目或成为全职数据科学家之前都会使用 Kaggle 作为自己的垫脚石。\n所以你的关注重点应该是尽可能地学习。长远来看，参与能给你带来相关经验的竞赛比参加有最高奖金的竞赛更好。\n诀窍 7：不要担心排名低有些初学者担心低排名出现在他们的个人资料中，结果一直没有开始。当然，比赛焦虑是很正常的现象，并不只限于 Kaggle。\n但是，排名低真的没什么关系。没人会因此贬低你，因为他们曾经某个时候也是初学者。\n即便如此，如果仍然担心个人资料里的低排名，你可以再单独创建一个练习账号。一旦觉得自己能力不错了，就可以开始用你的「主帐号」来建立丰功伟绩了。（再说一下，这么做毫无必要！） \n结论\n在这篇指南中，我们分享了上手 Kaggle 的 5 大步骤：\n\n选择一种编程语言\n学习探索数据的基础\n训练第一个机器学习模型\n解决入门级竞赛\n比赛是为了更好地学习，而不是赚钱\n\n\n最后，我们分享了享受这个平台的 7 个诀窍：\n\n设置循序渐进的目标\n查阅得票最多的 kernel\n在论坛中提问\n独立发展核心技能\n组队以拓展你的极限\n记住 Kaggle 可以成为你的垫脚石\n不要担心排名低\n\n\n\n","categories":["图像处理与机器学习"],"tags":["机器学习","深度学习","Kaggle"]},{"title":"说说心里话：很高兴遇见你们","url":"https://tanqingbo.cn/Nice-to-meet-you/","content":"\n从今年3月末开始运营公众号到现在，4个多月的时间关注我的读者已经增长到1万多了，真的很高兴能够在这里和大家相遇。在这个过程中我自己成长了很多，也认识了很多新的朋友，因此有些心里话想和大家说一说：\n\n在这个互联网时代，随着用户的增加通常都会遇到一些奇奇怪怪的人，比如说“杠精”、比如说“喷子”。这种人我在知乎上遇到过不少，让我印象最深刻的一次是有一位朋在我的文章下面把我骂完一顿之后，又在他的知乎想法里面把我挂出来，骂我一顿，理由是我分享的干货不够全。但是在这4个多月的时间里，在我的公众号上从来没有遇到过这种情况，大家都在友善的沟通和交流，这应该算是我的幸运，也感谢大家多我的包容。希望大家再以后也能够接着包容我，如果我有什么不对的地方也请及时指出。\n\n\n很多人喜欢把积累的用户称作粉丝，但我觉得我们之间不是粉丝与博主的关系，你们在那么多的公众号里面发现了我的公众号，说明我们是有共同语言的，说明我们是能够交流，能对话的，所以我们是朋友的关系。在这个时代，谁都不傻，读者只会去挑选适合自己的公众号去阅读。既然你们选择了我，我以后也会努力输出有用的内容，希望不会辜负你们的期待。\n\n腾讯给微信公众号加的广告词是：再小的个体也需要有自己的品牌。从最开始做公众号开始，我就想着去打造一个属于自己的个人品牌。所以我想在这里给自己立一个flag，也算是对读者的承若：坚持原创，打造一个原创类型的公众号。\n\n其实做一个号，还保持持续输出这件事情很简单，只需要去各个平台转载和自己主题相关的文章就可以了，但是我觉得这样有点偏离了自己的初衷：输出的内容全都不是自己的，何谈人格品牌。我不想把它变成一个圈钱的工具，我希望在运营公众号的过程中和大家一起成长，一起进步，我希望我的内容能够帮助到大家。\n\n\n\n最后，写在2018年8月，相信只有写过文字或做过微信公众号的人才能体会其中的种种。今天过后，全部归零，因为有你们，我会继续写下去~\n\n希望大家能够多多支持我，或点赞、或打赏、或转发、或点广告，都是对我的一份鼓励和认可，感恩~\n\n\n公众号如下：\n\n文章写于2018年7月13号！\n","categories":["技术以外"],"tags":["公众号","互联网"]},{"title":"我是学计算机的，觉得自己很弱，要不要考虑换个专业？","url":"https://tanqingbo.cn/Computer-for-another-major/","content":"之前有个学计算机的大一的小朋友加我微信，跟我抱怨说：“自己的专业里面很多大神，有的同学在还没上大学之前就已经打过ACM比赛了，而我现在连编程是个什么概念都还没搞明白，感觉自己真的很弱，要不要考虑换个专业？”\n其实这种感觉我当时也经历过，当我还在努力记住“int”类型和“char”类型的区别的时候，我们专业已经有人在刷ACM官网上的算法题了，太变态了吧！后来慢慢熟悉之后，才发现那个刚入学算法题就刷的贼溜的朋友，他爸也是个程序员，在他们高中的时候也有开设过计算机相关的课程，所以并不是你不行，而是人家学的比你早。\n我相信很多刚上大学的朋友都会萌生这种想法：专业大神甩我好几十条街，这么菜的我要不要考虑转专业。今天就来聊聊这个问题，帮上大学之前没学过编程的同学打打气吧！\n首先你要清楚的是，高中的学习和大学的学习不太一样，在高中的时候有家长和班主任追在屁股后面催你学习，条件好的家庭还可以请家教培养你各种兴趣爱好和编程能力，所以当你刚进入大学校园的时候，你感觉你不如人家牛逼的时候并不能代表你不行，可能只是代表你的家庭条件或者母校没有人家好，但能考到同一所学校，说明智商都是一样的。\n第二点就是，大学是一场马拉松，我见过很多同学入学的时候各种牛逼，当我们还在努力弄清楚什么是编程的时候，他们已经能做一些小项目了，可是有一部分“大一时候的大佬”等到毕业的时候也没见到他们比入学的时候强多少，因为大学是一个开放的学习环境，再也没有人像高中班主任那样这么上心的催你学习了，全靠自己的自制能力，有的同学可能习惯被管着的学习方式，一旦没有人管了，就放弃治疗了，所以只要你的自制能力比较强的话，4年的时间，足够你追上任何一个大佬（一些特殊的变态除外）。\n还有就是想给学计算机的同学提个建议，编程实践能力真的很重要，在大学期间千万不要为了让自己的卷面成绩考的很漂亮而放弃了自己的动手能力，毕竟你以后是要去公司给公司带来效益的，而不是看你考试成绩打多少分。\n暂时只想到这些，欢迎大家接着补充和反驳~\n","categories":["技术以外"],"tags":["计算机","程序员"]},{"title":"推荐一款特别厉害的在线工具，程序员的百宝箱","url":"https://tanqingbo.cn/Programmer-treasure-chest/","content":"\n今天发现了一款特别厉害的程序员在线工具网站，堪称程序员的百宝箱。可支持在线运行php、c、c++、go、python、java等主流语言，页面简单明了，通俗易懂。\n\n\n此外还提供在线js美化、解压缩、混淆；在线css美化、格式化、压缩；在线编辑json；语法检查；转php,go类；还支持图片base64编码；常用进制转换工具；html转markdown；在线时间戳转换；一键推广外链等等，功能齐全强大。\n\n\n还有更多的功能可以自己去挖掘发现，在线工具页面如下图所示：\n\n\n\n官网：https://tool.lu/\n\n","categories":["工具"],"tags":[]},{"title":"邻域近似随机森林（NAF）对二维图像分割的源码解释","url":"https://tanqingbo.cn/Neighborhood-approximate-random-forest/","content":"软件\nmatlab2018a（2015版本以上最好，有的函数旧版本不兼容）, vlfeat-0.9.18源码结构0globalset\n0globalset/makeGlobalConst.m：记录程序要用到的全部目录路径、参数设置，点击运行，参数就会更新，并保存到const.mat中。一般只需要根据自己的本机情况修改根目录路径：\n\n%% 根目录FP_WORK = 'E:\\文献\\2DNAF\\';\n\n​    \n\n0globalset/addConstpath.m：把文件夹内的全部路径加入到环境变量（否则有的跨文件夹函数就找不到）。\n\nNAF\nNAFmain.m是程序运行的入口，参见代码的注释可以知道采用NAF的方法分割具体需要哪些步骤。\n数据预处理（preprocess.m）：\n首先将训练数据的img和label都存到train.mat中，变量名为：trainimgdata。并存在2DNAF\\database\\oridata\\oritrain文件夹中。\n之后再按照步长宽和步长分别为NPX、NPX、NIX、NIY对数据进行切分，切分成重叠的像素块，因为重叠是核心的方法，如果不重叠，就没有容错率，KNN判出来是什么就必须是什么，如下图：\n\n\n\n\n\n比如这个，如果没有重叠，会少标记3个像素，多标记1个像素；如果重叠，哪怕每个块像素都有漏分或者多分，也能产生一个投票数目，通过设定一个阈值就能更平滑地去分割。\n\n比如阈值设为2，也就是被2次判定为目标像素的才真的判定为目标像素，这样的话就是完美的分割；阈值设为1，只是多标记了2个像素而已。\n\n对img和label分块好的数据存放在trainpatches.mat中，和train.mat放在同一个文件夹中，trainpatches.mat包含如下信息：\n  patches(patchidx).imgpatch = imgpatch;%灰度图像快patches(patchidx).gtpatch = gtpatch;%label图像快patches(patchidx).fileidx = fileidx;%所属的图像文件IDpatches(patchidx).mx = mx;%相对左上坐标Xpatches(patchidx).my = my;%相对左上坐标Ypatches(patchidx).ctrx = ceil(mx+px/2 -1);%相对中心X坐标patches(patchidx).ctry = ceil(my+py/2 -1);%相对中心Y坐标patches(patchidx).gtcl = culgtcl(gtpatch,1);%对应存入的标签，返回像素为1的像素值个数占总像素个数的比例patches(patchidx).pid = patchidx;%PID\n\n\n\n\n\n\n之后再按照像素为1的像素值个数占总像素个数的比例（gtcl）将块数据分成11类，只要是因为数据太多，内存装载不下，所以需要分11次处理，视情况而定，可以多分一些类，名字为i_trainpatches.mat.\n\nmakeFeaPos.m:外部特征提取，采邻域样本特征值。FW为邻域的宽度，要大于块的长度。生成的随机领域坐标存在database\\feature_aux\\NAFfpos.mat中。\n\nNAFtrain()：训练NAF。\n\nextNAFFeature：训练之前需要先提取块（patches）的特征向量，先像素归一化，然后提取均值 / 标准差 / 最小值 / 最大值 / 中位数 / 中心3×3的纹理特征(LBP) / 邻域特征。提取向量特征的时候是提取上一步分好成11类中每一类的特征，并保存在i_trainFea.mat中。\n之后再将已经分成11类的i_trainpatches.mat中的label矩阵存储方式变成向量，方便计算，存储在\\feature_aux\\gtmat.mat中。\n随机选择特征值，即随机选择i_trainFea.mat中的值，保存在features变量中（第一列是pid，第2-7是那些均值之类的特征，剩下的都是邻域特征），然后计算pairdist距离，因为KNN是根据距离来找到最相似的图像的。距离公式和过程如下：\n\n\n\n\n\nL0 范数，含义为矩阵含0 的个数，分数下侧为块像素的大小。pairdist 的值越大，说明两个块像素的GT 图像差异越大，块像素越不相似；反之，如果pairdist 的值越小，则说明两个块像素的GT 图像值几乎相同，块像素相似程度越高。\n\n将pairdist距离和随机选择的特征传到构造树的函数中就可以训练树了。\n\nmakeNAFtree.m构建树：\n\n随机取阈值t，按照特征值得大小将块的特征分成左右两个子树，训练树，通过学习获得阈值t使得熵Eq取得最大值，Eq的计算公式如下：\n\n\n\n\n\n其中，Nleft、Nright 分别左侧和右侧的儿子节点， AvgDist 表示在节点Ni 处内部的块像素聚集程度。块像素越聚集，AvgDist 应该越小，块像素越分散，AvgDist 应该越大，所以定义AvgDist 为“距离”的平均值：\n\n\n\n找到使得熵Ep取得最大值的特征和阈值，就近似地将距离接近的块像素分到了一堆去。\n\n测试\n同样需要先将测试数据分块，再分成11类，然后提取均值 / 标准差 / 最小值 / 最大值 / 中位数 / 中心3×3的纹理特征(LBP) / 邻域特征等特征，保存在testFea.mat中。\n再将测试数据的特征传入之前训练好的树，再将每个块像素遍历INARF，每棵INAT都会得到它的KNN 训练块像素编号，把这些编号进行计数后由大到小排序，前KNN_K 个块像素就是被多棵INAT 都判定为相似的最相似训练块像素。如图4-7 所示为一个红色块像素PA 遍历INARF 的3 棵树的过程。第一棵树INAT1测试了N1 处的特征后，认为应该分到N3，再在N3 处测试特征后，认为应该分到N4，N4 是叶子节点，存储着“1，3，5，6”，它们都是具有和PA 相似特征的块像素。INAT2 在N3 处给出了“3，5，7，9”的结果，INAT3 在N5 处给出了“3，5，9，10”的结果，最后通过统计，输入块像素被三棵树判定为和“3”、“5”相似，被两棵树判定为和“9”相似，其余都仅被一棵树认为相似，如果KNN_K取4，那么最相似的四个块像素可能为“3，5，9，1”，\n“可能”的意思是，“1”、“6”、“7”、“10”都可能被选为第四相似的块像素。在这里不能仅仅根据这个统计数字来对最终相似块像素做一个判断，比如“3”、“5”块像素都被三棵树认为相似，只是因为排序算法的特性巧合地让“3”排到了“5”前面，它们的相似程度都是相同的。增加树的数目可以让被选中次数更加有辨别力，但是会增加训练和测试的复杂程度，并且总可能会发生被选中次数相同的情况。\n\n\n\n为了解决这个问题，INARF 的测试采用协相关系数来比较当前测试块像素和KNN 训练块像素之间的相似程度。协相关系数（correlation coefficient, CC）,计算公式如下：\n\n\n\n其中，mean 表示取均值，PA、PB 的尺寸都是L×W 的。注意分母不能为0，就要求PA、PB 的都不能是像素值全相同的矩阵，因此一旦检测到块像素的值全相同，则随机在模板上的一个位置增加0.0001。如果PA、PB 非常相似，那么CC 会趋近于1；如果PA、PB 反色非常相似，则CC 会趋近于-1；而如果PA、PB 不相似，CC 会趋近于0。只要找出“3，5，9，1”中和测试块像素计算CC 后绝对值最大的一个训练块像素，就是最相似块像素。再将这个最相似块像素的GT 图像作为测试块像素的GT 图像，作为分类结果。 \n\n","categories":["图像处理与机器学习"],"tags":["机器学习","深度学习"]},{"title":"知乎万赞程序员学习资料，盘它！！！","url":"https://tanqingbo.cn/coder-source/","content":"关注我的原创公众号 轮子工厂，发送 领取资源 获取我给你准备的知乎万赞程序员学习大礼包！资源包括： \n\n1T视频教程：涵盖Javaweb前后端教学视频、机器学习/人工智能教学视频、Linux系统教程视频、雅思考试视频；\n100多本书：包含C/C++、Java、Python三门编程语言的经典必看图书、LeetCode题解大全；\n软件工具：几乎包括你在编程道路上的可能会用到的大部分软件；\n项目源码：20个JavaWeb项目源码。\n\n\n\n\n关注公众号 轮子工厂，发送 领取资源 就可以获取上面所有资源了~感谢支持！\n\n","categories":["编程资料"],"tags":["程序员"]},{"title":"无意中发现一位大佬的算法刷题pdf笔记","url":"https://tanqingbo.cn/Algorithm-brush-notes/","content":"昨晚逛GitHub，无意中看到一位大佬（https://github.com/halfrost）的算法刷题笔记！                                                                         \n感觉发现了宝藏！有些小伙伴可能已经发现了，但咱这里还是忍不住安利一波，怕有些小伙伴没有看到。\n关于算法刷题的困惑和疑问也经常听朋友们提及。这份笔记里面共包含作者刷LeetCode算法题后整理的数百道题，每道题均附有详细题解过程。很多人表示刷数据结构和算法题效率不高，甚是痛苦。有了这个笔记的总结，对校招和社招的算法刷题帮助之大不言而喻，果断推荐给大家。\n\n\n\n\n\n需要刷题笔记PDF文档的小伙伴可以直接扫码关注下方二维码，回复 「刷题笔记」 四个字自取：\n\n每天进步一点点\n慢一点才能更快\n加油！\n","categories":["编程资料"],"tags":["算法"]},{"title":"第一个100万!","url":"https://tanqingbo.cn/100万的小目标/","content":"再过11天，我就25岁了，趁着年末以及25岁生日即将到来，想和大家聊一下100万这个话题。\n我特别认同这样一句话：“人的成长都是非线性的。”\n去年4月份的时候，我和几个朋友第一次出国旅游，当时给自己定了一个目标：30岁之前赚到人生中的第一个100万。\n我还在年终总结里说，要在能够承担风险的年纪多承担点风险，为自己多积累点资本，就算最后钱没攒下，至少还能攒下点经验。\n然后今年我赚到了70多万，可能在未来的几个月里便能实现100万的小目标。\n回顾这两年所经历的一些事情，我想说：很幸运，也很感恩！\n我从来不觉得自己是一个优秀的人，相反，我的起点可能比大多数人都要低。\n我的父母都是农民，高考的时候拼尽全力，最后勉强比一本线高7分，这个尴尬的分数让我没有挑学校的余地，留在本省可能连一本也录不上，所以我选择了来哈尔滨，被我的母校东北林业大学录取，再后来保送哈工大直接攻读博士，然后到了现在。\n所以也借着年末，和大家复盘我这一路的经历，希望我这样一个普通人经历，能给即将前行的你有所启发。\n1、从个人博客到公众号我本科是学计算机专业的，在大三的时候我们专业做了一次尝试，让企业一些有项目经验的老师来给我们上课，有点类似于联合培养的意思。\n上课的时间是在寒假，也就是说你想要参加这个培养，可能要牺牲寒假回家的机会，当时的我觉得，这可能是一次机会，便参与了 选拔，很幸运，我通过了。\n当然这并不是说我有多优秀，而是很多优秀的同学都想寒假回家，所以我才捡了个漏洞。\n这个培养一直持续了大半年，一直到第二年秋季才结束，在这个过程中，我学到了很多实用的编程技巧，更重要的是认识了一群优秀的小伙伴，后来这群小伙伴保研的都去了985高校，找工作的都拿到了腾讯、阿里这样大公司的offer。当然这是后话了。\n在这个过程中，我认识了我的好搭档，也是好兄弟刘勇，我们一起给社团做过项目，一个搭建个人网站，一起捣鼓域名。\n也是因为这个原因，我用自己名字申请了一个域名，映射到了自己搭建的个人网站上去，这对当时虚荣心极强的我来说，是一件很厉害的事情，当时我觉得那些在CSDN上写博客的人没有我优秀，我是在自己的网站上写，而且用自己的名字就能直接访问，那我肯定要把这个网站的内容做好好一下。\n\n我的个人网站地址：tanqingbo.cn\n\n于是那两年，我积累了不少优秀的博客内容，也养成了写博客的习惯，后来我把这些内容搬运到了知乎上，很快便在知乎上积累了一定量的关注，在知乎的朋友建议下，我开始做公众号，在这之前，因为个人网站和知乎已经积累了一点流量，所以公众号也很快获得了启动流量。\n到现在，我的公众号矩阵粉丝已经超过10万，全网累积粉丝接近20万。\n可以说没有当初决定放弃那次寒假，参加选拔，我现在可能是另外一个模样。\n经历过这件事，我明白一个道理：其实我们不缺机会，但是想要抓住机会需要有行动力，还需要付出点代价来交换这个机会。\n2、破圈成长到今天，我一共经历过三次重要的破圈。\n其实想要破圈，主要有两种方法，第一是靠内容和持续的输出能力，第二靠花钱。\n恰好这两种方法我都用上了，前两次靠内容，后一次靠花钱。\n在做公众号之前，我是个普通的学生，身边除了学生就是老师，每天的话题无非就是科研、找工作。\n这样的环境没有什么不好，但是呆久了会严重影响自己的眼界。用一句老话来说叫：书生意气太重，不知道社会的险恶。\n这也是很多博士为什么最后走不出来，选择结算自己的生命，因为这种环境下呆久了，会觉得这个世界只有科研、工作这两个选择，一旦遇到瓶颈，就容易发生悲剧。\n我也是个博士，那种孤立和无助我也感受过。\n这就是需要破圈的原因，当我打开自己的眼界，突破自己的圈子之后，我发现凭借我的执行力，做什么都能成。\n第一次破圈是因为公众号，当我的公众号有一定粉丝之后，便认识了自媒体圈子里的一些朋友，他们的一些涨粉的方法以及变现的商业模式，都对我后来有很大的帮助。\n第二次破圈是因为视频号，视频号出来的时间不长，在它出来的第一时间我就去做视频号了，相当于我是和所有人在同一起跑线上，也就是说不管你以前是多厉害的精英，都需要和我一样从0粉丝开始做视频号，也是因为这个原因，我实现了第二次的破圈，从之前的学术圈、到自媒体圈，到现在链接到了各行各业优秀的朋友，我的通讯录里甚至有李笑来、papi酱的微信，我发现原来大佬们都是这样生财的。\n第三次破圈是花钱之后的精准高效链接，这个我在第三部分专门和大家聊一下。\n3、花钱请顾问我特别喜欢《富爸爸穷爸爸》这本书，我现在很多的一些行为也都是书上教的，比如投资理财，比如花钱请顾问。\n书里面说一定要舍得在请顾问这件事情上花钱，因为我们不可能懂每一个赚钱的机会，但是总会有人懂，只要花钱请懂得人带我们一起赚钱就好了。\n这也是我要聊的第三次破圈：花钱破圈。\n这可能是我们普通人破圈最简单的方式，因为不需要我们有什么特别出众的能力。\n有人说：“你能力不行，入什么圈都没有用。”\n其实不是的，舍得花钱的人，至少能看出不抠搜，格局还行，这本身也是实力。\n具体怎么操作呢？\n如果你知道做某件事可以套利赚钱，但是你又不懂，你需要做的不是放弃，也不是马上入场，而是应该先向有结果的人学习，也就是先花钱找个顾问咨询一下，或者直接花钱加入他们的社群。\n我在A股做了两年的基金定投，目前收益10多万左右，是因为我很懂A股吗？当然不是，是因为我花钱加入了薇薇庄主的星球，她懂A股，我直接抄她的作业就行了。\n\n我最近打算做港股打新，但是入金需要香港银行卡，我打了很多银行和律所的电话，咨询他们办香港账户的事情，结果他们和我说的门坎都高的吓人，比如招行，需要500w存款才能办。\n但是我花钱加入胭脂扣的社群之后，在群里朋友推荐下，我用10万元门槛办好了香港账户。\n\n关于港股打新，我仍然不专业，但是我花钱买了顾问服务，我只需要抄顾问的作业就行了。\n好啦，说了很多，可能这个复盘不成体系，但基本上把我想表达的意思都说出来了。\n我记得有一次听分享会，嘉宾有句话让我特别印象深刻，就是人与人之间的根本差距，就是知行合一的差距。\n有人知道，有人不知道，有人能做到，有人做不到，如果有人即知道又能做到，那他就会和其他人拉出很大的距离。\n去年我给自己立了个flag：30岁之前赚到人生中的第一个100万。\n今年再立一个flag：30岁之前赚到人生中的第一个1000万。\n可能会打脸，但是有什么关系呢？\n我的人生之旅还在继续，明年的今天也一定会比现在更优秀。\n最后，希望大家明年也都能变得更优秀！\n","categories":["技术以外"],"tags":[]},{"title":"分享两个可供练手的Javaweb网站源码","url":"https://tanqingbo.cn/javaweb-source-code/","content":"\n本科大二的时候记得有一回实验课，系主任给我们代的课。当时我特别认真的坐在第一排敲代码，老师可能是觉得我写代码的姿势特别的帅气，于是过来和我聊天，然后我凭借三寸不烂之舌成功把老师忽悠，下课之后就要邀请我去了他的实验室。\n老师的实验室很多同学都是做Javaweb开发，于是便开始跟着师兄们开始做网站开发，虽然现在已经转行， 但是还是很感谢那个老师把我拽进实验室，也由此锻炼了我还算可以的coding能力。\n今天我就把当时写的网站系统分享给大家来参考和学习，用到了spring、hibernate、bootstrap、dwr等技术，我自认为我写的代码可读性还算可以，因此在这里把源码提供给大家练手。\n在入手之前可能需要一些Javaweb的预备知识，可以先提前参考这篇文章再阅读源码：Java学习视频教程一网打尽\n\n博客网站\n这是一个类似于CSDN的博客网站，用户可以发表博客，智能检索博客，同时还带有文件上传与下载、在线预览等功能，方便大家实现资源共享；部分系统截图如下：\n\n源码地址：https://github.com/tqb4342/blog\n\n\n基于javaweb的众筹网\n这个网站是帮同学做的一个毕业设计，参考的是目前主流的众筹网站，包括发起众筹项目、赞助某个项目、资金管理、智能检索等功能，部分截图如下图：\n\n\n\n源码地址：https://github.com/tqb4342/Crowdfunding\n\n说明\n类似这种网站写过很多，这两个网站风格差别有点大，因此很适合用来给大家练手，之前买的服务器过期了，不然大家可以直接在线浏览这两个网站，我使用的是MySQL数据库，eclipse作为开发软件，而且代码需要使用的jar都包含再里面。\n\n用hibernate连接的数据库，它自带建表功能，只要程序运行起来，它会根据你的代码逻辑自动在数据库中建好系统所需要的表，在大家运行代码的时候，只需要修改一下WebContent/WEB-INF/applicationContext.xml文件中的MySQL用户名和密码就行。如下图：\n\n此外，还需要在MySQL中建立一个和applicationContext.xml配置文件中数据库名字一致的数据库，到此代码就可以顺利运行了，剩下的就得靠自己好好消化代码了。祝顺利！\n\n\n","categories":["Java"],"tags":[]},{"title":"机器学习之结构学习详解","url":"https://tanqingbo.cn/Structure-learning/","content":"1、什么是结构学习\n所谓结构学习就是输入或输出是有结构的数据，比如说语句、列表、树和边界框（bounding box）.而通常的网络学习之中，输入和输出都是向量。而在结构学习中，我们需要学习的是一个函数F，它的输入是一种形式，输出是另外一种形式，比如输入的是你语音，输出对应的文本、输入中文，输出英文，输入图像，输出bounding box，等等。2、结构学习统一框架\n结构学习具有一个统一的框架，可以表示为下图中的形式：\n\n\n\n在训练的过程中，我们希望找到一个这样的函数f，用它来评价我们的输入与我们的输出目前有多匹配，在测试的过程中，给定了一个x，我们穷举所有的y，使得F(x,y)最大的y即位测试结果。2.1 目标检测\n目标检测所要达到的目的是。输入一张图片，我们使用一个边界框在图像中标注出确定目标的位置。具体的训练的框架如下所示：\n\n\n\n在这里训练的过程就是在估计边界框与目标之间的匹配程度。\n\n2.2  生成摘要\n摘要生成的结构学习与上面的目标检测十分相似，首先训练一个函数 F使得摘要和文本的匹配程度最好，之后在测试阶段，穷举所有的摘要，从中选择得分最高的那一个。 \n\n3、 从统计的角度看待统一框架\n结构学习的统一框架与概率模型之间有着如下的对应关系：\n\n\n\n其中学习到的函数 F因为是在评估 x,y 之间的匹配程度的，所以可以认为是 x,y 同时出现的概率；而给定x 找最匹配的结果实际上可以认为是再找给定 x 的一个最大后验概率，所以这个过程实际上课贝叶斯分类的过程是十分相像的。\n但是使用概率的方法有有点也有缺点。优点在于概率模型是可解释的，有意义的；缺点在于并不是多有的东西都可以用概率进行描述，其次对于一个连续函数对所有的可能的结果进行求和是没有办法实现的。\n\n4、 结构学习与DNN之间的关系\nDNN实际上可以看作是结构学习的一个特例，两者之间的关系如下图所示：\n\n\n\n在上面的神经网络中，我们将 x 输入神经网络中，将输出与 y 做交叉熵，那F就是两者交叉熵的相反数，然后在测试的时候，穷举所有的标签，带入F中找使他最大的y。\n\n5、结构学习统一框架要解决的三个问题\n问题1 ：估计输入间的相似程度应该用什么方法，也就是说 F(x,y)应该长成什么样子 ；\n问题2：如何解决那个穷举所有找出最大的问题； \n问题3：给定了训练数据，怎么样找打合适的 F(x,y)。\n如下图所示：\n\n\n5.1 问题1：F(x,y) 的具体形式\nF(x,y) 的具体形式如下图所示 \n\n\n\n其中 ϕ(x,y)表示通过输入的数据和输出的共同构成的特征，而 w是对应的权重，这里通过权重与特征的线性组合，然后将这些线性组合以向量的点积的形式表示出来，就得到了 F(x,y) 。\n其中 ϕ(x,y)可以是自己定义的特征，也可以是通过深度学习得到的特征。\n\n问题2：如何解决那个穷举所有找出最大的问题\n这里假设已经得到如下的一个标签：\n\n\n\n在这里我们假设是可以通过穷举或者某一种方式得到 y 。\n\n问题3：如何训练得到一个 F(x,y)\n因为在问题1中我们已经知道了这个 F(x,y) 是关于 w的函数，通过训练我们应该使我们的模型满足下面的条件：\n\n\n\n也就是说正确的标签所得到的函数值要大于所有非正确的标签的函数值。\nF(x,y) 的训练过程实际上十分简单，如下图所示：\n\n\n\n输入是训练数据，输出模型的权重，在这里首先将 w初始化为0，一直重复以下操作直到 w不能被更新。\n对于某一组数据 (xr,y^r)，找到使 w⋅ϕ(xr,y)最大的 y˜r，如果得到的 y˜r≠y^r，就执行如上的更新。\n其实这个更新的原则也很好理解，就是让w离正确的值越来越近。\n\n","categories":["图像处理与机器学习"],"tags":["机器学习","深度学习","结构学习"]},{"title":"支持向量机：SVM","url":"https://tanqingbo.cn/SVM/","content":"介绍\n支持向量机主要由两部分组成：折页损失函数(Hinge Loss)和核方法(Kernel Method)。损失函数\n假设我们输入的数据格式如下：\n\n\n\n其中x表示数据向量，y表示数据标签，标签分为两类，即+1和-1.在这里去模型函数为：\n\n\n\n所以分类用的损失函数为：\n\n\n\n其中定义当计算出的函数值于标签不相等的时候取1，相等的时候取0，但是这样得到的函数有一点不好，它无法进行微分，即无法进行梯度下降。所以我们采用了另外一种函数作为损失函数，即：\n\n\n对各种损失函数的讨论\n在下面我们将讨论各种损失函数的特性，如下图所示：\n\n\n\n在上图中，横坐标是,如果预测的符号于原始标签的符号是相同的，那么它们的损失值为0，如果符号相反则损失值为1，其中黑色的线是理想损失函数曲线，但是可以明显的看到这是一个不可微分的函数，所以我们使用了近似损失函数进行代替，这个近似损失函数可以由多种选择，下面将对每一种可能的选择进行讨论：\n其中红色曲线是二次函数曲线，其损失函数的表达式为:\n\n\n\n我们可以看到当数据的标签值是 +1 的时候，预测值为 +1 可以达到最小的损失；当标签值为 -1 的时候，预测值为 -1 可以达到最小的损失。所以当 y^nf(xn)=1 的时候取到最小的损失函数值，但是在后面这个函数就是不合理的，因为随着预测值逐渐变大，损失函数的取值居然越来越大，这明显是不合理的。\n接下来我们考虑使用sigmoid+square loss作为损失函数，其函数曲线是蓝色的那一条，具体的损失函数如下：\n\n\n\n画出损失函数曲线如上图所示，这个方法的效果并没有使用交叉熵的效果好，具体原因如下：\n\n\n\n从表达式可以看出，如果 ，那么整体的函数值将趋近于 ln1=0，如果 ，那么整体的函数值将趋近于 ∞，所以函数曲线如上图。这个函数曲线是合理的，因为随着 y^nf(xn) 的增加函数值会逐渐下降。对比 sigmoid + square loos 作为损失函数的方法，我们可以看到，当自变量（横坐标对应的值）取到负无穷的时候， sigmoid + cross entropy 会有很大的梯度值，而 sigmoid + square loos 的梯度值几乎为0，也就是说，前者在梯度下降的过程中，主要努力就会得到回报，而后者没有回报，所以也很有可能不想努力。另一点，在这里我们将交叉熵的函数值除以了 ln2，主要目的是希望可以得到理想损失函数的一个上界。\n\n最后我们来考虑折页损失函数(Hinge Loss)，具体表达式以及函数曲线如下图所示：\n\n\n\n\n如上的损失函数，我们可以看到，对于一个正例，如果 f(x)&gt;1，那么便得到了一个完美的分类结果，如果是反例的话，如果 f(x)&lt;−1，那么便得到了一个完美的分类结果。所以x 不用太大，因为大了函数值也是相同的。观察函数曲线可以知道，当  的时候，就已经够好了，但是它们同向却在 penalty 认为实际上还不够好，虽然可以正确分类了，但是损失函数仍然或让自变量向右移动变得更好，这个区间也就是所谓的边界(margin)。其中损失函数中取 1 的原始，它可以得到理想损失函数的一个紧致的上界。\n\n如果我们对比交叉熵函数和折页损失函数的话，它们最大的区别在于对待已经正确分类的例子的态度。如果将图中的黑点从1 的位置移动到 2 的位置，我们可以看到交叉熵损失函数的函数值会继续下降，也就是说它在已经得到好的结果之后还希望得到更好的结果；但是折页函数是一种及格就好的函数，当大于margin的时候就好了。在实际的使用中，折页函数略优于交叉熵损失函数，就是说没有领先的很多。但是折页函数更能够顾全全局，当进行多分类的时候得到的效果会更好。\n\n\n线性SVM分类器\n线性的SVM的步骤主要如下图所示分为三部：\n\n\n\n第一部分是目标函数，这里使用如上图所示的目标函数，它可以表示为两个向量之间的点积运算，进而可以表示为权重的转置与输入 x 的相乘。\n\n第二步，构建损失函数，这里使用的是折页损失函数和 L2 的正则项，因为前面的损失函数明显是一个凸函数，后面的正则化项也明显是一个凸函数，所以这些的组合也是一个凸函数；\n\n这样在第三步就可以使用梯度下降的方法更新参数。有的人可能会想，这个函数是分段线性的可以使用梯度下降嘛，可以的。想想之前的RElu，也是这样的啊，同样可以使用梯度下降的方法进行训练。\n\n在这里我们可以看到，实际上逻辑回归和线性的 SVM 之间的区别就在于 损失函数的不同。另一方面，通过第一步我们可以看出，实际上SVM与神经网络之间是相通的，所以在2013年的ICML中有一篇文章是“Deep Learning Using Linear Support Vector Machines”。\n\n\n使用梯度下降训练SVM\n首先我们将损失函数中折页损失函数取出，并判断下面两个等式是否相等：\n\n\n\n实际上仅仅考虑这两个等式，他们之间是不相等的，但是同时考虑最小化如下的损失函数的话，两者就是相同的了：\n\n\n\n这个时候我们用 ϵ 代替原来的折页损失函数，这里 ϵ 满足之前红色框框内的两个不等式，所以在这里我们认为他是松弛变量，而这样的问题可以使用二次规划的方法进行求解。\n\n核方法对偶表示\n最后分类函数的权重实际上是输入数据的线性组合，如下图所示 \n\n\n\n造成这种结果的原始，实际上可以通过之前所讲的利用梯度下降的方法更新参数的角度进行考虑。如上图所示，我们将所有的权重更新的过程合并成一个向量，其中的折页损失函数的导数记为 cn(w)，他的具体表达式也如上图所示。如果我们将权重的初始值设为0 的话，那么参数 w 实际上就是输入数据的线性组合，另外因为对于折页损失函数来讲，它里面有很多零的值，所以系数 α 中有很多的0，这样权重实际上是输入数据的稀疏组合，其中稀疏不为零所对应的数据点称为支持向量。这样的结果导致模型的鲁棒性更强，即使有离群值的点或者不合理的点，只要不选取它们作为支持向量，那么对于分类结果的影响并不大。\n由于在上面的部分已经证明了，SVM的权重实际上是通过输入点的线性组合得到，因此它可以表示为如下的形式：\n\n\n\n这里是将原来的求和转变为了向量相乘的形式，这个表达方式在机器学习中是常常使用的。在得到了的权重的对偶表达方式之后，第一步是进行变量替代，如下图所示\n\n\n\n将 w 带入之后可以看到 f(x) 主要这三部分组成，第一部分是系数 α ，他是一个行向量，一共有 N 列，后面的两项可以使用矩阵乘法的结合律，得到一个列向量，一共有 N 行。所以 f(x) 可以表示为上图那种形式，将其中的  可以表示为 ，我们将K称为核方法。\n如下图所示，经目标函数表达为系数与  的线性组合之后，接下来的任务就是最小化损失函数：\n\n\n\n其中需要注意的是，虽然后一项中有 n 还有 n′ ，但是这两个的求和范围是相同的，只不过先对 n′ 进行求和运算再对 n 进行求和运算。在这里我们不是真的需要知道向量 xn，只需要知道向量 xn 与 xn′ 的内部关系即可。这种方法就叫做核技巧(Kernel Trick)。\n\n核技巧（Kernel Trick）\n当我们将原来的数据点映射到高维空间的时候，这个时候使用核技巧往往是十分有用的，如下图所示:\n\n\n\n如上图中我们将 x 映射到 Φ(x)，这个时候我们计算转化到高维再做点积，通过化简可以知道这个过程等价于先对原始数据进行点积，之后再平方。这种方式主要在输入数据是高维数据的时候可以减少大量的计算量，如下图所示:\n\n\n\n如果首先做高维映射的话，需要进行 乘法得到高维数据的点，之后再让高维的点之间进行点积，一共需要 次乘法。但是如果首先进行内积运算在进行平方运算的话，需要计算 k+1 次乘法。这个计算量明显要小很多。所以核技巧的主要作用是减少计算量。\n\n下面再以径向基核(Radial Basis Function Kernel)为例进行介绍 \n\n\n\n\n我们可以看到如果将径向基函数用泰勒公式展开的话,我们可以看到是无穷多项的求和，所以是没有办法通过先向高维映射，之后在进行点积的方法求解的。另外通过上面的过程我们也可以了解到，实际上RBF(Radial Basis Function)核实际上是一种在无穷维上的分类器，虽然效果比较好，但是也十分容易过拟合。\n\n接着我们以 Sigmoid 核为例进行介绍\n\n\n\n\n我们实际上可以看到 f(x) 的计算过程可以通过如下的神经网络进行计算，对于输入的数据 x ，它首先与 x1 做点积，这个过程实际上即使在计算第一个神经元的加权输入，一共有 n 个这样的神经元，它们与对应的系数相乘再相加就可以可到目标函数 f(x)。因此使用 Sigmoid 核的SVM实际上是一个只包含一个隐层，激活函数为 Sigmoid 函数的神经网络。\n并不是所有的先对向量做点积再做其他操作都有对应的核函数，只有满足Mercer’s theory can check的才可以。\n\n深度学习与支持向量机的关系\n深度学习与支持向量机在原理上有很大的相关性，具体如下图所示:\n\n\n\n深度学习前面的隐层实际上是在做特征的高维映射，最后使用一个线性的分类器进行分类；\n而SVM使用核方法对数据进行非线性映射，之后在使用线性分类器进行分类。\n两者都是先特征映射再做分类的方法，这里实际上SVM的核方法也是可学习的，但是它们没有办法学习到深度学习那种程度。\n当你使用多个核函数的时候，对于两个核之间的连接的权重是可以学习的，就好像之前的SVM只有一个隐层，当使用多核方法的时候就相当于有多个隐层，那么它们之间权重就是可学习的了。\n\n","categories":["图像处理与机器学习"],"tags":["机器学习","深度学习","SVM"]},{"title":"迁移学习（Transfer Learning）","url":"https://tanqingbo.cn/Transfer-Learning/","content":"什么是迁移学习？\n通常对于同一类型的事业,我们不用自己完全从头做, 可以借鉴别人的经验, 往往能节省很多时间. 有这样的思路, 机器学习也能偷偷懒, 不用花时间重新训练一个无比庞大的神经网络, 借鉴借鉴一个已经训练好的神经网络就行.这就叫迁移学习。\n比如这样的一个神经网络, 我花了两天训练完之后, 它已经能正确区分图片中具体描述的是男人, 女人还是眼镜. 说明这个神经网络已经具备对图片信息一定的理解能力. 这些理解能力就以参数的形式存放在每一个神经节点中. 不巧, 领导下达了一个紧急任务,要求今天之内训练出来一个预测图片里实物价值的模型. 我想这可完蛋了, 上一个图片模型都要花两天, 如果要再搭个模型重新训练, 今天肯定出不来呀. 这时, 迁移学习来拯救我了. \n因为这个训练好的模型中已经有了一些对图片的理解能力, 而模型最后输出层的作用是分类之前的图片, 对于现在计算价值的任务是用不到的, 所以我将最后一层替换掉, 变为服务于现在这个任务的输出层. #接着只训练新加的输出层, 让理解力保持始终不变. 前面的神经层庞大的参数不用再训练, 节省了我很多时间, 我也在一天时间内, 将这个任务顺利完成。\n\n如何做迁移学习？\n在实践中，我们通常不会完全从头开始随机初始化训练 DCNN，这是因为有能满足深度网络需求的足够大小的数据集相当的少见。作为代替，常见的是在一个大型数据集上预训练一个 DCNN，然后使用这一训练的 DCNN 的权重作为初始设置或作为相关任务的固定的特征提取器。 举个例子，我们知道Imagnet是目前最大的图像识别数据库，目前已经有很多基于imagenet数据训练的网络模型，如inceptionv3、v4等，假如现在给你一个任务，希望你能做一个车系识别，你有两个选择：\n\n一是搜集大量的车系数据，对这些车系数据进行模型训练；\n二是基于imagenet训练好的网络模型，然后把搜集好的车系数据加到基于之前训练好的模型继续训练，进行fine-tuning（微调）。\n\n\n传统的做法都是第一种，但是这就会遇到一个问题，一是车系的图片够不够多，体量够不够大？如果数据量不够，最后训练的效果会不会很不好？其实我们可以通过 把ImageNet 或其他大型数据集学习到的网络特征运用于一个图片分类或其他基于图片特征的任务，这就是迁移学习的思想。其实可以这样理解，如果从零开始训练，那么初始化权重一般情况下要么是都为0，要么随机设置，当我们导入了在大规模数据集上训练好的模型后，相当于在以这个模型现有的参数作为初始化的权重，不过至于在具体的任务上的泛化能力如何，还是得看具体的场景。\n\n\n迁移学习为什么能work？\n通常我们在做深度学习的时候，网络的每一个layer分别提取训练集上的不同特征，假如我们要用NN去做大象识别，可能第一层的NN的作用是判断图片上的动物是否有腿，第二层判断是否有尾巴….然后剩下的每一层都分别提取图片上的不同特征，当所有的特征都满足时则判断为大象，如果有特征不满足的话，则判断为不是大象，如下图所示：\n\n\n\n所以当我们要重新训练一个网络去识别其它动物的时候，例如识别猫与狗，我们就可以不用重新训练这个网络，可以把大象的那个NN前面几层拿过来，猫与狗他们有某些相同的特征，例如都有腿、都有尾巴、都有耳朵，因此我们把识别相同特征的layer直接拿过来用，相当于借鉴前人已有的经验，借鉴过来的网络不用训练，因为参数在之前已经训练好了，我们只需要训练新加的layer就好了，这样可以大量的节省网络训练的时间，而且就算我们的训练数据不足也能取得很好的性能。\n\n迁移学习的限制\n上文提到我们在迁移学习中会使用预训练的网络，所以我们在模型架构方面受到了一点点限制。比如说，我们不能随意移除预训练网络中的卷积层。但由于参数共享的关系，我们可以很轻松地在不同空间尺寸的图像上运行一个预训练网络。这在卷积层和池化层和情况下是显而易见的，因为它们的前向函数（forward function）独立于输入内容的空间尺寸。在全连接层（FC）的情形中，这仍然成立，因为全连接层可被转化成一个卷积层。所以当我们导入一个预训练的模型时，网络结构需要与预训练的网络结构相同，然后再针对特定的场景和任务进行训练。\n\n迁移学习相关资料\n对迁移学习感兴趣的同学，可以关注这个github repo：transferlearning,里面所有的资料与数据集都是由王晋东所整理。\n\n","categories":["图像处理与机器学习"],"tags":["机器学习","深度学习","迁移学习"]},{"title":"无监督学习之生成模型","url":"https://tanqingbo.cn/Generative-Model-of-Unsupervised-Learning/","content":"什么是生成模型\n什么是生成（generation）？就是模型通过学习一些数据，然后生成类似的数据。让机器看一些动物图片，然后自己来产生动物的图片，这就是生成。\n\n以前就有很多可以用来生成的技术了，比如auto-encoder（自编码器），你训练一个encoder，把input转换成code，然后训练一个decoder，把code转换成一个image，然后计算得到的image和input之间的MSE（mean square error），训练完这个model之后，取出后半部分NN Decoder，输入一个随机的code，就能generate一个image。\n\n生成模型主要分为以下三种：\n\nPixelRNN;\nVariational Autoencoder(VAE)\nGenerative Adversarial Network(GAN)\n\n\n\nPixelRNN\nPixelRNN方法的主要过程如下图所示：\n\n\n\n在训练的过程中，首先输入图像的第一个像素，这个时候网络输出的是图像的第二个像素，然后将第一第二个像素作为第二次伸进网络的输出，输出为第三个像素点，以此类推，对网络进行训练。\n根据这个原理，我们可以输入半幅图像，通过该网络预测另外一半的样子。 \n假设我们给出了图像的一半，如下图，最左侧是原始图像，中间为输入遮挡一般的图像，希望补全另一半图像。后面是得到的三种结果。\n\n\n\n在训练上面这个网络的时候，一个直观的方法是将图像的 RGB 三个通道作为输入，但是这种方法得到的测试结果往往会偏灰色和棕色，这是因为神经网络的输出常常使得输出的三个值在数值上十分接近。因此在这里利用 1 of N encoding 对颜色进行编码，但是如果对所有颜色进行编码的话，总共有256256256种编码，维数过高，所以首先对颜色进行聚类，对聚在一类的颜色使用相同的编码，大大降低了编码的维数。\n\nVariational Autoencoder(VAE)\nAutoencoder在之前的博客无监督学习：深度自编码器中已经介绍了，主要过程如下所示：\n\n\n\n如果随机产生 code 然后经过 decode 之后是可以产生图像，但是要产生需要的图像，这个时候就需要VAE的帮助了。VAE的主要过程如下图所示 \n\n\n\n它的过程与 Aotuencoder 十分相似，前面的编码和后面的解码部分没有变化，中间的部分是添加的部分。首先如果你中间的编码部分希望得到的维数是3维的话，那么就会输出一个三维的 m 和一个三维的 σ，同时利用正态分布生成一个相同维数的向量 e ，经过计算得到编码 c（计算过程如上图所示），然后是解码的过程，最终的损失函数是同时最小化重建误差和下面的累加求和。\n下面是VAE的实验结果：\n\n\n\n可以看出来 VAE 想画点什么东西出来，但是并不知道 VAE 具体想画什么出来。\n那么他与pixel Rnn 的区别在于哪呢？在 VAE 中，可以如下图所示 \n\n\n\n假如我们中间编码的是一个十维的向量，那么可以保持其中的八维不变，变化其中的两维，看看这两维对于图像的影响是怎样的。具体的实验结果如下图所示:\n\n\n为什么要用VAE的直观解释\n从直观的理解为什么使用VAE，与之前的自编码的区别在于哪里呢？ \n\n\n\n如上图，左侧是自编码过程，右侧是VAE过程。如果在左图中，取满月和弦月编码的之间点，输出的结果是怎么样的，会不会是介于两者之间的月相是不好说的。但是如果采用VAE的方法，他实际上相当于在编码的时候向里面加入了噪声，使得含有噪声的图像仍然可以恢复为原来的图像，那么加入取两者中间重叠的点，这个时候由于损失函数要使得恢复的误差最小，这样就需要综合满月和弦月的图像，很有可能就得到介于两者之间的图像。\n加入噪声的原理如下图所示 \n\n\n\n其中的 m 可以认为是原始的编码，而 σ 认为是方差，e 本身是从正太分布得到的，所以本身有固定的方差，将两者相乘相当于向编码中加入方差为某一个值的噪声，其中e 要取指数，这个时候就可以保证所得到的方差是整数的，而且又由于 σ 是通过网络得到的，所以网络在学习中可以自动调节噪声方差的大小。\n在训练这个网络时，不仅仅只是用之前的重建误差最小，还需要加入如上图黄色框中的那一项最小。因为如果让网络自己随便学习的话，他会倾向于不在网络中加入噪声，如果这样的话他就与之前的自编码器没有区别了，所以需要加入如下图的惩罚项。\n\n\n\n其中蓝色的那一项如图中的蓝色的曲线所示，途中红色的项如图中红色的曲线所示，两项相减得到的结果如图中的绿色曲线所示。我们可以看到，如果要使这一项取到最小值需要使得 σi 的值为0，这个时候 exp（σi）的值为1，而不是零，这样就可以保证加入模型中的方差不是0，即有噪声加入网络中。其中的 m 直接认为是正则项就好，可以增强模型鲁棒性。\n\n从VAE的原理解释为什使用VAE\n回到问题的本身，我们实际上是希望生成图像。假如我们将图像看作是高维空间上的一个点，那么我们需要的就是估计这些点在高维空间的分布，这个概率分布的大概的形式应该如下图所示：\n\n\n\n它在有宝可梦存在的地方的概率应该比较高，在没有宝可梦的区域应该比较低。所以可以从概率比较高的部分进行抽样，生成新的数据。\n而估计概率这件事情可以使用高斯混合模型。高斯混合模型可以大概表示为下图的样子 \n\n\n\n其中黑线是高斯混合模型的概率密度曲线，它是由许许多多个高斯模型按照一定的权重混合得到的。那如何从这样的混合模型中进行采样呢？首先我们选取从组成高斯混合模型的若干个高斯分布中选择使用哪一个高斯分布，然后对于选定的某一个高斯分布，他有着自己的均值和方差 μm,Σm ，根据他的均值和方差，就可以从中采样。\n对于高斯混合模型中参数的估计，实际上可以利用数据通过EM算法进行估计。\n实际上，之前有讲过，对数据进行聚类的话，不如对数据进行分布式的表示，有多少的概率属于A，有多少的概率属于B等等……而本质上，VAE就是高斯混合模型的分布表示的形式。\n\n\n\n假设 z 服从某一个标准概率分布，从这样的分布中采样若干个点，其中 z 可能是一个多维的向量，每一个维度代表一个属性。以一个 1 维的高斯分布为例，我们从中采样出一个 z ，然后根据 z 决定所对应的高斯分布的均值和方差 μ(z),σ(z) ，在这里我们的 z 有无穷种可能，不想之前的混合模型中只是几种高斯模型的混合。所以现在给定了某一个 z 那么如何得到对应的均值和方差呢？这里我们假设均值和方差是通过一个函数得到的，就是说给定一个输入 z 就会得到一个均值和方差（实际上就是一个高斯分布）。所以可以认为它们是通过一个神经网络的均值和方差（也就是说输入一个 z 输出可一个对应的高斯分布）。所以 P(x) 的表示方式就如上图所示。\n在下面的这个用来采样的分布不一定非要是一个标准的高斯分布，可以是任何分布。因为NN是powerful 的，它可以通过神经网络得到。\n\nVAE存在的问题\nVAE主要的问题在于，他一直希望能够模仿已经存在的数字，而不是希望真正的生成一张图像，如下图所示：\n\n\n\n假设生成的图像与原始的图像只有一个像素的差距，这个像素的位置有如图中的两种可能，可以明显看出左侧的那个图是更现实的，而右侧的图明显比较假，但是对于VAE来说这两张图象之间的loss很有可能是一样的，所以才会导致这样的问题。为了解决这个问题，才有后文的 GAN 模型。\n\n生成对抗网络（GAN）\n大名鼎鼎的GAN是如何生成图片的呢？首先大家都知道GAN有两个网络，一个是generator，一个是discriminator，通过两个网络互相对抗来达到最好的生成效果。流程如下：\n\n\n\n主要流程类似上面这个图。首先，有一个一代的generator，它能生成一些很差的图片，然后有一个一代的discriminator，它能准确的把生成的图片，和真实的图片分类，简而言之，这个discriminator就是一个二分类器，对生成的图片输出0，对真实的图片输出1。\n接着，开始训练出二代的generator，它能生成稍好一点的图片，能够让一代的discriminator认为这些生成的图片是真实的图片。然后会训练出一个二代的discriminator，它能准确的识别出真实的图片，和二代generator生成的图片。以此类推，会有三代，四代。。。n代的generator和discriminator，最后discriminator无法分辨生成的图片和真实图片，这个网络就拟合了。\n\n","categories":["图像处理与机器学习"],"tags":["机器学习","深度学习"]},{"title":"无监督学习之邻域嵌入法（Neighbor Embedding）","url":"https://tanqingbo.cn/Neighbor-Embedding/","content":"流行学习（Manifold Learning）\n流行学习（Manifold Learning）是机器学习、模式识别中的一种方法，再维数简约方面具有广泛的应用。他的主要思想是将高维的数据映射到低维，使该低维的能够放映高维数据的某些本质特征。\n流行学习的前提使有一种假设，假设某些高维数据实际是一种低维的流行结构嵌入再高维空间中。流行学习的目的是将其映射回低维空间中，揭示其本质。\n下图可以特别形象的解释流行学习：\n\n\n\n因为只有在同一维中，欧式距离才具有比较的意义，在上面这样的高维空间中式欧式距离并不能将不同的点进行很好的区分。\n在流行学习中认为上面这种情况实际上是将低维数据强行塞进了一个高维空间，所以我们应该将这个高维数据摊平，以便于后面的聚类或者接下来的有监督学习。更常用的应用是将它们可视化。\n接下来将依次介绍如下几种常用的将高维数据进行降维的方法：\n局部线性嵌入（Locally Linear Embedding，LLE）.\n拉普拉斯特征映射（Laplacian Eigenmaps）.\nt分布随机邻居嵌入（T-distributed Stochastic Neighbor Embedding，t-SNE）.\n\n\n\n局部线性嵌入（Locally Linear Embedding，LLE）\n如下图所示，首先对于某个数据点xi选择它附近若干个点xj，用wij代表xi和xj之间的关系，通过最小化下面的式子获得对应的权重：\n\n\n\n在这个式子中，对于某个数据点xi认为它可以通过它周围的所有点的线性组合进行标识，令所有的点xj的线性表示与实际点xi的距离最小，得到点之间的权重wij，然后用得到的权重wij进行降维。\n\n\n\n在找到wij之后，固定wij，然后通过上式找到对应的zj得到降维后的点。\n需要注意的是在这里对于整个降维过程并没有一个显示的表达，假如我们不知道x的具体值，只知道wij是可以进行操作的，另外还有一点需要注意的是，在邻域里选择几个xj点也是需要实验才能得到的一个超参数。\n\n\nK的值是选择的邻域点个数，如上图，当选择的邻域点数过少时，降维效果并不好，可能时因为无法表达点之间的关系；\n当邻域的点数过多时降维效果也不好，主要时因为这个方法的假设时基于局部线性假设，当选择邻域过大时，很有可能不满足局部线性的假设。\n\n拉普拉斯特征映射（Laplacian Eigenmaps）\n这是一种基于图的方法，首先根据数据点之间的相似性建立一个图，比如说相似性大于某个值就连接在一起，小于某个值就不连接。这时候如下图所示：\n\n\n\n这个时候两个点之间的距离就可以根据图上的连接来近似。\n\n\n这里使用有标签数据和无标签数据，其中无标签的数据的那一项更像是正则项，它刻画了标签到底有多平滑。将它应用到我们这里：\n\n\n\n但是仅仅有这个表达式是不够的，因为我们只需要将所有的z都集中在同一个点，就可以达到最小值，所以还需要对这个等式添加约束：\n\n\nt分布随机邻域嵌入（T-distributed Stochastic Neighbor Embedding，t-SNE）\n上面的方法确实可以对高维非线性数据进行降维，但是它们只强调了要将相似数据放在一起，并没有强调将不相关的数据分开，所以常常会出现如下现象：\n\n\n\n可以看到，相似的数据已经聚集在一起了，但是不同的数据也聚在一起，所以性能有局限性，这个时候就需要t-SNE了。\n具体的做法如下：\n\n\n\n\n\n对于降维之前的数据，计算两点之间的相似度，并将相似度进行归一化，对于降维之后数据点也是一样的。之后通过将两个之间的KL散度最小化得到降维之后的点向量。\n这里的相似度计算方法主要根据下面这种方式：\n\n\n\n\n\n其中原高维数据的相似性人根据RBF函数进行计算，这种距离的计算方式可以保证距离比较远的点之间相似性可以快速下降；\n在介绍t-SNE的相似性计算方法之前首先介绍SNE相似性的计算方法。SNE的相似性计算方法与之前的高维数据间的相似性的计算方法相同，但是t-SNE改用了下面的T分布的一种表达式，将两种计算相似性的方法曲线进行比较，我们可以知道，对于距离比较近的数据之间，它们经过计算相似性之后任保持着较为相近的距离，但是距离较远的点会变得更远，所以在保证将相似性的点放在一起的同时将不相同的点区分的较好，实验结果如下图所示：\n\n\n\n从上图可以看到不同数据之间区分的很开。\n\n注意很少直接对高维数据进行t-SNE降维，因为计算高维数据之前，你的相似性是十分难确定的，因此首先利用常用的线性降维方法降维进行降维（如PCA），之后再利用t-SNE进行降维。\n\n\n","categories":["图像处理与机器学习"],"tags":["机器学习","深度学习"]},{"title":"无监督学习之词嵌入or词向量(Word Embedding)","url":"https://tanqingbo.cn/Word-Embedding/","content":"为什么要使用词嵌入（Word Embedding）\n在词嵌入之前往往采用 1-of-N Encoding 的方法，如下图所示:\n\n\n\n使用这种1-of-N Encoding 的方法有两种缺点：\n\n词向量是正交的，因为正交的属性不能体现出相似属性的词之间的关系。\n这种方式编码的向量太长，若有10万个单词的话，就需要用长度为10万的向量进行编码，计算量和内存消耗都特别大。\n\n\n为了克服以上缺点，我们引入Word Embedding的方法。这种方法将词映射到高维之中（但是维数仍比 1-of-N Encoding 低很多），相似的词性的单词会聚集在一起，而不同词性 的单词会分开；每个坐标轴可以看作是区分这些单词的一种属性，比如说在上图中，横坐标可以认为是生物与其他的区别，纵坐标可以认为是会动和不会动的区别。\n\n因为在进行学习的过程中，我们只知道输入的是词的一种编码，输出的是词的另一种编码，但是并不知道具体应该是怎样的一种编码，**所以是Word Embedding无监督学习。 **\n\n\n词嵌入（Word Embedding）的两种方法\n词嵌入（Word Embedding）主要有基于统计（Count based ）和基于预测（Perdition based）的两种方法。\n\n基于统计（Count based ）的方法\n基于统计的主要思想是：两词向量共同出现的频率比较高的话，那么这两个词向量也应该比较相似。如下图：\n\n\n基于预测（Count based ）的方法\n在这里神经网络的输入是前一个单词 wi−1 的词向量（ 1-of-N Encoding ）形式，经过神将网络他的输出应该是下一个可能出现的单词 wi 是某一个词的几率，因为是 1-of-N Encoding 形式，所以输出的每一维代表是某一个词的概率。然后取第一层的权值输入 z 作为词向量。如下图：\n\n\n\n在实际使用中，往往找的不仅仅是一个词与下一个词之间的关系，而是通过前面一堆词推出后面的一个词，在训练的过程中有类似于权值共享的行为，如下图所示：\n\n\n\n其中我们可以看到位于相同位置的输入神经元有着相同的权值（在途中用相同颜色的线表示出来），这样做的原因主要保证两点，首先在要保证对于在同一批输入的同一个位置的单词具有同样的编码（即相同的权重）；\n\n其次权值共享可以减少模型中参数的个数。\n\n那么如何保证在训练的过程中它们具有相同的权重呢？如下图所示：\n\n\n\n\n在梯度更新的过程中，首先对共享的权值参数设置相同的初始值，其次在更新的过程中不仅仅要减去自己对应的梯度，还应该减去另一个相同位置神经元的梯度，保证两个参数之间的更新过程是相同的。\n\n除了可以根据之前的词推出后面的词，还可以根据两边的词推出中间的词，或者从中间的词推出两边的词，如图：\n\n\n\n\n在这里虽然用了神经网络，但是并没有用deep learning，而只是用了一层的 linear hidden layer，主要是因为过去虽然有用过deep的方法，但是很难训练，并且实际上用一层就可以达到的效果。\n\n","categories":["图像处理与机器学习"],"tags":["机器学习","深度学习"]},{"title":"【无监督学习之线性降维】Unsupervised Learning-Linear Dimension Reduction","url":"https://tanqingbo.cn/Unsupervised-Learning-Linear-Dimension-Reduction/","content":"介绍\n本节主要介绍了两种线性降维的方法：Cluster和PCA,并从两个角度解释了PCA。\n\n聚类(Cluster)\n聚类的基本思想是将数据集中的样本划分为若干个通常是不相交的子集，每个子集称为一个**”簇”(cluster)**。K均值算法（K-means）\n\n\n随机初始化K个样本(点)，称之为簇中心(cluster centroids)；\n簇分配: 对于所有的样本，将其分配给离它最近的簇中心；\n移动簇中心：对于每一个簇，计算属于该簇的所有样本的平均值，移动簇中心到平均值处；\n重复步骤2和3，直到找到我们想要的簇.\n如下图演示了特征量个数和簇数均为2的情况：\n\n\n分层凝聚聚类（Hierarchical Agglomerative Clustering,HAC）原理\n顾名思义就是要一层一层地进行聚类，可以从下而上地把小的cluster合并聚集，也可以从上而下地将大的cluster进行分割。似乎一般用得比较多的是从下而上地聚集，因此这里我就只介绍这一种。\n所谓从下而上地合并cluster，具体而言，就是每次找到距离最短的两个cluster，然后进行合并成一个大的cluster，直到全部合并为一个cluster。整个过程就是建立一个树结构，类似于下图。 \n\n\n\n层次聚类最大的优点，就是它一次性地得到了整个聚类的过程，只要得到了上面那样的聚类树，想要分多少个cluster都可以直接根据树结构来得到结果，改变cluster数目不需要再次计算数据点的归属。层次聚类的缺点是计算量比较大，因为要每次都要计算多个cluster内所有数据点的两两距离。另外，由于层次聚类使用的是贪心算法，得到的显然只是局域最优，不一定就是全局最优，这可以通过加入随机效应解决，这就是另外的问题了。\n\n主成分分析(Principle Component Analysis,PCA)\nPCA降维原理可以从两个角度来考虑：\n基于最大方差原理，样本点在这个超平面上的投影尽可能分开。\n基于最小化误差原理，样本点到这个超平面距离都足够近。\n\n\n\n基于最大方差原理\n需要找到一个投影矩阵W，使得x在W上的投影方差尽可能大，其中W是由多个向量组成，其中W是由多个向量组成(w1,w2,w3…),希望x在w1上的投影的方差最大，w2上的投影的方差其次…..依次类推。\n\n\n\n并且，W是一个单位正交矩阵，即（w1,w2,w3,…）相互正交，且都是单位向量。\n\n\n\nPCA达到的效果就是decorrelation（去关联），所以最后投影之后得到z的协方差矩阵D是对角矩阵； \n投影矩阵W是单位正交矩阵。\nW就是x协方差矩阵S的特征向量。\n\n\n\n\n基于最小化误差原理\n基本思想：将近似看成由多个u组成，求解最小化他们之间的error时的系数c和分量u。\n其中向量(u1,u2,u3…)表示一个Basic component,如下图：\n\n\n\n为了求解c和u（component），可以将X做奇异值分解SVD，用分解后的U代替u，ΣxV代替系数c其中U就是XXT的特征向量 \n有时候只选取特征值比较大的component。\nPCA相当于只含一层hidden layer的网络。\n\n\nPCA与LDA(Linear Discriminant Analysis)的比较\nPCA是无监督的，LDA是有监督的；\nPCA基本思想是方差最大，LDA基本思想是让不同类别分的尽可能开；\nPCA和LDA都是线性映射；\n对于结构比较复杂的降维，只能采用非线性流行学习比如局部线性嵌入(Locally Linear Embedding，LLE)等方法.\n\nPCA和非负矩阵分解(Non-negative Matrix Factorization,NMF)比较\nNMF分解之后的component的系数都是正的，就拿image来说，也就是说分解之后的component像是原始image的一部分;\n而PCA的系数可正可负，涉及到component的“加加减减” .\n\n","categories":["图像处理与机器学习"],"tags":["机器学习","深度学习"]},{"title":"机器学习之半监督学习（Semi-supervised learning）","url":"https://tanqingbo.cn/Semi-supervised-learning/","content":"介绍\n什么是半监督学习？既有有标记数据 xr，又有无标记数据 xu，一般无标记数据的数量远大于有标记数据。半监督学习又可以分为两种：\n**Transductive learning:**无标记数据就是Testing data.\n**Inductive learning:**无标记数据不是 testing data，假设在训练时不知道 testing set.\n\n\n为什么要用半监督学习（Semi-supervised learning）？\n因为收集数据比较容易，但是收集label数据的代价却很昂贵。半监督学习下的 generative model\n\n\n为了更直观的了解半监督学习下的生成模型，我们先介绍一下全监督学习下的生成模型，好让大家有个对比。\n\n全监督学习下的生成模型\n首先，估计 prior probability P(Ci)，再估计出每一类有标记数据的分布 P(x|Ci)，假设数据的分布为共用协方差矩阵的高斯分布，因此只需要估计出就行，之后就可以估计某个数据属于某一类的概率了，计算公式如下：\n\n\n半监督学习下的生成模型\n前面部分与监督学习的操作一样，先使用有监督的数据估计出 P(Ci)、μi 和 Σ，接下来使用未标记的数据 xu 来对这些参数重新估计，以二分类问题为例，估计过程主要分为如下两个步骤：\n初始化 θ={P(C1),P(C2),μ1,μ2,Σ}，（可以随机初始化，也可以根据已有的标记数据估计出来）。\nstep1：根据初始化的参数计算无标记数据的后验概率Pθ(C1|xu) 。\nstep2：更新模型参数：\n\n\n\n\n\n接着再返回step1，直到参数收敛为止。\n其实上面这个过程，我们用到了再机器学习领域一个超级NB的算法的思想，它就是EM(Expectation-maximization),step1就是 E，step2就是 M. 这样反复下去，在最终一定会收敛.\n\n半监督学习之低密度分离假设（Low-density Separation）\n在用这个假设的时候，需要假设有一个很明显的区域(Low-density),能够把数据分开。Self-training\n先对有标记数据训练出一个模型f*,这个可以模型可以用任何方法训练。\n用这个 f∗ 来预测无标记的数据，预测出的就叫 pseudo label.\n接下来，就用无标记数据中拿出一部分数据，放到有标记数据中，怎么选出这部分是自己定的，也可以对每一个数据提供一个权重。新加入了这些数据之后，就可以再重新训练一个 f∗，往复进行。 \n这招用在 regression 中，是没有用的，因为用预测出来的数字重新用来做训练，并不会影响模型的参数。\n在做 self-training 时，其实就是把某个未标记数据指定一个分类，而在 generative model 中，其实就是把未标记数据对应于各个分类的概率计算出来。\n\n基于熵的正则化(Entropy-based Regularization)\n假如未标记数据数据 xu 经过某一组参数估计后属于某一类的概率如下：\n\n\n\n又边红圈中的公式为熵的计算公式。由上图可知 xu 属于某一类的概率越大，熵的值E就越小，因此重新定义损失函数，其中E(yu)可以微分，我们可以直接用梯度下降法来求解。\n\nSemi-supervised SVM\n将未标记数据穷举所有的分法，然后对每一种分法都进行 SVM，具有最大的间隔和最小误差的那一种。但是，如果有 10000 个未标记数据，那么就会有 210000 种分法来穷举，Transductive Inference for Text Classification using Support Vector Machines 中提出的解决办法是，每次只改一个数据，看一下能否让间距变大，变大了就改。\n\n平滑假设(smoothness assumption)\n做出如下假设：\nx的分布不均匀，在有些地方集中，有些地方分散，若x1和x2在一个high density region内很接近，那么 y^1 就与 y^2 相同，那么什么是high density region呢？请看下图：\n\n\n\n\n\n在图中，虽然x2与x3比较接近，但是x1与x2在同一块high density region，所以 y^1 与 y^2 相同,y^2 与 y32 不相同。\n\n基于图的方法(Graph-based Approach)\n首先需要定义相似度，一般可以用 Gaussian Radial Basis Function (RBF) 来定义：，这个函数可以让相似度随着距离的增加而迅速减小。 \n定义完相似度之后，就可以逐渐把数据点之间相连的边加上去，加边可以用 kNN 或者 e-Neighborhood 的方法来做。然后设置边的权重，和 s(xi,xj) 成比例。 \n然后，定义在图上的标记的平滑因子(smoothness)S:，该式可以写成 ，y 是 R+U 维的向量（所有的有标记和无标记数据），L=D−W，W 是所有数据之间两两的连接权重，D 是对角矩阵，对角线上的值是每个数据点所有的连接的权重之和。之后，就可以定义出 loss function:\n\n\n","categories":["图像处理与机器学习"],"tags":["机器学习","深度学习"]},{"title":"Deep Learning","url":"https://tanqingbo.cn/Deep-Learning/","content":"深度学习的三个步骤\n建立函数集合，即建立神经网络模型；\n训练模型；\n找出对数据表现最好的参数，作为模型的参数。\n\n\n全连接前向网络\n输入向量x与第一层神经元相连，将wx+b（其中w与权重，b为变差）经过激活函数（sigmoid或其它函数）的运算得到的结果作为下一层的输入，如此一直运算下去，直到得到整个网络的输出，该种模型称为全连接前向网络。如下图：\n\n\n\n可以把不带权重和偏差的网络结构当作一个函数集合，通过训练学习到参数的网咯可以当作针对某一数据集的best函数。\n矩阵运算：\n网络的输入为一个向量X,对应的权重w是一个矩阵，因此在网络中的运算通常都是矩阵运算。\n\n\n\n\n\n因为时矩阵运行，可以通过并行计算的技术加速运算速度。\n\n交叉熵（Cross-Entropy）\n介绍交叉熵之前，需要先介绍一下信息量。举个例子：\n\n可以理解为，一个事件发生的概率越大，则它所携带的信息量就越小，而当p(x0)=1时，熵将等于0，也就是说该事件的发生不会导致任何信息量的增加。举个例子，小明平时不爱学习，考试经常不及格，而小王是个勤奋学习的好学生，经常得满分，所以我们可以做如下假设：事件A：小明考试及格，对应的概率P(xA)=0.1，信息量为I(xA)=−log(0.1)=3.3219事件B：小王考试及格，对应的概率P(xB)=0.999，信息量为I(xB)=−log(0.999)=0.0014可以看出，结果非常符合直观：小明及格的可能性很低(十次考试只有一次及格)，因此如果某次考试及格了（大家都会说：XXX竟然及格了！），必然会引入较大的信息量，对应的I值也较高。而对于小王而言，考试及格是大概率事件，在事件B发生前，大家普遍认为事件B的发生几乎是确定的，因此当某次考试小王及格这个事件发生时并不会引入太多的信息量，相应的I值也非常的低。\n熵其实是信息量的期望值，它是一个随机变量的确定性的度量。熵越大，变量的取值越不确定，反之就越确定。\n\n\n因此深度学习网络中，损失函数的网络就可以有交叉熵来定义，值越小，确定性越大，越准确。\n\n\n\n\n目标便是寻找一组最优的参数，使损失函数L最小，使用的方法就是我们熟悉的Gradient Descent。\n\n","categories":["图像处理与机器学习"],"tags":["机器学习","深度学习"]},{"title":"深度神经网络(DNN)详解","url":"https://tanqingbo.cn/DNN/","content":"\n当我们训练网络的时候，通常会出现如下两种情况：\n第一种情况：训练数据表现不好，这种时候通常可以使用新的激活函数，或者调整学习率。\n第二种情况：训练数据表现的很好，但是测试数据的表现很差，这个时候可以提前终止、数据正则化和Dropout的方法来改善情况。\n\n\n\n\n\n不一定网络越深，performance越好。\n接下来我们先讨论针对以上两种情况，具体如何改善：\n对于训练数据表现不好时，用新的激活函数（New Activation function），再讨论**调整学习率(Adaptive Learning Rate)**。\n训练数据表现的很好，但是测试数据的表现很差时：提前终止、数据正则化和Dropout的方法来改善情况。\n\n\n\n第一种情况之激活函数梯度消失问题\n网络在做梯度下降时，如果我们用sigmoid作为激活函数，在接近输出的地方梯度很大，学习速度快，通过反向传播，在接近出入层的地方，梯度会变得很缓，学习效率很慢。这就是梯度消失的问题。\n因为sigmoid在接近0和1的地方会突然变得很缓慢。如图：\n\n\n\n为了解决这个问题，我们引入其它激活函数。\n\n整流线性单元（ReLU）\n很自然的，我们会想到能不能引入一个变换均匀的激活函数，这样就能减缓梯度消失的问题了。于是我们引入了ReLU,它的函数图像如下：\n\n\n\n小于0的部分函数值为0，大于0的部分函数为a=z。\nReLU的变种，有人觉得z值小于0的部分函数值为0，这个还是不好，没有梯度了。于是引入ReLU的变种。令z&lt;0的部分函数值为a = αz,其中α 也可以根据gradient descent学习出来，这样激活函数就变得更加合理了，可以在一定程度上减少训练时间。函数图像如下：\n\n\nMaxout\n顾名思义，输出最大值，使用这种激活函数时，需要两个及以上结点组成一组，从下图中我们可以看出Maxout是如何工作的。\n\n\n\nMaxout是可学习的激活函数，它可以是任何分段线性凸函数。有几段取决于每一组中元素的个数。\n\n\n第一种情况之学习率\n前面在讲梯度下降的时候讲到了Adagrad的方法，就是将每个参数的学习率除以其先前导数的均方根当作步长，在深度神经网络中，要介绍一种与Adagrad类似的学习率调整方法：RMSProp。\n\nRMSProp\n使用RMSProp方法的权值更新公式如下：\n\n\n\n可以通过调整α使得下一次的权值调整是受当前梯度倒数gt的影响都一些还是受前面的调整多一些。如果α接近0，则受当前梯度倒数gt影响多一些。\n而且α的值还可以通过gradient descen的方法学习出来。\n但是这种方法很难找到全局最优值，通常在遇到局部最优点的时候就停止了。\n\n动量(Momentum)\n现实生活中，当一个球从高处滚落下来，在遇到平坦处和低谷处时，由于惯性的原因有可能还会继续滚动，直到到达全局最低点的位置。因此在机器学习中，通过学习率更新权值时，能不能也引入一个惯性，使迭代到达局部最优时，还有有一个动量继续向前，直到到达全局最优呢？\n基于这个想法，接下来开始Momentum方法：使移动的方向不仅基于当前求导的方向，还要参考上一次移动的方向。参数的更新过程如下：\n\n\n\n加入了动量之后权值更行的过程中运动轨迹如下，在遇到平坦处和低谷时，由于受到上一次方向的影响，还会继续向前。\n\n\n\nAdam：RMSProp + Momentum称为Adam。\n\n第二种情况Early Stopping\n网络在训练的过程中，可能训练的时间越长，对Training set的performance就越好，但是用训练时间很长得到的参数作用于Testing set时，有可能并不会得到预期中的好结果，反而提前结束训练得到的参数作用于Testing set能得到相对满意的结果。\n\n\n\n所以我们在训练时，有时需要提前结束，至于到底什么时候结束，我们也不清楚，这个时候，验证集的作用就体现出来了。\n在Training set分出一部分数据用来做Validation set，当获得的参数在Validation set取得好结果的时候，就停止训练，再将参数作用于Testing set。\n\n正则化(Regularization)\n权值更新公式如下：\n\n\n\n其中sgn(x)时符号函数，x为正数时值为1，x值为负数时，值为-1，x为0时，值为0.\n\nDropout\n在每次训练之前，都摘掉p%和神经元，如下图所示：\n\n\n\n这样训练没循环一次我们都是使用新的网络结构在训练。如果训练时神经元的摘除率为p%，则最后所哦于权值都乘以1-p%。\n假设dropout rate为50%，如果通过训练得到的权值为w=1，则最后令w=0.5作用于Testing set。\n\n","categories":["图像处理与机器学习"],"tags":["机器学习"]},{"title":"机器学习之判别模型(Discriminative model)和生成模型(Generative model)","url":"https://tanqingbo.cn/Discriminative-and-Generative-model/","content":"前言\n前面讲的都是用线性回归模型预判某件事是否会发生，这一节讲回归用于分类。\n\n二分类问题\n我们以二分类为例子，定义模型输出大于0时，属于class1，小于0时属于class2.此时如果我们依然用y=b+wx作为我们的回归方程的话，就会出现如下的问题：\n\n\n\n当样本如图一所示的时候，程序能够很准确找出两类的边界，但是样本是像图二分布的话，程序找出来的分界线就会像紫色线那样，&gt;&gt;1的样本会被当成误差很大的样本点，实际上在分类问题中这类样本并不属于误差点。\n因此在分类问题中我们需要重新寻找模型函数，使得输入为样本x，F输出为为类别class，这类模型可以用感知器(perceptron)和SVM,但我们今天先讲另外一种模型。\n损失函数L可以定义为错误分类的次数，即L越小，分类错误数越小。如图：\n\n\nGaussain Distribution and Bayes’s theorem\n我们假设已知的训练样本满足高斯分布(Gaussain Distribution),当然假设样本时其他分布也行，比如二值特征还可以用伯努利分布(Bernoulli Distribution),但是在现实中高斯分布比较常见，我先假设样本满足高斯分布，可以减少工作量。高斯分布函数如下：\n\n\n\n由高斯函数求出来的是样本的先验概率P(X|C1)，根据贝叶斯(Bayes)公式：\n\n\n\n我们就能求出样本的后验概率P(C1|X)，即测试样本的概率。现在我们的问题就转化为根据训练样本求高斯函数的参数,一般我们采用最大似然估计法(Maximum Likelihood)求解这两个参数。有关最大似然估计法(Maximum Likelihood)可以参考我的这篇文章：从最大似然估计|贝叶斯估计|EM算法浅解|线性判别分析。\n我们整理一下上图的后验概率公式，可以得到一个sigmoid函数：\n\n\n\n把高斯函数代入z中，经过一系列的数学变换，可以把Z整理成wx+b的形式。 其中的w与b和前面用最大似然估计求出来的有关。求出来的结果如下：\n\n\n\n整理成wx+b的形式了大家是不是已经很熟悉了，因为我们在前面的线性回归案例中用的回归方程就是这种形式啊，那么是不是我们也可以用Gradient Descent的方法来求w与b呢，整最大似然法不是舍近求远了吗？\n这两种求w与b的方法分别对应我们题目所说的判别模型(Discriminative model)和生成模型(Generative model)，说了这么多，终于提到了和文章标题有关的东西了好难啊！用Gradient Descent的是判别模型，用最大似然法求解高斯参数的是生成模型。Logistic Regression\n上面的回归过程我们大致可以这样描述：某个事物有i个属性组成一个vector:(x1,x2,…,xi)，在某个节点处进行wx+b操作，得到的结果作为sigmoid函数的输入，函数的输出为即为事物的类别。我们把这整个这一组合的操作定义为函数f(x),过程如图：\n\n\n\n假设已知w与b,给定一组Training data的特征和标签如下：\n\n\n\n则上图的序列出现的概率为，如果我们的模型越准确，则这个概率值越大，对其取反就变成模型越准确，值越小，正好满足loss function的要求。因此我们对前面的公式取反整理一下就变成：，从下图我们可以看出Logistic Regression与Linear Regression的异同：\n\n\n\n到这一步的时候，问题就来了，为什么我们不能像Linear Regression一样用均方根差当作误差呢？我们用均方根差当作误差当作我们的loss function：\n\n\n\n这样求偏导的时候，会出现如下情况，当超级接近目标时，梯度方向导数为0，即停止迭代。但是距目标超级远的时候也会出现梯度方向导数为0的情况，这就是我们不想要的结果了。所以在逻辑回归时，不能使用均方根差当作误差。数学推导过程如下：\n\n\n判别模型(Discriminative model) VS 生成模型(Generative model)\n我们用相同的Training data，分别用判别模型(Discriminative model) 和 生成模型(Generative model)求出w和b。然后比较他们的perfermance,实验结果为，生成模型模型准确率为：73%，判别模型准确率为79%。\n\n生成模型的优点\n因为训练前假设了数据分布模型，可以用较少的数据量训练出性能比较好的模型；\n因为训练前假设了数据分布模型，使其对噪音更加具有鲁棒性；\n\n判别模型的优点\n通过学习大量的Training data，一般准确率要略高于生成模型。\n\n","categories":["图像处理与机器学习"],"tags":["机器学习"]},{"title":"机器学习之梯度下降方法优化","url":"https://tanqingbo.cn/Gradient-descent-optimization/","content":"前言\n上一节《机器学习之回归案例研究》中简单介绍了回归方程和过拟合。这一节详细介绍一下梯度下降法。learning rate\n学习率n与梯度下降的步长有关，若步长太短，则收敛数据太慢，若步长太长，则有可能错过错误率最低的点。如下图：\n\n\n\n图中黄色与绿色的步长便错过了最小的误差点。\n因此有一个简单的想法：为了不错过最小的误差点，同时还保持一定的收敛效率，我们可以对学习率做如下操作：\n在开始时，我们里目标很远，斜率比较陡的时候，设置学习率大一点；\n等快要接近目标时，便减少学习率，以免跳过目标点，因此可以将学习率n定义为迭代次数t的函数，如下图：\n\n\n\n\n\n但是又有一个问题，如果用这一个规则的学习率去求解所有回归问题问题的参数有点不太合理，能不能将参数w、b和学习率n的函数结合起来共同设置步长，这样处理不同问题的时候，更能适应相应的场合。Adagrad Gradient Descen\n将每个参数的学习率除以其先前导数的均方根。如图：\n\n\n\n图中gt为损失函数的导数，看着是不是很不厉害的样子，但是却有一个矛盾的地方，在前面我们讲在开始时，我们里目标很远，斜率比较陡的时候，设置学习率大一点，等快要接近目标时，便减少学习率，以免跳过目标点。\n可是在上图的公式中，gt很大时，步长的分母也很大，即步长很小，这与上面的叙述看起来矛盾，如图：\n\n\n\n这为什么呢？什么原因要这样设置呢？直观的原因时造成反差效果，在某次迭代中，gt可能会由某个很小的值变成一个特别大的值，或者由某个很大的值突然变成一个很小的值。如图：\n\n\n\n这还有一个疑问，大的梯度，真的需要大的步长吗？我们看一个图：\n\n\n\na点的梯度比c点的梯度小，但是很明显a点距最优点比c点距最优点要远，所以不一定就是大的梯度对应大的步长。\n假设上图中，a的横坐标为x0，曲线方程为y=ax^2 + bx + c。则a点到最优点的步长为：\n\n\n\n其中(2ax+b)为y的一阶导，2a为y的二阶导。因此我们有理由假设最优步长等于损失函数的一阶导除以二阶导，再乘以学习率n。但是对于很多比较复杂的损失函数来说，求二阶导的计算量非常大，因此我们用先前导数均方根的和近似二阶导，如图所示：\n\n\nStochastic Gradient Descen\nStochastic梯度下降法是每计算一次样本更新一次参数，而普通梯度下降法是计算所有的样本之后才更新参数。\n\n\nFeature Scaling\n当样本的两个特征数值规模相差有点大时，为了节省训练时间，可以先对样本特征正则化，再进行训练。\n正则化的公式如下：\n\n\n\n其中xi为每个对应特征的样本值，mi为样本均值。\n\n","categories":["图像处理与机器学习"],"tags":["机器学习"]},{"title":"机器学习之Bias and Variance","url":"https://tanqingbo.cn/Bias-and-Variance/","content":"前言\n在上一节《机器学习之回归案例研究》中说过，在机器学习的模型中并不是越复杂越好，也不是越简单越好，都有可能在Testing data上造成较大的误差。那么这些误差到底是怎么造成的呢？我们这一节来讨论一下。\n\nBias and Variance of Estimator\n假设Testing data样本的均值为u,模型估计出来的均值为m,则u与m之间的距离为偏差（bias），设模型估计出来的标准差（Variance）为s。\n因为没有100%准确的模型，所以u不等于m.\n模型估计有点类似于打靶，虽然每个model瞄准的都是靶心，但是实际射中的地方一般都是距靶心有一定的距离，而我们要做的工作就是寻找一个方法使我们射出的目标距靶心更近。如下图所示：\n\n\n\n从下图我们可以得知，一般简单的模型都会有small Variance but large Bias的情况，而复杂的模型通常会有small Bias but large Variance，而且简单的模型受数据量的影响较少。\n\n\nUnderfitting and Overfitting\nUnderfitting:**如果如果模型不能拟合训练样本，产生较大的偏差，称为Underfitting**。\nOverfitting:**如果模型可以拟合训练数据，但是在Testing data上有较大的误差，则是Variance较大的原因，称为Overfitting**。\nOK！现在我们知道了模型估计偏差（bias）较大和标准差（Variance）分别是由什么原因引起的了，下一步我们就可以对症下药，根据不同情况做不同的调整了。\n对于Large Bias，也就是Underfitting，我们通常做如下处理：\n重新设计模型方程；\n增加更多的特征作为输入；\n设计一个更复杂的模型。\n\n\n对于Large Variance，也就是过拟合，我们通常做如下处理：\n增加训练数据，使模型学习到更多的特征；\n训练之前对数据进行Regularization（正则化），以减少Variance（标准差）。\n将训练集分为Training set and Validation set,如下图所示：\n\n\n\n \n\n将training set分成3份，一次让其中2份Training，一份用来验证(Validation)，最后让每一份都当作一次验证集，求出3次训练的平均误差，取模型中平均误差最小的模型去处理测试集。\n\n","categories":["图像处理与机器学习"],"tags":["机器学习","Keras"]},{"title":"机器学习之线性回归案例研究","url":"https://tanqingbo.cn/Linear-regression-of-machine-learning/","content":"前言\n在机器学习中，回归则是根据样本研究其两个（或多个）变量之间的依存关系，是对于其趋势的一个分析预测。\n比如说根据当前的股市行情预测接下来的股票走势；\n根据消费者过去的消费习惯预测他将来会购买某物；\n\n\n\n样例分析\n根据当前pokemon的cp值以及其他属性，预测它进化之后的cp值。Step1：create Model（创建模型）\n建立回归方程，假设方程为线性的：\n\n\n\n其中xi为pokemon的特征（feature），wi:权重(weight);b:偏差(bias)；y为预测的升级之后pokemon的Cp值。\n假设现在只考虑pokemon当前cp值这一个feature，于是方程可以变成：\n\n\n\n现在问题变成如何找到偏差b与权值w使得预测出来的y接近真实值y，首先想到的是穷举负无穷到正无穷之间的数，从而找到最优的b和w.这显然不可能。于是，我们想能不能从已有的真实数据集上学习出我们想要的偏差b与权值w？step2:loss function（损失函数）\n假设我们已经知道了，10组pokemon的cp值以及升级后的cp值，根据回归方程，我们定义损失函数L。\n\n\n\n损失函数L的结果等于真实值减去方程预测出来的值，上图红线部分为预测值，显然L是w和b的函数，现在我们的目标变成寻找使损失函数L最小的w和b。Step 3: Gradient Descent（梯度下降）\n这回我们当然不能再用穷举法求w和b了。我们可以用一个稍微高级一点的方法了，叫做梯度下降法，我们先以单个变量讲解度下降法，先只考虑W。\n\n\n\n图为损失函数L的曲线，只需要找到使L最小的W值，在图中可以很容易的看出，L的最小值在谷底取得，但是我们不知道此时W取何值，所以需要先随机初始化w，再沿着曲线下降的方向慢慢调整w,直到L取到最小值，此时的w就为我们求的w.\n曲线下降，我们很容易想到该点的斜率，即斜率小于0，则曲线下降，可以加大w，斜率大于0，则曲线上升，减少w。\n斜率就是在该点求导咯，于是w可以按如下公式调整：\n\n\n\n这样我们就能相对快一点找到使L最小的W了。\n刚刚只是考虑W一个参数，考虑w和b两个参数的话，就让L同时对w和l求偏导，再按偏导符号调整就可以了。如图：\n\n\n\n如下公式即位损失函数L的梯度：\n\n\nover fitting（过拟合）\n当我们令回归方程为一次时，即方程形式如下：\n\n\n\n用梯度下降的方法求出b和w,再去预测pokemon的测试数据时，平均误差为35.当我们将回归方程设为2次时：\n\n\n\n用梯度下降法求出W和b,再去预测pokemon的测试数据时，平均误差为18.于是猜想是不是回归方程的次数越高，对测试数据的预测就越准确呢？\n\n\n\n上图分别是当回归方程是2、3、4、5次时，回归方程预测的曲线图，最后一张是对training data 和 testing data的误差，由图可知，虽然回归方程越复杂，对训练数据效果越好，但是对测试数据可能会更差，这就是over fiting。\n\n","categories":["图像处理与机器学习"],"tags":["机器学习","Keras"]},{"title":"经典必读，程序是怎么跑起来的","url":"https://tanqingbo.cn/How-does-the-program-run/","content":"给大家推荐一本程序员必看的书—《程序是怎么跑起来的》，本书从计算机的内部结构开始讲起，以图配文的形式详细讲解了操作系统和应用程序的关系，目的是让读者了解从用户双击程序图标到程序开始运行之间到底发生了什么。\n可以先看一下目录：\n\n作者用图文并茂的方式通透地解说了软硬件如何支撑程序运作起来，相对于指导实践的书，这本阐明基础逻辑和原理的书，个人觉得真正起到了授之以渔的作用。\n\n在把这本书免费分享给大家，戳下面的链接可以下载：\n链接：https://pan.baidu.com/s/1LXxYyBo8-5QFDZ3YFjNJew提取码：dj0c需要的朋友自行下载就好了~\n","categories":["编程资料"],"tags":["操作系统"]},{"title":"keras新手指南","url":"https://tanqingbo.cn/keras-beginner-guide/","content":"一些基本概念\n张量：张量可以看作是向量、矩阵的自然推广，我们用张量来表示广泛的数据类型。\n\n张量的阶数有时候也称为维度，或者轴，轴这个词翻译自英文axis。譬如一个矩阵[[1,2],[3,4]]，是一个2阶张量。\n\n函数式模型：\n\n在Keras 0.x中，模型其实有两种，一种叫Sequential，称为序贯模型，也就是单输入单输出，一条路通到底，层与层之间只有相邻关系，跨层连接统统没有。这种模型编译速度快，操作上也比较简单。\n第二种模型称为Graph，即图模型，这个模型支持多输入多输出，层与层之间想怎么连怎么连，但是编译速度慢。可以看到，Sequential其实是Graph的一个特殊情况。\n\n\nbatch：现在一般采用的是一种折中手段，mini-batch gradient decent，小批的梯度下降，这种方法把数据分为若干个批，按批来更新参数，这样，一个批中的一组数据共同决定了本次梯度的方向，下降起来就不容易跑偏，减少了随机性。另一方面因为批的样本数与整个数据集相比小了很多，计算量也不是很大。所以Keras的模块中经常会出现batch_size，就是指批的大小。\n\nepochs指的就是训练过程中数据将被“轮”多少次。\n\n\nBN层（batch normalize）、LN层（Layer Normalization）\n在BN中，是通过将activation规范为均值和方差一致的手段使得原本会减小的activation的scale变大。\n，在神经网络训练时遇到收敛速度很慢，或梯度爆炸等无法训练的状况时可以尝试BN来解决。另外，在一般使用情况下也可以加入BN来加快训练速度，提高模型精度。\nBN通过mini-batch的输入样本近似的计算normalize中的均值和方差，既同一个minibatch中的输入拥有相同的均值和方差。\nBN于LN不同的是，LN中同层中所有的神经元输入都拥有相同的均值和方差。\n在传统RNN中，recurrent unit经过累加求和后的输入（summed input）的量级会随着训练进行发生波动，导致梯度爆炸或梯度消失发生。加入LN之后，Normalization term会对summed input的进行尺度变换，使RNN在training和inference时更加稳定。\n实践证明，LN用于RNN进行Normalization时，取得了比BN更好的效果。但用于CNN时，效果并不如BN明显。\n\nWN层（weight normalization）\n对深度学习网络权值W进行normalization的操作公式如下：\n\n\n\n通过一个标量g和一个向量V对权重向量W进行尺度变换。标量g的值一般为||W||，即权重W的大小。\n如此便解耦了权重向量的范数和方向，加速了收敛，保证了gradient的稳定，不会爆炸或者消失；同时解决了BN的数据依赖性，计算开销也降低了许多；\n\n","categories":["图像处理与机器学习"],"tags":["机器学习","Keras"]},{"title":"关于keras模型","url":"https://tanqingbo.cn/about-keras-model/","content":"\nKeras有两种类型的模型，序贯模型（Sequential）和函数式模型（Model），函数式模型应用更为广泛，序贯模型是函数式模型的一种特殊情况。\n\n两类模型有一些方法是相同的：\n\nmodel.summary():打印出模型概况，它实际调用的是keras.utils.print_summary。\n\nmodel.get_config()：返回包含模型配置信息的Python字典。模型也可以从它的config信息中重构回去。\nconfig = model.get_config()model = Model.from_config(config)# or, for Sequential:model = Sequential.from_config(config)\n\n\n\n\n\n\n\nmodel.get_layer()：依据层名或下标获得层对象。\n\nmodel.get_weights()：返回模型权重张量的列表，类型为numpy array。\n\nmodel.set_weights()：从numpy array里将权重载入给模型，要求数组具有与model.get_weights()相同的形状。\n\nmodel.to_json：返回代表模型的JSON字符串，仅包含网络结构，不包含权值。可以从JSON字符串中重构原模型：\n  from models import model_from_jsonjson_string = model.to_json()model = model_from_json(json_string)\n\n\n\n\n\nmodel.to_yaml：与model.to_json类似，同样可以从产生的YAML字符串中重构模型。\n  from models import model_from_yamlyaml_string = model.to_yaml()model = model_from_yaml(yaml_string)\n\n\n\n\n\nmodel.save_weights(filepath)：将模型权重保存到指定路径，文件类型是HDF5（后缀是.h5）\nmodel.load_weights(filepath, by_name=False)：从HDF5文件中加载权重到当前模型中, 默认情况下模型的结构将保持不变。如果想将权重载入不同的模型（有些层相同）中，则设置by_name=True，只有名字匹配的层才会载入权重。\n\n","categories":["图像处理与机器学习"],"tags":["机器学习","Keras"]},{"title":"Keras解析之函数式（Functional）模型","url":"https://tanqingbo.cn/Functional-model/","content":"前言\nkeras的函数式模型接口是用户定义多输出模型，非循环有向模型或具有共享层的模型。只要你的模型多于一个输出，你就应该选择函数式模型。它是最广泛的一种模型。\n\n几个概念\n层对象接受张量为参数，返回一个张量；\n输入是张量，输出也是张量的一个框架就是一个模型，通过model定义。\n利用函数式模型的接口，我们可以很容易的重用已经训练好的模型：你可以把模型当作一个层一样，通过提供一个tensor来调用它。注意当你调用一个模型时，你不仅仅重用了它的结构，也重用了它的权值。\n这种方式可以允许你快速的创建能处理序列信号的模型，你可以很快将一个图像分类的模型变为一个对视频分类的模型。\n层“节点”的概念：\n无论何时，当你在某个输入上调用层时，你就创建了一个新的张量（即该层的输出），同时你也在为这个层增加一个“（计算）节点”。这个节点将输入张量映射为输出张量。当你多次调用该层时，这个层就有了多个节点，其下标分别为0，1，2…\n\n\n\n","categories":["图像处理与机器学习"],"tags":["机器学习","Keras"]},{"title":"Keras解析之序贯（Sequential）模型接口","url":"https://tanqingbo.cn/Sequential-model/","content":"前言\n序贯模型是多个网络层的线性堆叠，也就是“一条路走到黑”。\n\n可以向Sequential模型中传递Dense类构造给模型。\n\n我将以一段代码的形式先简单介绍一下如何用python编写Sequential模型。\n样例\n开始一个序贯模型一般有4个步骤：\n\n定义模型；\n通过compile对模型进行编译；\n准备训练数据；\n模型训练。\n\n\n在下面的代码中，我简单的介绍了一下这4个过程，详情请见注释：\n# 从keras中到入库from keras.models import Sequentialfrom keras.layers import Dense,Activation# 定义Sequential模型model = Sequential()model.add(Dense(32, activation='relu', input_dim=100))   # 全连接层model.add(Dense(1, activation='sigmoid'))     #激活函数# 通过compile对模型进行编译，编译的时候一般有三个参数optimizer、loss、metrics，后续会讲到model.compile(optimizer='rmsprop',\t\t\t  loss='binary_crossentropy',\t\t\t  metrics=['accuracy'])# 准备训练数据；import numpy as np  data = np.random.random((1000, 100))  # 生成一个1000*100的矩阵，数值在0～1之间labels = np.random.randint(2, size=(1000, 1))    # 为每一行加上0\\1标签# Train the model, iterating on the data in batches of 32 samplesmodel.fit(data, labels, epochs=10, batch_size=32)   # 将数据加入fit函数，epochs=10表示循环10次，批大小为32\nSequential模型方法\n在上面的代码中，Sequential模型方法的一些常见的方法基本都登场了，下面详细介绍一下这些方法以及参数的作用。\nadd\n向模型中添加一个层，如果需要多个层的话，就多add几次。\npop\n与add方法相对应，作用是弹出模型的最后一层。\n\n\ncompile\n用来编译模型，配置模型的学习过程。\ncompile方法有几个参数，含义分别如下：\noptimizer：定义优化器名或优化器对象，一般为字符串；\nloss：预定义损失函数名或目标函数；\nmetrics：指标列表，指标可以是一个预定义指标的名字,也可以是一个用户定制的函数.指标函数应该返回单个张量,或一个完成metric_name - &gt; metric_value映射的字典.典型用法是metrics=['accuracy']。\n\n\n\nfitfit(data, labels, epochs=10, batch_size=32, verbose=1, callbacks=None, validation_split=0.0, validation_data=None, shuffle=True, class_weight=None, sample_weight=None, initial_epoch=0)\n\ndata:输入数据。如果模型只有一个输入，那么data的类型是numpy array，如果模型有多个输入，那么x的类型应当为list，list的元素是对应于各个输入的numpy array.\nlabel:对应的data的标签。\nepochs：它就是训练的总轮数。\nbatch_size：指定进行梯度下降时每个batch包含的样本数。训练时一个batch的样本会被计算一次梯度下降，使目标函数优化一步。\nverbose：日志显示，0为不在标准输出流输出日志信息，1为输出进度条记录，2为每个epoch输出一行记录\ncallbacks：list，其中的元素是keras.callbacks.Callback的对象。这个list中的回调函数将会在训练过程中的适当时机被调用；\nvalidation_split：0~1之间的浮点数，用来指定训练集的一定比例数据作为验证集。验证集将不参与训练，并在每个epoch结束后测试的模型的指标，如损失函数、精确度等。\nvalidation_data：形式为（X，y）的tuple，是指定的验证集。此参数将覆盖validation_spilt。\nshuffle：布尔值或字符串，一般为布尔值，表示是否在训练过程中随机打乱输入样本的顺序。\nclass_weight：字典，将不同的类别映射为不同的权值，该参数用来在训练过程中调整损失函数（只能用于训练）。\ninitial_epoch: 从该参数指定的epoch开始训练，在继续之前的训练时有用。\nsample_weight：权值的numpy array，用于在训练时调整损失函数。\n\nevaluate\n本函数按batch计算在某些输入数据上模型的误差，其参数有：evaluate(self, x, y, batch_size=32, verbose=1, sample_weight=None)\nx：输入数据，与fit一样，是numpy array或numpy array的list\ny：标签，numpy array\nbatch_size：整数，含义同fit的同名参数\nverbose：含义同fit的同名参数，但只能取0或1\nsample_weight：numpy array，含义同fit的同名参数\n\npredict\n本函数按batch获得输入数据对应的输出，其参数有：train_on_batch(self, x, y, class_weight=None, sample_weight=None)\ntest_on_batch\n本函数在一个batch的样本上对模型进行测试predict_on_batch(self, x)\nfit_generatorfit_generator(self, generator, steps_per_epoch, epochs=1, verbose=1, callbacks=None, validation_data=None, validation_steps=None, class_weight=None, max_q_size=10, workers=1, pickle_safe=False, initial_epoch=0)\n利用Python的生成器，逐个生成数据的batch并进行训练。生成器与模型将并行执行以提高效率。例如，该函数允许我们在CPU上进行实时的数据提升，同时在GPU上进行模型训练.\n\nevaluate_generator\n本函数使用一个生成器作为数据源评估模型，生成器应返回与test_on_batch的输入数据相同类型的数据。该函数的参数与fit_generator同名参数含义相同，steps是生成器要返回数据的轮数。\n\npredict_generator\n本函数使用一个生成器作为数据源预测模型，生成器应返回与test_on_batch的输入数据相同类型的数据。该函数的参数与fit_generator同名参数含义相同，steps是生成器要返回数据的轮数。\n\n","categories":["图像处理与机器学习"],"tags":["机器学习","Keras"]},{"title":"医学图像分析中的深度学习调查","url":"https://tanqingbo.cn/Medical-image-analysis-deep-learning/","content":"一、前言\n深度学习算法：由许多层组成的网络，将输入数据（例如图像）转换为输出，同时学习越来越高级别的特征。\n迄今为止最成功的图像分析模型是卷积神经网络（CNN）。 CNN包含很多层，可以在很小程度上利用卷积滤波器来转换它们的输入。\n在计算机视觉领域，深度卷积网络现在已成为首选技术。医学影像分析界已经注意到这些关键的发展。但是，从使用手工功能的系统转换到从数据中学习功能的系统进度很慢。\n在AlexNet的突破之前，许多不同的学习功能的技术很受欢迎：它们包括主成分分析，图像补丁聚类，字典方法等等。\n第2节：介绍用于医学图像分析的主要深度学习技术；\n第3节：描述了深度学习对医学图像分析中典型任务的影响：分类，检测，分割，配准，检索，图像生成和增强；\n第4节：讨论了在不同应用领域获得的结果和开放挑战：神经，眼科，肺部，数字病理和细胞成像，乳房，心脏，腹部，肌肉骨骼和其他杂项应用。\n\n\n\n二、Overview of deep learning methods\n随机梯度下降的最大似然是目前最常用的拟合参数的方法。\n以无监督的方式（预训练）逐层训练DNN通过对堆叠网络进行有监督的微调，可以获得良好的性能。以这种方式训练的两种流行体系结构是堆叠自动编码器（SAE）和深度置信网络（DBN）。但是，这些技术相当复杂，需要大量工程才能产生令人满意的结果。\n目前，最受欢迎的模型是以受监督的方式进行端对端训练，极大地简化了训练过程。 最流行的体系结构是卷积神经网络（CNN）和递归神经网络（RNN）。 尽管RNN越来越受欢迎，但CNN目前在（医学）图像分析中应用最广泛。\nMLP与CNN的区别：\n网络中的权重以对图像执行卷积操作的方式共享，这样，模型不需要为在图像中不同位置出现的同一对象分别检测单独的检测器，从而使网络在输入的平移方面等同。它也大大减少了需要学习的参数的数量（即权重的数量不再取决于输入图像的大小）\n\n\n\nDeep CNN Architectures\nAlexNet或VGG等其他简单模型很受医学数据的欢迎。尽管最近的标志性研究都使用GoogleNet的一个名为Inception v3的版本\n将深度学习技术应用于医疗领域的挑战往往在于将现有架构适应于不同的输入格式，例如三维数据。 在CNN早期应用于这样的体积数据时，通过将感兴趣体积（VOI）分成切片并将其作为不同的流馈送到网络来规避全3D卷积和由此产生的大量参数。\n分割是自然和医学图像分析中的一项常见任务，为了解决这个问题，CNN可以简单地用于分别对图像中的每个像素进行分类，方法是在特定像素周围提取补丁。\n\nRecurrent Neural Networks (RNNs)\nRNN是为离散序列分析而开发的。 它们可以看作是MLP的泛化，因为输入和输出的长度都是不同的，这使得它们适用于诸如机器翻译这样的任务，其中源语言和目标语言的句子是输入和输出。\nRBMs是一种马尔科夫随机场（MRF），它构成输入层或可见层x =（x1; x2;：：; xN），隐层h =（h1; h2;：： ：; hM）携带潜在特征表示。 节点之间的连接是双向的，因此给定一个输入向量x，可以获得潜在特征表示h，反之亦然。\n最近，引入了两种新颖的无监督体系结构：变分自动编码器（VAE）（Kingma和Welling，2013）和生成对抗网络（GAN）（Goodfellow等，2014）。 目前还没有同行评议的论文将这些方法应用于医学图像，但在自然图像中的应用是有希望的。\nGPU的发展和开源软件包促进了深度学习在图像处理领域的发展。目前最流行的软件开源包有：\n**Caffe:**提供C ++和Python接口，由加州大学伯克利分校的研究生开发。\n**Tensorflow:**提供C ++和Python接口，由Google开发。\nTheano：提供python接口，由蒙特利尔MILA实验室开发。\nTorch：提供一个Lua接口。\n\n\n两个重要的深度学习库：\nLasagne：https://github.com/tqb4342/Lasagne；\nKeras：https://keras.io/。\n\n\n\nDeep Learning Uses in Medical Imaging分类\n转移学习本质上是使用预先训练的网络来尝试解决大数据集的需求。\n\n确定了两种转移学习策略：\n\n（1）使用预先训练的网络作为特征提取器，不需要训练深度网络，从而可以轻松地将提取的特征插入现有的图像分析流水线。；\n（2）对医疗数据的预先训练的网络进行微调。\n\n\n在最近的使用CNN的论文中，作者也经常从头开始训练他们自己的网络架构，而不是使用预先训练好的网络。\n\n在图像分类中，CNN是当前的标准技术。尤其是对自然图像进行预训练的CNN显示出惊人的强大成果，在一些任务中挑战了人类专家的准确性。\n\n但是在通用深度学习架构中，组合病变外观和病变位置信息，这种组合通常室不可能的，一些作者使用多流体系结构以多尺度的方式解决这个问题， Shen et al等人使用了三个CNN，每个CNN以不同比例的结节补丁作为输入。然后将三个CNN的结果特征输出串联起来形成最终特征向量。\n\n几乎所有最近的论文都倾向于使用经过端到端培训的CNN。\n\nCSAE和经典CNN之间的主要区别在于使用无监督预先训练和稀疏自动编码器。\n\n在对象注释生成训练数据昂贵的情况下，可以使用多实例学习（MIL）和深度学习的集成。\n\n\n分割\n分割的任务通常被定义为识别组成感兴趣对象的轮廓或内部的体素集。\n分割是将深度学习应用于医学成像的论文中最常见的主题；\n新型CNN架构中最着名的医学图像分析是由Ronneberger等人发表的U-net。U-net中的两个主要建筑创新是等量上采样和下采样层的组合。\nRNN最近在分割任务中变得越来越流行。\nfCNN也已扩展到3D。\n病灶分割可以看成对象检测和器官分割方法的混合。\n\n配准\n医学图像的配准（即空间对齐）是一种常见的图像分析任务，其中从一个医学图像到另一个医学图像计算坐标变换。\n当前文献中普遍存在两种策略：\n（1）使用深度学习网络来估计两幅图像的相似性度量以推动迭代优化策略;\n（2）使用深度回归网络直接预测变换参数。\n与分类和分割相比，研究界似乎还没有确定将深度学习技术整合到配准方法中的最佳方法。\n\n其它\n基于内容的图像检索（CBIR）是一种在大量数据库中进行知识发现的技术。\nCBIR方法开发中的主要挑战是从像素级信息中提取有效的特征表示，并将它们与有意义的概念联系起来。\n\n腹部\n大多数腹部文件旨在定位和分割器官，主要是肝脏，肾脏，膀胱和胰腺。\n要注意的是两个分割的挑战 - SLIVER07肝和PROMISE12前列腺。\n\n生物医学图像分析中的重大挑战\nhttps://grand-challenge.org/\n\n","categories":["图像处理与机器学习"],"tags":["机器学习"]},{"title":"Medical Data for Machine Learning","url":"https://tanqingbo.cn/Medical-Data-for-Machine-Learning/","content":"This is a curated list of medical data for machine learning.This list is provided for informational purposes only, please make sure you respect any and all usage restrictions for any of the data listed here.\nCT数据库\n癌症成像档案（TCIA）中的图像数据被组织成专门构建的集合。典型的收集包括来自几个科目（患者）的研究。在一些收藏中，每个主题可能只有一项研究。在其他收藏中，可能会随着时间的推移对主题进行跟踪，在这种情况下，每个主题都会有多项研究。受试者通常具有疾病和/或特定的解剖部位（肺，脑等）。  \nhttps://wiki.cancerimagingarchive.net/display/Public/Collections\n\n脑部MRI数据库（BrainWeb：模拟大脑数据库）\nhttp://brainweb.bic.mni.mcgill.ca/brainweb/selection_normal.html\n\n以下是Andrew L. Beam整理的网上医学公共数据库集\n链接：https://github.com/tqb4342/medical-data1. Medical Imaging DataThe National Library of Medicine presents MedPix®Database of 53,000 medical images from 13,000 patients with annotations. Requires registration.Information: https://medpix.nlm.nih.gov/home  \n\n\nABIDE: The Autism Brain Imaging Data Exchange: towards a large-scale evaluation of the intrinsic brain architecture in autism.Function MRI images for 539 individuals suffering from ASD and 573 typical controls. These 1112 datasets are composed of structural and resting state functional MRI data along with an extensive array of phenotypic information. Requires registration.Paper: http://www.ncbi.nlm.nih.gov/pubmed/23774715Information: http://fcon_1000.projects.nitrc.org/indi/abide/Preprocessed version: http://preprocessed-connectomes-project.org/abide/  \n\nAlzheimer’s Disease Neuroimaging Initiative (ADNI)MRI database on Alzheimer’s patients and healthy controls. Also has clinical, genomic, and biomaker data. Requires registration.Paper: http://www.neurology.org/content/74/3/201.shortAccess: http://adni.loni.usc.edu/data-samples/access-data/\n\nDigital Retinal Images for Vessel Extraction (DRIVE)The DRIVE database is for comparative studies on segmentation of blood vessels in retinal images. It consists of 40 photographs out of which 7 showing signs of mild early diabetic retinopathy.Paper: http://www.isi.uu.nl/Research/Publications/publicationview/id=855.htmlAccess: http://www.isi.uu.nl/Research/Databases/DRIVE/download.php  \n\nAMRG Cardiac AtlasThe AMRG Cardiac MRI Atlas is a complete labelled MRI image set of a normal patient’s heart acquired with the Auckland MRI Research Group ‘s Siemens Avanto scanner. The atlas aims to provide university and school students, MR technologists, clinicians…\nCongenital Heart Disease (CHD) AtlasThe Congenital Heart Disease (CHD) Atlas represents MRI data sets, physiologic clinical data and computer models from adults and children with various congenital heart defects. The data have been acquired from several clinical centers including Rady…\nDETERMINEDefibrillators to Reduce Risk by Magnetic Resonance Imaging Evaluation, is a prospective, multicenter, randomized clinical trials in patients with coronary artery diseases and mild-to-moderate left ventricular dysfunction. The primary objective…\nMESAMulti-Ethnic Study of Atherosclerosis, is a large-scale cardiovascular population study (&gt;6,500 participants) conducted in six centres in the USA. It aims to investigate the manifestation of subclinical to clinical cardiovascular disease before…\n\nOASISThe Open Access Series of Imaging Studies (OASIS) is a project aimed at making MRI data sets of the brain freely available to the scientific community. Two datasets are available: a cross-sectional and a longitudinal set.\n\nCross-sectional MRI Data in Young, Middle Aged, Nondemented and Demented Older Adults: This set consists of a cross-sectional collection of 416 subjects aged 18 to 96.  For each subject, 3 or 4 individual T1-weighted MRI scans obtained in single scan sessions are included.  The subjects are all right-handed and include both men and women.  100 of the included subjects over the age of 60 have been clinically diagnosed with very mild to moderate Alzheimer’s disease (AD).  Additionally, a reliability data set is included containing 20 nondemented subjects imaged on a subsequent visit within 90 days of their initial session.\nLongitudinal MRI Data in Nondemented and Demented Older Adults: This set consists of a longitudinal collection of 150 subjects aged 60 to 96. Each subject was scanned on two or more visits, separated by at least one year for a total of 373 imaging sessions. For each subject, 3 or 4 individual T1-weighted MRI scans obtained in single scan sessions are included. The subjects are all right-handed and include both men and women. 72 of the subjects were characterized as nondemented throughout the study. 64 of the included subjects were characterized as demented at the time of their initial visits and remained so for subsequent scans, including 51 individuals with mild to moderate Alzheimer’s disease. Another 14 subjects were characterized as nondemented at the time of their initial visit and were subsequently characterized as demented at a later visit.\n\nAccess: http://www.oasis-brains.org/ \n\nSCMR Consensus DataThe SCMR Consensus Dataset is a set of 15 cardiac MRI studies of mixed pathologies (5 healthy, 6 myocardial infarction, 2 heart failure and 2 hypertrophy), which were acquired from different MR machines (4 GE, 5 Siemens, 6 Philips). The main objectives…\nSunnybrook Cardiac DataThe Sunnybrook Cardiac Data (SCD) , also known as the 2009 Cardiac MR Left Ventricle Segmentation Challenge data, consist of 45 cine-MRI images from a mixed of patients and pathologies: healthy , hypertrophy , heart failure with infarction and heart…\nAccess: http://www.cardiacatlas.org/studies/\n\nLung Image Database Consortium (LIDC)\nPreliminary clinical studies have shown that spiral CT scanning of the lungs can improve early detection of lung cancer in high-risk individuals. Image processing algorithms have the potential to assist in lesion detection on spiral CT studies, and to assess the stability or change in lesion size on serial CT studies. The use of such computer-assisted algorithms could significantly enhance the sensitivity and specificity of spiral CT lung screening, as well as lower costs by reducing physician time needed for interpretation.\nThe intent of the Lung Imaging Database Consortium (LIDC) initiative was to support a consortium of institutions to develop consensus guidelines for a spiral CT lung image resource and to construct a database of spiral CT lung images. The investigators funded under this initiative created a set of guidelines and metrics for database use and for developing a database as a test-bed and showcase for those methods. The database is available to researchers and users through the Internet and has wide utility as a research, teaching, and training resource.\nSpecifically, the LIDC initiative aims were to provide:\n\na reference database for the relative evaluation of image processing or CAD algorithms and\na flexible query system that will provide investigators the opportunity to evaluate a wide range of technical parameters and de-identified clinical information within this database that may be important for research applications.\n\nThis resource will stimulate further database development for image processing and CAD evaluation for applications that include cancer screening, diagnosis, and image guided intervention, and treatment. Therefore, the NCI encourages investigator-initiated grant applications that utilize the database in their research. NCI also encourages investigator-initiated grant applications that provide tools or methodology that may improve or complement the mission of the LIDC.\nAccess: http://imaging.cancer.gov/programsandresources/informationsystems/lidc\n\nTCIA Collections\nCancer imaging data sets across various cancer types (e.g. carcinoma, lung cancer, myeloma) and various imaging modalities.The image data in The Cancer Imaging Archive (TCIA) is organized into purpose-built collections of subjects. The subjects typically have a cancer type and/or anatomical site (lung, brain, etc.) in common. Each link in the table below contains information concerning the scientific value of a collection, information about how to obtain any supporting non-image data which may be available, and links to view or download the imaging data. To support reproducibility in scientific research, TCIA supports Digital Object Identifiers (DOIs) which allow users to share subsets of TCIA data referenced in a research manuscript. \nAccess: http://www.cancerimagingarchive.net/\n\nBelarus tuberculosis portal\nTuberculosis (TB) is a major problem of Belarus Public Health .Recently situation has been complicated with emergence and development of MDR/XDR TB and HIV/TB which require long-term treatment. Many and the most severe cases usually disseminate across the country to different TB dispensaries. The ability of leading Belarus TB specialists to follow such patients will be greatly improved by using a common database containing patients’ radiological images, lab work and clinical data. This will also significantly improve adherence to the treatment protocol and result in a better record of the treatment outcomes.Criteria for inclusion clinical cases in the database of the portal - patients admitted to the MDR-TB department of RSPC of Pulmonology and Tuberculosis with diagnosed or suspected of MDR-TB, which conducted CT – study (± 2 months from the date of registration)Belarus dataset have both chest X-rays and CT scans of the same patient. \nAccess: http://tuberculosis.by/\n\nDDSM: Digital Database for Screening Mammography\n The Digital Database for Screening Mammography (DDSM) is a resource for use by the mammographic image analysis research community. Primary support for this project was a grant from the Breast Cancer Research Program of the U.S. Army Medical Research and Materiel Command. The DDSM project is a collaborative effort involving co-p.i.s at the Massachusetts General Hospital (D. Kopans, R. Moore), the University of South Florida (K. Bowyer), and Sandia National Laboratories (P. Kegelmeyer). Additional cases from Washington University School of Medicine were provided by Peter E. Shile, MD, Assistant Professor of Radiology and Internal Medicine. Additional collaborating institutions include Wake Forest University School of Medicine (Departments of Medical Engineering and Radiology), Sacred Heart Hospital and ISMD, Incorporated. The primary purpose of the database is to facilitate sound research in the development of computer algorithms to aid in screening. Secondary purposes of the database may include the development of algorithms to aid in the diagnosis and the development of teaching or training aids. The database contains approximately 2,500 studies. Each study includes two images of each breast, along with some associated patient information (age at time of study, ACR breast density rating, subtlety rating for abnormalities, ACR keyword description of abnormalities) and image information (scanner, spatial resolution, …). Images containing suspicious areas have associated pixel-level “ground truth” information about the locations and types of suspicious regions. Also provided are software both for accessing the mammogram and truth images and for calculating performance figures for automated image analysis algorithms. \nAccess: http://marathon.csee.usf.edu/Mammography/Database.html\n\nProstate\nProstate cancer (CaP) has been reported on a worldwide scale to be the second most frequently diagnosed cancer of men accounting for 13.6% (Ferlay et al. (2010)). Statistically, in 2008, the number of new diagnosed cases was estimated to be 899, 000 with no less than 258, 100 deaths (Ferlay et al. (2010)).\nMagnetic resonance imaging (MRI) provides imaging techniques allowing to diagnose and localize CaP. The I2CVB provides a multi-parametric MRI dataset to help at the development of computer-aided detection and diagnosis (CAD) system.Access: http://i2cvb.github.io/\n\nAccess: http://www.medinfo.cs.ucy.ac.cy/index.php/downloads/datasets\n\nMRI Lesion Segmentation in Multiple Sclerosis Database\n\nEmergency Tele-Orthopedics X-ray Digital Library\n\nIMT Segmentation\n\nNeedle EMG MUAP Time Domain Features\n\n\n\nDICOM image sample setsThese datasets are exclusively available for research and teaching. You are not authorized to redistribute or sell them, or use them for commercial purposes.\nAll these DICOM files are compressed in JPEG2000 transfer syntax.\nAccess: http://www.osirix-viewer.com/resources/dicom-image-library/\n\nSCR database: Segmentation in Chest Radiographs\nThe automatic segmentation of anatomical structures in chest radiographs is of great importance for computer-aided diagnosis in these images. The SCR database has been established to facilitate comparative studies on segmentation of the lung fields, the heart and the clavicles in standard posterior-anterior chest radiographs.\nIn the spirit of cooperative scientific progress, we freely share the SCR database and are committed to maintaining a public repository of results of various algorithms on these segmentation tasks. On thes pages, instructions can be found on downloading the database and uploading results, and benchmark results of various methods can be inspected. \nAccess: http://www.isi.uu.nl/Research/Databases/SCR/\n\nMedical Image Databases &amp; Libraries\nAccess: http://www.omnimedicalsearch.com/image_databases.html\n General Category\n\ne-Anatomy.org - Interactive Atlas of Anatomy - e-anatomy is an anatomy e-learning web site. More than 1500 slices from normal CT and MR exams were selected in order to cover the entire sectional anatomy of human body. Images were labeled using Terminologia Anatomica. A user-friendly interface allows to cine through multi-slice image series combined with interactive textual information, 3D models and anatomy drawings.\n\nMedical Pictures and Definitions - Welcome to the largest database of medical pictures and definitions on the Internet. There are many sites sites that provide medical information but very few that provide medical pictures. As far as we know we are the only one that provides a medical picture database with basic information about each term pictured. Editor’s Note: Nice website with free access &amp; no pesky registration to 1200+ health and medical related images with definitions.\n\nNucleus Medical Art - Medical Illustrations, Medical Art. Includes 3D animations. “Nucleus Medical Art, Inc. is a leading creator and distributor of medical illustrations, medical animations, and interactive multimedia for publishing, legal, healthcare, entertainment, pharmaceutical, medical device, academia and other markets, both in the U.S. and abroad. Editors Note: Great website.\n\nMedical Image Databases on the Internet (UTHSCSA Library) - A directory of links to websites with topic specific medical related images.\n\nSurgery Videos - A National Library of Medicine MedlinePlus collection of links to 100s and 100s of different surgical procedures. You must have RealPlayer media player on your computer to view these videos which are free of charge.\n\nThe ADAM Medical Encyclopedia with Illustrations. Perhaps one of the best illustrated medical works on the internet today, the ADAM Medical Encyclopedia includes over 4,000 articles about diseases, tests, symptoms, injuries, and surgeries. It also contains an extensive library of medical photographs and illustrations to back up those 4,000 articles. These illustrations and articles are free to the public.\n\nHardin MD - Medical and Disease Pictures, is a Free and established resource that has been offered by the University of Iowa for quite some time. The home page is in directory style where users will have to drill down to find the images they are looking for, many of which go offsite. Nevertheless, Hardin MD is an excellent gateway to 1,000s of detailed medical photos and illustrations.\n\nHealth Education Assets Library (HEAL) - Health on the Net Foundation Media Gallery Headquartered in Switzerland, (HON) is an international body that seeks to encourage ethical provision of online health information. “HONmedia (the image gallery) is an unique repository of over 6’800 medical images and videos, pertaining to 1,700 topics and themes. This peerless database has been created manually by HON and new image links are constantly being added from the world-wide Web. HON encourages users to make their own image links available via the Submit an image link.” Library includes anatomical images, visual affects of diseases and conditions and procedures.\n\nPublic Health Image Library (PHIL) Created by a Working Group at the Centers for Disease Control and Prevention (CDC), the PHIL offers an organized, universal electronic gateway to CDC’s pictures. We welcome public health professionals, the media, laboratory scientists, educators, students, and the worldwide public to use this material for reference, teaching, presentation, and public health messages. The content is organized into hierarchical categories of people, places, and science, and is presented as single images, image sets, and multimedia files.\n\nImages from the History of Medicine - This system provides access to the nearly 60,000 images in the prints and photograph collection of the History of Medicine Division (HMD) of the U.S. National Library of Medicine (NLM). The collection includes portraits, pictures of institutions, caricatures, genre scenes, and graphic art in a variety of media, illustrating the social and historical aspects of medicine.\n\nPozemedicale.org - Collection of medical images in Spanish, Italian, Portuguese and Italian.\n\nOld Medical Pictures: Hundreds of fascinating and interesting old, but high quality photographs and images from the late 19th and early 20th century.\n\n\nSubject Speciality Image Libraries and Collections\n\nAnatomy of the Human Body by Henry Gray - The Bartleby.com edition of Gray’s Anatomy of the Human Body features 1,247 vibrant engravings—many in color—from the classic 1918 publication.\n\nThe Crookston Collection - A collection of medical slides taken by Dr. John H. Crookston that have been digitized and are available to the public and doctors.\n\nDAVE Project - A searchable library of gastrointestinal endoscopic video clips covering a wide spectrum endoscopic imaging.\n\nDermnet - Browsable collection of over 8,000 high quality, dermatology images.\n\nInteractive Dermatology Atlas - Image reference source for common and uncommon skin problems.\n\nThe Multi-Dimensional Human Embryo is a collaboration funded by the National Institute of Child Health and Human Development (NICHD) to produce and make available over the internet a three-dimensional image reference of the Human Embryo based on magnetic resonance imaging.\n\nGastroLab Endoscopy Archives Was initiated in 1996 with the goal of maintaining an endoscopic image gallery free to use for all interested health care personals.\n\nMedPix Is a Radiology and Medical Picture Databases resource tool. The home page interface is confusing and the entire website design is not user-friendly and has a mid 1990s feel to it. However, if you have the time (patience) it could prove to be an important resource for some.\n\nOBGYN.net Image Library - This site is devoted entirely to providing access to images of interest to women’s health. In addition to providing you with access to OBGYN.net images we also point to other women’s health related images on the Internet. Because of the graphic nature of the material some individuals may prefer not to view these images.They are provided for educational purposes only. \n\n\n\nVIA Group Public Databases\n Documented image databases are essential for the development of quantitative image analysis tools especially for tasks of computer-aided diagnosis (CAD). In collaboration with the I-ELCAP group we have established two public image databases that contain lung CT images in the DICOM format together with documentation of abnormalities by radiologists. Please access the links below for more details:\nAccess: http://www.via.cornell.edu/databases/\n\nCVonline: Image DatabasesAccess: http://homepages.inf.ed.ac.uk/rbf/CVonline/Imagedbase.htm\n\nThe USC-SIPI Image Database The USC-SIPI image database is a collection of digitized images. It is maintained primarily to support research in image processing, image analysis, and machine vision. The first edition of the USC-SIPI image database was distributed in 1977 and many new images have been added since then.\nThe database is divided into volumes based on the basic character of the pictures. Images in each volume are of various sizes such as 256x256 pixels, 512x512 pixels, or 1024x1024 pixels. All images are 8 bits/pixel for black and white images, 24 bits/pixel for color images. The following volumes are currently available:\nTextures     Brodatz textures, texture mosaics, etc.\nAerials     High altitude aerial images\nMiscellaneous     Lena, the mandrill, and other favorites\nSequences     Moving head, fly-overs, moving vehicles\nAccess: http://sipi.usc.edu/database/\n\n2. Challenges/Contest DataVisual Concept Extraction Challenge in Radiology Manually annotated radiological data of several anatomical structures (e.g. kidney, lung, bladder, etc.) from several different imaging modalities (e.g. CT and MR). They also provide a cloud computing instance that anyone can use to develop and evaluate models against benchmarks.\nAccess: http://www.visceral.eu/\n\nGrand Challenges in Biomedical Image Analysis\nA collection of biomedical imaging challenges in order to facilitate better comparisons between new and existing solutions, by standardizing evaluation criteria. You can create your own challenge as well. As of this writing, there are 92 challenges that provide downloadable data sets.\nAccess: http://www.grand-challenge.org/ \n\nDream Challenges\nDREAM Challenges pose fundamental questions about systems biology and translational medicine. Designed and run by a community of researchers from a variety of organizations, our challenges invite participants to propose solutions — fostering collaboration and building communities in the process. Expertise and institutional support are provided by Sage Bionetworks, along with the infrastructure to host challenges via their Synapse platform. Together, we share a vision allowing individuals and groups to collaborate openly so that the  “wisdom of the crowd” provides the greatest impact on science and human health.\n\nThe Digital Mammography DREAM Challenge.\nICGC-TCGA DREAM Somatic Mutation Calling RNA Challenge (SMC-RNA)\nDREAM Idea Challenge \nThese were the active challenges at the time of adding, many more past challenges and upcoming challenges are present!\n\nAccess: http://dreamchallenges.org/\n\nKaggle diabetic retinopathy\nHigh-resolution retinal images that are annotated on a 0–4 severity scale by clinicians, for the detection of diabetic retinopathy. This data set is part of a completed Kaggle competition, which is generally a great source for publicly available data sets.\nAccess: https://www.kaggle.com/c/diabetic-retinopathy-detection\n\nCervical Cancer Screening\nIn this kaggle competition, you will develop algorithms to correctly classify cervix types based on cervical images. These different types of cervix in our data set are all considered normal (not cancerous), but since the transformation zones aren’t always visible, some of the patients require further testing while some don’t.\nAccess: https://www.kaggle.com/c/intel-mobileodt-cervical-cancer-screening/data\n\nMultiple sclerosis lesion segmentation\n challenge 2008. A collection of brain MRI scans to detect MS lesions.\nAccess: http://www.ia.unc.edu/MSseg/\n\nMultimodal Brain Tumor Segmentation Challenge\nLarge data set of brain tumor magnetic resonance scans. They’ve been extending this data set and challenge each year since 2012.\nAccess: http://braintumorsegmentation.org/\n\nCoding4Cancer\nA new initiative by the Foundation for the National Institutes of Health and Sage Bionetworks to host a series of challenges to improve cancer screening. The first is for digital mammography readings. The second is for lung cancer detection. The challenges are not yet launched.\nAccess: http://coding4cancer.org/\n\nEEG Challenge Datasets on Kaggle\n\nMelbourne University AES/MathWorks/NIH Seizure Prediction - Predict seizures in long-term human intracranial EEG recordings \n\nAccess: https://www.kaggle.com/c/melbourne-university-seizure-prediction\n\nAmerican Epilepsy Society Seizure Prediction Challenge - Predict seizures in intracranial EEG recordings \n\nAccess: https://www.kaggle.com/c/seizure-prediction\n\nUPenn and Mayo Clinic’s Seizure Detection Challenge - Detect seizures in intracranial EEG recordings\n\nAccess: https://www.kaggle.com/c/seizure-detection\n\nGrasp-and-Lift EEG Detection - Identify hand motions from EEG recordings \n\nAccess: https://www.kaggle.com/c/grasp-and-lift-eeg-detection\n\nChallenges track in MICCAI Conference\nThe Medical Image Computing and Computer Assisted Intervention. Most of the challenges would’ve been covered by websites like grand-challenges etc. You can still see all of them under the “Satellite Events” tab of the conference sites.\n\n2017 - http://www.miccai2017.org/satellite-events\n2016 - http://www.miccai2016.org/en/SATELLITE-EVENTS.html\n2015 - https://www.miccai2015.org/frontend/index.php?page_id=589\n\nAccess: http://www.miccai.org/ConferenceHistory\n\nInternational Symposium on Biomedical Imaging (ISBI)\nThe IEEE International Symposium on Biomedical Imaging (ISBI) is a scientific conference dedicated to mathematical, algorithmic, and computational aspects of biomedical imaging, across all scales of observation. Most of these challenges will be listed in grand-challenges. You can still access it by visiting the “Challenges” tab under “Program” in each year’s website.\n\n2017 - http://biomedicalimaging.org/2017/challenges/\n2016 - http://biomedicalimaging.org/2016/?page_id=416\n\nAccess: http://biomedicalimaging.org\n\n3. Data derived from Electronic Health Records (EHRs)Building the graph of medicine from millions of clinical narrativesCo-occurence statistics for medical terms extracted from 14 million clinical notes and 260,000 patients.Paper: http://www.nature.com/articles/sdata201432Data: http://datadryad.org/resource/doi:10.5061/dryad.jp917  \n\nLearning Low-Dimensional Representations of Medical ConceptLow-dimensional embeddings of medical concepts constructed using claims data. Note that this paper utilizes data from Building the graph of medicine from millions of clinical narrativesPaper: http://cs.nyu.edu/~dsontag/papers/ChoiChiuSontag_AMIA_CRI16.pdfData: https://github.com/clinicalml/embeddings  \n\nMIMIC-III, a freely accessible critical care databaseAnonymized critical care EHR database on 38,597 patients and 53,423 ICU admissions. Requires registration.Paper: http://www.nature.com/articles/sdata201635Data: http://physionet.org/physiobank/database/mimic3cdb/  \n\n4. National Healthcare DataCenters for Disease Control and Prevention (CDC)Data from the CDC on many areas, including:  \n\nBiomonitoring\nChild Vaccinations\nFlu Vaccinations\nHealth Statistics\nInjury &amp; Violence\nMMWR\nMotor Vehicle\nNCHS\nNNDSS\nPregnancy &amp; Vaccination\nSTDs\nSmoking &amp; Tobacco Use\nTeen Vaccinations\nTraumatic Brain Injury\nVaccinations\nWeb Metrics\n\nLanding page: https://data.cdc.govData Catalog: https://data.cdc.gov/browse  \n\nMedicare DataData from the Centers for Medicare &amp; Medicaid Services (CMS) on hospitals, nursing homes, physicians, home healthcare, dialysis, and device providers.Landing page: https://data.medicare.govExplorer: https://data.medicare.gov/data  \n\nTexas Public Use Inpatient Data FileData on 11 Million inpatient visits with diagnosis, procedure codes and outcomes from Texas between 2006 &amp; 2009.\nLink: https://www.dshs.texas.gov/thcic/hospitals/Inpatientpudf.shtm\n\nDollars for DoctorsPropublica investigation of money paid by pharmaceutical companies to doctors.Information: https://www.propublica.org/series/dollars-for-docsSearch tool: https://projects.propublica.org/docdollars/Data request: https://projects.propublica.org/data-store/sets/health-d4d-national-2   \n\nDocGraphPhysician interaction network obtained through a freedom of information act request. Covers nearly 1 million entities.Main page: http://www.docgraph.comInformation: http://thehealthcareblog.com/blog/2012/11/05/tracking-the-social-doctor-opening-up-physician-referral-data-and-much-more/Data: http://linea.docgraph.org  \n\n5. UCI DatasetsLiver Disorders Data SetData on 345 patients with and without liver disease. Features are 5 blood biomarkers thought to be involved with liver disease.Data: https://archive.ics.uci.edu/ml/datasets/Liver+Disorders  \nThyroid Disease Data SetData: https://archive.ics.uci.edu/ml/datasets/Thyroid+Disease  \nBreast Cancer Data SetData: https://archive.ics.uci.edu/ml/datasets/Breast+Cancer  \nHeart Disease Data SetData: https://archive.ics.uci.edu/ml/datasets/Heart+Disease  \nLymphography Data SetData: https://archive.ics.uci.edu/ml/datasets/Lymphography  \n6. Biomedical LiteraturePMC Open Access SubsetCollection of all the full-text, open access articles in Pubmed central.Information: http://www.ncbi.nlm.nih.gov/pmc/tools/openftlist/Archived files: http://www.ncbi.nlm.nih.gov/pmc/tools/ftp/#Data_Mining  \nPubMed 200k RCT\nCollection of pubmed abstracts from randomized control trials (RCTs). Annotations for each sentence in the abstract are available.\nPaper: https://arxiv.org/abs/1710.06071\nData: https://github.com/Franck-Dernoncourt/pubmed-rct\n6. TREC Precision Medicine / Clinical Decision Support TrackText REtrieval Conference (TREC) is running a track on Precision Medicine / Clinical Decision Support from 2014. \n2014 Clinical Decision Support TrackFocus: Retrieval of biomedical articles relevant for answering generic clinical questions about medical records.Information and Data: http://www.trec-cds.org/2014.html\n2015 Clinical Decision Support TrackFocus: Retrieval of biomedical articles relevant for answering generic clinical questions about medical records.Information and Data: http://www.trec-cds.org/2015.html\n2016 Clinical Decision Support TrackFocus: Retrieval of biomedical articles relevant for answering generic clinical questions about medical records. Actual electronic health record (EHR) patient records are be used instead of synthetic cases.Information and Data: http://www.trec-cds.org/2016.html\n2017 Clinical Decision Support TrackFocus: Retrieve useful precision medicine-related information to clinicians treating cancer patients.Information and Data: http://www.trec-cds.org/2017.html\n","categories":["图像处理与机器学习"],"tags":["机器学习"]},{"title":"基于SIFT与ransac的全景图像拼接","url":"https://tanqingbo.cn/Panoramic-image-stitching-based-on-SIFT-features/","content":"前言\n全景图像拼接主要分为如下几个步骤\n读入两张图片并分别提取SIFT特征；\n利用k-d tree和BBF算法进行特征匹配查找；\n利用RANSAC算法筛选匹配点并计算变换矩阵；\n图像融合。实验环境\n\n\nvs2017、QT的版本是Qt5.6.3，OpenCV版本是2.4.9.SIFT特征提取\n直接调用RobHess源码(RobHess的SIFT源码分析：综述)中的sift_features()函数进行默认参数的SIFT特征提取，主要代码如下：\n\nimg1_Feat = cvCloneImage(img1);//复制图1，深拷贝，用来画特征点  img2_Feat = cvCloneImage(img2);//复制图2，深拷贝，用来画特征点  //默认提取的是LOWE格式的SIFT特征点  //提取并显示第1幅图片上的特征点  n1 = sift_features( img1, &amp;feat1 );//检测图1中的SIFT特征点,n1是图1的特征点个数  export_features(\"feature1.txt\",feat1,n1);//将特征向量数据写入到文件  draw_features( img1_Feat, feat1, n1 );//画出特征点  cvNamedWindow(IMG1_FEAT);//创建窗口  cvShowImage(IMG1_FEAT,img1_Feat);//显示  //提取并显示第2幅图片上的特征点  n2 = sift_features( img2, &amp;feat2 );//检测图2中的SIFT特征点，n2是图2的特征点个数  export_features(\"feature2.txt\",feat2,n2);//将特征向量数据写入到文件  draw_features( img2_Feat, feat2, n2 );//画出特征点  cvNamedWindow(IMG2_FEAT);//创建窗口  cvShowImage(IMG2_FEAT,img2_Feat);//显示  \n\n\n\n评价两幅图像中特征点的品质重要的指标是重复度，基于SIFT提取特征点如下所示：\n\n  \n\n利用k-d tree和BBF算法进行特征匹配查找\n特征点检测出来后，使用最近距离比次近距离算法（BBF）做特征点匹配。\n主要思想是先将图像1中的特征点建立k-d树，找到图像2中每个特征点到与图像1中点的最近邻距离d0和次近邻距离d1，淘汰d0/d1大于某个阈值的点，再把两幅图像中剩下的对应特征点匹配起来。\n也是调用RobHess源码中的函数，加上之后的一些筛选处理，主要代码如下：\n\n//根据图1的特征点集feat1建立k-d树，返回k-d树根给kd_root  kd_root = kdtree_build( feat1, n1 );  Point pt1,pt2;//连线的两个端点  double d0,d1;//feat2中每个特征点到最近邻和次近邻的距离  int matchNum = 0;//经距离比值法筛选后的匹配点对的个数  //遍历特征点集feat2，针对feat2中每个特征点feat，选取符合距离比值条件的匹配点，放到feat的fwd_match域中  for(int i = 0; i &lt; n2; i++ )  {  \tfeat = feat2+i;//第i个特征点的指针  \t//在kd_root中搜索目标点feat的2个最近邻点，存放在nbrs中，返回实际找到的近邻点个数  \tint k = kdtree_bbf_knn( kd_root, feat, 2, &amp;nbrs, KDTREE_BBF_MAX_NN_CHKS );  \tif( k == 2 )  \t{  \t\td0 = descr_dist_sq( feat, nbrs[0] );//feat与最近邻点的距离的平方  \t\td1 = descr_dist_sq( feat, nbrs[1] );//feat与次近邻点的距离的平方  \t\t//若d0和d1的比值小于阈值NN_SQ_DIST_RATIO_THR，则接受此匹配，否则剔除  \t\tif( d0 &lt; d1 * NN_SQ_DIST_RATIO_THR )  \t\t{   //将目标点feat和最近邻点作为匹配点对  \t\t\tpt2 = Point( cvRound( feat-&gt;x ), cvRound( feat-&gt;y ) );//图2中点的坐标  \t\t\tpt1 = Point( cvRound( nbrs[0]-&gt;x ), cvRound( nbrs[0]-&gt;y ) );//图1中点的坐标(feat的最近邻点)  \t\t\tpt2.x += img1-&gt;width;//由于两幅图是左右排列的，pt2的横坐标加上图1的宽度，作为连线的终点  \t\t\tcvLine( stacked, pt1, pt2, CV_RGB(255,0,255), 1, 8, 0 );//画出连线  \t\t\tmatchNum++;//统计匹配点对的个数  \t\t\tfeat2[i].fwd_match = nbrs[0];//使点feat的fwd_match域指向其对应的匹配点  \t\t}  \t}  \tfree( nbrs );//释放近邻数组  }  //显示并保存经距离比值法筛选后的匹配图  cvNamedWindow(IMG_MATCH1);//创建窗口  cvShowImage(IMG_MATCH1,stacked);//显示\n\n\n\n匹配结果如下：\n\n\n利用RANSAC算法筛选匹配点并计算变换矩阵\n利用随机采样一致算法（RANSAC），筛选匹配点，RANSAC算法是目前使用的很广泛的剔除误配点的方法。\n\n此部分最主要的是RobHess源码中的ransac_xform()函数，此函数实现了用RANSAC算法筛选匹配点，返回结果是计算好的变换矩阵，若能成功计算出变换矩阵，即两幅图中有共同区域，可以进行拼接。\n\n程序中计算出的变换矩阵H用来将img2中的点变换为img1中的点，无论img1和img2的左右顺序，计算出的变换矩阵H永远是将img2中的特征点变换为其匹配点，即将img2中的点变换为img1中的对应点。\n\n此部分中，我利用匹配点的坐标关系，对输入的两幅图像的左右关系进行了判断，并根据结果选择使用矩阵H或H的逆阵进行变换。\n\n所以读入的两幅要拼接的图像的左右位置关系可以随意，程序中可自动调整。\n\n主要代码如下：\n\n\n//利用RANSAC算法筛选匹配点,计算变换矩阵H，  //无论img1和img2的左右顺序，计算出的H永远是将feat2中的特征点变换为其匹配点，即将img2中的点变换为img1中的对应点  H = ransac_xform(feat2,n2,FEATURE_FWD_MATCH,lsq_homog,4,0.01,homog_xfer_err,3.0,&amp;inliers,&amp;n_inliers);  //若能成功计算出变换矩阵，即两幅图中有共同区域  if( H )  {  \tqDebug()&lt;&lt;tr(\"经RANSAC算法筛选后的匹配点对个数：\")&lt;&lt;n_inliers&lt;&lt;endl; //输出筛选后的匹配点对个数  \tint invertNum = 0;//统计pt2.x &gt; pt1.x的匹配点对的个数，来判断img1中是否右图  \t//遍历经RANSAC算法筛选后的特征点集合inliers，找到每个特征点的匹配点，画出连线  \tfor(int i=0; i&lt;n_inliers; i++)  \t{  \t\tfeat = inliers[i];//第i个特征点  \t\tpt2 = Point(cvRound(feat-&gt;x), cvRound(feat-&gt;y));//图2中点的坐标  \t\tpt1 = Point(cvRound(feat-&gt;fwd_match-&gt;x), cvRound(feat-&gt;fwd_match-&gt;y));//图1中点的坐标(feat的匹配点)  \t\t//qDebug()&lt;&lt;\"pt2:(\"&lt;&lt;pt2.x&lt;&lt;\",\"&lt;&lt;pt2.y&lt;&lt;\")---&gt;pt1:(\"&lt;&lt;pt1.x&lt;&lt;\",\"&lt;&lt;pt1.y&lt;&lt;\")\";//输出对应点对  \t\t//统计匹配点的左右位置关系，来判断图1和图2的左右位置关系  \t\tif(pt2.x &gt; pt1.x)  \t\t\tinvertNum++;  \t\tpt2.x += img1-&gt;width;//由于两幅图是左右排列的，pt2的横坐标加上图1的宽度，作为连线的终点  \t\tcvLine(stacked_ransac,pt1,pt2,CV_RGB(255,0,255),1,8,0);//在匹配图上画出连线  \t}  \tcvNamedWindow(IMG_MATCH2);//创建窗口  \tcvShowImage(IMG_MATCH2,stacked_ransac);//显示经RANSAC算法筛选后的匹配图  \t/*程序中计算出的变换矩阵H用来将img2中的点变换为img1中的点，正常情况下img1应该是左图，img2应该是右图。 \t  此时img2中的点pt2和img1中的对应点pt1的x坐标的关系基本都是：pt2.x &lt; pt1.x \t  若用户打开的img1是右图，img2是左图，则img2中的点pt2和img1中的对应点pt1的x坐标的关系基本都是：pt2.x &gt; pt1.x \t  所以通过统计对应点变换前后x坐标大小关系，可以知道img1是不是右图。 \t  如果img1是右图，将img1中的匹配点经H的逆阵H_IVT变换后可得到img2中的匹配点*/  \t//若pt2.x &gt; pt1.x的点的个数大于内点个数的80%，则认定img1中是右图  \tif(invertNum &gt; n_inliers * 0.8)  \t{  \t\tCvMat * H_IVT = cvCreateMat(3, 3, CV_64FC1);//变换矩阵的逆矩阵  \t\t//求H的逆阵H_IVT时，若成功求出，返回非零值  \t\tif( cvInvert(H,H_IVT) )  \t\t{  \t\t\tcvReleaseMat(&amp;H);//释放变换矩阵H，因为用不到了  \t\t\tH = cvCloneMat(H_IVT);//将H的逆阵H_IVT中的数据拷贝到H中  \t\t\tcvReleaseMat(&amp;H_IVT);//释放逆阵H_IVT  \t\t\t//将img1和img2对调  \t\t\tIplImage * temp = img2;  \t\t\timg2 = img1;  \t\t\timg1 = temp;  \t\t\tui-&gt;mosaicButton-&gt;setEnabled(true);//激活全景拼接按钮  \t\t}  \t\telse//H不可逆时，返回0  \t\t{  \t\t\tcvReleaseMat(&amp;H_IVT);//释放逆阵H_IVT  \t\t\tQMessageBox::warning(this,tr(\"警告\"),tr(\"变换矩阵H不可逆\"));  \t\t}  \t}  \telse  \t\tui-&gt;mosaicButton-&gt;setEnabled(true);//激活全景拼接按钮  }  else //无法计算出变换矩阵，即两幅图中没有重合区域  {  \tQMessageBox::warning(this,tr(\"警告\"),tr(\"两图中无公共区域\"));  }\n\n\n\n\n经RANSAC筛选后的匹配结果如下图：\n\n\n图像融合\n这里的拼接的方法有两种：\n\n简易拼接方法的过程是：首先将右图img2经变换矩阵H变换到一个新图像中，然后直接将左图img1加到新图像中，这样拼接出来会有明显的拼接缝，但也是一个初步的成品了。\n\n另一种方法首先也是将右图img2经变换矩阵H变换到一个新图像中，然后图像的融合过程将目标图像分为三部分，最左边完全取自img1中的数据，中间的重合部分是两幅图像的加权平均，重合区域右边的部分完全取自img2经变换后的图像。加权平均的权重选择也有好多方法，比如可以使用最基本的取两张图像的平均值，但这样会有明显的拼接缝。这里首先计算出拼接区域的宽度，设d1，d2分别是重叠区域中的点到重叠区域左边界和右边界的距离，则使用如下公式计算重叠区域的像素值：\n , 这样就可以实现平滑过渡。\n\n\n\n主要代码如下：\n\n\n//若能成功计算出变换矩阵，即两幅图中有共同区域，才可以进行全景拼接  if(H)  {  \t//拼接图像，img1是左图，img2是右图  \tCalcFourCorner();//计算图2的四个角经变换后的坐标  \t//为拼接结果图xformed分配空间,高度为图1图2高度的较小者，根据图2右上角和右下角变换后的点的位置决定拼接图的宽度  \txformed = cvCreateImage(cvSize(MIN(rightTop.x,rightBottom.x),MIN(img1-&gt;height,img2-&gt;height)),IPL_DEPTH_8U,3);  \t//用变换矩阵H对右图img2做投影变换(变换后会有坐标右移)，结果放到xformed中  \tcvWarpPerspective(img2,xformed,H,CV_INTER_LINEAR + CV_WARP_FILL_OUTLIERS,cvScalarAll(0));  \tcvNamedWindow(IMG_MOSAIC_TEMP); //显示临时图,即只将图2变换后的图  \tcvShowImage(IMG_MOSAIC_TEMP,xformed);  \t//简易拼接法：直接将将左图img1叠加到xformed的左边  \txformed_simple = cvCloneImage(xformed);//简易拼接图，克隆自xformed  \tcvSetImageROI(xformed_simple,cvRect(0,0,img1-&gt;width,img1-&gt;height));  \tcvAddWeighted(img1,1,xformed_simple,0,0,xformed_simple);  \tcvResetImageROI(xformed_simple);  \tcvNamedWindow(IMG_MOSAIC_SIMPLE);//创建窗口  \tcvShowImage(IMG_MOSAIC_SIMPLE,xformed_simple);//显示简易拼接图  \t//处理后的拼接图，克隆自xformed  \txformed_proc = cvCloneImage(xformed);  \t//重叠区域左边的部分完全取自图1  \tcvSetImageROI(img1,cvRect(0,0,MIN(leftTop.x,leftBottom.x),xformed_proc-&gt;height));  \tcvSetImageROI(xformed,cvRect(0,0,MIN(leftTop.x,leftBottom.x),xformed_proc-&gt;height));  \tcvSetImageROI(xformed_proc,cvRect(0,0,MIN(leftTop.x,leftBottom.x),xformed_proc-&gt;height));  \tcvAddWeighted(img1,1,xformed,0,0,xformed_proc);  \tcvResetImageROI(img1);  \tcvResetImageROI(xformed);  \tcvResetImageROI(xformed_proc);  \tcvNamedWindow(IMG_MOSAIC_BEFORE_FUSION);  \tcvShowImage(IMG_MOSAIC_BEFORE_FUSION,xformed_proc);//显示融合之前的拼接图  \t//采用加权平均的方法融合重叠区域  \tint start = MIN(leftTop.x,leftBottom.x) ;//开始位置，即重叠区域的左边界  \tdouble processWidth = img1-&gt;width - start;//重叠区域的宽度  \tdouble alpha = 1;//img1中像素的权重  \tfor(int i=0; i&lt;xformed_proc-&gt;height; i++)//遍历行  \t{  \t\tconst uchar * pixel_img1 = ((uchar *)(img1-&gt;imageData + img1-&gt;widthStep * i));//img1中第i行数据的指针  \t\tconst uchar * pixel_xformed = ((uchar *)(xformed-&gt;imageData + xformed-&gt;widthStep * i));//xformed中第i行数据的指针  \t\tuchar * pixel_xformed_proc = ((uchar *)(xformed_proc-&gt;imageData + xformed_proc-&gt;widthStep * i));//xformed_proc中第i行数据的指针  \t\tfor(int j=start; j&lt;img1-&gt;width; j++)//遍历重叠区域的列  \t\t{  \t\t\t//如果遇到图像xformed中无像素的黑点，则完全拷贝图1中的数据  \t\t\tif(pixel_xformed[j*3] &lt; 50 &amp;&amp; pixel_xformed[j*3+1] &lt; 50 &amp;&amp; pixel_xformed[j*3+2] &lt; 50 )  \t\t\t{  \t\t\t\talpha = 1;  \t\t\t}  \t\t\telse  \t\t\t{   //img1中像素的权重，与当前处理点距重叠区域左边界的距离成正比  \t\t\t\talpha = (processWidth-(j-start)) / processWidth ;  \t\t\t}  \t\t\tpixel_xformed_proc[j*3] = pixel_img1[j*3] * alpha + pixel_xformed[j*3] * (1-alpha);//B通道  \t\t\tpixel_xformed_proc[j*3+1] = pixel_img1[j*3+1] * alpha + pixel_xformed[j*3+1] * (1-alpha);//G通道  \t\t\tpixel_xformed_proc[j*3+2] = pixel_img1[j*3+2] * alpha + pixel_xformed[j*3+2] * (1-alpha);//R通道  \t\t}  \t}  \tcvNamedWindow(IMG_MOSAIC_PROC);//创建窗口  \tcvShowImage(IMG_MOSAIC_PROC,xformed_proc);//显示处理后的拼接图  \t/*重叠区域取两幅图像的平均值，效果不好 \t\t//设置ROI，是包含重叠区域的矩形 \t\tcvSetImageROI(xformed_proc,cvRect(MIN(leftTop.x,leftBottom.x),0,img1-&gt;width-MIN(leftTop.x,leftBottom.x),xformed_proc-&gt;height)); \t\tcvSetImageROI(img1,cvRect(MIN(leftTop.x,leftBottom.x),0,img1-&gt;width-MIN(leftTop.x,leftBottom.x),xformed_proc-&gt;height)); \t\tcvSetImageROI(xformed,cvRect(MIN(leftTop.x,leftBottom.x),0,img1-&gt;width-MIN(leftTop.x,leftBottom.x),xformed_proc-&gt;height)); \t\tcvAddWeighted(img1,0.5,xformed,0.5,0,xformed_proc); \t\tcvResetImageROI(xformed_proc); \t\tcvResetImageROI(img1); \t\tcvResetImageROI(xformed); //*/  \t/*对拼接缝周围区域进行滤波来消除拼接缝，效果不好 \t\t//在处理前后的图上分别设置横跨拼接缝的矩形ROI \t\tcvSetImageROI(xformed_proc,cvRect(img1-&gt;width-10,0,img1-&gt;width+10,xformed-&gt;height)); \t\tcvSetImageROI(xformed,cvRect(img1-&gt;width-10,0,img1-&gt;width+10,xformed-&gt;height)); \t\tcvSmooth(xformed,xformed_proc,CV_MEDIAN,5);//对拼接缝周围区域进行中值滤波 \t\tcvResetImageROI(xformed); \t\tcvResetImageROI(xformed_proc); \t\tcvShowImage(IMG_MOSAIC_PROC,xformed_proc);//显示处理后的拼接图 */  \t/*想通过锐化解决变换后的图像失真的问题，对于扭曲过大的图像，效果不好 \t\tdouble a[]={  0, -1,  0, -1,  5, -1, 0, -1,  0  };//拉普拉斯滤波核的数据 \t\tCvMat kernel = cvMat(3,3,CV_64FC1,a);//拉普拉斯滤波核 \t\tcvFilter2D(xformed_proc,xformed_proc,&amp;kernel);//滤波 \t\tcvShowImage(IMG_MOSAIC_PROC,xformed_proc);//显示处理后的拼接图*/  }  \n\n\n\n\n实验结果如下：\n\n\n源码下载\n源码下载，基于SIFT与ransac的全景图像拼接，VS工程：\n链接：https://pan.baidu.com/s/1IhafkSETAqVAGSwUPCn5jA提取码：8jnu \n\n","categories":["图像处理与机器学习"],"tags":["机器学习"]},{"title":"超详细最新版Chrome插件安装方法!","url":"https://tanqingbo.cn/chrome-crx-intruduce/","content":"相信很多人都在使用 Chrome 浏览器，其流畅的浏览体验得到了不少用户的偏爱，但流畅只是一方面， Chrome 最大的优势还是其支持众多强大好用的扩展程序（Extensions）。最近为了更好的利用谷歌浏览器，我整理了一些常用且牛逼的谷歌插件，分享给大家。\n正文\n\n闲话不多说，直接上推荐的插件，点击标题就可以直接下载该插件，文章的末尾附有插件的安装教程！！！\n通用类插件1、OneTab：将无数 Tab 合并在一个页面很多时候我们在一个窗口打开太多的tab，每一个tab太小不容易管理，这时候使用OneTab能够把所有tab收起放在一个页面，点击就可打开该tab，非常方便。\n\n离线版下载地址：https://pan.baidu.com/s/1ZYN3l6-uy1S7WzbVd7tE_w 提取码：vfoy\n2、Momentum：美到爆表的新标签页受够了新建页面时候的空白页的话可以试试，Momentum每天都会提供一张高清大图，都很好看。\n\n离线版下载地址：https://pan.baidu.com/s/1yn787oDJ_A40ftBLr7zUXQ 提取码：n8k5\n3、markdown here超好用的一款插件，强烈推荐！！有个它再也不用担心编辑器不支持markdown语法了，写好以后直接一键转换。而且也是一个跨平台神器，比如我们可以把简书写好的文章（带md语法）直接复制到微信公众号，然后一键转换，格式几乎无变化！\n\n离线版下载地址：https://pan.baidu.com/s/1ParM59nUfqxV2Ft9Iea26g 提取码：dxe0\n4、Adblock Plus：免除广告困扰只要是使用 Chrome 的人都应该安装的一款扩展应用，可以帮助你屏蔽几乎大部分网页广告，如果存在漏网之鱼，还可以手动添加到屏蔽列。\n\n离线版下载地址：https://pan.baidu.com/s/1TmJHWu7ZEclUS9BZ7sB5DA 提取码：h4h0\n5、LastPass：密码管理软件LastPass，全球知名在线密码管理工具之一，采用军事级加密算法，支持自动填充网站用户名和密码，与朋友分享登录信息等实用功能，且在全平台同步免费，无需订阅 Premium，即可在手机、网页、电脑端同步你的所有 LastPass 信息。\n\n离线版下载地址：https://pan.baidu.com/s/1OzsJt196G9BCjwBfR6POzw 提取码：25gj\n6、关灯看视频有时候网速太差，全屏以后分辨率很低，可以试试这个，可以让周围页面变暗从而达到最好的视觉效果。\n\n离线版下载地址：https://pan.baidu.com/s/1959uYHrnD918qu53LkTf0A 提取码：5rlp\n7、二维码(QR码)生成器在线的二维码生成器。可以把当前的网页直接生成二维码，进行编辑。还可以把文字生成二维码，这个很重要！\n\n离线版下载地址：https://pan.baidu.com/s/1yvPvbQnQiGf2rhjS-Su8YA 提取码：sbbd\n8、下载+Chrome的下载管理在二级菜单里，进去很不方便。装了这个插件就可以直接看和管理，很好用。\n\n离线版下载地址：https://pan.baidu.com/s/14cJWMp17ThZndgBlUuvYIQ 提取码：v39o\n9、一键管理所有扩展Chrome其实很占内存，尤其当插件装多了以后会卡顿。不过有个这个就不用担心，用不到的时候把插件关掉就行了，随时开随时关。\n\n离线版下载地址：https://pan.baidu.com/s/1-y76jnigaaDlqambnDcTAw 提取码：kf32\n10、购物党在线的比价工具，网购的时候可以看价格历史记录，以及各大网站的价格对比，也有查快递的快捷方式。经常剁手的童鞋要注意了~~\n\n离线版下载地址：https://pan.baidu.com/s/10mAHu_2z3-F6bnT1r6V-YA 提取码：hyh5\n11、右键搜Chrome默认的搜索是谷歌搜索，没有翻墙的童鞋可能用起来不方便，但有这个这个就不用担心了。\n\n离线版下载地址：https://pan.baidu.com/s/1gV39VlYEAtJeozeV58AD9g 提取码：no6t\n12、印象笔记剪藏大象官方的一个插件，可以直接把当前网页直接保存的evernote，非常方便。\n\n离线版下载地址：https://pan.baidu.com/s/1QeVEUXejMCl_HPGSsszZkQ 提取码：qxt7\n13、AlloyDesignerAlloyDesigner是来自Tencent AlloyTeam的前端开发工具，其只出现开发阶段的一定时期，可以在制作时期，也可以在开发测试期，旨在提高前端开发的效率，获得更加便捷的开发体验。AlloyDesigner的主要功能是加载Web页面的视觉稿，结合开发者工具(F12)进行页面的开发和调整。使用AlloyDesigner进行页面开发，基本上可以舍弃Photoshop进行页面的测量，以视觉稿做为背景蓝本进行开发，可以使开发体验更加便捷、高效，其结果页面也更高。AlloyDesigner也可以做为页面开发完成后，对页面进行细微调整，达到更加贴近视觉稿的目的。\n\n离线版下载地址：https://pan.baidu.com/s/1T4Mbe-t2RgIDnF3t4zCdNw 提取码：l5tn\n14、新浪微博图床简单好用的新浪微博图床,支持选择/拖拽/粘贴上传图片,并生成图片地址,HTML,UBB和Markdown等格式,支持浏览和删除历史记录。\n\n离线版下载地址：https://pan.baidu.com/s/1el_JepBuPvyut_CI1KL_bg 提取码：ix5i\n15、Cloudbleed Bookmark Checker：检测书签是否有死链\n对于书签收藏的狂魔同志，收藏夹里的网页肯定有很多都无法访问了吧！这款扩展就是来检测书签是否有死链的。因为不怎么常用，所以才三颗星。\n\n离线版下载地址：https://pan.baidu.com/s/1mWptQbxrvaT5GAwBt-c-yw 提取码：fzlm\n16、Infinity：功能强大的新建标签页扩展功能强大的新建标签页扩展！做的界面很美，每日壁纸质量也很高！有同步笔记、代办事项等，同时，喜欢它的网页图标，提供了很多常用网站的图标，自定义书签时很好看唯一的缺点，就是感觉启动比较慢\n\n离线版下载地址：https://pan.baidu.com/s/1-k6DarlqQcsK8noSwKa6BA 提取码：5fa2\n17、crxMouse Chrome Gestures对于国产浏览器自带鼠标手势的功能，真觉得很方便！这款扩展也是必装啊！\n\n离线版下载地址：https://pan.baidu.com/s/1cp3orsu4FSnqzqlgNd0NHQ 提取码：kh8f\n18、Imagus图片放大镜的功能！在体验了360浏览器、猎豹浏览器之后，特地去找的扩展！微博党的利器！这个不管能鼠标悬停放大图片，同时，对链接等也有预览。提供很多功能选项进行设置。\n\n离线版下载地址：https://pan.baidu.com/s/1qneKCmyOYWQ7cR8okbFkRQ 提取码：t0o1\n19、Save to Pocket\n看到感兴趣的先收藏着，然后走哪儿都能看，因为它提供了全平台的APP，方便管理。Pocket也是手机端我必装的APP之一。\n\n离线版下载地址：https://pan.baidu.com/s/1n0ZEeh8UM_eOwCbkFlHT3w 提取码：jvm9\n20、网页截图:注释&amp;批注在安装了一堆截图扩展之后，最后剩下了它，满足了截图所有的需求，截取可见网页，选择区域，整个网页，另外，还有对截图的标记\n\n离线版下载地址：https://pan.baidu.com/s/1TqxWueQlhFooTVt9q27Spg 提取码：7sl5\n21、眼不见心不烦（新浪微博）Chrome就是满分评价，可见这扩展真是良心扩展啊！微博党的福音！在浏览器端，自己通过这个插件进行设置，可以将热门微博、会员推广等等内容窗口都给屏蔽了！还我们一个干净、舒服的微博环境！推荐！！！\n\n离线版下载地址：https://pan.baidu.com/s/1uMq3lUl_ffF7O5Vw5wplyw 提取码：hjw1\n22、Image Downloader Chrome下载页面图片的工具，很棒\n\n离线版下载地址：https://pan.baidu.com/s/1eaBo7tLcENmoBcSIt7ZtIA 提取码：qou6\n23、WhatRunsWhatRuns是一款用于了解网站技术的chrome网站技术分析工具，主要能通过分析网站页面所使用的框架、代码等技术以及页面所使用的样式等方面，让使用者能直观的了解网站的整体技术信息。在安装了这款插件后，使用者可以通过点击WhatRuns图标来打开插件窗口，通过该窗口使用者可以轻松了解网站的技术信息\n\n离线版下载地址：https://pan.baidu.com/s/11LN06hSLhY42QMo8GQevMw 提取码：9cn4\n24、Google翻译Google翻译是一款由谷歌公司提供的网页划词翻译插件，是Google Chrome的翻译扩展工具，由Google官方发布。安装后，会在Chrome浏览器菜单栏中添加一个按钮，可以方便的在任何时候点击翻译你当前正在访问的页面。\n\n离线版下载地址：https://pan.baidu.com/s/1ZwcH1O0sb5iRlS8sfwzIdQ 提取码：fks1\n25、FireShot 任意方式截取网页的截图插件捕捉网页截图，编辑并将它们保存为PDF，JPEG，GIF，PNG或BMP；上传，打印，在Photoshop中打开，复制到剪贴板或电子邮件\n\n离线版下载地址：https://pan.baidu.com/s/1CyoCaaGhRb2hXjOJT4ToQQ 提取码：4sxw\n26、Lucidchart Diagrams - Desktop：在线绘制多种图表这个扩展程序是一款多功能绘制程序，支持绘制流程图，思维导图，版面设计等，并且有在线和离线两种模式，可谓功能强大。\n\n离线版下载地址：https://pan.baidu.com/s/1ccnG8ON_vyr-P_fsIuhddA 提取码：79fm\n27、Trackr：追踪你的上网习惯这个扩展程序做的事情就是记录你使用 Chrome 上网的习惯，包括上了哪些网站、每个网站呆多长时间，并且还用图表的形式反馈出来，总之装了这个扩展程序就不要上奇奇怪怪的网站了。\n\n离线版下载地址：https://pan.baidu.com/s/1OnL1GGE1HA8T_Mu4oyhiqw 提取码：wgrs\n28、Reader View：Chrome 也有 Safari 的阅读模式将网页转换成 Safari 阅读模式的样式，让你更方便舒适的阅读网页文字，当你访问文章网页的时候，扩展程序的按钮会显示在地址栏末端，点击就能轻松享受更好的阅读模式。\n\n离线版下载地址：https://pan.baidu.com/s/1-eB6gJ5BjJ76e64hnRl8lA 提取码：p3j0\n29、DrumUp：个性化的浏览推荐当你打开一个网页的时候，为您推荐与现在浏览的网页内容相似或者相关的内容，对于英文的支持比较好，每天阅读很多的人能找到很多关联的感兴趣内容。\n\n离线版下载地址：https://pan.baidu.com/s/1kqSQ13j5ZENdMz-rMwbd5g 提取码：j5zt\n30、Mainichi：学习日语，每页一词学习日语的新方式，每当你打开一个新标签页对会显示一个日文单词，并且配有一张简洁的图片、假名及其读音，不知道有多少朋友在学习日语呢？\n\n离线版下载地址：https://pan.baidu.com/s/1mgj9snpaKNApw7WwfVYwow 提取码：s3pu\n31、New Tab Startup Quotes：学习成功人士的格言想学习成功人士的精神和智慧，这个扩展程序可以帮到你，每当你打开一个标签页，它都会显示一位成功人士的格言，不得不说熬得一锅好鸡汤。\n\n离线版下载地址：https://pan.baidu.com/s/1rKHB7vrDB2jhKCFjiry07Q 提取码：kgms\n32、Unsplash Instant每次打开一个新标签页都会显示一张来自 Unsplash 的摄影作品，全高清的分辨率和专业的摄影元素，Unsplash 的作品都是满满的文艺范儿，非常适合文艺青年。\n\n离线版下载地址：https://pan.baidu.com/s/1_xhk3XmFO9U01IaYPD3GSw 提取码：dagz\n33、Search by Image：强大的以图搜图Chrome 又一神器，结合 Google 以图搜图，可以快速让你找到一张图片的来源、其他尺寸、或者寻找到相似的图片，毕竟在搜索方面，还是 Google 做的最好。\n\n离线版下载地址：https://pan.baidu.com/s/1zBtKidy3hjLlXAX-f1Knfw 提取码：1wvy\n33、Instapaper：稍后阅读神器全球两大稍后阅读神器之一 (另外一款为 Pocket)，自从被 Pinterest 收购后，Instapaper 所有高级订阅功能完全免费，令人称道！当你对某个网页内容感兴趣，却没时间马上阅读，点击 Instapaper 图标或使用快捷键 (Cmd+Shift+S)，一键保存至 Instapaper，方便你随时随地进行查看。\n\n离线版下载地址：https://pan.baidu.com/s/1WCHRnak2Bo4dtG0yX1k0YQ 提取码：rhyb\n34、为什么你们就是不能加个空格呢每次看到文章中的英文、数字、中文写在一起，你知道我的内心是什么样吗？你们能不能在它们之间加个空格呢？！不过自从装上了「为什么你们就是不能加个空格呢？」，插件会自动把网页中所有中文、英文、数字、符号之间插入一个空格，从此告别此痛苦，又能和大家好好玩耍啦。\n\n离线版下载地址：https://pan.baidu.com/s/15AJtf81eNN5bzyWTBTZBBA 提取码：l56x\n35、Clear Cache点击图标即可清除缓存、cookie等，开发必备！\n\n离线版下载地址：https://pan.baidu.com/s/1DlTBc1t38jSj-rZXpgx6og 提取码：2ibx\n开发类插件36、JSON ViewerJSONView 是一个方便查看 Json 结构的插件，展开，折叠，可以非常方便的查看接口返回数据。\n\n离线版下载地址：https://pan.baidu.com/s/1Tn28U_cxM0Nh3m9Q8MN_EQ 提取码：6fdv\n37、Postman\n相信开发者朋友一定知道这款插件，这是一款强大的 API &amp; HTTP 请求调试工具，它不仅可以调试简单的 HTML、CSS 以及脚本等简单的网页基本信息，这款 Chrome 插件甚至还能发送几乎所有的 HTTP 请求，可谓是 Web 开发者的一大利器。\n\n离线版下载地址：https://pan.baidu.com/s/15HWzPQsn-ff4WaxmbU3Rtw 提取码：uk0o\n38、Octotreegithub上查看代码的时候总是一层层进入再出来，有点麻烦，没关系，有Octotree。安装Octotree之后，浏览托管在Github上的项目，可看到左侧的树形结构，更方便查看代码。\n\n离线版下载地址：https://pan.baidu.com/s/1B65-8n9qV-fZGBmpqwymMg 提取码：t2lo\n39、VimiumVimium 这个名字其实是 Vim 和 Chromium 的合体。可能很多童鞋已经猜到她是干嘛的了，她继承了Vim的常用操作，完全脱离鼠标来控制浏览器，是一款黑客级别的Chrome插件。对熟悉linux的同学来说，简直是神器。\n\n离线版下载地址：https://pan.baidu.com/s/1r1d_ALxiJLKLAV6zSq_Edw 提取码：yj3l\n40、Tampermonkey俗称‘油猴子’，是一款功能非常强大的插件，他包含：方便的脚本管理、脚本概览、设置多样性、脚本自动更新、安全、兼容性、Chrome 同步、CodeMirror 编辑器、JSHint 语法检查、快速开发、卸载等功能。 其官方描述只一句 The world’s most popular userscript manager。足见其优秀。\n\n离线版下载地址：https://pan.baidu.com/s/1PU1emGwTPP67KFoabVRj8g 提取码：6r6y\n41、Code ColaCode Cola是一个可视化编辑在线页面css样式的chrome插件。\n\n离线版下载地址：https://pan.baidu.com/s/10iM11u4ARNM-Am03crTKQA 提取码：6t4p\n42、WEB前端助手FE助手：包括字符串编解码、图片base64编码、代码压缩、美化、JSON格式化、正则表达式、时间转换工具、二维码生成器、编码规范检测、页面性能检测、栅格检测、JS运行效率分析等。\n\n离线版下载地址：https://pan.baidu.com/s/17ChKeWr-krRIfDMc0YZ5sA 提取码：ufaf\n插件安装离线安装谷歌插件方法也很简单：1、打开谷歌浏览器输入：chrome://extensions/2、打钩开发者模式3、把下载的后缀为crx的文件拖进来即可安装\n整这个真是体力活，好几个小时才整理完，后面发现新的好玩的插件再补充进来，如果对你有用的话，帮我点个赞吧！\n","categories":["工具"],"tags":["工具","Chrome"]},{"title":"GPU医学图像处理应用","url":"https://tanqingbo.cn/GPU-medical-image-processing/","content":"前言\n通常情况下GPU（图像处理单元）与CPU（中央处理单元）的理论性能相差10倍，GPU强于CPU。\nGPU是多数据并行设计，性能取决于给定算法的并行化成程度。它主要用于苛刻的重建算法、医学图像、超声波、光学成像、显微技术。\n本文主要介绍GPU用于医学图像处理的4个方面：\n基本的图像处理操作，如滤波和插值\n医学成像中最常用的算法： 图像配准，图像分割和图像去噪\n讨论特定于不同形式（例如，CT，MRI和超声波）的算法和实现\nGPU加速医学成像的未来挑战和可能性的讨论\n\n\n\nGPU用于基本的图像处理操作\nCUDA（Compute Unified Device Architecture），是显卡厂商NVIDIA推出的运算平台。 CUDA™是一种由NVIDIA推出的通用并行计算架构，该架构使GPU能够解决复杂的计算问题。滤波\n由滤波卷积公式可知，卷积非常适合并行处。\nGPU可以高效地加速多维FFT，因为每个GPU线程可以独立处理沿着2D或3D图像的每个单独行的数据。相比之下，基于GPU的一维FFT通常需要非常大量的样本才能提高速度。\n通过应用和组合许多小的可分离滤波器而不是一个大的不可分离滤波器来加速卷积。理论上，这可以将2D所需乘法次数减少5倍，3D减少25次，4D减少300次。\n基于GPU的过滤已经完成了大量的工作。 但是，在2,3和4维中仍然不存在可分离和不可分离卷积的免费库。\n\n插值\n插值是GPU实现最大优势的应用程序。 由于计算机图形很大程度上依赖于插值计算，GPU已经被赋予了特殊的专用硬件支持（纹理存储器）来加速这些操作。 在医学成像中，对于从图像配准到重建CT数据的算法，插值是一个重要的处理步骤。\nLjung等人（2006）因此在GPU上执行了块间插值以提高可视化的质量。 Kraus等人（2007）使用GPU加速实现了边缘定向图像插值，以实现实时升频采样而不会产生振动伪像。\n\n距离变换\n距离计算可以针对每个元素独立执行，因此非常适合GPU实现。\n\nGPU用于算法图像配准\n图像配准是医学成像中最常见的算法之一，也是GPU实现最多的算法之一。 其中一个原因是GPU对线性插值的硬件支持，从而可以非常高效地转换图像和体积。\n\n图像分割\n分割仍然是一个活跃的研究领域，目前还没有发现可以解决所有问题的单一分割算法。\n\n基于GPU的图像分割可以用于三个目的:\n\n快速比较多个候选分割算法。\n一旦建立了工作分割算法，GPU可以加速大数据集的自动分割。\nGPU还可以执行交互式分割和可视化，用户可以帮助算法提供令人满意的结果。\n\n\n组合的交互式分割和可视化非常适合GPU，因为已经在GPU内存中的数据可以非常高效地渲染。\n\n\nGPU讨论\n全球显存的尺寸目前为1GB（例如Nvidia GTX 285）至6GB（例如Nvidia GTX Titan）用于消费者显卡，4-8GB用于专业显卡。\n对于工作站，CPU内存容量可以很容易地从4 GB到128 GB不等。对于2D图像处理来说，6GB的全局内存通常就足够了，但对于3D图像处理而言，它可能太少。\n\n编程语言和库\nCUDA编程语言显然使得为通用计算编程GPU变得更加容易。 CUDA的主要缺点是它只支持Nvidia GPU。\nOpenCL（全称Open Computing Language，开放运算语言）是第一个面向异构系统通用目的并行编程的开放式、免费标准。\n使用CUDA和OpenCL编写的代码可以产生不同的性能。 CUDA目前提供的更大优势是Nvidia致力于为其专有平台提供高度优化的库。\n\n","categories":["图像处理与机器学习"],"tags":["机器学习"]},{"title":"均值滤波和中值滤波去噪","url":"https://tanqingbo.cn/Mean filter and median filter denoising/","content":"\n均值滤波和中值滤波的内容非常基础，均值滤波相当于低通滤波，有将图像模糊化的趋势，对椒盐噪声基本无能为力。中值滤波的优点是可以很好的过滤掉椒盐噪声，缺点是易造成图像的不连续性。在下面的代码中，中值滤波主要通过冒泡算法来实现。\n\n程序中值滤波public void jMedian_ActionPerformed(ActionEvent e) {      \tif(flag_load){  \t\ttry{  \t\t\t  PixelGrabber pg = new PixelGrabber(im,0,0,iw,ih,pixels,0,iw);  \t\t\t  pg.grabPixels();  \t\t  }catch(InterruptedException e3){  \t\t\te3.printStackTrace();  \t\t  }  \t\tBufferedImage grayImage = new BufferedImage(iw, ih,   \t\t\t\t  BufferedImage.TYPE_INT_RGB);  \t\tColorModel cm = ColorModel.getRGBdefault();  \t\tint[] tpRed = new int[9];  \t\tint[] tpGreen = new int[9];  \t\tint[] tpBlue = new int[9];  \t\tfor(int i=1;i&lt;ih-1;i++){  \t\t\tfor(int j=1;j&lt;iw-1;j++){  \t\t\t\ttpRed[0] = cm.getRed(pixels[(i-1)*iw+j-1]);  \t\t\t\ttpRed[1] = cm.getRed(pixels[(i-1)*iw+j]);  \t\t\t\ttpRed[2] = cm.getRed(pixels[(i-1)*iw+j+1]);  \t\t\t\ttpRed[3] = cm.getRed(pixels[i*iw+j-1]);  \t\t\t\ttpRed[4] = cm.getRed(pixels[i*iw+j]);  \t\t\t\ttpRed[5] = cm.getRed(pixels[i*iw+j+1]);  \t\t\t\ttpRed[6] = cm.getRed(pixels[(i+1)*iw+j-1]);  \t\t\t\ttpRed[7] = cm.getRed(pixels[(i+1)*iw+j]);  \t\t\t\ttpRed[8] = cm.getRed(pixels[(i+1)*iw+j+1]);  \t\t\t\t\tfor(int rj=0; rj&lt;8; rj++){  \t\t\t\t\tfor(int ri=0; ri&lt;8-rj; ri++){  \t\t\t\t\t\tif(tpRed[ri]&gt;tpRed[ri+1]){  \t\t\t\t\t\t\tint Red_Temp = tpRed[ri];  \t\t\t\t\t\t\ttpRed[ri] = tpRed[ri+1];  \t\t\t\t\t\t\ttpRed[ri+1] = Red_Temp;  \t\t\t\t\t\t}  \t\t\t\t\t}  \t\t\t\t}  \t\t\t\tint medianRed = tpRed[4];  \t\t\t\ttpGreen[0] = cm.getGreen(pixels[(i-1)*iw+j-1]);  \t\t\t\ttpGreen[1] = cm.getGreen(pixels[(i-1)*iw+j]);  \t\t\t\ttpGreen[2] = cm.getGreen(pixels[(i-1)*iw+j+1]);  \t\t\t\ttpGreen[3] = cm.getGreen(pixels[i*iw+j-1]);  \t\t\t\ttpGreen[4] = cm.getGreen(pixels[i*iw+j]);  \t\t\t\ttpGreen[5] = cm.getGreen(pixels[i*iw+j+1]);  \t\t\t\ttpGreen[6] = cm.getGreen(pixels[(i+1)*iw+j-1]);  \t\t\t\ttpGreen[7] = cm.getGreen(pixels[(i+1)*iw+j]);  \t\t\t\ttpGreen[8] = cm.getGreen(pixels[(i+1)*iw+j+1]);  \t\t\t\tfor(int rj=0; rj&lt;8; rj++){  \t\t\t\t\tfor(int ri=0; ri&lt;8-rj; ri++){  \t\t\t\t\t\tif(tpGreen[ri]&gt;tpGreen[ri+1]){  \t\t\t\t\t\t\tint Green_Temp = tpGreen[ri];  \t\t\t\t\t\t\ttpGreen[ri] = tpGreen[ri+1];  \t\t\t\t\t\t\ttpGreen[ri+1] = Green_Temp;  \t\t\t\t\t\t}  \t\t\t\t\t}  \t\t\t\t}  \t\t\t\tint medianGreen = tpGreen[4];  \t\t\t\ttpBlue[0] = cm.getBlue(pixels[(i-1)*iw+j-1]);  \t\t\t\ttpBlue[1] = cm.getBlue(pixels[(i-1)*iw+j]);  \t\t\t\ttpBlue[2] = cm.getBlue(pixels[(i-1)*iw+j+1]);  \t\t\t\ttpBlue[3] = cm.getBlue(pixels[i*iw+j-1]);  \t\t\t\ttpBlue[4] = cm.getBlue(pixels[i*iw+j]);  \t\t\t\ttpBlue[5] = cm.getBlue(pixels[i*iw+j+1]);  \t\t\t\ttpBlue[6] = cm.getBlue(pixels[(i+1)*iw+j-1]);  \t\t\t\ttpBlue[7] = cm.getBlue(pixels[(i+1)*iw+j]);  \t\t\t\ttpBlue[8] = cm.getBlue(pixels[(i+1)*iw+j+1]);  \t\t\t\tfor(int rj=0; rj&lt;8; rj++){  \t\t\t\t\tfor(int ri=0; ri&lt;8-rj; ri++){  \t\t\t\t\t\tif(tpBlue[ri]&gt;tpBlue[ri+1]){  \t\t\t\t\t\t\tint Blue_Temp = tpBlue[ri];  \t\t\t\t\t\t\ttpBlue[ri] = tpBlue[ri+1];  \t\t\t\t\t\t\ttpBlue[ri+1] = Blue_Temp;  \t\t\t\t\t\t}  \t\t\t\t\t}  \t\t\t\t}  \t\t\t\tint medianBlue = tpBlue[4];  \t\t\t\tint rgb = 255&lt;&lt;24|medianRed&lt;&lt;16|medianGreen&lt;&lt;8|medianBlue;   \t\t\t\tgrayImage.setRGB(j, i, rgb);  \t\t\t}     \t\t}  \t\ttmp = grayImage;  \t\trepaint();  \t}else{  \t\tJOptionPane.showMessageDialog(null, \"先点击“装载图像”，3Q！\",\"提示：\",  \t\t\t\tJOptionPane.WARNING_MESSAGE);  \t\t}  }\n\n\n\n均值滤波public void jMean_ActionPerformed(ActionEvent e) {      \tif(flag_load){  \t\ttry{  \t\t\t  PixelGrabber pg = new PixelGrabber(im,0,0,iw,ih,pixels,0,iw);  \t\t\t  pg.grabPixels();  \t\t  }catch(InterruptedException e3){  \t\t\te3.printStackTrace();  \t\t  }  \t\tBufferedImage grayImage = new BufferedImage(iw, ih,   \t\t\t\t  BufferedImage.TYPE_INT_RGB);  \t\tColorModel cm = ColorModel.getRGBdefault();  \t\tfor(int i=1;i&lt;ih-1;i++){  \t\t\tfor(int j=1;j&lt;iw-1;j++){  \t\t\t\tint red1 = cm.getRed(pixels[(i-1)*iw+j-1]);  \t\t\t\tint red2 = cm.getRed(pixels[(i-1)*iw+j]);  \t\t\t\tint red3 = cm.getRed(pixels[(i-1)*iw+j+1]);  \t\t\t\tint red4 = cm.getRed(pixels[i*iw+j-1]);  \t\t\t\tint red6 = cm.getRed(pixels[i*iw+j+1]);  \t\t\t\tint red7 = cm.getRed(pixels[(i+1)*iw+j-1]);  \t\t\t\tint red8 = cm.getRed(pixels[(i+1)*iw+j]);  \t\t\t\tint red9 = cm.getRed(pixels[(i+1)*iw+j+1]);  \t\t\t\tint meanRed = (red1+red2+red3+red4+red6+red7+red8+red9)/8;  \t\t\t\tint green1 = cm.getGreen(pixels[(i-1)*iw+j-1]);  \t\t\t\tint green2 = cm.getGreen(pixels[(i-1)*iw+j]);  \t\t\t\tint green3 = cm.getGreen(pixels[(i-1)*iw+j+1]);  \t\t\t\tint green4 = cm.getGreen(pixels[i*iw+j-1]);  \t\t\t\tint green6 = cm.getGreen(pixels[i*iw+j+1]);  \t\t\t\tint green7 = cm.getGreen(pixels[(i+1)*iw+j-1]);  \t\t\t\tint green8 = cm.getGreen(pixels[(i+1)*iw+j]);  \t\t\t\tint green9 = cm.getGreen(pixels[(i+1)*iw+j+1]);  \t\t\t\tint meanGreen = (green1+green2+green3+green4+green6+green7+green8+green9)/8;  \t\t\t\tint blue1 = cm.getBlue(pixels[(i-1)*iw+j-1]);  \t\t\t\tint blue2 = cm.getBlue(pixels[(i-1)*iw+j]);  \t\t\t\tint blue3 = cm.getBlue(pixels[(i-1)*iw+j+1]);  \t\t\t\tint blue4 = cm.getBlue(pixels[i*iw+j-1]);  \t\t\t\tint blue6 = cm.getBlue(pixels[i*iw+j+1]);  \t\t\t\tint blue7 = cm.getBlue(pixels[(i+1)*iw+j-1]);  \t\t\t\tint blue8 = cm.getBlue(pixels[(i+1)*iw+j]);  \t\t\t\tint blue9 = cm.getBlue(pixels[(i+1)*iw+j+1]);  \t\t\t\tint meanBlue = (blue1+blue2+blue3+blue4+blue6+blue7+blue8+blue9)/8;  \t\t\t\tint rgb = 255&lt;&lt;24|meanRed&lt;&lt;16|meanGreen&lt;&lt;8|meanBlue;   \t\t\t\tgrayImage.setRGB(j, i, rgb);  \t\t\t}     \t\t}  \t\ttmp = grayImage;  \t\trepaint();  \t}else{  \t\tJOptionPane.showMessageDialog(null, \"先点击“装载图像”，3Q！\",\"提示：\",  \t\t\t\tJOptionPane.WARNING_MESSAGE);  \t\t}  }  \n\n\n\n\n去噪效果高斯噪声\n椒盐噪声\n源码下载\nhttp://download.csdn.net/download/tanqingbo/10162135\n\n","categories":["图像处理与机器学习"],"tags":["机器学习"]},{"title":"图像处理之给图片加噪声","url":"https://tanqingbo.cn/Image-processing-plus-noise/","content":"前言\n图像处理的实验，用matlab捣鼓了一会最后还是觉得Java用的比较顺手，所以使用Java实现的给图像加噪声，分别给图像添加椒盐噪声、高斯噪声、泊松分布噪声。椒盐噪声（Salt And Pepper Noise）\n椒盐噪声是一种因为信号脉冲强度引起的噪声，信噪比（Signal NoiseRate）是衡量图像噪声的一个数字指标。\n给一副数字图像加上椒盐噪声的处理顺序应该如下：\n指定信噪比 SNR 其取值范围在[0, 1]之间\n\n\n计算总像素数目 SP， 得到要加噪的像素数目 NP = SP * (1-SNR)\n随机获取要加噪的每个像素位置P（i, j）\n指定像素值为255或者0。\n重复3, 4两个步骤完成所有像素的NP个像素\n输出加噪以后的图像\n\n\n\n代码如下：\n   /*\t* 椒盐噪声*/   private BufferedImage addSaltAndPepperNoise(BufferedImage src, BufferedImage dst) {      int width = src.getWidth();        int height = src.getHeight();         if ( dst == null )     \t   dst = createCompatibleDestImage( src, null );        int[] inPixels = new int[width*height];        getRGB( src, 0, 0, width, height, inPixels );     \t        int index = 0;        int size = (int)(inPixels.length * (1-SNR));        for(int i=0; i&lt;size; i++) {     \tint row = (int)(Math.random() * (double)height);     \tint col = (int)(Math.random() * (double)width);     \tindex = row * width + col;      \tinPixels[index] = (255 &lt;&lt; 24) | (255 &lt;&lt; 16) | (255 &lt;&lt; 8) | 255;        }       setRGB( dst, 0, 0, width, height, inPixels );        return dst;     }\n\n\n\n高斯噪声（Gaussian Noise）\n高斯噪声的密度取决于公式G(x, sigma) 其中X是代表平均值，sigma代表的标准方差，每个输入像素 Pin,一个正常的高斯采样分布公式G(d), 得到输出像素Pout.\nPout = Pin + XMeans + sigma *G(d)\n\n其中d为一个线性的随机数，G(d)是随机数的高斯分布随机值。\n\n给一副数字图像加上高斯噪声的处理顺序如下：\n\n输入参数sigam 和 X mean\n\n\n系统时间为种子产生一个伪随机数\n将伪随机数带入G（d）得到高斯随机数\n根据输入像素计算出输出像素\n重新将像素值防缩在[0 ~ 255]之间\n循环所有像素\n输出图像\n\n\n代码如下：\n\n\n/* * 添加高斯噪声   */   private int addGNoise(int tr, Random random) {     int v, ran;     boolean inRange = false;     do {     \tran = (int)Math.round(random.nextGaussian()*_mNoiseFactor);  //均值为0.0，标准差为1.0的高斯分布   \tv = tr + ran;     \t// check whether it is valid single channel value     \tinRange = (v&gt;=0 &amp;&amp; v&lt;=255);      \tif (inRange) tr = v;     } while (!inRange);     return tr;      }  public static int clamp(int p) {  \treturn p &gt; 255 ? 255 : (p &lt; 0 ? 0 : p);  }  \n\n\n\n泊松噪声\n泊松噪声，就是噪声分布符合泊松分布模型。泊松分布(Poisson Di)的公式如下：\n\n\n\n关于泊松分布的详细解释看这里：http://zh.wikipedia.org/wiki/泊松分佈.\n\n代码如下：\n/* * 泊松噪声   */   private int addPNoise(int pixel, Random random) {     // init:     double L = Math.exp(-_mNoiseFactor * MEAN_FACTOR);     int k = 0;     double p = 1;     do {     \tk++;     \t// Generate uniform random number u in [0,1] and let p ← p × u.     \tp *= random.nextDouble();    } while (p &gt;= L);     double retValue = Math.max((pixel + (k - 1) / MEAN_FACTOR - _mNoiseFactor), 0);     return (int)retValue;     }  \n\n\n\n\n程序效果\n原图\n\n\n\n高斯噪声\n\n\n\n椒盐噪声\n\n\n全部代码  package lab3;import java.awt.image.BufferedImage;  \timport java.util.Random;  \tpublic class NoiseAdditionFilter extends AbstractBufferedImageOp {  \tpublic final static double MEAN_FACTOR = 2.0;  \tpublic final static int POISSON_NOISE_TYPE = 2;  //泊松噪声\tpublic final static int GAUSSION_NOISE_TYPE = 1;  //高斯噪声\tpublic final static int Salt_NOISE_TYPE = 3;  //椒盐噪声\tprivate double _mNoiseFactor = 100;   //高斯分布数值大小\tprivate int _mNoiseType = 2;    //选择噪声\tprivate static final double SNR = 0.5;   //椒盐噪声信噪比  public NoiseAdditionFilter() {  \t\tSystem.out.println(\"Adding Poisson/Gaussion Noise\");  \t}  \tpublic void setNoise(double power) {  \t\tthis._mNoiseFactor = power;  \t}  \tpublic void setNoiseType(int type) {  \t\tthis._mNoiseType = type;  \t}  \t@Override  public BufferedImage filter(BufferedImage src, BufferedImage dest) {   \tint width = src.getWidth();   \tint height = src.getHeight();   \tRandom random = new Random();   \tif ( dest == null )   \t\tdest = createCompatibleDestImage( src, null );   \tint[] inPixels = new int[width*height];   \tint[] outPixels = new int[width*height];   \tgetRGB( src, 0, 0, width, height, inPixels );   \tint index = 0;   \tfor(int row=0; row&lt;height; row++) {   \t\tint ta = 0, tr = 0, tg = 0, tb = 0;   \t\tfor(int col=0; col&lt;width; col++) {   \t\t\tindex = row * width + col;   \t\t\tta = (inPixels[index] &gt;&gt; 24) &amp; 0xff;   \t\t\ttr = (inPixels[index] &gt;&gt; 16) &amp; 0xff;   \t\t\ttg = (inPixels[index] &gt;&gt; 8) &amp; 0xff;   \t\t\ttb = inPixels[index] &amp; 0xff;   \t\t\tif(_mNoiseType == Salt_NOISE_TYPE) { \t\t\t\treturn this.addSaltAndPepperNoise(src,dest); \t\t\t} \t\t\tif(_mNoiseType == POISSON_NOISE_TYPE) {   \t\t\t\ttr = clamp(addPNoise(tr, random));   \t\t\t\ttg = clamp(addPNoise(tg, random));   \t\t\t\ttb = clamp(addPNoise(tb, random));   \t\t\t} else if(_mNoiseType == GAUSSION_NOISE_TYPE) {   \t\t\t\ttr = clamp(addGNoise(tr, random));   \t\t\t\ttg = clamp(addGNoise(tg, random));   \t\t\t\ttb = clamp(addGNoise(tb, random));   \t\t\t}   \t\t\toutPixels[index] = (ta &lt;&lt; 24) | (tr &lt;&lt; 16) | (tg &lt;&lt; 8) | tb;   \t\t}   \t}   System.out.println(\"fd\"); \tsetRGB( dest, 0, 0, width, height, outPixels );   \treturn dest;   }   /*   * 添加高斯噪声    */    private int addGNoise(int tr, Random random) {      int v, ran;      boolean inRange = false;      do {      \tran = (int)Math.round(random.nextGaussian()*_mNoiseFactor);  //均值为0.0，标准差为1.0的高斯分布    \tv = tr + ran;      \t// check whether it is valid single channel value      \tinRange = (v&gt;=0 &amp;&amp; v&lt;=255);       \tif (inRange) tr = v;      } while (!inRange);      return tr;       }    public static int clamp(int p) {   \treturn p &gt; 255 ? 255 : (p &lt; 0 ? 0 : p);   }   /*   * 泊松噪声    */    private int addPNoise(int pixel, Random random) {      // init:      double L = Math.exp(-_mNoiseFactor * MEAN_FACTOR);      int k = 0;      double p = 1;      do {      \tk++;      \t// Generate uniform random number u in [0,1] and let p ← p × u.      \tp *= random.nextDouble();      } while (p &gt;= L);      double retValue = Math.max((pixel + (k - 1) / MEAN_FACTOR - _mNoiseFactor), 0);      return (int)retValue;      }      /*   * 椒盐噪声    */    private BufferedImage addSaltAndPepperNoise(BufferedImage src, BufferedImage dst) {      int width = src.getWidth();         int height = src.getHeight();         if ( dst == null )      \t   dst = createCompatibleDestImage( src, null );         int[] inPixels = new int[width*height];         getRGB( src, 0, 0, width, height, inPixels );      \t        int index = 0;         int size = (int)(inPixels.length * (1-SNR));          for(int i=0; i&lt;size; i++) {      \tint row = (int)(Math.random() * (double)height);      \tint col = (int)(Math.random() * (double)width);      \tindex = row * width + col;      \tinPixels[index] = (255 &lt;&lt; 24) | (255 &lt;&lt; 16) | (255 &lt;&lt; 8) | 255;         }         setRGB( dst, 0, 0, width, height, inPixels );         return dst;      }    }  \n\n","categories":["图像处理与机器学习"],"tags":["机器学习"]},{"title":"分割精度性能度量","url":"https://tanqingbo.cn/分割精度说明/","content":"介绍\n为了能对提出的方法的性能进行定量的评估。本文采用了和2007年医学影像计算与计算机辅助介入国际会议（MICCAI）医学图像分割竞赛[21]相同的两个基于体积的度量指标体积重叠率（Dice Similarity Coefficient，Dice）和基于表面距离的度量指标平均对称表面距离（Average Symmetric Surface Distance，ASD）来对分割结果A与手动分割金标准B进行比较。其中体积重叠率（Dice）与平均对称表面距离（ASD）的定义如下：\n（1）体积重叠率（Dice Similarity Coefficient，Dice）：在定义体积重叠率之前需要先定义分割结果A和金标准B的体积重叠率系数，也称Jaccard系数( Jaccard Index，JI )[22]:\n\n  \n\n其中，V(A)表示分割结果A的体素集合、V(B)表示金标准B的体素集合。相应的，体积重叠率（Dice）就可以定义为：\n\n  \n\n（2）平均对称表面距离（Average Symmetric Surface Distance，ASD）：它是基于表面距离的度量指标。定义为分割结果A的表面体素S(A)与金标准B的表面体素S(B)之间的平均距离：\n\n  \n\n其中，d(v,S(X))定义为体素V到分割结果X表面体素的最小欧式距离：\n\n  \n\n这两个基于体积的度量指标体积重叠率（Dice）和基于表面距离的度量指标平均对称表面距离（ASD）的单位分别为%和mm，对于体积重叠率（Dice）来说，值越大表示分割结果越精确，对于平均对称表面距离（ASD）来说，值越小说明分割结果越精确。\n\n算法实现\n计算体积重叠率的时候，先计算分割结果和金标准的非零体素的总个数volume1+volume2，再计算体素重叠的个数intersection，用intersection/（volume1+volume2）得到JI，再用Dice计算公式得到Dice。\n\n部分代码如下：\n  // Tanimoto overlap metric  unsigned long volume1=0, volume2=0, intersection=0;  IteratorType resIt( resultImage, resRegion ), valIt( validationImage, valRegion );  for ( resIt.GoToBegin(), valIt.GoToBegin(); !resIt.IsAtEnd(); ++resIt, ++valIt ) {\tif (resIt.Get()!=0) {\t  volume1++;\t  if (valIt.Get()!=0) {\t\tvolume2++;\t\tintersection++;\t  }\t}\telse {\t  if (valIt.Get()!=0) volume2++;\t}  }  double tanimotoVal = 100.0 * (double)(intersection) / ((double)(volume1+volume2-intersection));  double tanimotoError = 100.0 - tanimotoVal; //求dice  double jiError = (100.0 - tanimotoError)/100.0;  double diceError = 2 * jiError/(1 + jiError) * 100;\n\n\n\n\n\n\n\n计算平均对称表面距离ASD的时候，需要先计算分割结果和金标准元素在同一个坐标系里面的全球坐标，再利用ANNkd_tree类求平均表面对称距离。\n\n部分代码如下：\n ANNpointArray borderPts2 = annAllocPts( numBorderPts2, 3 ); numBorderPts2 = 0;for ( it2.GoToBegin(); !it2.IsAtEnd(); ++it2 ) {if (it2.Get() != 0) {  validationImage-&gt;TransformIndexToPhysicalPoint( it2.GetIndex(), pnt );   //将像素数组中的Index转换为物理空间中的坐标。  for (int d=0; d&lt;3; d++) borderPts2[numBorderPts2][d] = pnt[d];  numBorderPts2++; } } ANNkd_tree *borderTree2 = new ANNkd_tree( borderPts2, numBorderPts2, 3 ); ANNidxArray  nnIdx = new ANNidx[1]; ANNdistArray dists = new ANNdist[1]; for(unsigned int idx1=0; idx1&lt;numBorderPts1; idx1++) {borderTree2-&gt;annkSearch( borderPts1[idx1], 1, nnIdx, dists);avgSqrDistance += dists[0];double d = sqrt( dists[0] ); //分割结果到金标准的最小欧式距离avgDistance += d; if (d&gt;maxDistance) maxDistance = d; }\n\n\n\n","categories":["图像处理与机器学习"],"tags":["图谱分割"]},{"title":"基于分层区域稀疏成分的肝脏分割","url":"https://tanqingbo.cn/Liver-segmentation-of-sparse-components/","content":"前言本文是我阅读医学图像分析论文《A hierarchical local region-based sparse shape composition for liversegmentation in CT scans》所做的一些笔记。翻译的中文名为：基于分层区域稀疏成分的肝脏分割。\n基于分层区域稀疏成分的肝脏分割\n本文的主要贡献可以概括如下:\n\n(1)提出了MLR-SSC增加形状先验模型的灵活性和获取详细的局部形状信息更忠实的小训练集(3.1节);\n(2)一个有效和可伸缩的优化算法(即。,LARS-Homotopy方法[34])求解稀疏优化问题在MLR-SSC(3.1.2节);\n(3)提出一种血液vessel-based肝脏形状初始化方法获得一个更特定的初始形状(3.2.1节);\n(4)分级优化策略开发的细分框架更有效率和更健壮的局部最小值(3.2.2节),并成功地应用于部分肝组织从CT图像(5节)。背景和相关工作\n\n\n提出一个新颖的多级当地提出SSC(MLR-SSC)提高精度和降低计算成本。具体来说,我们将肝脏形状分解成多个区域多层次的方式,这样,每个地区都有均匀的形状变化。然后我们建立一个当地的形状库中为每个地区和完善地区的方式输入形状。\n\nZhang et al。[35]他们使用的内点方法解决稀疏优化问题,当我们使用一个更加高效和可伸缩的优化算法(即。LARS-Homotopy方法[34]);\n\n他们应用来自每个次区域的稀疏系数xj来完善整个输入形状,而我们使用一个地区细化策略,更准确和高效。\n\n在他们的层次分割框架,single-resolution技术(即。,只有使用原始输入图像)实现,我们开发一个多分辨率优化策略(即。,使用原始输入图像的高斯金字塔),已被证明对于局部最小值是更有效更健壮的[39]。\n方法（Method）\n在本节中,我们描述我们提出ASM-based分层肝脏分割框架。主要工作流程分割框架见图2,包括离线训练和运行时测试阶段。\n多级形状分割过程：\n输入：\n\nM¯：主要的肝脏形状\n{δi }：对于每一个三角形Ti的形状变化标准差\nnl：多级形状分割L水平划分的区域个数\n\n\nstep1：初始化：\n\n为每一个区域Ri创建一个随机的种子三角形Ti.\n为每一个区域标记代理Pi：Pi=(mi)←δi.\n\n\nstep2：区域划分：\n\nRi←∅;将Ti添加到对应的区域Ri中，Ri←Ri∪Ti.\n\n初始化一个全局优先队列Q： Q←∅.\n\n将每一个与种子三角形Ti相邻的三角形Tj的近似误差L(Tj, Pi)和标签TagTj插入Q，L(Tj,Pi)=|δj−mi|。\nwhile Q≠∅ do\t Tj← Pop 三角形最小的近似误差\t  if 没有标签Tj then\t    添加Tj地区表示其标签TagTj:RTagTj←RTagTj∪Tj。\t    将TagTj重新插入Q\t  end if\tend while\n\n\n\n\n\n\n\nstep3:代理配件\n\n根据邻近区域Ri的平均形状变化更新每一个代理Pi=(mi)， mi←1/|Ri|∑Tj∈Ri δj.\n为每一个新区域Ri更新种子三角形Ti，使Ri的近似误差最小。Ti←argminTj∈Ri L(Tj,Pi).\n\n\nstep4:重复step3和step3.\n\n输出在l区域水平主要肝脏形状的分割结果。R={R1,…,Rnl}.\n\nMLR-SSC模型能够非常健壮的处理大型的稀疏错误和小密度的高斯噪音，能够恢复复杂的形状变形和详细地局部信息.\n分层肝脏分割框架\n我们的细分框架包含两个主要组件:肝脏形状初始化和分层优化算法。\n\n肝脏形状初始化\n\n中值滤波应用于输入的CT图像减少噪音\nFrangi׳s vesselness方法来增强肝脏血管\n移动立方体算法将提取的肝血管转换成三角网格\n使用Quickhull算法计算血管的凸包来提取肝脏的核心区域\nASM本地搜索策略可能会导致最终结果过度或欠分割\n\n\n使用我们提出的MLR-SSC策略能够更准确的分割肝脏形状\n\n设level l = 0，nl= 1（设0层只有一个区域）\n用全局SSC定义核心区域\n所推断出来的初始形状更准确，与真值更一致，尤其是在白色矩形所表示的区域分级优化策略\n\n\n分级优化策略的形状模型是由粗到精的方式，是一个支持多分辨率的策略\n\n首先构造多分辨率高斯金字塔的所有训练体积，这样MLR-SSC在不同的级别对应不同的决议。\n输入一个CT进行分割，我们同样为其建立一个多分辨率高斯金字塔，然后开始ASM搜索，设level l = 0，nl= 1，然后再level l 上逐渐增加跟多的区域，这样更详细的局部信息可以重建。\nASM搜索从输入的体积最低分辨率开始，外观模型对应这一级别。\n在收敛或迭代预定义的次数之后移动到更高的分辨出。\n每一级的分割结果直接用来初始化下一级。\n重复这个过程直到收敛达到原始输入量的金字塔。\n\n\n上述算法描述：\n\n输入：\n\nV:腹部门静脉体积\nLmax:分辨率级别数量\nNmax:每级分辨率的迭代次数。\n\n\n输出：\n\nM(Lmax−1)：分割结果\n\nM0:肝脏血管初始化形状\n\n{ V0,V1,…,V(Lmax−1)= V }：为V构建的多分辨率高斯金字塔  \n for l=0 to (Lmax−1) do\t for i=0 to (Nmax−1) do\t  for 所有的点vj∈Ml do\t\tqj = ASM搜索算法在Vj中找到的目标点；\t\tvj = qj；\t  end for\t  Ml = 使用MLR-SSC完善的中间变形形状\t  i = i+1;\t end for \t l = l+1;\tend for\treturn M(Lmax−1);\n\n\n\n\n\n\n\n\n实验\n数据集：在这项研究中所有数据集的详细信息由表1给出\n注意,当比较我们的方法和先进的方法基于3 dircadb1(部分5.4.1之前)和SLIVER07-Test(5.4.2节)数据库中,我们仅仅使用SLIVER07-Train数据库作为训练数据。\n\n\n评价指标和统计分析\n为了定量评估我们的方法和性能，提供五个体积和表面的基础指标:体积重叠误差(VOE),标记相对体积差异(SRVD),平均对称表面距离(ASD),均方根对称表面距离(RMSD)和最大对称面的距离(MSD)。\n这些评价指标,值越小,分割的结果更好。\n在所有的指标中，VOE和ASD通常用来评价分割准确性。\n\n\n实现细节\n分层肝脏分割框架的参数集确定离线使用SLIVER07-Train数据库来获得最优性能\n在我们的实现中，对所有的测试数据设置都是相同的\n所有的参数设置部署都在表2中列出了\n在Eq中选择稀疏参数 λ 的值\n形状划分的层次数量L和分辨率水平Lmax 将在5.1.3和5.1.4详细讨论 \n\n\n\ntable 2\n参数值详细信息\nnp2562有意义的点的数量\nL5形状分割层数\nλ100Eq中稀疏参数\nLmax5分辨率级别数量\nNmax10每级分辨率的迭代次数\nk9标准剖面两侧采样点的数量\nne6在每一次迭代时，评估两边点的新位置数量\n\n\n\n\n在这项研究中,我们还将提出MLR-SSC模型与两个紧密相关的方法进行比较：\nSSM,统计形状模型使用主成分分析(PCA)学习形状先验模型\nSSC,稀疏的形状组成使用形状库D中提炼的一个输入形状作为全局训练形状（这是我们提出的方法中的一个特例，levels L=1.）\n\n\n用到的工具：C++实现，Ubuntu平台，SPAMS库（开源稀疏优化工具）结果\nMLR-SSC模型评估：在不同情况下，评价其泛化能力，在所有试验中令  level l=2 with nl=4 regions.\n泛化能力、专一性和密实度是量化一个形状模型质量的三个最常用的措施。在本论文中采用泛化能力评价模型质量\n泛化能力值越小,形状建模方法就越好。\n泛化能力和效率完胜其他两个方法\n训练数据的大小对泛化能力的影响\n我们的方法能够克服有限的训练数据的影响（一般训练数据越小，泛化值越大）\n\n\n稀疏参数对泛化能力的影响\n由图12，稀疏参数λ的选择对我们的成功至关重要\n我们的方法在λ的值很大范围内都不敏感，一般选择固定值λ= 100\n\n\n层次和区域个数对MLR-SSC肝脏形状重建的影响\nMLR-SSC模型的特征是能够保存详细的局部形状信息，即使训练的数据上没有显著的统计\n每一层的区域个数选择对MLR-SSC模型至关重要，区域个数小，不能更好的重建局部细节；个数多，在细分的交叉区域会发生矛盾，从而导致肝脏表面非常粗糙。\n图13显示了泛化能力和区域个数的关系，随着地区的数量增加,泛化能力的价值下降,但20个区后,它开始上涨,使我们的方法达到最好的结果，区域个数在12-20。\n最大数量的水平 level L = 6\n我们选择 level L = 5，2的4次方 = 16，因此区域数16个，满足最佳重建结果。\n\n\n\n","categories":["图像处理与机器学习"],"tags":["机器学习"]},{"title":"基于稀疏表示变形模型的肝脏分割方法","url":"https://tanqingbo.cn/Deformation-model-based-sparse-representation/","content":"前言肝脏图谱包括灰度图像和对应的标签图像，基于图谱的方法主要是利用肝脏图谱灰度图像到目标图像的非刚性配准来达到分割的目的，现有图谱方法存在如下缺点：    1. 图谱易偏向所选择的初始模板图像特定解剖结构    2. 灰度图像对其到目标图像是易产生较大配准误差 为了解决上述问题，提出了基于稀疏表示变形模型。\n肝脏分割方法\n新提出的肝脏分割方法主要包括训练和测试连个阶段：\n\n\n在训练阶段构建得到图谱和基于稀疏表示变形模型（SRDM）。在测试阶段，当输入一副带分割的CT图像时，首先寻找将肝脏图谱的灰度图像对齐到目标图像法的非刚性变换，并依据训练得到的变形模型对这一变换进行正则化，然后利用正则化后的非刚性变换将肝脏图谱的标签图像传播到目标图像，就得到了初始的分割结果，最后再利用可变形Simplex网格方法对获取的初始结果进行进一步细分。\n\n\n构建肝脏图谱\n采用迭代方法构建图谱，并采用最小变形目标（MDT）方法获取初始的平均模板。具体步骤如下：\n\n准备一组预处理的训练图像{Ii|i=1..k}和对应的二值图像{Li|i=1…k}，从中选择一幅最接近平均肝脏形状的图片作为初始模板图像（比如I1）\n\n计算出模板图像I1对齐到其它所有训练图像的平均非刚性变换`T1\n T1 = 1/(k-1)*(T1j)  j=2...k\n\n  T1j是将I1对齐到训练图像Ij的非刚性变换 这样模板图像I1的最小变形目标目标MDT1 = `T1（I1），即将得到的平均非刚性变换。\n\n由于非刚性配准算法具有保持拓扑结构的性质，MDT1会偏向于初始模板I1的特定形状，因此本文将MDT1定义为初始的平均模板，采用迭代的方法构建最终的肝脏图谱，迭代过程见算法（3-1）。\n\n所有非刚性图像配准均采用基于B样条的自由变形模型（FFD），通过上述过程可以得到一组K幅对齐了的训练样本{Ii|i=1..k}和对应的二值图像{Li|i=1...k},最终的图谱就是它们的平均值;\n （`I,`L）\n\n\n\n\n\n构建基于稀疏表示变形模型\n通过图谱灰度图像`I非刚性地配准到这些处理后的训练图像用于构建变形模型的非刚性变换，这一过程得到了一组K个用于训练的非刚性变换{Ti|i=1,2…k}.\n\n","categories":["图像处理与机器学习"],"tags":["机器学习"]},{"title":"论文《Shape-Based Human Detection and Segmentation via Hierarchical Part-TemplateMatching》精读","url":"https://tanqingbo.cn/Shape-Based-Human-Detection-and-Segmentation-via-Hierarchical-Part-TemplateMatching/","content":"基于形状的人体检测和通过分层部分模板进行分段匹配1.介绍\n论文地址：Shape-Based Human Detection and Segmentation via Hierarchical Part-TemplateMatching\n\n1.1 Previous Work\n形状建模或形状特征提取方案可以大致分为两类。\n\n基于全局和密集的特征提取方法，人被模拟成全局模板。需要大量的训练集。\n基于稀疏局部特征，或者部分视觉集合表示物体形状的方法（基于可变部分模型方法）。处理部分遮挡的物体特别有效。检测器分别针对每个身体部位进行训练，并与二级分类器组合。问题是在非常混乱的图像中，可能产生太多的检测假设，因此需要鲁棒的组合方法来组合这些检测。\n\n\n基于可变部分模型方法法已经成功的运用到很多的视觉处理当中。\n\n基于全局的方法训练数据集单一，分类功能强大，它们比基于可变部分模型的方法简单很多。\n\n在基于可变部分模型方法中，每个部分都需要分开训练，此外还必须训练一个额外的装配分类器。相对于基于全局的方法，它更容易处理部分遮挡的图像，而且也更加灵活。\n\n基于部分模型还可以结合形状外观线索，外观线索结合运动线索，同时检测和分割。\n\n\n\n一些检测方法构建了基于树的数据结构来进行有效的形状匹配，每个窗口基于模板匹配和最邻近搜索来计算得分。\n\n在监控的场景，运动斑点信息为人类检测提供了非常可靠的线索。这些基于斑点的方法在计算上比纯粹的基于形状的方法更高效。但是他俩的共同问题是结果取决于背景减法或者运动分割的情况。\n\n我们的方法提出的动机如下：\n\n分层模板匹配是一种便捷的方法去有效地整合形状的检测和分割，但由于需要收集和匹配大量全局形状模型导致计算量大。\n之前的大多数识别方法主要是在大量的人类中心对齐的二值样本上训练分类器，然而由于图像中人体高度铰接且姿势不一，这就需要大量的对齐了的训练样本，而且还有可能使结果偏向训练样本。也就是说训练之后的分类器泛化能力会受到影响。\n可变形零件模型和多个基于实例的学习方案对本地化对象分割非常有效，但受精度和姿势约束。\n\n\n\n1.2 Overview of Our Approach（方法概述）\n在本文中，我们解决了同时检测和分割多个人类（可能部分被遮挡）的困难。为了实现这一目标，提出了一种结合可视化学习（discriminative learning）的分层部分模型匹配方法来建立一个通用的人类检测器。\n给定输入图像，该检测器返回人类边框作为精准的分割。\n我们的方法优于基于局部和基于全局的方法。人类检测器是通过分解全局模型构建一个更加灵活和有效的部分模板树人体模型，它能更有效的匹配人体姿势。然后估计的姿势通过合成部件自动检测。\n使用分层部分模板匹配方案时，为了更好的区分人和非人类，我们提出一种姿态自适应特征提取方法。它能更好的处理局部形状空间重复的事件。\n我们在人体的正面和反面样本上面分割人体姿势，并在姿势局部邻域进行特征自适应提取。再将所有可能的姿势实例集合映射到规范的姿势上，即任意姿势上的点要与规范姿势一一对应，\n将树的匹配算法用于处理多个封闭的人体，检测假设集由通用的人体检测器产生，然后通过基于形状匹配分数重新评估和精细遮挡分析的迭代过程来改进和优化。\n\n\n我们的主要贡献总结如下：\n介绍部分模板树模型和自动学习算法，并应用于人体检测和姿势分割。将流行的基于局部零件的物体检测器与基于全局形状模板的方案相结合。\n提出快速封层部分模板匹配算法根据局部图像的线索来估计人体的形状和姿势，人的形状和姿势由部分参数模型表示。\n在任意姿势和规范姿势的轮廓点组之间建立一对一的对应关系。\n树匹配算法也被扩展到具有挑战性的监控场景中处理多次闭塞的人类检测和分割，我们通过基于形状匹配分数重新评估和精细遮挡分析的迭代过程以贪婪方式执行优化来估计人体配置。\n\n\n\n\n第2节介绍了我们的分层部分模板匹配方法的细节。\n第3节描述了用于学习泛型的姿态适应特征提取方法人体探测器。\n第4节扩展了到个人类检测和细分的方法。\n第5节简要介绍了框架中运动和几何线索的结合。\n第6节介绍实验和评估。\n\n2 HIERARCHICAL PART-TEMPLATE MATCHING\n引入了一种分层形状匹配方法，以有效地搜索粗糙的人类姿势（形状），并计算每个候选窗口检测的匹配分数，为了实现这一点，我们通过利用基于局部组件和全局形状模板的方法将它们结合在统一的自顶向下和自下而上的搜索方案中， 具体来说，我们通过将全局形状模型分解为零件，并构建一个新的基于部件模板的树，从人物形状的训练数据库中获取部件模型之间的外观联系。2.1 Generating the Part-Template Tree Model（生成部分模板树模型）\n由于真实图像中人体姿态自由度高，直接从真实的图像中构建形状模型需要大量的真实轮廓数据集，这给训练样本对齐带来了很大的困难，所以我们使用简单的姿势生成器通过零件合成生成一组灵活的全局形状模型，然后使用身体部分分解构建零件模板层次结构。平行四边形部分在空间上组合，用于模拟粗糙的人类部分形状。 我们通过在空间上分解全局形状模型来获得部分模板模型，并构建一个部分模板树来捕获人类姿态变化。 之后，我们再通过从一小组真实姿态图像学习来优化合成树模型。2.1.1 Synthesizing Global Shape Models（合成全局形状模型）\n为捕捉人体姿态，用6个区域：头、躯干、两只手和两条腿来表示人体。通过在空间中合成这些区域形成全局形状模型。每个部分区域的形状由水平平行四边形建模，其特征位于其中心位置（2 dofs），大小（2 dofs）和方向参数（1 dof）。 因此，全身的自由度系数是5*6=30.（dofs：自由度）。\n我们生成这些全局模型主要是为了通过空间分解获得自动姿势对齐紧凑的部分模板模型集。给予躯干位置作为参考，其余参数被视为在在线检测/测试阶段估计的隐藏变量。\n全局形状的6个自由度（头、躯干、两只手和两条腿）即6个参数在其范围内的取值为{3; 2; 3; 3; 3; 3}（每个自由度可以对应有几个姿势），也就是说部分实例可以独立组合成32333*3=486种全局模型形状。2.1.2 Generating Parts by Decomposition（通过分解生产零件）\n全局形状模型的数量由每个部分区域（合成之前）的自由度确定，部分模板的数量等于树中的节点数，所以它远小于全局模型。\n\n\n\n先将全局模型分成3各部分（头躯体（ht），大腿（ul）和小腿部（11）），如图所示。2.1.3 Constructing an Initial Tree Model Using Parts(使用零件构建初始树模型)\n给定索引部分的集合，通过将分解的部分区域和边界片段放置在树中来构建部分模板树，如图所示。树边缘（或链接）是根据全局形状模型中部分索引之间的关系自动确定的。\n\n\n\n树中的每个部分模板表示零件的一个实例，也可以被视为参数模型，其中零件位置和尺寸是模型参数。\n树中的部分模板的数量直接由生成的全局形状模型的数量决定。在生成全局形状模型时，通过更精细的离散化和更广泛的参数范围可以获得更大的一部分模板。但是通过参考树中的模板数量，虽然计算需求的线性增加，但匹配成本几乎不变。速度非常快。\n初始树结构和部分模板由上述合成剪影构建，但是通过从实际图像学习来进行细化，这在下面的部分描述。在上图中，任何树路径（从根节点到叶节点）唯一地确定全局形状模型，并且唯一树路径与任何全局形状模型相关联。2.2 Learning the Part-Template Tree（学习部分模板树 ）\n所有全局形状模型的集合通过枚举所有可能的部分参数形成，因此构造的部分模板树不包含来自真实人类剪影的任何先前统计。所以，我们通过将它们与真正的人物剪影相匹配来学习部分模板的出现概率。由于我们将零件模板模型放置在树形配置中，所以先验值被估计为条件概率分布（每个内部树节点处的分支概率）。\n为了通过将树匹配到输入图像来更有效和可靠地估计人的形状和姿势，我们使用真实图像来学习与部分模板树模型的边缘相关联的概率。具体地，通过将​​树匹配到一组人体剪影图像来执行学习。目标是明确地估计分支概率分布，即在每个树层中的树边缘（图2中连接两个连续层之间的节点的箭头）的条件分布，以处理观察到的形状关节的范围。例如，给定层L0处的空节点，我们基于其在训练轮廓集中的发生频率来估计层L1处的六个ht模型的概率分布。\n剪影训练集由404（加镜像）二进制剪影图像（白色前景和黑白背景）组成。那些二进制剪影图像是通过手动分割INRIA个人数据库的正图像块的一个子集获得的。每个训练轮廓图像通过树从根节点到叶节点，用于识别最佳路径（对应于最大匹配分数）。使用贪心搜索算法通过选择每个节点处的局部最优分支来估计最优路径。这可以由更复杂的动态规划算法代替，但是我们发现贪婪搜索工作得很好，速度要快得多。每个节点的匹配分数被计算为当前节点的部分模板与观察到的轮廓之间的覆盖程度（即，与训练剪影一致的假设内的像素的比例）。对于所有训练轮廓重复此过程，并且针对每个轮廓估计最佳路径。然后，基于路径集合，基于发生频率针对每个节点估计分支概率分布（分支边缘的条件分布）。\n给定已知的分支概率，从根到叶的任何树路径可以与三个概率值（分别为三个部分ht，ul和ll）相关联。每个树节点现在携带部分模板的二进制图像，其边界采样点坐标和从树学习步骤获得的分支概率分布。由于路径和全局形状模型之间存在一一对应关系，因此每个全局形状模型现在由软覆盖图表示。我们累积所有路径的软覆盖图，以计算学习树的平均全局形状。图3通过显示学习的平均全局形状与所有训练轮廓的平均值非常相似，验证了我们的树学习方法。\n补充：“我们累积所有路径的软覆盖图，以计算学习树的平均全局形状”，这句话的理解，每条路径都携带自身的概率，树的平均全局形状由所有路径乘以自身概率的和所得。\n\n2.3 Hierarchical Part-Template Matching（分层部分模板匹配）\n给定一个测试图像，我们使用扫描窗口方法来估计每个候选检测窗口的最佳姿势。对于每个窗口，我们将所学习的树与图像观察（边缘或边缘方向）相匹配，以估计路径节点的最佳树路径和相关位置参数。与用于树木学习的模型类似，特定检测的总体匹配得分窗口被简单地建模为沿着该路径的所有节点的匹配分数的总和。但是，与学习不同，测试阶段的匹配是在边缘或梯度取向而不是轮廓上执行的，并且每个节点的得分都被计算为部分模板匹配分数与该节点之前学习的先前可抢占性的乘积培训阶段。我们定性验证，结合分支先验概率给予姿态估计更好的鲁棒性。另一个区别是，在测试阶段，我们允许零件模板位置在本地移动，并且对于每个零件模板估计最佳位置，而不是固定零件模板位置。其中每个部分可以调整到其局部最佳位置。\n我们使用类似于Chamfer匹配的方法匹配单个零件模板并计算零件模板匹配分数[6]。通过边缘方向匹配来测量零件模板轮廓上的采样点的匹配分数。目标是估计与图像观察最一致的最佳人类姿势（对应于路径上的每个部分模板的树路径和位置估计）。\n优化问题可以通过动态规划解决，实现全局最优解。但是，这个算法在计算上太昂贵，不能密集地扫描所有的假想窗口。为了提高效率，我们使用快速的K-fold贪心搜索算法。我们保留层L1中所有节点（k = 1; 2。.K）的分数，而不是估计最佳k，并且对于这些K个节点（或线程）中的每一个单独执行贪婪过程。通过分层部分模板匹配算法估计的姿态模型参数直接用于通过部分合成（区域连接）进行姿态分割。\n\n3 POSE-ADAPTIVE DESCRIPTORS（自适应描述）\n为了将我们的部分模板树模型和分层部分模板匹配算法应用于区分人类检测，引入标准机器学习技术SVM和Boosting，并且介绍姿势自适应特征计算方法来从图像中检测人体。3.2 Low-Level Feature Representation（低级特征表示）\n在行人检测方面，定向梯度直方图（HOG）方法将人与非人分离表现出优异的性能，能忽略空间本身的信息，具有很强的鲁棒性。我们使用相似的方法—边缘方向直方图（梯度幅度加权）作为我们的低级特征描述。\n输入图像，使用差分运算计算梯度G和边缘方向O，每幅图像量化为8*8的无重叠单元格。，用边缘取向直方图表示（每个周围的像素对直方图栏进行梯度变化的投票）。边缘方向被量化为Nb = 9，为了减少混叠和不连续性的影响，我们还使用三线插值法来计算空间和取向尺寸的梯度大小。\n低级特征描述由一组原始直方图和一组归一化图像位置索引快组成。原始直方图携带梯度幅度信息，因此它们用于姿态匹配（匹配直方图对于树中姿势轮廓的边缘方向），而归一化直方图基于估计姿态用于最终描述符。3.3 Pose Inference on the Low-Level Features（低级特征姿势推理）\n通过方向一致性而不是传统倒角匹配中边缘之间的距离来测量得分。 使用基于位置的查找表来测量每个模板点的得分。 加权来自相邻直方图栏的幅度以减少定向偏差并使每个模板点的匹配分数正规化。\n令O（t）轮廓点t处的边缘方向，与其对应的方向索引B(t)=[O(t)/(#/9)],#:圆周率。对于每个点t，我们首先在检测窗口中识别与之最邻近的8*8单元格。令H = （hi）表示t处的直方图，则t处的匹配分数计算为： \n\n   （1）\n\n其中b表示领域范围，w(b)表示对称权重分布。如果给定一个模板T（部分模板上的边界采样点的集合），则该模板的匹配分数可以计算为：\n\n  （2）\n3.4 Representation Using Pose-Adaptive Descriptors（使用姿态自适应描述符表示）\n为了获得具有不同尺寸姿态模型的图像的统一（恒定尺寸）描述，并且在不同的轮廓点之间建立一对一的对应关系姿势，我们将任何姿态模型的边界点映射到规范姿态模型的边界点。对于人体上部（头部和躯干），边界被均匀地取样为八个左侧和八个右侧位置，并且根据垂直y坐标和侧面（左侧或右侧）信息在姿势之间建立点对应关系。对于下体（腿），边界被均匀地采样到每个y值处具有四个位置的垂直，如何分配采样位置参照下图：\n\n\n\n注意，只有块的子集与描述符相关，并且块可能会根据位于块内的轮廓点的频率重复多次。4. DETECTING AND SEGMENTING MULTIPLE OCCLUDED HUMANS（检测和分类多个被检测的人）\n上一节讨论的姿态自适应描述符主要是为了从图像中检测完全可视的人的目的而开发的。在这些复杂情况下，我们基于姿态自适应特征的通用检测器可用于提供初始 一组人类假设（通过降低阈值以确保低错失率），然后可以执行更详细的闭塞分析和优化。\n\n4.1 Initial Hypotheses（初始假设）\n使用我们的姿势适应特征训练的通用人体检测器和诸如SVM的辨别分类器可以提供用于从静止图像中检测人类的可靠的初始人类假设集合。 然而，对于拥挤的视频，由于人体的任何部分都可以闭塞，有时只能看到很小的一部分。 因此，在这里，我们介绍了一种替代方法，用于生成监控场景的初始人为假设。\n分层部分模板匹配提供每个检测窗口的姿态模型参数的估计。 我们定义能够评估任何部分或部分组合的图像响应的分数函数Fw，该函数被建模为单个部分匹配分数fj的加权和：\n\n  （3）\n\n其中权重分布w={wj,j=ht,ul,ll}(三个wj之和等于1)，若Wht = Wul = Wll = 1/3,则对应全是检测器。若Wht = 0，Wul = Wll = 1/2,则对应腿部检测器。对于得分函数Fw通过应用检测阈值，我们得到7个部分或分布组合检测器。如下图所示：\n\n\n\n使用M部分检测器，对应于M个权重向量基于公式（2）计算单个零件匹配得分fi。\n在实践中，我们从输入图像中构建一个金字塔，并使用我们的基于滑动窗口的通用人类检测器将搜索空间减少到一个小的子集，并通过使用上述部分/部分组合检测器搜索其他假设来提高搜索空间。每个响应图我们使用恒定的全局检测阈值，并自适应选择模式。 也可以在平滑似然图像之后通过局部最大选择来执行该步骤。 最大值的联合形成了人类假设的集合：\n\n\n\n我们计算所有假设的全身匹配分数，并用L(ui)，i，2…N表示。更具体点，L(ui)被计算为所有 部分模板轮廓点的平均匹配分数。\n\n4.2 Objective Function(目标函数)\n使用初始检测假设u作为图像观察，我们将多次闭塞人类检测模型作为最大化目标函数%的问题进行建模。\n\n\n\n其中c表示有序的人体配置，n表示配置中的人数。\n由于遮挡，不能直接用L(ui)来模拟%(u|c)，相反，需要基于遮挡图Iocc全局重新估计每个假设ui的匹配分数。如果ui属于c，则仅基于或可见部分计算其匹配分数。我们通过从精确的人类分割生成的遮挡图在像素级处精确地执行遮挡补偿。这种基于遮挡补偿的评分重新评估方案在保留真实检测的同时有效地拒绝大多数假警报。\n如果ui属于c，则存在j，使得ui = cj，并且因此，遮挡补偿匹配分数L(ui|Iocc)被定义为位于cj可见区域内的ui形状模板点的平均匹配分数;如果ui不属于c，则L(ui|Iocc)被设置为常数检测阈值α。基于上述建模，目标函数可以重写为：\n\n\n\n现在，给定任何有序的人类假设（配置），可以精确地评估目标函数。\n\n5 COMBINING WITH CALIBRATION AND BACKGROUND SUBTRACTION（结合校准和背景技术）\n我们还可以将基于形状的检测器与统一系统中的背景扣除和校准技术相结合。\n\n问题\n该论文介绍的是二维图像上人体的检测和分割，其中的方法如何应用到3维的医学图像分割上去？\n论文树模型分块部分是先利用姿势生成其来产生人体的部分零件，然后再通过真实姿态图像学习来优化合成树模型，而并非一开始就是真实的人体图像，这一情况如何与医学图像的器官对应上？\n分块程序对每一个脾脏和脑室分割时，每一块都是不规则的，而人体分块是规则的，是不是得寻找其他程序对器官分块，而分块的标准又是什么呢？\n\n","categories":["图像处理与机器学习"],"tags":["机器学习"]},{"title":"分块程序执行","url":"https://tanqingbo.cn/分块程序执行/","content":"前言分块程序依然是基于ITK的，但是借助的辅助工具比较多，有一些还需要自己编译过后才能用，但是都可以在网上下载得到，先介绍一下工具MEPP、SPHARM-PDM-master和ParaView这3个工具的获得，在介绍程序执行的具体步骤。\nMEPP和SPHARM-PDM-master\n这两个工具的编译过程在关于环境配置的一些事中有介绍。\nMEPP/build中的mepp和SPHARM-PDM-master/build/SPHARM-PDM-build中的GenParaMeshCLP、ParaToSPHARMMeshCLP、SegPostProcessCLP的文件是我们最后需要的，用的时候拷贝到需要的地方就可以了。ParaView\n这是个3维图像软件，从官网下载即可，如果是Linux版本的话，打开bin文件夹下的paraView即可，主要用来做3维文件的格式装换。分块程序执行步骤\n\n\n先将nrrd格式的二值图像文件转化为nii格式的，转化的代码在此处获得：nrrd2nii。\n\n将GenParaMeshCLP、ParaToSPHARMMeshCLP、SegPostProcessCLP和nii文件放到同一文件夹下，在此文件夹下运行GeneralMesh脚本，脚本内容如下：\n #!/bin/bashmkdir brain-segoutfor ((a=0; a &lt;= 19; a++))do\t./SegPostProcessCLP brain-$a.nii brain-segout/brain-$a-segout.vtk --space 1.5,1.5,1.5donemkdir brain-meshoutfor ((a=0; a &lt;= 19; a++))do\t./GenParaMeshCLP brain-segout/brain-$a-segout.vtk brain-meshout/brain-$a-para.vtk brain-meshout/brain-$a-surf.vtk --label 1donemkdir brain-alignfor ((a=0; a &lt;= 19; a++))do\t./ParaToSPHARMMeshCLP brain-meshout/brain-$a-para.vtk brain-meshout/brain-$a-surf.vtk brain-align/brain-$a   done\n\n\n\n\n\n\n数据名字与数据个数随自己的数据情况修改。\n\n执行这个脚本需要很长时间，待执行完之后，在brain-align文件加下会出现brain-$aSPHARM_ellalign.vtk形式的文件，先用ParaView软件将该类型的文件挨个转化为.ply格式，然后用mepp软件将.ply文件转化为.off文件，在保存的时候会跳出两个提示框：Do you want to save colors?、Do you want to save normals?，都选择NO就行，得到的.off 文件需要去掉第二行（mepp的注释）。\n\n进入meshSegmetation,该文件夹里有meshSeg.cpp等程序及CmakeList.txt,新建build文件夹,在build下面新建data和training两个文件夹，data里面放测试数据，training里面放训练数据，都是.off文件。\n\n用average.cpp求data里面数据的平均值，根据数据的情况修改average.cpp文件，会得到meanShape_liver.off，将meanShape_liver.off保存到meshSegmetation/build中。\n\n在meshSegmetation/build中ccmake、make、./main后得到shapeVariation_Face.csv和shapeVariation_Vertex.csv，将这两个文件放到MEPP/build中，打开mepp软件，用该软件打开meshSegmetation/build中的meanShape_liver.off文件，点击components——segmentation——VSA——Variation Segmentation，修改Region Number为要分的块数，数字不要太大，否则会崩掉，再点击components——segmentation——VSA——Face Label to Map，会得到’seg.csv’。\n\n将得到的seg.csv放入到meshSegmetation/build文件夹中，并在该文件夹中建labels 、segs 和 segsF三个文件夹，注释掉meshSeg.cpp中的前3行有用代码，重新编译，运行main\n ./main\n\n最终结果会出现在segsF文件中，用mepp软件打开便可以看到分块的情况。\n\n\n","categories":["图像处理与机器学习"],"tags":["图谱分割"]},{"title":"图谱分割关于环境配置的一些事","url":"https://tanqingbo.cn/关于环境配置的一些事/","content":"前言最近干的活有很多涉及环境配置的工作，有很多细节需要注意，稍有疏漏就有可能让你捣鼓一天，因此把这些环境配置的细节和步骤整理下来以便往后查看。\n主要分为两个部分，分块程序环境配置和图谱程序环境配置，具体如下：\n分块程序环境配置\n首先接受介绍一款Linux系统下软件包下载神器：新立得（Synaptic），它是Linux操作系统的包管理工具apt的图形化前端。它可以以图形界面代替apt-get install命令来对软件包进行下载，因此我们在配置环境之前先安装新立得（Synaptic），指令如下：\nsudo apt-get install synaptic\n\n\n\n\n\n\n分块代码主要需要配置MEPP和SPHARM-PDM-master这两部分代码的运行环境，我之前用Ubuntu 16.04版本的系统试验的时候，多次失败，后来改为14.04后一次成功，所以在陪环境的时候不要用高版本的Ubuntu系统。默认已经装好了g++，以及make，如不知道怎么装，移步Linux 下配置ITKMEPP\n\n\n建一个build文件夹存放make编译后的文件，在ccmake配置过程中，依次需要安装CGAL，用新立得（Synaptic）搜索CGAL，安装libcgal-dev.\n\n\n安装软件包qt4，用Synaptic搜索qt4，一直往下翻，安装libavahi-qt4-dev这个软件包。\n\n安装QGLViewer，用Synaptic搜索QGLViewer，安装libqglviewer-dev这个软件包。\n\n下载xerces源码包，源码包下载链接http://xerces.apache.org/xerces-c/download.cgi,先将xerces源码包解压到/usr/include文件加下（需要root权限），进入xerces文件家中执行如下语句(#号代表在root权限下)：\n  # chmod +x configure# ./configure --prefix=/usr # make# make install\n\n\n\n\n\n\n之后在ccmake这一块应该就不会有什么关卡了，接下来就是make编译，大概需要等10多分钟，结束之后会出现一个mepp文件，要是能正常执行就说明大功告成了。SPHARM-PDM-master\n\n\n这个ccmake配置这一块很简单，也要建一个build文件夹存放make编译后的文件，然后安装一个git-svn和libsvn-dev,用Synaptic搜索SVN，安装git-svn和libsvn-dev软件包就可以了。\n之后用make编译，编译过程需要联网，时间会很长，大概要1-2个小时，中途没有报错，顺利完成就没有问题了。\n\n图谱程序环境配置\n要运行图谱的程序，需要先安装ITK，这是大前提，具体步骤在这：Linux 下配置ITK。\n接着需要安装eigen源码包，同上一样，用Synaptic搜索eigen，然后下载安装，文件保存在/usr/inlcude/目录下，进入到eigen文件中，把其中的Eigen文件夹拷贝到上一级目录中，这样才能起效。\n下载elastix，同样是在Synaptic中搜索，完事之后会在/usr/bin/文件夹中出现elastix和transfoxmix两个文件，然后拷贝到需要的地方去就行了。\n训练和分割是需要下载libblas-dev和liblapack-dev这两个源码包，方法如上，搜索libblas和liblapack。\n计算精度的代码需要下载libann-dev源码包，用Synaptic搜索libann。\n\n","categories":["图像处理与机器学习"],"tags":["图谱分割"]},{"title":"分割ROI篇","url":"https://tanqingbo.cn/分割ROI篇/","content":"获取灰度图像的ROI\n获取ROI之前需要需要数据对应的坐标，并存放到roi.txt文件夹中，并将roi.txt与getROI的代码可执行文件放到同意路径下，再执行程序便可以得到灰度图像的ｒｏｉ，原始灰度图像和和ROI图像对比如下：\n\n原始灰度图像:  \n\nROI图像:   \n\n将处理好的ＲＯＩ图像放到分割代码的training文件夹中，注意命名方式，序号从０开始。\n图谱处理以及分割\n使用3dseg软件对图谱进行处理，将目标器官分割出来。\n\n注意：用软件对灰度图谱和二值图谱进行分割是，二者的尺寸和坐标要完全一致。\n\n分割完之后也放入training文件夹中，命名方式：灰度－avg.nrrd;二值－avg_mask.nrrd.\n\n接着开始分割，不过需要注意的是，分割数据和图谱都是ROI，并且需要每组分割数据的坐标存放在roi.txt文件中,roi.txt文件放到ｂｕｉｌｄ中。分割代码的执行方式和之前一样，所不同的是会产生两个分割结果：ＲＯＩ结果FINALLL.nrrd，通过坐标处理后的正常大小分割结果FINALLLL.nrrd(比前面多了一个L)。\n\n分割时需要修改如下３个参数：\n  bool TUMOR_CASE_USE_PA_EQUAL_ONE = true;   //true/falsebool Use_Process_Ori_mask_9par = false;   //true/falsedouble PAThreshold = 0.2;　　//  0.2/0.9\n\n\n\n\n\n\n排列组合有８中可能，所以需要分割８次，保存每次的分割结果，注意最终结果的命名，以便区分。\n计算精度\n运行计算精度的代码时需要另外再下载 libann-dev,下载方式如下：\n  sudo apt-get install libann-dev\n\n\n\n\n\n\n或者用synatic直接搜索下载。\n\n然后配置和编译好的计算精度的代码，执行时需要两个参数，批量执行的脚本如下：\n  for((a=0;a&lt;=20;a++))do ./EvaluateSegmentationResult seg-spleen/FINALLL-$a-0.2-ff.nrrd refer-spleen/label-roi-$a.nrrddone\n\n\n\n\n\n\n执行完之后会产生一个evaluation.txt文件，对比精度信息全部存在里面，如下图：\n\nJI表示程序分割与手动分割的数据重合率，值越大，说明效果越好，最大是１００．\n\nASD表示程序分割与手动分割的数据的边缘距离，值越小，说明效果越好，结果最好是，值为０．\n\n\n","categories":["图像处理与机器学习"],"tags":["图谱分割"]},{"title":"图谱训练与分割","url":"https://tanqingbo.cn/图谱训练与分割/","content":"代码运行脑图\n每一步的运行过程说明对灰度和二值图像做插值（该步可以跳过）\n插值是为了防止在训练的过程出现错误，所以相对灰度和二值图像做插值运算，插值代码在UpsampleVolume_char-label和UpsampleVolume_short-img文件夹中。\n\n-label作用二值图像，-img作用于灰度图像，使用前需要先ccmake和make一下进行配置和编译，然后将生成的main可执行文件拷贝到需要插值的文件夹中，执行upsample脚本文件就可以进行插值运算来，如果脚本文件不能执行需要先给执行权限，upsample脚本文件内容如下：\n  #!/bin/bashmkdir upsample_labelfor ((a=1; a &lt;= 40; a++))do\t./main label-$a-flip-spleen-roi.nrrd upsample_label/label-$a-flip-spleen-roi-2.nrrd 1 1 2 done\n\n\n\n\n\n\n该脚本是作用于二值图像的例子，灰度图像也要重复上述过程。###　掩码运算\n\n掩码的代码在MASKImage文件夹中，同样使用前需要先ccmake和make一下进行配置和编译，然后执行mask-spleen脚本文件，注意脚本中文件的路径，mask-spleen脚本文件内容如下：\n#!/bin/bashfor ((a=1; a &lt;= 40; a++))do\t./main spleen-roi/upsample_img/img-$a-flip-spleen-roi-2.nrrd \tspleen-label-roi/upsample_label/label-$a-flip-spleen-roi-2.nrrd mask_result-2/img-$a-flip-spleen-masked.nrrddone\n\n\n\n\n\n\n如图：\n\n\n开始训练\n训练的代码在atlas_*_UAB文件夹中，先在此文件夹中建build文件夹，并在build中进行配置和编译。\n\n执行mkdir_file脚本，在build中生成必要的文件夹，将elastix、parameters_BSpline.txt、parameters_Affine.txt、transformix这4个文件拷贝到build中，这个很重要！！！\n\n将掩码后的nrrd文件拷贝到training文件夹中，规范命名，将手动挑选的初始模板与第0组交换。\n\n执行编译后生成的asm的文件，如图：\n\n如果运行出错，需要重新下载elastix和transformix文件，下载方式如下：\n  sudo apt-get install elastix\n\n\n\n\n\n\n然后将/etc/bin中的elastix和transformix文件替换掉原来的elastix和transformix文件，重新执行asm文件。\n\n如果数据很多的话，训练过程需要很久，一、两天也有可能，慢慢等吧。\n\n\n计算图谱\n在计算图谱之前需要将最后一次迭代矩阵作用于最初的灰度和二值图像，建两个文件夹‘img_txt’、label_txt分别处理灰度和二值图像。\n将最后一次训练迭代的矩阵，即最后一次迭代产生的txt文件拷贝到‘img_txt’、label_txt文件中。\n执行mkdir_file脚本，生成必要的文件夹，用g++编译.cpp文件，interpolate0to3.cpp作用于img_txt中的txt,avgTranform.cpp作用于label_txt中的txt.如图：\n将最初的灰度和二值图像（nrrd）分别拷贝到‘img_txt’、label_txt文件中，注意命名方式和将手动挑选的初始模板与第0组交换。\n执行update脚本，将txt作用到nrrd上,结果保存在exampleoutput中，如图：\n将处理后的nrrd求平均，得到最终的图谱：avg.nrrd。需要先ccmake和make一下进行配置和编译求平均的代码，得到一个可执行文件main.\n执行main，传的参数为数据集的个数，如图：\n\n通过图谱对原始灰度图像进行分割\n训练的代码在MAS_*_UAB_FFD文件夹中，先在此文件夹中建build文件夹，并在build中进行配置和编译。\n执行mkdir_file脚本，在build中生成必要的文件夹，将elastix、parameters_BSpline.txt、parameters_Affine.txt、transformix这4个文件拷贝到build中，这个很重要！！！\n将图谱和要分割的原始灰度图像拷贝到training文件夹，灰度图谱命名：avg.nrrd,二值图谱命名：avg_mask.nrrd,原始灰度图像命名：liver-0.nrrd.\n在MAS文件夹中建一个文件夹用来保存分割后的结果，命名为：0.注：有多少组原始灰度图像，就需要有多少个保存结果的文件，命名方式依次递增。\n执行asm文件进行分割，如图：\n最后分割结果保存在0文件夹中，如图：\n\n","categories":["图像处理与机器学习"],"tags":["图谱分割"]},{"title":"图谱程序字典","url":"https://tanqingbo.cn/图谱程序字典/","content":"掩码\n对掩码程序进行make编译后会生成一个main的可执行文件，执行该文件是需要传递3个参数，传递方式如下：\n  ./main 原始灰度图像.nrrd 对应的二至图像.nrrd 掩码后文件名.nrrd\n\n如果需要掩码的图像数量较多，可以写一个脚本批量处理，执行脚本前需要主要脚本的执行权限。\n\n\n图像对齐建立图谱\n该部分是进行图像分割的核心代码，代码量比较多，需要有很多细节需要注意。\n\n程序通过调用Traditional_Regi_Elastix函数建立图谱，共有4个参数，参数列表如下：\n  iterIndex   //当前的迭代次数，迭代次数在main函数中设置numSamples  //数据集的个数USE_HEALTHY_ATLAS_AS_REF  //USE_HEALTHY_ATLAS_AS_REF=falseofstream &amp;ofs  //记录程序执行时间等信息\n\n\n\n\n\n\n为了方便程序的阅读，有些参数的默认值需要记住：    \n  int Index_Atlas = 0;\tbool use_Index_Atlas = true;\tnumTrainData = numSamples  //数据集的个数\tFixedAsMoving = false;\tFirstIterationAffine = false;\tNON_GREEDY = true;\tchar * movingIm_Affine //存放将要对齐的图像集名\tfixedIm  //存放平均模板名\tchar *EXE_REGISTER = \"./elastix\"; //elastix是一个可执行文件，程序中通过system调用，对齐的作用。\n\n\n\n\n\n程序运行说明\n将所有掩码后的数据集放到training文件夹中，命名格式为liver-mask_#.nrrd,#从0开始，且liver-mask_0.nrrd是初始的平均图像模板。初始模板的选择是通过手动挑选最接近平均目标分割图像的数据集。\n\n创建REG_UAB文件夹，用于存放每次Ii对齐到平均图像模板之后所产生的变换矩阵T和刚性与非刚性变换后的图片数据以及平均模板。\n\n每次迭代后产生的平均图形模板命名为：Average_UAB_iter#-0.nrrd\n\nNON_GREEDY用来控制要对齐的数据源，NON_GREEDY=true时，每一次迭代都是将原始的掩码图像（liver-mask_#.nrrd）对齐到平均图像模板上；NON_GREEDY=false时，第一次迭代是将原始的掩码图像（liver-mask_#.nrrd）对齐到初始的平均图像模板（liver-mask_0.nrrd）上，之后得迭代过程是将非刚性变换的数据集（Iter%d_%d_Warped.nrrd）对齐到平均图像模板上；本程序中是第二种情况：NON_GREEDY=true。\n\n刚性变换得到的数据集：Affine_Iter%d_%d_Warped.nrrd;非刚性变换得到的数据集：Iter%d_%d_Warped.nrrd;刚性变换得到的T：Affine_Iter%d_%d.txt;非刚性变换得到的T：BSpline_Iter%d_%d.txt。第一个%d是迭代的次数，第二个%d是第几个数据集。程序先求刚性再求非刚性。\n\n关于第0组数据，需要注意的：\n  Average_UAB_iter0-0.nrrd = liver-mask_0.nrrdAverage_UAB_iter0-0.nrrd = Affine_Iter0_0_Warped.nrrdAverage_UAB_iter0-0.nrrd = Iter0_0_Warped.nrrd\n\n\n\n\n\n\nAverage_UAB_iter#-0.nrrd由每一组数据非刚性对齐后的数据集（Iter%d_%d_Warped.nrrd）叠加求和再求平均得到的。\n\n新的肝脏初始化方法\n\n上图的执行流程如下：\n先将灰度图谱对齐到测试灰度图像上，得到一个刚性变换矩阵和一个非刚性变换矩阵；\n将变换矩阵作用到二值图谱中得到变换后的二值图像；\n将测试的灰度图像做似然运算，得到最大似然图像；\n似然图像与变换后的二值图像做与运算，得到最终的分割结果。\n\n\n\n分割参数调节\n在做图像分割是，需要调节MAS_Elastix.cpp文件中如下三个参数：\n  bool TUMOR_CASE_USE_PA_EQUAL_ONE = false;   //true/falsebool Use_Process_Ori_mask_9par = false;     //true/falsedouble PAThreshold = 0.2;   //PAThreshold = 0.2/0.9\n\n\n\n\n\n\n每个参数都有两个取值，排列组合共有八中可能，所以最后分割数据需要测试八次，取其中结果最好的一次。\n\n训练图谱\n需要将灰度图像和二值图像作掩码之后才能开始训练图谱；\n\n掩码的结果又4种可能，因此对应的图谱也有4中结果，情况如下：\n  1.灰度图像与二值图像都不插值作掩码，训练得到图谱；  2.灰度图像插值、二值图像不插值，再作掩码，训练得到图谱；  3.灰度图像不插值、二值图像插值，再作掩码，训练得到图谱；  4.灰度图像与二值图像都插值，再作掩码，训练得到图谱。\n\n分别测试上述4种图谱，对比分割结果，取其中分割结果最好的图谱。\n\n\n","categories":["图像处理与机器学习"],"tags":["图谱分割"]},{"title":"港股打新，小白教程！","url":"https://tanqingbo.cn/New-Hong-Kong-stocks/","content":"港股打新是什么？说港股打新之前，一定要交代一下公司发行股票的流程：公司在上市（IPO）发行股票之前，会先以特定价格流到一级市场里，大部分（90%）会卖给机构，小部分（剩下10%）会给散户申购。港股打新，其实就是对即将在香港上市的这些新股进行申购。 如果申购的人很多，那么僧多粥少，必然只有一部分人才能申购成功，即中签。\n港股打新流程开户-&gt;入金-&gt;申购-&gt;卖出-&gt;出金\n1、开户理论上一个人只能开一个账户申购新股，但由于中国大陆身份证位数比较多，加上券商的骚操作，因此实际上，一个身份证可以开多个账户申购新股。\n主流的券商有：辉立、华盛通、富途、华泰、尊嘉、玖富等。\n如果要开户的话，优先开辉立。\n为什么首选辉立？辉立是香港本土第一券商，融资利率低，额度充足，最重要的是，辉立可以白嫖呀！ \n它有4种套餐：0元，38元，68元和100元。\n0元，白嫖套餐：一万港币以下的打新可以100%融资，而且还不用手续费！38餐，38元手续费可以100%融资免息打4万港币68餐，90%孖展（10倍杠杆），可以申购10万市值，也就是1万当10万花，手续费68100餐，10倍杠杆，可以申购20万市值，手续费100白嫖套餐，相当于打新，本金、利息、手续费全免了，你说香不香？ \n香香香！怎么开辉立账户？辉立有两个渠道可以开：线上和线下。 线上必须有港卡才能开。 线下目前只有上海能开，不需要港卡。7月份之前广州也可以开，现在暂停了。 而且上海线下预约已经排到10月份了，如果有条件开港卡的话，办港卡+线上开户可能时间也差不多。 \n没有港卡，线下开了辉立后，如何入金？\n线下开的辉立可以通过香港 ATM 入金，找香港那边的朋友帮忙存到指定账号，然后把存款凭证拍照发给你，你再上传到辉立APP，下一个工作日就能成功入账了。 \n但这都是权宜之计，还是那句话，要好好玩港股打新，香港卡必备。 \n2、入金所谓的入金就是往账户里面充钱，如果有香港卡的话，香港卡入金各大券商是最方便的。\n如果没有香港卡，可以选择一个可以大陆银行卡入金的券商，比如华泰券商。\n入金需要使用本人同名银行账号，华泰开好户后会有收款信息提供，然后我们需要先在大陆银行卡上（比如说我之前入金成功的招商银行）购汇港币，相当于用人民币换港币，然后再向券商提供的收款信息转港币，华泰的收款银行是渣打银行（香港），大陆卡会收一笔通讯费，招商银行是105块人民币，收款银行可能也会收个手续费，渣打收了我15港币（各券商、银行收费不一样），那么这次入金总共的花费就是大概120块。\n基本每家券商都会有个开户入金奖励，比如华泰入金2w港币，奖励一股阿里巴巴（市值200多块），所以要注意入金的时候多入一点，刚好入2w的话，银行收了15港币，就不够条件拿不到奖励了。\n从大陆卡转出到成功入金要1-5个工作日，我比较顺利，6月30日那天，9点半从大陆卡汇出，13点左右成功入金，赶上了思摩尔和欧康的申购。 当然要想玩好港股打新，香港卡是必需的，大陆卡入金属于无奈之举。港卡办理渠道后面讲。\n3、申购申购的操作其实很简单，在APP上动动手指就可以完成。 \n申购的最小单位是一手，一手是多少股呢，这个由上市公司来决定，有可能100股是一手，也有可能1000股是一手。申购分为两种，现金申购和融资申购，这两个概念和全款买房、贷款买房有些相似。\n现金申购就是用你账户上的余额来申购。入金之后，你的账户上才有余额。融资申购，香港称为孖展（由“Margin”音译而来，是保证金的意思），大白话就是借钱申购。这个好处是不用占用资金，可以利用杠杆来提高中签率，但是要付利息。\n既然可以通过杠杆来提高中签率，那意思是不是申购的份额越多，中签的概率越大呢？\n比如华泰之前放出过的“33倍杠杆”，就是你出3%，他出97%，假设你的账户有3万，那么通过融资，相当于有100万本金，如果一手是3万块，那么本来只能现金打一手的你，通过融资可以打33手，中签率也就跟着上升。 \n港股打新的核心就在于多开账户，多融资，虽然融资需要付利息，但是这点利息钱相对于打新的收益来说，不值一提。 \n多融资来提升中签率这点很好理解，那多开账户呢？港股打新有个特点是偏向散户，尽量让更多的人中签，单手中签率按照申购数量递减，所以在一个账户上打两手的中签率小于在两个账户上打一手。 \n这么说可能比较难理解，以思摩尔为例，见下图： 一手中签率是20%，打两手的话，单手中签率就掉到了15%，最终实际中签率：2*15%=30% \n\n但是如果分开两个账户打一手的话，实际中签率是 2*20% = 40% \n大热如欧康，一手中签率是5%，打十手实际中签率才10.5%，见下图：\n而冷门如渤海银行，一手中签率是100%，也就是说申购多少中多少.\n我有幸日入15k的那次，欧康和思摩尔各打了现金一手，见下图：\n不是说要多开户多融资吗？是的，但是因为我本金才2w，所以只开了一个账户，而融资额度并不是什么时候都有的，比如7月初，一堆新股争相上市，银行的额度就没那么多了，就需要我们按券商发出的时间去抢额度，没抢到也就只能现金打一手了。\n4、卖出中签后，我们就以一级市场的价格（发行价）持有了即将上市公司的股份，在公司上市的前一天，我们可以在暗盘系统交易。 \n暗盘系统：指的是部分大型券商的内部系统，一般在新股上市前一天的16:15-18:30进行报价撮合，辉立是香港最大的暗盘交易商，大部分券商都是接入辉立的暗盘系统。 \n富途的暗盘交易价格往往高于辉立，所以如果我们在富途中签，可以通过富途卖出，辉立买入的方式，做一个无风险的套利。 \n如果我们特别看好一支新股，还想拿多几手，可以选择在暗盘买入（捞货），等正式上市，股价涨起来后再卖出，不过这已经不属于传统的打新了，所以就不多说了。 \n刚卖出去，股价就持续往上涨，叫做卖飞，其实卖出去之后应该要像分手一样，不用过多关注，各自安好吧，总想着在最高点卖出去容易心态大崩。 当然，也会出现上市后，当日就跌破发行价的情况，俗称破发，一般的策略是破发就赶紧走人，当日卖出，及时止损。\n5、出金出金，跟入金相对，大白话就是提现。\n港股打新账户上的钱不能通过大陆卡出金，要通过香港卡或者境外卡才可以出金。 \n香港卡：疫情期间，香港闭关，不能去当地线下开卡，甚至大部分省份护照都不让办了，所以只能通过大陆银行去开香港卡，大部分门槛都比较高（要求几十万存款，存3-6个月） \n境外卡：比较流行的是华美卡，门槛较低，线上就可以办理，缺点是手续费、管理费高，没有和华美合作的券商，单笔出入金需要60美金左右，管理费25美金一个月。\n香港卡具体怎么开？去香港开港卡的话门槛比较低，部分银行存1万港币就可以开了。不过现在疫情期间，香港闭关，过不去，甚至港澳通行证都不好办。 \n目前我对接的两种，在大陆低门槛港卡办理方式： \n\n通过某券商渠道，在大陆的民生银行，开信用卡，存5w理财，6-8周成功下卡（民生香港卡） \n 由于疫情和港股打新最近捷报频传，当前是港卡办理的旺季，据内部人员透露，香港账户每小时500户递增。听闻5月初的时候，港卡2周就能办理下来。 \n\n通过中介渠道，不用存款，一次性付费4000左右，一个月左右下卡 \n 这个渠道的优势在于，5万块钱不用占用1-2个月，比如近期蓝月亮、农夫山泉快要上市了，用这5万块去打新，我认为大概率能覆盖办港卡的费用。 \n 当然，不差钱的话，也可以问问当地的几个大银行，门槛普遍是20万-50万，存3-6个月，还有要500万的…… \n\n\n既然港股打新，有破发的可能，那么我们怎么知道哪些股应该打呢？哪些有赚头,哪些没赚头，哪些是大肉，圈内基本有共识，刚入门的话，跟着大佬走就对了，抄作业就可以了。 \n大佬的判断不会出大问题，这个不用担心，港股打新不能保证百分百赚钱，但是大概率是赚钱的。 \n如果是极度风险厌恶型，不愿意冒一点点破发风险的话，那还是别玩打新了。 \n风险和收益一般是成正比的，低风险、中收益就属于很好的套利方式了\n我想玩打新，怎么搞？首先门槛是2万，2万1个账户是比较舒服的。没有2万块钱的，建议玩玩a股可转债打新。 \n然后是开户，开户其实很快，几分钟搞定，入金是比较麻烦的，也有失败的可能性，具体细节问题，只能边实操边解决。 \n港股打新老实讲，技术含量并不高，不然我作为新手，也不会在这么短的时间里就实现日入15k。 \n最重要的是行动力，早就是优势，我就是因为行动得快，所以赶上了这波打新，赚到了第一桶金。 \n无论我这篇科普写得多么详细，都是纸上谈兵，边学实践边学是进步最快的！学编程是这样，港股打新也是这样。\n我手头上有xx万，投入多少合适？港股打新出入金不太灵活，而且手续费高，要坚持闲钱投资的理念。\n另外提醒一句，保险是非常重要的分担风险的工具，我认为非常非常有必要先把保险配置好。 几百块钱的百万医疗险就能提供上百万的保额，杠杠比非常高。（反而重疾险不太推荐，百万医疗险买支付宝的好医保就行了） \n港股打新投入的本金，至少要准备1年内不动的，如果频繁调动资金的话，还不如不玩，毕竟入金出金都是有成本的。\n最近有什么新股要上吗？蓝月亮、农夫山泉应该在本月会招股，前段时间讨论比较多的蚂蚁集团也准备上市了。 \n打新不是天天都有的，没有新股可打的时候，该办港卡的办港卡，该找家人要身份证开户的就去开户，等看到别人中肉签，赚钱的时候再去准备，就错过了。 \n总之，有热门新股的时候，多融资；\n没新股可打的时候，多开户，多入金，备足弹药，迎接新股！ \n讲的细节比较多，没有参与过的有个概念就好，总的来讲，我认为港股打新是一个非常靠谱的套利模式，本质上是赚一级市场跟二级市场的差价； \n钱生钱的效率太高了，本金20k，中签后卖出净赚15k让我兴奋了好久，现在我不是在打新，就是在准备账户的路上，祝大家都能在2020年赚到港股打新的第一桶金！\n","categories":["技术以外"],"tags":[]},{"title":"深度学习在医学图像分析领域的研究","url":"https://tanqingbo.cn/Deep-learning-and-medical-image-analysis/","content":"摘要\n随着医学成像技术和计算机技术的不断发展和进步，医学图像分析已成为医学研究、临床疾病诊断和治疗中一个不可或缺的工具和技术手段。近几年来，深度学习（Deep learning,DL），特别是深度卷积神经网络（Convolutional neural networks,CNNs）已经迅速发展成为医学图像分析的研究热点，它能够从医学图像大数据中自动特区隐含的疾病诊断特征。本文首先简述医学图像分析的特点；其次，论述深度学习的基本原理，介绍主要用于医学图像分析的主要深度学习技术；然后分别论述深度学习在医学图像分类、检测、分割、配准、检索、图像生成和增强等各领域的国内外研究现状；最后，讨论归纳医学图像分析深度学习方法未来要面临的挑战和应对的策略。\n关键词：医学图像分析；深度学习；卷积神经网络\n\n1、介绍\n在医学图像领域，医生或者研究人员在对某种特定的内部组织器官进行定量分析、实时监控和治疗规划时，为了做出正确的治疗决策，通常需要了解这种组织器官的一些详细信息。所以生物医学影像已成为疾病诊断和治疗中不可或缺的组成部分，且日益重要。\n核磁共振成像 (Magnetic resonance image, MRI)、正电子发射断层扫 描 (Positron emission tomography, PET)、计算机 断层扫描 (Computer tomography, CT)、锥形束 CT、3D 超声成像等医学影像技术目前已广泛应用于临床检查、诊断、治疗与决策。如何充分利用人工智能深度学习方法分析处理这些超大规模的医学图像大数据，为临床医学中各种重大疾病的筛查、诊断、疗效评估提供科学方法，是当前医学图像分析领域急需解决的重大科学问题和前沿医学影像关键技术。\n医学图像分析最初主要采用边缘检测、纹理特征、形态学滤波以及构建形状模型和模板匹配等方法。这类分析方法通常针对特定任务而设计，被称为手工定制式设计方法。而深度学习是以数据驱动方式分析任务，能自动地从特定问题的大规模数据集中学习相关模型特征和数据特性。与针对特定问题而显式地手工设计模型不同，深度学习方法可直接从数据样本中隐式地自动学习医学图像特征，其学习过程本质上是一个优化问题的求解过程。通过学习，模型从训练数据中选择正确的特征，使其在测试新数据时做出正确决策。因此，深度学习在医学图像 分析中起着至关重要的作用。 \n近年来, 深度学习不断取得重大进展, 主要得益于不断提高的计算能力和持续增长的可用数据量，以及深度学习模型及其算法的不断改进。其实质是通过构建多隐层的机器学习模型，利用海量的样本数据训练，学习更精准的特征，最终提高分类或预测的准确性[1]。 深度学习这种从数据中学习层次特征的特点，使得它非常适合发现高维数据中的复杂结构，目前深度学习已经应用到图像识别、语音识别、自然语言处理、天气预测、基因表达、内容推荐等领域和各种挑战赛中。\n深度学习在计算机视觉领域的巨大成功, 激发了国内外许多学者将其应用于医疗图像分析。近年来，已有多位专家对深度学习在医学图像分析中的研究现状及问题进行了总结、评述和讨论。最近,Medical Image Analysis上发表的综述对深度学习在医学图像分类、检测和分割、配准 和检索等方面的研究进行了较全面的归纳总结[2] 。\n\n2、医学图像分析的特点\n医学图像分析已广泛应用于良恶性肿瘤、脑功能与精神障碍、心脑血管疾病等重大疾病的临床辅助筛查、诊断、分级、治疗决策与引导、疗效评估等方面。医学图像分类与识别、定位与检测、组织器官与病灶分割是当前医学图像分析深度学习方法研究主要应用领域。不同成像原理的医学图像分析和计算机视觉领域中的自然图像分析存在较大的差别。至今为止，国内外学者主要针对MRI、CT、X射线、超声、PET、病理光学显微镜等不同成像原理的医学图像分析任务开展了一系列的深度学习研究工作。因此，本节主要简述这几种医学图像的分析。\n\n2.1 常见的医学图像\nMRI图像：核磁共振图像（MRI），该图像是人体组织器官和病灶中的氢原子核在外部强磁场作用下产生的磁共振信号大小的度量，并通过计算机对体外核磁共振信号探测器接收到的信息数据进行3D图像重建。它能够提供非常清晰的人体软组织解剖结构和病灶影像。\nCT图像：计算机断层扫描(CT)利用精确准直的X射线束对人体某部位一定厚度的断面进行照射扫描，并由与射线线束一起旋转的探测器接收透射穿过该断面的X射线，最后，计算机根据探测器接收到的X射线信号数据重建相应人体断面的3D图像。它具有亚毫米级的空间分辨率，能够提供清晰的人体骨性组织解剖结构和病灶影像，已广泛应用于多种临床疾病检查和辅助诊断。\nX射线图像：医学X射线图像是人体不同组织器官和病灶的电子密度度量影像。基于X射线的成像包括2D的计算机放射成像、数字化 X 射线摄影术、数字减影血管造影术和乳房X线摄影术，以及3D的螺旋计算机断层扫描术等，已广泛地应用于骨科、肺部、乳腺和心血管等临床疾病检测和辅助诊断，但2DX射线图像不能提供人体组织器官和病灶的三维立体信息。\n超声成像：利用超声束扫描人体，通过对反射信号的接收、处理，以获得体内器官的图像。近年来，超声成像技术不断发展，出现了 3D 彩超、超声全息摄影、体腔内超声成像、彩色多普勒成像及超声生物显微镜等新的超声成像技术。\nPET图像：正电子发射断层扫描(PET)利用F18等放射性元素标记的示踪剂 衰变时发射的正电子信息成像，因此，PET图像是相应示踪剂放射性活度的度量， 能提供肿瘤生物学特性(如葡萄糖代谢、乏氧、增殖等)信息，其标准摄入值大小可用于临床辅助判别肿瘤良/恶性。PET能提供比CT、MRI更直观、更精确的可视化生物学与放射生物学特性信息。\n病理图像：是指切取一定大小的病变组织，采用苏木精和曙红 (H ＆ E) 等染色方法将切片组织做成病理玻片，然后用显微镜成像技术对微观的细胞和腺体成像。通过对病理图像进行分析，可探讨病变产生的原因、发病机理、病变的发生发展过程，从而做出病理诊断。\n\n目前，临床医学图像分析深度学习研究对象主要可分为上述6类医学图像。\n2.2 主要的医学图像分析任务\n医学图像分类与识别\n临床医生需要借助医学图像来辅助诊断人体是否有病灶，并对病灶的轻重程度进行量化分级，因此自动识别图像中的病灶区域和正常组织器官是医学图像分析的基本任务。\n\n\n医学图像定位与检测\n人体组织器官解剖结构和病灶区域的定位是临床治疗计划和干预流程中非常重要的预处理步骤,定位的精度直接影响治疗的效果。图像目标定位任务不仅需要识别图像中的特定目标,而且需要确定其具体的物理位置。图像目标检测任务则需要把图像中所有目标识别出来，且确定它们的物理位置和类别。\n\n\n医学图像分割任务\n图像分割是识别图像中感兴趣的目标区域内部体素以及外部轮廓，它是临床手术图像导航和图像引导肿瘤放疗的关键任务。\n\n\n\n3、深度学习方法概述\n机器学习算法通常分为有监督学习算法和无监督学习算法。在有监督学习算法中不仅把训练的数据输入给计算机，同时还把数据的标签也一并作为输入传给计算机，计算机进行学习之后，再给它传进新的未知的数据，它也能计算出该数据属于某种结果的概率，最后给你一个最接近正确的结果。由于计算机在学习的过程中不仅有训练数据，而且还有结果（标签），因此训练的效果往往都不错。与有监督学习不同的是，无监督学习的输入数据只有原始数据，没有标签，因此计算机无法准确地知道哪些数据属于哪些类，只能凭借强大的计算能力分析数据的特征，从而得到一定的成果，通常得到的是一些集合，集合内的数据在某些特征上相同，或相似。\n\n3.1 神经网络\n神经网络是一门重要的机器学习技术，在机器学习和认知领域。是一种模仿生物神经网络的结构和功能的数学模型或计算模型，用于对函数进行估计或近似。神经网络由大量的人工神经元联结进行计算。大多数情况下人工神经网络能在外界信息的基础上改变内部结构，是一种自适应系统，通俗的讲就是具备学习功能。现代神经网络是一种非线性统计性数据建模工具。典型的神经网络具有以下三个部分：\n结构（Architecture）：结构指定了网络中的变量和它们的拓扑关系。例如，神经网络中的变量可以是神经元连接的权重（weights）和神经元的激励值（activities of the neurons）。\n激励函数（Activity Rule）：大部分神经网络模型具有一个短时间尺度的动力学规则，来定义神经元如何根据其他神经元的活动来改变自己的激励值。一般激励函数依赖于网络中的权重（即该网络的参数）。\n学习规则（Learning Rule）：学习规则指定了网络中的权重如何随着时间推进而调整。这一般被看做是一种长时间尺度的动力学规则。一般情况下，学习规则依赖于神经元的激励值。它也可能依赖于监督者提供的目标值和当前权重的值。\n通常一个简单的神经网络包含3部分：输入层、隐含层和输出层。一般输入层和输出层的节点是固定的，隐含层可以自由指定，图1是一个简单的神经网络结构示意图，图中的圆圈代表神经元，箭头代表数据的流向，每根连线上面都对应一个不同的权重，权重是网络通过学习自己得到的。\n\n\n\n每一个神经元都包含了输入、输出以及计算模型3个部分，可以把神经元看成一个计算与存储单元，计算是神经元对其的输入进行计算功能。存储是神经元会暂存计算结果，并传递到下一层。如图2所示是一个典型的神经元模型，包含3个输入，1个输出以及1个计算功能。\n\n\n\n其中a表示输入，w表示权值，一个表示连接的有向箭头可以这样理解：在初端，传递的信号大小仍然是a，端中间有加权参数w，经过这个加权后的信号会变成aw，因此在连接的末端，信号的大小就变成了aw。在神经元处加权信号求和通过函数f就得到了输出Z,公式如下：\n\n\n\n事实上，为了使神经元取得更好的效果，通常对每一个输入进行加权之后都会加上一个偏置b，此时Z的计算公式如下：\n\n\n其中函数f又称为激活函数，常见的激活函数有sigmoid函数、tanh函数和ReLU函数等。\n\n\n3.2 神经网络框架1.深度神经网络（DNN）\nDNN是层数很深的全连接网络，层数决定了神经网络对数据的刻画能力：利用每层更少的神经元拟合更加复杂的函数。2006年Hinton利用预训练方法缓解了局部最优解问题，将隐含层推动到了7层，揭开了深度学习的浪潮。注意这里的“深度”并没有固定的定义，在语音识别领域，4层就认为是比较深的了；而在图像识别领域20层的模型屡见不鲜。2016年提出的highway network以及深度残差学习（deep residual learning）进一步杜绝了梯度消失达到了一百多层。2.卷积神经网络（CNN）\n卷积神经网络更改了神经网络的结构，不再是全连接的结构了，大量的减少了网络的参数；同时，通过参数共享进一步减少了网络参数。它考虑到了空间结构和局部特征，非常适用于图像处理领域，目前卷积神经网络在医学图像分析领域应用的最为广泛。例如对医学图像进行分割时，CNN可以简单的对图像中的每个像素进行分类，方法是在特定像素周围提取补丁。\n\n3.循环神经网络（RNN）\n鉴于深度学习在现实任务中的广泛适用性，它已经吸引了众多技术专家、投资者和非专业人员的关注。尽管深度学习最著名的成果是使用前馈卷积神经网络来解决计算机视觉问题，少数公众的注意力已经投入到使用递归神经网络来对时间关系进行建模。在普通的全连接网络或者CNN中，每层神经元的信号只能向上传播，样本的处理在各个时刻独立，因此又称为前馈神经网络。而在RNN中，神经元的输出可以在下一个时间戳直接作用到自身；即第i层的神经元在m时刻的输入包含i-1层在该时刻的输出以及其自身在m-1时刻的输出。在此基础上发展出了长短期记忆LSTM网络。4.深度置信网络DBN\n深度置信网络（deep belief networks，DBN）是一种包含多层隐单元的概率生成模型，可被视为多层简单学习模型组合而成的复合模型。可以作为深度神经网络的预训练部分，并为网络提供初始权重，再使用反向传播或者其他判定算法作为调优的手段。\n虽然我们可以对深度学习的各种方法进行分类，但是广义上来说NN或者DNN是包含了其它各种变种方法的。在实际使用中往往也是多种结构的融合。\n\n4、深度学习在医学图像中应的用4.1 医学图像分类\n医学图像分类可以分为图像筛查和目标或病灶分类。图像筛查是深度学习在医学图像分析领域中的最早应用之一, 是指将一个或多个检查图像作为输入, 通过训练好的模型对其预测, 输出一个表示是否患某种疾病或严重程度分级的诊断变量。图像筛查属于图像级分类，用来解决此任务的深度学习模型最初关注于 SAE、 DBN 及 DBM 网络和非监督预训练方法。研究主要集中在神经影像的分析上，如通过神经影像诊断是否患有老年痴呆症 (Alzheimer0s disease, AD) 或轻度认识功能障碍(Mild cognitive impairment, MCI)[90−92]。这些算法通常利用多模态图像作为输入，提取MRI、PET等模态中的互补特征信息。目前, CNN 正逐渐成为图像筛查分类中的标准技术,其应用非常广泛。如 Arevalo 等提出了乳腺癌诊断的特征学习框架, 采用CNN自动学习区分性特征，对乳房X线照片病变分类[3]。Kooi等比较了传统CAD中手动设计和自动CNN特征提取方法,两者都在约4.5万乳房X线图像的大数据集上训练,结果显示 CNN 在低灵敏度下优于传统CAD系统方法,且在高灵敏度下两者相当[4]。Spampinato等应用深度 CNN 自动评估骨骼骨龄[5]。另外,还有一些工作将CNN与RNN结合起来，如Gao等利用CNN 提取裂隙灯图像中的低层局部特征信息,结合RNN进一步提取高层特征，对核性白内障进行分级[6]。\n目标或病灶的分类可以辅助医生对疾病进行诊断，如对乳腺病灶进行良恶性分类。其处理过程通常首先通过预处理方法识别或标记出的特定区域,然后再对特定区域进行目标或病灶分类。精确的分类不仅需要病灶外表的局部信息,而且还需结合其位置的全局上下文信息。CNN在目标或病灶的分类中也应用的非常广泛。Kawahara等采用多处理流CNN对皮肤病灶分类,其中每个流程处理不同分辨率的图像[7]。Jiao等利用CNN提取不同层次的深度特征,提高了乳腺癌的分类准确率[8]。Tajbakhsh 等就 CT 图像中检测肺结节且区分良性和恶性肺结节的任务,比较了大规模训练人工神经网络(Massive-training artificial neuralnetworks, MTANNs) 与 CNN 这两种端到端训练的人工神经网络的性能,其实验结果表明,只有使用较少训练数据时,MTANN的性能明显高于 CNN[9]。\n\n4.2 医学图像定位与检测\n准确地在医学图像中定位特定生物标记或解剖结构在临床治疗中具有非常重要的意义，直接关系到治疗效果的好坏。医学图像定位常需要分析3D体素信息。为了使用经典深度学习算法进行3D数据处理,一些方法将3D空间看成2D正交面的组合,这样可将定位任务转换成为分类任务,利用通用深度学习框架进行处理。如Yang等结合三个正交方向CNN的信息识别股骨末端的标记,标记3D位置定义为三个2D图块的交点[10]。Vos等通过将3D CT体积解析成2D形式,识别目标3D矩形包围盒,进而定位到感兴趣的心脏、主动脉弧和下降主动脉等解剖区域[11]。\n而医学图像的感兴趣目标或病灶检测的关键是对每个像素进行分类。目前大多数基于深度学习目标检测系统采用CNN执行像素分类任务,之后采用某种形式的后处理方式得到目标。香港中文大学Chen等利用多个2D深层特征近似表达3D医学图像的特征,结合SVM分类器,实现敏感性加权图像(Susceptibility weighted imaging,SWI)自动检测脑微出血(Cerebral microbleeds, CMBs)[12]。还有少量工作采用其他深度学习方法来实现感兴趣目标或病灶检测, 如 Shin 等将SAE深度学习方法应用于MRI图像上检测腹部器官,先以非监督方式学习空间特征,然后基于兴趣点进行多器官检测[13]。\n\n4.3 医学图像分割\n医学图像分割的任务通常被定义为识别组成感兴趣对象的轮廓或内部的体素集，它是深度学习应用于医学图像分析领域的论文中最常见的主题。医学图像中器官及其子结构的分割可用于定量分析体积和形状有关的临床参数，如心脏的心室体积和收缩射出率。另一方面，在采用智能调强放疗技术对肿瘤进行治疗时, 危及器官勾画是制定放疗计划中非常重要的步骤之一，深度学习在此任务中应用非常广泛，主要应用于：组织病理学图像和显微镜图像分割；脑组织结构分割以及心脏心室分割等领域。\n通过计算机分割来自手术和活检组织标本的图像特征可以帮助预测疾病侵袭性的程度，从而进行疾病诊断和分级。这些预测器的关键组成部分就是从组织病理图像挖掘的图像特征。目前绝大对数组织病理学图像和显微镜图像分割的方法都是基于CNN的。许多学者利用图块训练网络取得了非常优秀的分割结果。Ciresan等率先将深度CNN应用于医学图像分割，他们以滑窗方式在电子显微镜图像中分割出生物神经膜[14]。Kumar等利用基于块的CNN对H&amp;E染色的病理学图像进行细胞核分割[15]。\n脑组织结构的体积形态与很多的脑部神经疾病都息息相关。如抑郁症、阿耳茨海默氏病、精神分裂症和躁郁症等。因此通过计算机技术对脑组织结构的解剖结构进行研究在医学研究、临床诊断和治疗方面都起着十分重要的意义。例如Zhang 等将 T1、T2和FA (Fractional anisotropy) 三种模态图像作为输入,采用深度CNN网络解决婴儿GM、WM和CSF分割这一挑战性任务，从而对婴儿脑发育优劣程度作评估[16]。\n从心脏MRI数据中分割出左心室是计算心室体积和收缩射出率等临床指标的重要步骤之一。Carneiro等采用基于DBN学习特征对左心室外观建模,利用监督学习模型在心脏超声波图像中自动分割出左心室[17]，而Avendi等采用SAE 学习深度特征初步推断左心室的形状，再结合形变模型提高左心室分割的准确性和鲁棒性[18]。\n从深度学习应用框架来看，目前大多数图像分割方法都是基于CNN的。许多学者利用基于图像块方式训练网络取得了很好的分割结果。\n\n5、总结\n综上所述,深度学习具有自动地从数据中学习深层次、更具鉴别性特征的能力，已应用于医学图像分析的多个研究领域，并取得了突破性进展。我们注意到,在大多数文献中，使用深度学习相关方法展示了其领先水平的性能，这已由医学图像分析的若干计算挑战赛结果证明；其次，云计算和多 GPU高性能并行计算技术的发展，使得深度学习从海量的医学图像大数据中学习深层特征成为可能； 最后，可公开访问的相关医学图像数据库的出现及多个医学图像分割挑战赛数据集，使得基于深度学习的分割算法能够得到有效验证。\n我们相信，通过深度学习算法的不断改进，借助高性能并行计算技术的发展和日益改善的医学图像质量与不断增长的医学图像标记样本集，基于深度学习的医学图像分析将大有所为。\n\n参考文献[1]Zhang Lei, Zhang Yi. Big data analysis by infinite deep neural networks. Journal of Computer Research and Development, 2016, 53(1): 68−79.\n[2]Litjens G, Kooi T, Bejnordi B E, Setio A A A, Ciompi F,Ghafoorian M, van der Laak J A W M, van Ginneken B,S´anchez C. A survey on deep learning in medical image analysis. Medical Image Analysis, 2017, 42(9): 60−88.\n[3]Arevalo J, Gonz´alez F A, Ramos-Poll´an R, Oliveira J L,Lopez M A G. Representation learning for mammographymass lesion classification with convolutional neural networks. Computer Methods and Programs in Biomedicine,2016, 127: 248−257.\n[4]Kooi T, Litjens G, van Ginneken B, Gubern-M´erida A,S´anchez C I, Mann R, den Heeten A, Karssemeijer N.Large scale deep learning for computeraided detection of mammographic lesions. Medical Image Analysis, 2017, 35:303−312.\n[5]Spampinato C, Palazzo S, Giordano D, Aldinucci M,Leonardi R. Deep learning for automated skeletal bone age assessment in X-ray images. Medical Image Analysis, 2016,36: 41−51.\n[6]Gao X T, Lin S, Wong T Y. Automatic feature learning to grade nuclear cataracts based on deep learning. IEEE Transactions on Biomedical Engineering, 2015, 62(11):2693-2701.\n[7]Kawahara J, Hamarneh G. Multi-resolution-tract CNN with hybrid pretrained and skin-lesion trained layers. International Workshop on Machine Learning in Medical Imaging. Athens, Greece: Springer, 2016. 164−171.\n[8]Jiao Z C, Gao X B, Wang Y, Li J. A deep feature based framework for breast masses classification. Neurocomputing, 2016, 197: 221−231.\n[9]Tajbakhsh N, Suzuki K. Comparing two classes of end-toend machine-learning models in lung nodule detection and classification: MTANNs vs. CNNs. Pattern Recognition,2016, 63: 476−486.\n[10]Yang D, Zhang S T, Yan Z N, Tan C W, Li K, Metaxas D.Automated anatomical landmark detection ondistal femur surface using convolutional neural network. In: Proceedings of the 12th International Symposium on Biomedical Imaging. New York, NY, USA: IEEE, 2015. 17−21.\n[11]de Vos B D, Wolterink J M, de Jong P A, Viergever MA, Iˇsgum I. 2D image classification for 3D anatomy localization: employing deep convolutional neural networks.In: Proceedings of the 9784, Medical Imaging 2016: ImageProcessing. San Diego, California, US: SPIE, 2016, 9784:Article No. 97841Y.\n[12]Chen H, Yu L Q, Dou Q, Shi L, Mok V C T, Heng PA. Automatic detection of cerebral microbleeds via deep learning based 3D feature representation. In: Proceedings of the 12th International Symposium on Biomedical Imaging (ISBI). New York, NY, USA: IEEE, 2015. 764−767.\n[13]Shin H C, Orton M R, Collins D J, Doran S J, Leach M O. Stacked autoencoders for unsupervised feature learning and multiple organ detection in a pilot study using 4D patient data. IEEE Transactions on Pattern Analysisand Machine Intelligence, 2013, 35(8): 1930−1943.\n[14]Cire¸san D C, Giusti A, Gambardella L M, Schmidhuber J. Deep neural networks segment neuronal membranes in electron microscopy images. In: Proceedings of the 25th International Conference on Neural Information Processing Systems. Lake Tahoe, Nevada: Curran Associates Inc., 2012. 2843−2851.\n[15]Kumar N, Verma R, Sharma S, Bhargava S, Vahadane A,Sethi A. A dataset and a technique for generalized nuclear segmentation for computational pathology. IEEE Transactions on Medical Imaging, 2017, 36(7): 1550−1560.\n[16]Zhang W L, Li R J, Deng H T, Wang L, Lin W L, Ji S W, Shen D G. Deep convolutional neural networks for multi-modality isointense infant brain image segmentation. NeuroImage, 2015, 108: 214−224.\n[17]Carneiro G, Nascimento J C, Freitas A. The segmentation of the left ventricle of the heart from ultrasound data using deep learning architectures andderivative-based search methods. IEEE Transactions on Image Processing, 2012,21(3): 968−982.\n[18]Avendi M R, Kheradvar A, Jafarkhani H. A combined deep-learning and deformable-model approach to fully automatic segmentation of the left ventricle in cardiac MRI.Medical Image Analysis, 2016, 30: 108−119.\n","categories":["图像处理与机器学习"],"tags":["机器学习"]},{"title":"ECCV所有论文下载链接","url":"https://tanqingbo.cn/2018ECCV-Paper-DL/","content":"Aaron_Gokaslan_Improving_Shape_Deformation_ECCV_2018_paper.pdf\nAashish_Sharma_Into_the_Twilight_ECCV_2018_paper.pdf\nAayush_Bansal_Recycle-GAN_Unsupervised_Video_ECCV_2018_paper.pdf\nAbdullah_Abuolaim_Revisiting_Autofocus_for_ECCV_2018_paper.pdf\nAbhimanyu_Dubey_Coreset-Based_Convolutional_Neural_ECCV_2018_paper.pdf\nAbhimanyu_Dubey_Improving_Fine-Grained_Visual_ECCV_2018_paper.pdf\nAdam_Geva_X-ray_Computational_Tomography_ECCV_2018_paper.pdf\nAdria_Recasens_Learning_to_Zoom_ECCV_2018_paper.pdf\nAdrian_Bulat_To_learn_image_ECCV_2018_paper.pdf\nAdrien_Kaiser_Proxy_Clouds_for_ECCV_2018_paper.pdf\nAggeliki_Tsoli_Joint_3D_tracking_ECCV_2018_paper.pdf\nAhmet_Iscen_Local_Orthogonal-Group_Testing_ECCV_2018_paper.pdfAidean_Sharghi_Improving_Sequential_Determinantal_ECCV_2018_paper.pdfAlbert_Pumarola_Anatomically_Coherent_Facial_ECCV_2018_paper.pdfAlex_Locher_Progressive_Structure_from_ECCV_2018_paper.pdfAlex_Zhu_Realtime_Time_Synchronized_ECCV_2018_paper.pdfAlexander_Vakhitov_Stereo_relative_pose_ECCV_2018_paper.pdfAli_Diba_Spatio-Temporal_Channel_Correlation_ECCV_2018_paper.pdfAmeya_Prabhu_Deep_Expander_Networks_ECCV_2018_paper.pdfAmir_Mazaheri_Visual_Text_Correction_ECCV_2018_paper.pdfAmir_Sadeghian_CAR-Net_Clairvoyant_Attentive_ECCV_2018_paper.pdfAmit_Raj_SwapNet_Garment_Transfer_ECCV_2018_paper.pdfAnanya_Harsh_Jha_Disentangling_Factors_of_ECCV_2018_paper.pdfAndreas_Veit_Convolutional_Networks_with_ECCV_2018_paper.pdfAndrew_Gilbert_Volumetric_performance_capture_ECCV_2018_paper.pdfAndrew_Owens_Audio-Visual_Scene_Analysis_ECCV_2018_paper.pdfAngela_Dai_3DMV_Joint_3D-Multi-View_ECCV_2018_paper.pdfAngjoo_Kanazawa_Learning_Category-Specific_Mesh_ECCV_2018_paper.pdfAnil_Baslamisli_Joint_Learning_of_ECCV_2018_paper.pdfAnirudh_Som_Perturbation_Robust_Representations_ECCV_2018_paper.pdfAnkan_Bansal_Zero-Shot_Object_Detection_ECCV_2018_paper.pdfAntonio_Torralba_Interpretable_Basis_Decomposition_ECCV_2018_paper.pdfAnurag_Arnab_Weakly-_and_Semi-Supervised_ECCV_2018_paper.pdfAnurag_Ranjan_Generating_3D_Faces_ECCV_2018_paper.pdfApoorv_Vyas_Out-of-Distribution_Detection_Using_ECCV_2018_paper.pdfArchan_Ray_U-PC_Unsupervised_Planogram_ECCV_2018_paper.pdfArjun_Nitin_Bhagoji_Practical_Black-box_Attacks_ECCV_2018_paper.pdfArmand_Zampieri_Multimodal_image_alignment_ECCV_2018_paper.pdfArslan_Chaudhry__Riemannian_Walk_ECCV_2018_paper.pdfArtsiom_Sanakoyeu_A_Style-aware_Content_ECCV_2018_paper.pdfArun_Mallya_Piggyback_Adapting_a_ECCV_2018_paper.pdfAttila_Szabo_Understanding_Degeneracies_and_ECCV_2018_paper.pdfAuston_Sterling_ISNN_-_Impact_ECCV_2018_paper.pdfBaosheng_Yu_Correcting_the_Triplet_ECCV_2018_paper.pdfBaris_Gecer_Semi-supervised_Adversarial_Learning_ECCV_2018_paper.pdfBeery_Recognition_in_Terra_ECCV_2018_paper.pdfBenjamin_Coors_SphereNet_Learning_Spherical_ECCV_2018_paper.pdfBenjamin_Eckart_Fast_and_Accurate_ECCV_2018_paper.pdfBenjamin_Hepp_Learn-to-Score_Efficient_3D_ECCV_2018_paper.pdfBharath_Bhushan_Damodaran_DeepJDOT_Deep_Joint_ECCV_2018_paper.pdfBin_Xiao_Simple_Baselines_for_ECCV_2018_paper.pdfBingbin_Liu_Temporal_Modular_Networks_ECCV_2018_paper.pdfBo_Dai_Rethinking_the_Form_ECCV_2018_paper.pdfBo_Peng_Extreme_Network_Compression_ECCV_2018_paper.pdfBo_Xiong_Snap_Angle_Prediction_ECCV_2018_paper.pdfBo_Zhao_Modular_Generative_Adversarial_ECCV_2018_paper.pdfBochao_Wang_Toward_Characteristic-Preserving_Image-based_ECCV_2018_paper.pdfBogdan_Bugaev_Combining_3D_Model_ECCV_2018_paper.pdfBolei_Zhou_Temporal_Relational_Reasoning_ECCV_2018_paper.pdfBorui_Jiang_Acquisition_of_Localization_ECCV_2018_paper.pdfBowen_Cheng_Revisiting_RCNN_On_ECCV_2018_paper.pdfBowen_Zhang_Cross-Modal_and_Hierarchical_ECCV_2018_paper.pdfBoyu_Chen_Real-time_Actor-Critic_Tracking_ECCV_2018_paper.pdfBrandon_RichardWebster_Visual_Psychophysics_for_ECCV_2018_paper.pdfBrook_Roberts_A_Dataset_for_ECCV_2018_paper.pdfBruce_Hou_Transferable_Adversarial_Perturbations_ECCV_2018_paper.pdfBryan_Plummer_Conditional_Image-Text_Embedding_ECCV_2018_paper.pdfCHAOWEI_XIAO_Characterize_Adversarial_Examples_ECCV_2018_paper.pdfCHUNLUAN_ZHOU_Bi-box_Regression_for_ECCV_2018_paper.pdfCalvin_Murdock_Deep_Component_Analysis_ECCV_2018_paper.pdfCarl_Toft_Semantic_Match_Consistency_ECCV_2018_paper.pdfCarl_Vondrick_Self-supervised_Tracking_by_ECCV_2018_paper.pdfCarlos_Esteves_Learning_SO3_Equivariant_ECCV_2018_paper.pdfCeyuan_Yang_Pose_Guided_Human_ECCV_2018_paper.pdfChang_Chen_Deep_Boosting_for_ECCV_2018_paper.pdfChang_Liu_Linear_Span_Network_ECCV_2018_paper.pdfChangan_Chen_Constraints_Matter_in_ECCV_2018_paper.pdfChangqian_Yu_BiSeNet_Bilateral_Segmentation_ECCV_2018_paper.pdfChangqing_Zou_SketchyScene_Richly-Annotated_Scene_ECCV_2018_paper.pdfChanho_Kim_Multi-object_Tracking_with_ECCV_2018_paper.pdfChao-Yuan_Wu_Video_Compression_through_ECCV_2018_paper.pdfChao_Li_ArticulatedFusion_Real-time_Reconstruction_ECCV_2018_paper.pdfChao_Wang_Discriminative_Region_Proposal_ECCV_2018_paper.pdfChaojian_Yu_Hierarchical_Bilinear_Pooling_ECCV_2018_paper.pdfCharles_Herrmann_Object-centered_image_stitching_ECCV_2018_paper.pdfCharles_Herrmann_Robust_image_stitching_ECCV_2018_paper.pdfChen_Liu_FloorNet_A_Unified_ECCV_2018_paper.pdfChen_Sun_Actor-centric_Relation_Network_ECCV_2018_paper.pdfChen_Zhu_Fine-grained_Video_Categorization_ECCV_2018_paper.pdfCheng_Wang_Mancs_A_Multi-task_ECCV_2018_paper.pdfChenglong_Li_Cross-Modal_Ranking_with_ECCV_2018_paper.pdfChenxi_Liu_Progressive_Neural_Architecture_ECCV_2018_paper.pdfChenyang_Si_Skeleton-Based_Action_Recognition_ECCV_2018_paper.pdfChi_Li_A_Unified_Framework_ECCV_2018_paper.pdfChieh_Lin_Escaping_from_Collapsing_ECCV_2018_paper.pdfChong_Li_Constrained_Optimization_Based_ECCV_2018_paper.pdfChong_You_A_Scalable_Exemplar-based_ECCV_2018_paper.pdfChristopher_Zach_Descending_lifting_or_ECCV_2018_paper.pdfChristos_Sakaridis_Semantic_Scene_Understanding_ECCV_2018_paper.pdfChu_Wang_Local_Spectral_Graph_ECCV_2018_paper.pdfChuanxia_Zheng_T2Net_Synthetic-to-Realistic_Translation_ECCV_2018_paper.pdfChuhui_Xue_Accurate_Scene_Text_ECCV_2018_paper.pdfChunrui_Han_Face_Recognition_with_ECCV_2018_paper.pdfChunyan_Bai_Deep_Video_Generation_ECCV_2018_paper.pdfChunze_Lin_Graininess-Aware_Deep_Feature_ECCV_2018_paper.pdfCiprian_Corneanu_Deep_Structure_Inference_ECCV_2018_paper.pdfClement_Godard_Deep_Burst_Denoising_ECCV_2018_paper.pdfCsaba_Domokos_MRF_Optimization_with_ECCV_2018_paper.pdfCurtis_Wigington_Start_Follow_Read_ECCV_2018_paper.pdfDamien_Teney_Visual_Question_Answering_ECCV_2018_paper.pdfDanda_Pani_Paudel_Sampling_Algebraic_Varieties_ECCV_2018_paper.pdfDanfeng_Hong_Joint__Progressive_ECCV_2018_paper.pdfDaniel_Barath_Multi-Class_Model_Fitting_ECCV_2018_paper.pdfDaniel_Castro_From_Face_Recognition_ECCV_2018_paper.pdfDaniel_Gehrig_Asynchronous_Photometric_Feature_ECCV_2018_paper.pdfDaniel_Jakubovitz_Improving_DNN_Robustness_ECCV_2018_paper.pdfDaniel_Maurer_Structure-from-Motion-Aware_PatchMatch_for_ECCV_2018_paper.pdfDaniel_Worrall_CubeNet_Equivariance_to_ECCV_2018_paper.pdfDapeng_Chen_Improving_Deep_Visual_ECCV_2018_paper.pdfDario_Rethage_Fully-Convolutional_Point_Networks_ECCV_2018_paper.pdfDavid_Harwath_Jointly_Discovering_Visual_ECCV_2018_paper.pdfDavid_Schubert_Direct_Sparse_Odometry_ECCV_2018_paper.pdfDawei_Du_The_Unmanned_Aerial_ECCV_2018_paper.pdfDeng-Ping_Fan_Salient_Objects_in_ECCV_2018_paper.pdfDhruv_Mahajan_Exploring_the_Limits_ECCV_2018_paper.pdfDi_Chen_Person_Search_via_ECCV_2018_paper.pdfDi_Lin_Multi-Scale_Context_Intertwining_ECCV_2018_paper.pdfDian_SHAO_Find_and_Focus_ECCV_2018_paper.pdfDiana_Sungatullina_Image_Manipulation_with_ECCV_2018_paper.pdfDima_Damen_Scaling_Egocentric_Vision_ECCV_2018_paper.pdfDinesh_Jayaraman_ShapeCodes_Self-Supervised_Feature_ECCV_2018_paper.pdfDiwen_Wan_TBN_Convolutional_Neural_ECCV_2018_paper.pdfDmitry_Baranchuk_Revisiting_the_Inverted_ECCV_2018_paper.pdfDmytro_Mishkin_Repeatability_Is_Not_ECCV_2018_paper.pdfDong_Lao_Extending_Layered_Models_ECCV_2018_paper.pdfDong_Li_Recurrent_Tubelet_Proposal_ECCV_2018_paper.pdfDong_Su_Is_Robustness_the_ECCV_2018_paper.pdfDong_Yang_Proximal_Dehaze-Net_A_ECCV_2018_paper.pdfDongang_Wang_Dividing_and_Aggregating_ECCV_2018_paper.pdfDonghoon_Lee_Unsupervised_holistic_image_ECCV_2018_paper.pdfDongqing_Zhang_Optimized_Quantization_for_ECCV_2018_paper.pdfDongwoo_Lee_Joint_Blind_Motion_ECCV_2018_paper.pdfEddy_Ilg_Occlusions_Motion_and_ECCV_2018_paper.pdfEddy_Ilg_Uncertainty_Estimates_and_ECCV_2018_paper.pdfEdgar_Margffoy-Tuay_Dynamic_Multimodal_Instance_ECCV_2018_paper.pdfEdo_Collins_Deep_Feature_Factorization_ECCV_2018_paper.pdfEdouard_Oyallon_Compressing_the_Input_ECCV_2018_paper.pdfEfstratios_Gavves_Long-term_Tracking_in_ECCV_2018_paper.pdfEric_Muller-Budack_Geolocation_Estimation_of_ECCV_2018_paper.pdfErnesto_Brau_Stereo_gaze_Inferring_ECCV_2018_paper.pdfEunbyung_Park_Meta-Tracker_Fast_and_ECCV_2018_paper.pdfEunhyeok_Park_Value-aware_Quantization_for_ECCV_2018_paper.pdfEunji_Chong_Connecting_Gaze_Scene_ECCV_2018_paper.pdfFabian_Caba_What_do_I_ECCV_2018_paper.pdfFabian_Manhardt_Deep_Model-Based_6D_ECCV_2018_paper.pdfFabien_Baradel_Object_Level_Visual_ECCV_2018_paper.pdfFabio_Tosi_Beyond_local_reasoning_ECCV_2018_paper.pdfFang_Zhao_Dynamic_Conditional_Networks_ECCV_2018_paper.pdfFangneng_Zhan_Verisimilar_Image_Synthesis_ECCV_2018_paper.pdfFanyi_Xiao_Object_Detection_with_ECCV_2018_paper.pdfFatemeh_Sadat_Saleh_Effective_Use_of_ECCV_2018_paper.pdfFatih_Cakir_Hashing_with_Binary_ECCV_2018_paper.pdfFelipe_Codevilla_On_Offline_Evaluation_ECCV_2018_paper.pdfFengting_Yang_Recovering_3D_Planes_ECCV_2018_paper.pdfFilip_Radenovic_Deep_Shape_Matching_ECCV_2018_paper.pdfFilippos_Kokkinos_Deep_Image_Demosaicking_ECCV_2018_paper.pdfFitsum_Reda_SDC-Net_Video_prediction_ECCV_2018_paper.pdfFlorian_Strub_Visual_Reasoning_with_ECCV_2018_paper.pdfFrancisco_M._Castro_End-to-End_Incremental_Learning_ECCV_2018_paper.pdfFudong_Wang_Adaptively_Transforming_Graph_ECCV_2018_paper.pdfGang_Zhang_Generative_Adversarial_Network_ECCV_2018_paper.pdfGaofeng_Meng_Exploiting_Vector_Fields_ECCV_2018_paper.pdfGe_Deep_Metric_Learning_ECCV_2018_paper.pdfGedas_Bertasius_Object_Detection_in_ECCV_2018_paper.pdfGeorge_Papandreou_PersonLab_Person_Pose_ECCV_2018_paper.pdfGilad_Divon_Viewpoint_Estimation_-_ECCV_2018_paper.pdfGilles_Simon_A_Contrario_Horizon-First_ECCV_2018_paper.pdfGoutam_Bhat_Unveiling_the_Power_ECCV_2018_paper.pdfGratianus_Wesley_Putra_Data_Interpolating_Convolutional_Neural_ECCV_2018_paper.pdfGregoire_Payen_de_La_Garanderie_Eliminating_the_Dreaded_ECCV_2018_paper.pdfGuanan_Wang_Semi-Supervised_Generative_Adversarial_ECCV_2018_paper.pdfGuandao_Yang_A_Unified_Framework_ECCV_2018_paper.pdfGuangming_Zang_Super-Resolution_and_Sparse_ECCV_2018_paper.pdfGuangyu_Robert_Yang_A_dataset_and_ECCV_2018_paper.pdfGuanying_Chen_PS-FCN_A_Flexible_ECCV_2018_paper.pdfGuilin_Liu_Image_Inpainting_for_ECCV_2018_paper.pdfGul_Varol_BodyNet_Volumetric_Inference_ECCV_2018_paper.pdfGuo_Lu_Deep_Kalman_Filtering_ECCV_2018_paper.pdfGuojun_Yin_Zoom-Net_Mining_Deep_ECCV_2018_paper.pdfGuoliang_Kang_Deep_Adversarial_Attention_ECCV_2018_paper.pdfGuorun_Yang_SegStereo_Exploiting_Semantic_ECCV_2018_paper.pdfGuosheng_Hu_Deep_Multi-Task_Learning_ECCV_2018_paper.pdfHSUAN-I_HO_Summarizing_First-Person_Videos_ECCV_2018_paper.pdfHUSEYIN_COSKUN_Human_Motion_Analysis_ECCV_2018_paper.pdfHU_Jian-Fang_Deep_Bilinear_Learning_ECCV_2018_paper.pdfHai_Ci_Video_Object_Segmentation_ECCV_2018_paper.pdfHaitian_Zheng_CrossNet_An_End-to-end_ECCV_2018_paper.pdfHang_Yan_RIDI_Robust_IMU_ECCV_2018_paper.pdfHang_Zhao_The_Sound_of_ECCV_2018_paper.pdfHanyu_Wang_Learning_3D_Keypoint_ECCV_2018_paper.pdfHao_Cheng_Evaluating_Capability_of_ECCV_2018_paper.pdfHaoshu_Fang_Pairwise_Body-Part_Attention_ECCV_2018_paper.pdfHaoshuo_Huang_Domain_transfer_through_ECCV_2018_paper.pdfHaroon_Idrees_Composition_Loss_for_ECCV_2018_paper.pdfHeewon_Kim_Task-Aware_Image_Downscaling_ECCV_2018_paper.pdfHei_Law_CornerNet_Detecting_Objects_ECCV_2018_paper.pdfHelge_Rhodin_Unsupervised_Geometry-Aware_Representation_ECCV_2018_paper.pdfHeng_Wang_Scenes-Objects-Actions_A_Multi-Task_ECCV_2018_paper.pdfHengcan_Shi_Key-Word-Aware_Network_for_ECCV_2018_paper.pdfHengshuang_Zhao_Compositing-aware_Image_Search_ECCV_2018_paper.pdfHengshuang_Zhao_ICNet_for_Real-Time_ECCV_2018_paper.pdfHengshuang_Zhao_PSANet_Point-wise_Spatial_ECCV_2018_paper.pdfHenry_W._F._Yeung_Fast_Light_Field_ECCV_2018_paper.pdfHieu_Le_AD_Net_Training_ECCV_2018_paper.pdfHiroaki_Santo_Light_Structure_from_ECCV_2018_paper.pdfHoang_Le_Interactive_Boundary_Prediction_ECCV_2018_paper.pdfHong-Min_Chu_Deep_Generative_Models_ECCV_2018_paper.pdfHong_Xuan_Randomized_Ensemble_Embeddings_ECCV_2018_paper.pdfHongmei_Song_Pseudo_Pyramid_Deeper_ECCV_2018_paper.pdfHongyang_Li_Neural_Network_Encapsulation_ECCV_2018_paper.pdfHongyu_Xu_Deep_Regionlets_for_ECCV_2018_paper.pdfHossam_Isack_K-convexity_shape_priors_ECCV_2018_paper.pdfHsin-Ying_Lee_Diverse_Image-to-Image_Translation_ECCV_2018_paper.pdfHsueh-Fu_Lu_Toward_Scale-Invariance_and_ECCV_2018_paper.pdfHuaizu_Jiang_Self-Supervised_Relative_Depth_ECCV_2018_paper.pdfHuajie_Jiang_Learning_Class_Prototypes_ECCV_2018_paper.pdfHuang_Predicting_Gaze_in_ECCV_2018_paper.pdfHuayi_Zeng_Neural_Procedural_Reconstruction_ECCV_2018_paper.pdfHuizhong_Zhou_DeepTAM_Deep_Tracking_ECCV_2018_paper.pdfHumam_Alwassel_Action_Search_Spotting_ECCV_2018_paper.pdfHumam_Alwassel_Diagnosing_Error_in_ECCV_2018_paper.pdfHyo_Jin_Kim_Hierarchy_of_Alternating_ECCV_2018_paper.pdfHyojin_Bahng_Coloring_with_Words_ECCV_2018_paper.pdfIan_Cherabier_Learning_Priors_for_ECCV_2018_paper.pdfIkehata_CNN-PS_CNN-based_Photometric_ECCV_2018_paper.pdfIlchae_Jung_Real-Time_MDNet_ECCV_2018_paper.pdfIsma_Hadji_A_New_Large_ECCV_2018_paper.pdfIssam_Hadj_Laradji_Where_are_the_ECCV_2018_paper.pdfIvan_Eichhardt_Affine_Correspondences_between_ECCV_2018_paper.pdfJacob_Huh_Fighting_Fake_News_ECCV_2018_paper.pdfJi_Zhu_Online_Multi-Object_Tracking_ECCV_2018_paper.pdfJiabei_Zeng_Facial_Expression_Recognition_ECCV_2018_paper.pdfJiafan_Zhuang_Towards_Human-Level_License_ECCV_2018_paper.pdfJiahui_Zhang_Efficient_Semantic_Scene_ECCV_2018_paper.pdfJiajun_Wu_Learning_3D_Shape_ECCV_2018_paper.pdfJialin_Wu_Dynamic_Sampling_Convolutional_ECCV_2018_paper.pdfJian_Wang_Programmable_Light_Curtains_ECCV_2018_paper.pdfJianbo_Jiao_Look_Deeper_into_ECCV_2018_paper.pdfJiangxin_Dong_Learning_Data_Terms_ECCV_2018_paper.pdfJianwei_Yang_Graph_R-CNN_for_ECCV_2018_paper.pdfJiawei_He_Probabilistic_Video_Generation_ECCV_2018_paper.pdfJiaxin_Chen_Deep_Cross-modality_Adaptation_ECCV_2018_paper.pdfJiayuan_Gu_Learning_Region_Features_ECCV_2018_paper.pdfJie_Guo_Single_Image_Highlight_ECCV_2018_paper.pdfJie_Liang_Sub-GAN_An_Unsupervised_ECCV_2018_paper.pdfJie_Song_Selective_Zero-Shot_Classification_ECCV_2018_paper.pdfJie_Yang_Seeing_Deeply_and_ECCV_2018_paper.pdfJie_Zhang_Geometric_Constrained_Joint_ECCV_2018_paper.pdfJieru_Mei_Online_Dictionary_Learning_ECCV_2018_paper.pdfJin-Dong_Dong_DPP-Net_Device-aware_Progressive_ECCV_2018_paper.pdfJin-Seok_Park_Double_JPEG_Detection_ECCV_2018_paper.pdfJingwei_Ji_End-to-End_Joint_Semantic_ECCV_2018_paper.pdfJingyi_Zhang_Generative_Domain-Migration_Hashing_ECCV_2018_paper.pdfJinkyu_Kim_Textual_Explanations_for_ECCV_2018_paper.pdfJinlong_YANG_Analyzing_Clothing_Layer_ECCV_2018_paper.pdfJiqing_Wu_Wasserstein_Divergence_For_ECCV_2018_paper.pdfJiren_Zhu_HiDDeN_Hiding_Data_ECCV_2018_paper.pdfJiuxiang_Gu_Unpaired_Image_Captioning_ECCV_2018_paper.pdfJiyang_Gao_CTAP_Complementary_Temporal_ECCV_2018_paper.pdfJiyang_Yu_Selfie_Video_Stabilization_ECCV_2018_paper.pdfJoel_Janai_Unsupervised_Learning_of_ECCV_2018_paper.pdfJohannes_Schoenberger_Learning_to_Fuse_ECCV_2018_paper.pdfJongbin_Ryu_DFT-based_Transformation_Invariant_ECCV_2018_paper.pdfJoseph_DeGol_Improved_Structure_from_ECCV_2018_paper.pdfJue_Wang_Learning_Discriminative_Video_ECCV_2018_paper.pdfJulieta_Martinez_LSQ_lower_runtime_ECCV_2018_paper.pdfJuncheng_Li_Multi-scale_Residual_Network_ECCV_2018_paper.pdfJunho_Jeon_Reconstruction-based_Pairwise_Depth_ECCV_2018_paper.pdfJunjie_Zhang_Goal-Oriented_Visual_Question_ECCV_2018_paper.pdfJunwu_Weng_Deformable_Pose_Traversal_ECCV_2018_paper.pdfJustin_Liang_End-to-End_Deep_Structured_ECCV_2018_paper.pdfJyh-Jing_Hwang_Adaptive_Affinity_Field_ECCV_2018_paper.pdfKai_Xu_LAPCSRA_Deep_Laplacian_ECCV_2018_paper.pdfKaicheng_Yu_Statistically-motivated_Second-order_Pooling_ECCV_2018_paper.pdfKaipeng_Zhang_Super-Identity_Convolutional_Neural_ECCV_2018_paper.pdfKaiyue_Lu_Deep_Texture_and_ECCV_2018_paper.pdfKaiyue_Pang_Deep_Factorised_Inverse-Sketching_ECCV_2018_paper.pdfKang_Pairwise_Relational_Networks_ECCV_2018_paper.pdfKarim_Ahmed_MaskConnect_Connectivity_Learning_ECCV_2018_paper.pdfKe_Gong_Instance-level_Human_Parsing_ECCV_2018_paper.pdfKe_LI_Universal_Sketch_Perceptual_ECCV_2018_paper.pdfKe_Zhang_Retrospective_Encoders_for_ECCV_2018_paper.pdfKeisuke_Tateno_Distortion-Aware_Convolutional_Filters_ECCV_2018_paper.pdfKeizo_Kato_Compositional_Learning_of_ECCV_2018_paper.pdfKejie_Li_Efficient_Dense_Point_ECCV_2018_paper.pdfKemal_Oksuz_Localization_Recall_Precision_ECCV_2018_paper.pdfKeren_Ye_ADVISE_Symbolism_and_ECCV_2018_paper.pdfKim_SAN_Learning_Relationship_ECCV_2018_paper.pdfKo_Nishino_Variable_Ring_Light_ECCV_2018_paper.pdfKohei_Uehara_Visual_Question_Generation_ECCV_2018_paper.pdfKonda_Reddy_Mopuri_Ask_Acquire_and_ECCV_2018_paper.pdfKonstantin_Shmelkov_How_good_is_ECCV_2018_paper.pdfKonstantinos-Nektarios_Lianos_VSO_Visual_Semantic_ECCV_2018_paper.pdfKripasindhu_Sarkar_Learning_3D_shapes_ECCV_2018_paper.pdfKrishna_Kumar_Singh_Transferring_Common-Sense_Knowledge_ECCV_2018_paper.pdfKuan-Chuan_Peng_Zero-Shot_Deep_Domain_ECCV_2018_paper.pdfKuang-Huei_Lee_Stacked_Cross_Attention_ECCV_2018_paper.pdfKuang-Jui_Hsu_Unsupervised_CNN-based_co-saliency_ECCV_2018_paper.pdfKuniaki_Saito_Adversarial_Open_Set_ECCV_2018_paper.pdfKyoungoh_Lee_Propagating_LSTM_3D_ECCV_2018_paper.pdfKyungmin_Kim_Multimodal_Dual_Attention_ECCV_2018_paper.pdfLai_Jiang_DeepVS_A_Deep_ECCV_2018_paper.pdfLan_Wang_PM-GANs_Discriminative_Representation_ECCV_2018_paper.pdfLawrence_Neal_Open_Set_Learning_ECCV_2018_paper.pdfLei_Chen_Part-Activated_Deep_Reinforcement_ECCV_2018_paper.pdfLei_Zhou_Learning_and_Matching_ECCV_2018_paper.pdfLei_Zhu_Bi-directional_Feature_Pyramid_ECCV_2018_paper.pdfLele_Chen_Lip_Movements_Generation_ECCV_2018_paper.pdfLequan_Yu_EC-Net_an_Edge-aware_ECCV_2018_paper.pdfLi_Jiang_GAL_Geometric_Adversarial_ECCV_2018_paper.pdfLiang-Chieh_Chen_Encoder-Decoder_with_Atrous_ECCV_2018_paper.pdfLiang_Generative_Semantic_Manipulation_ECCV_2018_paper.pdfLiang_Mi_Variational_Wasserstein_Clustering_ECCV_2018_paper.pdfLiangliang_Ren_Collaborative_Deep_Reinforcement_ECCV_2018_paper.pdfLiangliang_Ren_Deep_Reinforcement_Learning_ECCV_2018_paper.pdfLiangyan_Gui_Adversarial_Geometry-Aware_Human_ECCV_2018_paper.pdfLiangyan_Gui_Few-Shot_Human_Motion_ECCV_2018_paper.pdfLigeng_Zhu_Sparsely_Aggregated_Convolutional_ECCV_2018_paper.pdfLinchao_Zhu_Compound_Memory_Networks_ECCV_2018_paper.pdfLingjie_Zhu_Large_Scale_Urban_ECCV_2018_paper.pdfLingyu_Wei_Real-Time_Hair_Rendering_ECCV_2018_paper.pdfLior_Talker_Efficient_Sliding_Window_ECCV_2018_paper.pdfLior_Wolf_Estimating_the_Success_ECCV_2018_paper.pdfLipeng_Ke_Multi-Scale_Structure-Aware_Network_ECCV_2018_paper.pdfLiren_Chen_The_Devil_of_ECCV_2018_paper.pdfLisa_Anne_Hendricks_Grounding_Visual_Explanations_ECCV_2018_paper.pdfLisa_Anne_Hendricks_Women_also_Snowboard_ECCV_2018_paper.pdfLiuhao_Ge_Point-to-Point_Regression_PointNet_ECCV_2018_paper.pdfLixiong_Chen_Polarimetric_Three-View_Geometry_ECCV_2018_paper.pdfLluis_Gomez_Single_Shot_Scene_ECCV_2018_paper.pdfLong_Zhao_Learning_to_Forecast_ECCV_2018_paper.pdfLuona_Yang_Real-to-Virtual_Domain_Uni_ECCV_2018_paper.pdfMang_YE_Robust_Anchor_Embedding_ECCV_2018_paper.pdfMarc_Oliu_Folded_Recurrent_Neural_ECCV_2018_paper.pdfMaria_Klodt_Supervising_the_new_ECCV_2018_paper.pdfMarie-Morgane_Paumard_Image_Reassembly_Combining_ECCV_2018_paper.pdfMariya_Vasileva_Learning_Type-Aware_Embeddings_ECCV_2018_paper.pdfMarkus_Oberweger_Making_Deep_Heatmaps_ECCV_2018_paper.pdfMartin_Sundermeyer_Implicit_3D_Orientation_ECCV_2018_paper.pdfMartyushev_Self-Calibration_of_Cameras_ECCV_2018_paper.pdfMarzieh_Edraki_Generalized_Loss-Sensitive_Adversarial_ECCV_2018_paper.pdfMateusz_Malinowski_Learning_Visual_Question_ECCV_2018_paper.pdfMatheus_Gadelha_Multiresolution_Tree_Networks_ECCV_2018_paper.pdfMathieu_Garon_A_Framework_for_ECCV_2018_paper.pdfMathilde_Caron_Deep_Clustering_for_ECCV_2018_paper.pdfMatteo_Fabbri_Learning_to_Detect_ECCV_2018_paper.pdfMatthew_Trager_On_the_Solvability_ECCV_2018_paper.pdfMatthew_Trumble_Deep_Autoencoder_for_ECCV_2018_paper.pdfMatthias_Kummerer_Saliency_Benchmarking_Made_ECCV_2018_paper.pdfMatthias_Muller_TrackingNet_A_Large-Scale_ECCV_2018_paper.pdfMedhini_Gulganjalli_Narasimhan_Straight_to_the_ECCV_2018_paper.pdfMeiguang_Jin_Normalized_Blind_Deconvolution_ECCV_2018_paper.pdfMelih_Engin_DeepKSPD_Learning_Kernel-matrix-based_ECCV_2018_paper.pdfMeng_Tang_On_Regularized_Losses_ECCV_2018_paper.pdfMengshi_Qi_stagNet_An_Attentive_ECCV_2018_paper.pdfMeredith_Hu_Understanding_Perceptual_and_ECCV_2018_paper.pdfMian_Wei_Coded_Two-Bucket_Cameras_ECCV_2018_paper.pdfMichael_Moeller_Lifting_Layers_Analysis_ECCV_2018_paper.pdfMichal_Polic_Fast_and_Precise_ECCV_2018_paper.pdfMichelle_Guo_Focus_on_the_ECCV_2018_paper.pdfMichelle_Guo_Neural_Graph_Matching_ECCV_2018_paper.pdfMichitaka_Yoshida_Joint_optimization_for_ECCV_2018_paper.pdfMiika_Aittala_Burst_Image_Deblurring_ECCV_2018_paper.pdfMikael_Persson_Lambda_Twist_An_ECCV_2018_paper.pdfMing_Liang_Deep_Continuous_Fusion_ECCV_2018_paper.pdfMing_Sun_Multi-Attention_Multi-Class_Constraint_ECCV_2018_paper.pdfMingfei_Gao_C-WSL_Count-guided_Weakly_ECCV_2018_paper.pdfMinghao_Guo_Dual-Agent_Deep_Reinforcement_ECCV_2018_paper.pdfMingtao_Feng_3D_Face_Reconstruction_ECCV_2018_paper.pdfMingze_Xu_Joint_Person_Segmentation_ECCV_2018_paper.pdfMinho_Shim_Teaching_Machines_to_ECCV_2018_paper.pdfMinhyeok_Heo_Monocular_Depth_Estimation_ECCV_2018_paper.pdfMinjun_Li_Unsupervised_Image-to-Image_Translation_ECCV_2018_paper.pdfMinxian_Li_Unsupervised_Person_Re-identification_ECCV_2018_paper.pdfMir_Rayat_Imtiaz_Hossain_Exploiting_temporal_information_ECCV_2018_paper.pdfMohammad_Tavakolian_Deep_Discriminative_Model_ECCV_2018_paper.pdfMohammadreza_Zolfaghari_ECO_Efficient_Convolutional_ECCV_2018_paper.pdfMohammed_Fathy_Hierarchical_Metric_Learning_ECCV_2018_paper.pdfMohit_Gupta_A_Geometric_Perspective_ECCV_2018_paper.pdfMoitreya_Chatterjee_Diverse_and_Coherent_ECCV_2018_paper.pdfMostafa_Ibrahim_Hierarchical_Relational_Networks_ECCV_2018_paper.pdfMrigank_Rochan_Video_Summarization_Using_ECCV_2018_paper.pdfMuhammed_Kocabas_MultiPoseNet_Fast_Multi-Person_ECCV_2018_paper.pdfMyunggi_Lee_Motion_Feature_Network_ECCV_2018_paper.pdfNIKITA_DVORNIK_Modeling_Visual_Context_ECCV_2018_paper.pdfNIKOLAOS_ZIOULIS_OmniDepth_Dense_Depth_ECCV_2018_paper.pdfNaeha_Sharif_NNEval_Neural_Network_ECCV_2018_paper.pdfNamhyuk_Ahn_Fast_Accurate_and_ECCV_2018_paper.pdfNan_Yang_Deep_Virtual_Stereo_ECCV_2018_paper.pdfNanyang_Wang_Pixel2Mesh_Generating_3D_ECCV_2018_paper.pdfNatalia_Neverova_Two_Stream__ECCV_2018_paper.pdfNathan_Silberman_ExplainGAN_Model_Explanation_ECCV_2018_paper.pdfNavaneeth_Bodla_Semi-supervised_FusedGAN_for_ECCV_2018_paper.pdfNgoc-Trung_Tran_Generative_Adversarial_Autoencoder_ECCV_2018_paper.pdfNicholas_Rhinehart_R2P2_A_ReparameteRized_ECCV_2018_paper.pdfNiclas_Zeller_Scale-Awareness_of_Light_ECCV_2018_paper.pdfNikolaos_Karianakis_Reinforced_Temporal_Attention_ECCV_2018_paper.pdfNikolaos_Passalis_Learning_Deep_Representations_ECCV_2018_paper.pdfNikolaos_Sarafianos_Deep_Imbalanced_Attribute_ECCV_2018_paper.pdfNimisha_T_M_Unsupervised_Class-Specific_Deblurring_ECCV_2018_paper.pdfNing_Xu_YouTube-VOS_Sequence-to-Sequence_Video_ECCV_2018_paper.pdfNingning_Light-weight_CNN_Architecture_ECCV_2018_paper.pdfNuno_Garcia_Modality_Distillation_with_ECCV_2018_paper.pdfOliver_Groth_ShapeStacks_Learning_Vision-Based_ECCV_2018_paper.pdfOliver_Zendel_WildDash_-_Creating_ECCV_2018_paper.pdfOlivia_Wiles_X2Face_A_network_ECCV_2018_paper.pdfPanna_Felsen_Where_Will_They_ECCV_2018_paper.pdfParikshit_Sakurikar_Single_Image_Scene_ECCV_2018_paper.pdfPatrick_Follmann_D2S_Densely_Segmented_ECCV_2018_paper.pdfPatrick_Wieschollek_Separating_Reflection_and_ECCV_2018_paper.pdfPau_Rodriguez_Lopez_Attend_and_Rectify_ECCV_2018_paper.pdfPaul_Hongsuck_Seo_Attentive_Semantic_Alignment_ECCV_2018_paper.pdfPaul_Hongsuck_Seo_Enhancing_Image_Geolocalization_ECCV_2018_paper.pdfPauline_Luc_Predicting_Future_Instance_ECCV_2018_paper.pdfPedro_Miraldo_A_Minimal_Closed-Form_ECCV_2018_paper.pdfPei_Wang_Towards_Realistic_Predictors_ECCV_2018_paper.pdfPeiliang_LI_Stereo_Vision-based_Semantic_ECCV_2018_paper.pdfPeng_Tang_Weakly_Supervised_Region_ECCV_2018_paper.pdfPengfei_Zhang_Adding_Attentiveness_to_ECCV_2018_paper.pdfPengyuan_Lyu_Mask_TextSpotter_An_ECCV_2018_paper.pdfPierre_Stock_ConvNets_and_ImageNet_ECCV_2018_paper.pdfPiotr_Koniusz_Museum_Exhibit_Identification_ECCV_2018_paper.pdfPo-Yu_Huang_Efficient_Uncertainty_Estimation_ECCV_2018_paper.pdfPradeep_Kumar_Jayaraman_Quadtree_Convolutional_Neural_ECCV_2018_paper.pdfPyojin_Kim_Linear_RGB-D_SLAM_ECCV_2018_paper.pdfQi_Guo_Tackling_3D_ToF_ECCV_2018_paper.pdfQi_Ye_Occlusion-aware_Hand_Pose_ECCV_2018_paper.pdfQiang_Qiu_ForestHash_Semantic_Hashing_ECCV_2018_paper.pdfQianru_Sun_A_Hybrid_Model_ECCV_2018_paper.pdfQing_Li_VQA-E_Explaining_Elaborating_ECCV_2018_paper.pdfQinghao_Hu_Training_Binary_Weight_ECCV_2018_paper.pdfQingnan_Fan_Learning_to_Learn_ECCV_2018_paper.pdfQingqiu_Huang_Person_Search_in_ECCV_2018_paper.pdfQingyi_Tao_Zero-Annotation_Object_Detection_ECCV_2018_paper.pdfQixing_Huang_Joint_Map_and_ECCV_2018_paper.pdfQuanlong_Zheng_Task-driven_Webpage_Saliency_ECCV_2018_paper.pdfRAFAEL_FELIX_Multi-modal_Cycle-consistent_Generalized_ECCV_2018_paper.pdfRahaf_Aljundi_Memory_Aware_Synapses_ECCV_2018_paper.pdfRajendra_Nagar_Fast_and_Accurate_ECCV_2018_paper.pdfRajvi_Shah_View-graph_Selection_Framework_ECCV_2018_paper.pdfRameswar_Panda_Contemplating_Visual_Emotions_ECCV_2018_paper.pdfRamprasaath_Ramasamy_Selvaraju_Choose_Your_Neuron_ECCV_2018_paper.pdfRelja_Arandjelovic_Objects_that_Sound_ECCV_2018_paper.pdfRene_Ranftl_Deep_Fundamental_Matrix_ECCV_2018_paper.pdfRenjiao_Yi_Faces_as_Lighting_ECCV_2018_paper.pdfRex_Yue_Wu_BusterNet_Detecting_Copy-Move_ECCV_2018_paper.pdfRishabh_Dabral_Learning_3D_Human_ECCV_2018_paper.pdfRoberto_Valle_A_Deeply-initialized_Coarse-to-fine_ECCV_2018_paper.pdfRoey_Mechrez_The_Contextual_Loss_ECCV_2018_paper.pdfRohit_Pandey_Efficient_6-DoF_Tracking_ECCV_2018_paper.pdfRonald_Clark_Neural_Nonlinear_least_ECCV_2018_paper.pdfRonghang_Hu_Explainable_Neural_Computation_ECCV_2018_paper.pdfRui_Yu_Hard-Aware_Point-to-Set_Deep_ECCV_2018_paper.pdfRuochen_Fan_Associating_Inter-Image_Salient_ECCV_2018_paper.pdfRuohan_Gao_Learning_to_Separate_ECCV_2018_paper.pdfRuohan_Zhang_AGIL_Learning_Attention_ECCV_2018_paper.pdfRuoteng_Li_Robust_Optical_Flow_ECCV_2018_paper.pdfRuoxi_Deng_Learning_to_Predict_ECCV_2018_paper.pdfSEUNG_HYUN_LEE_Self-supervised_Knowledge_Distillation_ECCV_2018_paper.pdfSachin_Mehta_ESPNet_Efficient_Spatial_ECCV_2018_paper.pdfSafa_Cicek_SaaS_Speed_as_ECCV_2018_paper.pdfSafa_Messaoud_Structural_Consistency_and_ECCV_2018_paper.pdfSaihui_Hou_Progressive_Lifelong_Learning_ECCV_2018_paper.pdfSaining_Xie_Rethinking_Spatiotemporal_Feature_ECCV_2018_paper.pdfSameh_Khamis_StereoNet_Guided_Hierarchical_ECCV_2018_paper.pdfSamuel_Albanie_Learnable_PINs_Cross-Modal_ECCV_2018_paper.pdfSamuel_Albanie_Semi-convolutional_Operators_for_ECCV_2018_paper.pdfSamuel_Schulter_Learning_to_Look_ECCV_2018_paper.pdfSanghyun_Son_Clustering_Kernels_for_ECCV_2018_paper.pdfSanghyun_Woo_Convolutional_Block_Attention_ECCV_2018_paper.pdfSangryul_Jeon_PARN_Pyramidal_Affine_ECCV_2018_paper.pdfSanthosh_Kumar_Ramakrishnan_Sidekick_Policy_Learning_ECCV_2018_paper.pdfSantiago_Cadena_Diverse_feature_visualizations_ECCV_2018_paper.pdfSantiago_Cortes_ADVIO_An_Authentic_ECCV_2018_paper.pdfSasikiran_Yelamarthi_A_Zero-Shot_Framework_ECCV_2018_paper.pdfSatwik_Kottur_Visual_Coreference_Resolution_ECCV_2018_paper.pdfSebastian_Bullinger_3D_Vehicle_Trajectory_ECCV_2018_paper.pdfSekii_Pose_Proposal_Networks_ECCV_2018_paper.pdfSeong-Jin_Park_SRFeat_Single_Image_ECCV_2018_paper.pdfSeong_Tae_Kim_Facial_Dynamics_Interpreter_ECCV_2018_paper.pdfSeonwook_Park_Deep_Pictorial_Gaze_ECCV_2018_paper.pdfSergey_Prokudin_Deep_Directional_Statistics_ECCV_2018_paper.pdfSergio_Silva_License_Plate_Detection_ECCV_2018_paper.pdfSeung-Wook_Kim_Parallel_Feature_Pyramid_ECCV_2018_paper.pdfShangbang_Long_TextSnake_A_Flexible_ECCV_2018_paper.pdfShangzhe_Wu_Deep_High_Dynamic_ECCV_2018_paper.pdfShao-Hua_Sun_Multi-view_to_Novel_ECCV_2018_paper.pdfShaofei_Wang_Accelerating_Dynamic_Programs_ECCV_2018_paper.pdfSheng-Wei_Huang_AugGAN_Cross_Domain_ECCV_2018_paper.pdfSheng_Guo_CurriculumNet_Learning_from_ECCV_2018_paper.pdfShervin_Ardeshir_Integrating_Egocentric_Videos_ECCV_2018_paper.pdfShi_Chen_Boosted_Attention_Leveraging_ECCV_2018_paper.pdfShi_Yan_DDRNet_Depth_Map_ECCV_2018_paper.pdfShifeng_Zhang_Occlusion-aware_R-CNN_Detecting_ECCV_2018_paper.pdfShihao_Wu_Specular-to-Diffuse_Translation_for_ECCV_2018_paper.pdfShitala_Prasad_Using_Object_Information_ECCV_2018_paper.pdfShivanthan_Yohanandan_Saliency_Preservation_in_ECCV_2018_paper.pdfShiyao_Wang_Fully_Motion-Aware_Network_ECCV_2018_paper.pdfShuangjun_Liu_Inner_Space_Preserving_ECCV_2018_paper.pdfShubham_Tulsiani_Layer-structured_3D_Scene_ECCV_2018_paper.pdfShuhan_Chen_Reverse_Attention_for_ECCV_2018_paper.pdfSiddharth_Tourani_MPLP_Fast_Parallel_ECCV_2018_paper.pdfSifei_Liu_Switchable_Temporal_Propagation_ECCV_2018_paper.pdfSijia_Cai_Weakly-supervised_Video_Summarization_ECCV_2018_paper.pdfSimon_Hecker_Learning_to_Drive_ECCV_2018_paper.pdfSimon_Jenni_Deep_Bilevel_Learning_ECCV_2018_paper.pdfSimyung_Chang_Broadcasting_Convolutional_Network_ECCV_2018_paper.pdfSiqi_Liu_Remote_Photoplethysmography_Correspondence_ECCV_2018_paper.pdfSiqi_Yang_Using_LIP_to_ECCV_2018_paper.pdfSiyang_Li_Unsupervised_Video_Object_ECCV_2018_paper.pdfSiyeong_Lee_Deep_Recursive_HDRI_ECCV_2018_paper.pdfSiyuan_Huang_Monocular_Scene_Parsing_ECCV_2018_paper.pdfSiyuan_Qi_Learning_Human-Object_Interactions_ECCV_2018_paper.pdfSiyuan_Qiao_Deep_Co-Training_for_ECCV_2018_paper.pdfSizhuo_3D_Motion_Sensing_ECCV_2018_paper.pdfSlawomir_Bak_Domain_Adaptation_through_ECCV_2018_paper.pdfSongtao_Liu_Receptive_Field_Block_ECCV_2018_paper.pdfSouYoung_Jin_Unsupervised_Hard-Negative_Mining_ECCV_2018_paper.pdfSteffen_Wolf_The_Mutex_Watershed_ECCV_2018_paper.pdfStephane_Lathuiliere_DeepGUM_Learning_Deep_ECCV_2018_paper.pdfSujoy_Paul_W-TALC_Weakly-supervised_Temporal_ECCV_2018_paper.pdfSunghun_Kang_Pivot_Correlational_Neural_ECCV_2018_paper.pdfT_M_Feroz_Ali_Maximum_Margin_Metric_ECCV_2018_paper.pdfTae-Hyun_Oh_Learning-based_Video_Motion_ECCV_2018_paper.pdfTae_Hyun_Kim_Spatio-temporal_Transformer_Network_ECCV_2018_paper.pdfTaihong_Xiao_ELEGANT_Exchanging_Latent_ECCV_2018_paper.pdfTal_Remez_Learning_to_Segment_ECCV_2018_paper.pdfTan_Yu_Product_Quantization_Network_ECCV_2018_paper.pdfTanmay_Gupta_Imagine_This_Scripts_ECCV_2018_paper.pdfTao_Kong_Deep_Feature_Pyramid_ECCV_2018_paper.pdfTao_Song_Small-scale_Pedestrian_Detection_ECCV_2018_paper.pdfTat-Jun_Chin_Robust_fitting_in_ECCV_2018_paper.pdfTete_Xiao_Unified_Perceptual_Parsing_ECCV_2018_paper.pdfThemos_Stafylakis_Zero-shot_keyword_search_ECCV_2018_paper.pdfThibault_Groueix_Shape_correspondences_from_ECCV_2018_paper.pdfThomas_Holzmann_Semantically_Aware_Urban_ECCV_2018_paper.pdfThomas_Probst_Incremental_Non-Rigid_Structure-from-Motion_ECCV_2018_paper.pdfThomas_Probst_Model-free_Consensus_Maximization_ECCV_2018_paper.pdfThomas_Robert_HybridNet_Classification_and_ECCV_2018_paper.pdfTian_Feng_Urban_Zoning_Using_ECCV_2018_paper.pdfTian_Ye_Interpretable_Intuitive_Physics_ECCV_2018_paper.pdfTianfan_Xue_Seeing_Tree_Structure_ECCV_2018_paper.pdfTianlang_Chen_Factual_or_Emotional_ECCV_2018_paper.pdfTianshu_Yu_Incremental_Multi-graph_Matching_ECCV_2018_paper.pdfTianwei_Lin_BSN_Boundary_Sensitive_ECCV_2018_paper.pdfTianyu_Yang_Learning_Dynamic_Memory_ECCV_2018_paper.pdfTianyun_Zhang_A_Systematic_DNN_ECCV_2018_paper.pdfTien-Ju_Yang_NetAdapt_Platform-Aware_Neural_ECCV_2018_paper.pdfTimo_von_Marcard_Recovering_Accurate_3D_ECCV_2018_paper.pdfTing_Yao_Exploring_Visual_Relationship_ECCV_2018_paper.pdfTobias_Fischer_RT-GENE_Real-Time_Eye_ECCV_2018_paper.pdfTolga_Birdal_PPF-FoldNet_Unsupervised_Learning_ECCV_2018_paper.pdfTomas_Hodan_PESTO_6D_Object_ECCV_2018_paper.pdfTrung_Pham_Bayesian_Instance_Segmentation_ECCV_2018_paper.pdfTsung-Yu_Lin_Second-order_Democratic_Aggregation_ECCV_2018_paper.pdfTushar_Nagarajan_Attributes_as_Operators_ECCV_2018_paper.pdfTz-Ying_Wu_Liquid_Pouring_Monitoring_ECCV_2018_paper.pdfUmar_Iqbal_Hand_Pose_Estimation_ECCV_2018_paper.pdfUta_Buchler_Improving_Spatiotemporal_Self-Supervision_ECCV_2018_paper.pdfVarun_Jampani_Superpixel_Sampling_Networks_ECCV_2018_paper.pdf\nVassileios_Balntas_RelocNet_Continous_Metric_ECCV_2018_paper.pdfVincent_Leroy_Shape_Reconstruction_Using_ECCV_2018_paper.pdfViorica_Patraucean_Massively_Parallel_Video_ECCV_2018_paper.pdfViresh_Ranjan_Iterative_Crowd_Counting_ECCV_2018_paper.pdfVivek_B_S_Gray_box_adversarial_ECCV_2018_paper.pdfWayne_Wu_Learning_to_Reenact_ECCV_2018_paper.pdfWei-Chih_Hung_Learning_to_Blend_ECCV_2018_paper.pdfWei-Chiu_Single_Image_Intrinsic_ECCV_2018_paper.pdfWei-Sheng_Lai_Real-Time_Blind_Video_ECCV_2018_paper.pdfWei_Dong_Probabilistic_Signed_Distance_ECCV_2018_paper.pdfWei_Liu_Learning_Efficient_Single-stage_ECCV_2018_paper.pdfWei_Tang_Deeply_Learned_Compositional_ECCV_2018_paper.pdfWeidi_Xie_Comparator_Networks_ECCV_2018_paper.pdfWeiwei_Shi_Transductive_Semi-Supervised_Deep_ECCV_2018_paper.pdfWeixuan_Chen_DeepPhys_Video-Based_Physiological_ECCV_2018_paper.pdfWeiyue_Wang_Depth-aware_CNN_for_ECCV_2018_paper.pdfWenhao_Jiang_Recurrent_Fusion_Network_ECCV_2018_paper.pdfWenqian_Liu_DYAN_A_Dynamical_ECCV_2018_paper.pdfWenqiang_Xu_SRDA_Generating_Instance_ECCV_2018_paper.pdfWonmin_Byeon_ContextVP_Fully_Context-Aware_ECCV_2018_paper.pdfWonsik_Kim_Attention-based_Ensemble_for_ECCV_2018_paper.pdfWoojae_Kim_Deep_Video_Quality_ECCV_2018_paper.pdfXU_JUN_A_Trilateral_Weighted_ECCV_2018_paper.pdfXU_YANG_Shuffle-Then-Assemble_Learning_Object-Agnostic_ECCV_2018_paper.pdfXi_Zhang_Attention-aware_Deep_Adversarial_ECCV_2018_paper.pdfXia_Li_Recurrent_Squeeze-and-Excitation_Context_ECCV_2018_paper.pdfXiang_Li_Adversarial_Open-World_Person_ECCV_2018_paper.pdfXiangyu_He_Learning_Compression_from_ECCV_2018_paper.pdfXiangyu_Xu_Rendering_Portraitures_from_ECCV_2018_paper.pdfXiangyun_Zhao_A_Modulation_Module_ECCV_2018_paper.pdfXiankai_Lu_Deep_Regression_Tracking_ECCV_2018_paper.pdfXiao_Sun_Integral_Human_Pose_ECCV_2018_paper.pdfXiaodan_Liang_CIRL_Controllable_Imitative_ECCV_2018_paper.pdfXiaofeng_Han_Single_Image_Water_ECCV_2018_paper.pdfXiaofeng_Liu_Dependency-aware_Attention_Control_ECCV_2018_paper.pdfXiaohan_Fei_Visual-Inertial_Object_Detection_ECCV_2018_paper.pdfXiaohang_Zhan_Consensus-Driven_Propagation_in_ECCV_2018_paper.pdfXiaojun_Chang_RCAA_Relational_Context-Aware_ECCV_2018_paper.pdfXiaokun_Wu_HandMap_Robust_Hand_ECCV_2018_paper.pdfXiaolin_Zhang_Self-produced_Guidance_for_ECCV_2018_paper.pdfXiaolong_Wang_Videos_as_Space-Time_ECCV_2018_paper.pdfXiaoming_Li_Learning_Warped_Guidance_ECCV_2018_paper.pdfXiaopeng_Zhang_ML-LocNet_Improving_Object_ECCV_2018_paper.pdfXiaoqing_Ye_3D_Recurrent_Neural_ECCV_2018_paper.pdfXiaoqing_Yin_FishEyeRecNet_A_Multi-Context_ECCV_2018_paper.pdfXiaoxiao_Li_Video_Object_Segmentation_ECCV_2018_paper.pdfXiaoyang_Guo_Learning_Monocular_Depth_ECCV_2018_paper.pdf\nXihui_Liu_Show_Tell_and_ECCV_2018_paper.pdfXin_Li_Contour_Knowledge_Transfer_ECCV_2018_paper.pdfXin_Wang_Look_Before_You_ECCV_2018_paper.pdfXin_Wang_SkipNet_Learning_Dynamic_ECCV_2018_paper.pdfXin_Yu_Face_Super-resolution_Guided_ECCV_2018_paper.pdfXin_Yuan_Towards_Optimal_Deep_ECCV_2018_paper.pdfXinchen_Yan_Generating_Multimodal_Human_ECCV_2018_paper.pdfXing_Wei_Grassmann_Pooling_for_ECCV_2018_paper.pdfXingang_Pan_Two_at_Once_ECCV_2018_paper.pdfXinge_Zhu_Penalizing_Top_Performers_ECCV_2018_paper.pdfXingping_Dong_Triplet_Loss_with_ECCV_2018_paper.pdfXingyi_Zhou_Category-Agnostic_Semantic_Keypoint_ECCV_2018_paper.pdfXingyi_Zhou_Unsupervised_Domain_Adaptation_ECCV_2018_paper.pdfXinjing_Cheng_Depth_Estimation_via_ECCV_2018_paper.pdfXinkun_Cao_Scale_Aggregation_Network_ECCV_2018_paper.pdfXinyu_Gong_Neural_Stereoscopic_Image_ECCV_2018_paper.pdfXinyuan_Chen_Attention-GAN_for_Object_ECCV_2018_paper.pdfXiyu_Yu_Learning_with_Biased_ECCV_2018_paper.pdfXu_Lan_Person_Search_by_ECCV_2018_paper.pdfXu_Tang_PyramidBox_A_Context-assisted_ECCV_2018_paper.pdfXuan_Chen_Focus_Segment_and_ECCV_2018_paper.pdfXuanqing_Liu_Towards_Robust_Neural_ECCV_2018_paper.pdfXuanyu_Zhu_Quaternion_Convolutional_Neural_ECCV_2018_paper.pdfXudong_Lin_Deep_Variational_Metric_ECCV_2018_paper.pdfXuecheng_Nie_Mutual_Learning_to_ECCV_2018_paper.pdfXuecheng_Nie_Pose_Partition_Networks_ECCV_2018_paper.pdfXuelin_Qian_Pose-Normalized_Image_Generation_ECCV_2018_paper.pdfXun_Huang_Multimodal_Unsupervised_Image-to-image_ECCV_2018_paper.pdfYa_Li_Deep_Domain_Generalization_ECCV_2018_paper.pdfYabin_Zhang_Fine-Grained_Visual_Categorization_ECCV_2018_paper.pdfYagiz_Aksoy_A_Dataset_of_ECCV_2018_paper.pdfYalong_Bai_Deep_Attention_Neural_ECCV_2018_paper.pdfYan-Pei_Cao_Learning_to_Reconstruct_ECCV_2018_paper.pdfYan_Wang_Spatial_Pyramid_Calibration_ECCV_2018_paper.pdfYanbei_Chen_Semi-Supervised_Deep_Learning_ECCV_2018_paper.pdfYanchao_Yang_Conditional_Prior_Networks_ECCV_2018_paper.pdfYandong_Li_How_Local_is_ECCV_2018_paper.pdfYang_Du_Interaction-aware_Spatio-temporal_Pyramid_ECCV_2018_paper.pdfYang_Feng_Video_Re-localization_via_ECCV_2018_paper.pdfYang_He_Diverse_Conditional_Image_ECCV_2018_paper.pdfYang_Liu_Synthetically_Supervised_Feature_ECCV_2018_paper.pdfYang_Shen_Egocentric_Activity_Prediction_ECCV_2018_paper.pdf\nYang_Shi_Question_Type_Guided_ECCV_2018_paper.pdfYang_Zou_Unsupervised_Domain_Adaptation_ECCV_2018_paper.pdfYangyu_Chen_Less_is_More_ECCV_2018_paper.pdfYantao_Shen_Person_Re-identification_with_ECCV_2018_paper.pdfYanting_Pei_Does_Haze_Removal_ECCV_2018_paper.pdfYao_Feng_Joint_3D_Face_ECCV_2018_paper.pdfYao_Yao_MVSNet_Depth_Inference_ECCV_2018_paper.pdfYaojie_Liu_Face_De-spoofing_ECCV_2018_paper.pdfYapeng_Tian_Audio-Visual_Event_Localization_ECCV_2018_paper.pdfYasutaka_Inagaki_Learning_to_Capture_ECCV_2018_paper.pdfYawei_Luo_Macro-Micro_Adversarial_Network_ECCV_2018_paper.pdfYe_Yuan_3D_Ego-Pose_Estimation_ECCV_2018_paper.pdfYedid_Hoshen_Separable_Cross-Domain_Translation_ECCV_2018_paper.pdfYeong_Jun_Koh_Sequential_Clique_Optimization_ECCV_2018_paper.pdfYi_Li_DeepIM_Deep_Iterative_ECCV_2018_paper.pdfYi_Wei_Quantization_Mimic_Towards_ECCV_2018_paper.pdfYi_Zhou_Semi-Dense_3D_Reconstruction_ECCV_2018_paper.pdfYi_Zhou_Single-view_Hair_Reconstruction_ECCV_2018_paper.pdf\nYidan_Zhou_HBE_Hand_Branch_ECCV_2018_paper.pdfYiding_Liu_Affinity_Derivation_and_ECCV_2018_paper.pdfYifan_Sun_Beyond_Part_Models_ECCV_2018_paper.pdfYifan_Xu_SpiderCNN_Deep_Learning_ECCV_2018_paper.pdfYifei_Shi_PlaneMatch_Patch_Coplanarity_ECCV_2018_paper.pdfYihua_Cheng_Appearance-Based_Gaze_Estimation_ECCV_2018_paper.pdfYihui_He_AMC_Automated_Model_ECCV_2018_paper.pdfYijun_Li_A_Closed-form_Solution_ECCV_2018_paper.pdfYijun_Li_Flow-Grounded_Spatial-Temporal_Video_ECCV_2018_paper.pdfYikang_LI_Factorizable_Net_An_ECCV_2018_paper.pdfYilei_Xiong_Move_Forward_and_ECCV_2018_paper.pdfYiming_Qian_Simultaneous_3D_Reconstruction_ECCV_2018_paper.pdfYin_Li_In_the_Eye_ECCV_2018_paper.pdfYin_Xia_Fictitious_GAN_Training_ECCV_2018_paper.pdfYinda_Zhang_Active_Stereo_Net_ECCV_2018_paper.pdfYing_Fu_Joint_Camera_Spectral_ECCV_2018_paper.pdfYing_Zhang_Deep_Cross-Modal_Projection_ECCV_2018_paper.pdfYingjie_Yao_Joint_Representation_and_ECCV_2018_paper.pdf\nYingwei_Li_RESOUND_Towards_Action_ECCV_2018_paper.pdfYinlong_Liu_Efficient_Global_Point_ECCV_2018_paper.pdfYipu_Zhao_Good_Line_Cutting_ECCV_2018_paper.pdfYiran_Zhong_Open-World_Stereo_Video_ECCV_2018_paper.pdfYiran_Zhong_Stereo_Computation_for_ECCV_2018_paper.pdfYiru_Zhao_A_Principled_Approach_ECCV_2018_paper.pdfYizhen_Lao_Rolling_Shutter_Pose_ECCV_2018_paper.pdfYongcheng_Jing_Stroke_Controllable_Fast_ECCV_2018_paper.pdfYonggen_Ling_Modeling_Varying_Camera-IMU_ECCV_2018_paper.pdf\nYongqiang_Zhang_SOD-MTGAN_Small_Object_ECCV_2018_paper.pdfYongyi_Lu_Attribute-Guided_Face_Generation_ECCV_2018_paper.pdfYongyi_Lu_Image_Generation_from_ECCV_2018_paper.pdfYoungjae_Yu_A_Joint_Sequence_ECCV_2018_paper.pdfYu-Ting_Chen_Leveraging_Motion_Priors_ECCV_2018_paper.pdfYuKang_Gan_Monocular_Depth_Estimation_ECCV_2018_paper.pdfYu_Liu_Transductive_Centroid_Projection_ECCV_2018_paper.pdfYuan-Ting_Hu_Unsupervised_Video_Object_ECCV_2018_paper.pdfYuan-Ting_Hu_VideoMatch_Matching_based_ECCV_2018_paper.pdfYue_Cao_Cross-Modal_Hamming_Hashing_ECCV_2018_paper.pdfYufei_Wang_ConceptMask_Large-Scale_Segmentation_ECCV_2018_paper.pdf\nYuge_Shi_Action_Anticipation_with_ECCV_2018_paper.pdfYuhang_Liu_Deblurring_Natural_Image_ECCV_2018_paper.pdfYuhang_Song_Contextual_Based_Image_ECCV_2018_paper.pdfYujun_Cai_Weakly-supervised_3D_Hand_ECCV_2018_paper.pdfYuliang_Zou_DF-Net_Unsupervised_Joint_ECCV_2018_paper.pdfYulun_Zhang_Image_Super-Resolution_Using_ECCV_2018_paper.pdfYumin_Suh_Part-Aligned_Bilinear_Representations_ECCV_2018_paper.pdfYunchao_Wei_TS2C_Tight_Box_ECCV_2018_paper.pdf\nYunhua_Zhang_Structured_Siamese_Network_ECCV_2018_paper.pdfYunlong_Wang_End-to-end_View_Synthesis_ECCV_2018_paper.pdfYunpeng_Chen_Fast_Multi-fiber_Network_ECCV_2018_paper.pdfYuta_Asano_Coded_Illumination_and_ECCV_2018_paper.pdf\nYuxin_Wu_Group_Normalization_ECCV_2018_paper.pdfZe_Yang_Learning_to_Navigate_ECCV_2018_paper.pdfZehao_Huang_Data-Driven_Sparse_Structure_ECCV_2018_paper.pdfZelun_Luo_Graph_Distillation_for_ECCV_2018_paper.pdfZeming_Li_DetNet_Design_Backbone_ECCV_2018_paper.pdfZeng_Huang_Deep_Volumetric_Video_ECCV_2018_paper.pdfZerong_Zheng_HybridFusion_Real-Time_Performance_ECCV_2018_paper.pdfZhangjie_Cao_Partial_Adversarial_Domain_ECCV_2018_paper.pdfZhao_Chen_Estimating_Depth_from_ECCV_2018_paper.pdf\nZhaoyang_Lv_Learning_Rigidity_in_ECCV_2018_paper.pdfZhaoyi_Yan_Shift-Net_Image_Inpainting_ECCV_2018_paper.pdfZhe_Chen_Context_Refinement_for_ECCV_2018_paper.pdfZhenbo_Xu_Towards_End-to-End_License_ECCV_2018_paper.pdfZhenfeng_Fan_Dense_Semantic_and_ECCV_2018_paper.pdfZheng_Dang_Eigendecomposition-free_Training_of_ECCV_2018_paper.pdfZheng_Shou_AutoLoc_Weakly-supervised_Temporal_ECCV_2018_paper.pdf\nZheng_Shou_Online_Detection_of_ECCV_2018_paper.pdfZheng_Zhang_Highly-Economized_Multi-View_Binary_ECCV_2018_paper.pdfZheng_Zhu_Distractor-aware_Siamese_Networks_ECCV_2018_paper.pdfZhengming_Ding_Graph_Adaptive_Knowledge_ECCV_2018_paper.pdfZhengqi_Li_CGIntrinsics_Better_Intrinsic_ECCV_2018_paper.pdfZhengqin_Li_Materials_for_Masses_ECCV_2018_paper.pdfZhenli_Zhang_ExFuse_Enhancing_Feature_ECCV_2018_paper.pdfZhenyu_Wu_Towards_Privacy-Preserving_Visual_ECCV_2018_paper.pdfZhenyu_Zhang_Joint_Task-Recursive_Learning_ECCV_2018_paper.pdf\nZhiding_Yu_SEAL_A_Framework_ECCV_2018_paper.pdfZhijian_Liu_Physical_Primitive_Decomposition_ECCV_2018_paper.pdfZhipeng_Cai_Deterministic_Consensus_Maximization_ECCV_2018_paper.pdfZhiqiang_Tang_Quantized_Densely_Connected_ECCV_2018_paper.pdfZhirong_Wu_Improving_Embedding_Generalization_ECCV_2018_paper.pdfZhiwen_Fan_A_Segmentation-aware_Deep_ECCV_2018_paper.pdf\nZhiwen_Shao_Deep_Adaptive_Attention_ECCV_2018_paper.pdf\nZhixin_Shu_Deforming_Autoencoders_Unsupervised_ECCV_2018_paper.pdfZhongzheng_Ren_Learning_to_Anonymize_ECCV_2018_paper.pdfZhou_GridFace_Face_Rectification_ECCV_2018_paper.pdfZhun_Zhong_Generalizing_A_Person_ECCV_2018_paper.pdfZi_Jian_Yew_3DFeat-Net_Weakly_Supervised_ECCV_2018_paper.pdfZihang_Meng_Efficient_Relative_Attribute_ECCV_2018_paper.pdfZiheng_Zhang_Saliency_Detection_in_ECCV_2018_paper.pdfZixin_Luo_Learning_Local_Descriptors_ECCV_2018_paper.pdfZorah_Laehner_DeepWrinkles_Accurate_and_ECCV_2018_paper.pdfZuxuan_Wu_DCAN_Dual_Channel-wise_ECCV_2018_paper.pdfgao_peng_Question-Guided_Hybrid_Convolution_ECCV_2018_paper.pdfmengdan_zhang_Visual_Tracking_via_ECCV_2018_paper.pdfshaifali_parashar_Self-Calibrating_Isometric__ECCV_2018_paper.pdfshi_jin_Learning_to_Dodge_ECCV_2018_paper.pdfyaxing_wang_Transferring_GANs_generating_ECCV_2018_paper.pdfyitong_wang_Orthogonal_Deep_Features_ECCV_2018_paper.pdfzechun_liu_Bi-Real_Net_Enhancing_ECCV_2018_paper.pdf\n","categories":["图像处理与机器学习"],"tags":["机器学习","ECCV"]},{"title":"论文精读与分析：Inception V1:Going Deeper with Convolution","url":"https://tanqingbo.cn/Inception-Going-Deeper-with-Convolution/","content":"Abstract我们提出了一种名为 Inception 的深度卷积网络结构，它在 ILSVRC14 的分类和检测任务上达到了 SOTA 的效果。这个网络的特征是他提升了网络内部计算资源的利用率。通过精细的设计，我们在提升了网络的宽度和深度的同时保持了计算量不变。为了提升网络输出的质量，网络结构的决策是基于 Hebbian 原则和多尺度处理的直观性。在我们提交的 ILSVRC14 中，有一个特殊的体现被称为“谷歌网”，它是一个22层深的网络，其效果是在分类和检测的背景下进行评估的。\n1. Introduction神经网络和深度学习在目标分类和检测上效果的提升，不仅仅是因为更强大的计算硬件，更大的数据机和更大的模型，也是 idaes ，算法和改进的网络结构的结果。一个证明这种结论的实例是，在 ILSVRC14 中，我们所使用的网络的参数量比 ILSVRC12 最好的结果少 12 倍，并且准确率显著的提升，并且这两年的数据是相同的。在目标检测方面，最大的收益不是来源于越来越大的深层网络结构的简单应用，而是来自于深层网络结构和经典计算机视觉的协同作用，比如说 R-CNN。\n随着手机和嵌入式设备的普及，我们算法的效率，特别是功耗和内存的使用变得越发重要。我们在设计这个网络的时候不仅仅考虑一个好的指标，也考虑了算法的效率。对于大多数的实验，我们将计算量控制在 15 亿次乘加计算，它们就不会纯粹是学术上的好奇心，而是可以以合理的成本投入到现实世界中，即使是在大型数据集上。\n作者书写这段的逻辑是，理论上一个好的网络在是怎样的，在实际应用上的需求是怎样的。而我们设计的网络怎么怎么好，正好满足了这个需求。\n2. Related Work从 LeNet-5 开始，卷积神经网络开始具有了一种典型的网络结构：叠加的卷积层，之后跟着归一化和最大池化。针对处理如 ImageNet 等更大的数据集，最近（2015年之前）的一个趋势是增加层的个数与层的尺寸，同时使用 dropout 来解决过拟合的问题。\n受到了灵长类视觉皮层神经元模型的启发， Serre 等人使用了一系列不同尺寸的固定的 Gabor 滤波器来解决多尺度的问题。我们使用了类似的策略，没有使用固定的参数，在 Inception 模块中，所有的参数都是可以学习的。\nNetwork-in-Network 是 Lin 等人提出的，用于增强网络表示能力的一种方法。在它们的模型中，网络中增加了额外的 1×1 1 \\times 11×1 的卷积，用以增加网络的深度。我们在我们的网络中重度使用这种方法。然而，在我们的设定中， 1×1 1 \\times 11×1 的卷积有着双重目标：最重要的，它们主要被用来作为降维的方法，以去除计算瓶颈，否则的话将会限制我们网络的尺寸。这样不仅可以增加网络的深度，还可以增加网络的宽度，而不会造成显著的性能损失。\n最后，目前（2015年）目标检测的 SOTA 是 Girshick 等人提出的 R-CNN。R-CNN将整个检测问题分解为两个子问题：利用颜色和纹理等低级线索以类别不可知的方式生成对象位置建议，并使用CNN分类器在这些位置识别对象类别。这种两阶段的方法利用了低水平线索边界框分割的准确性，以及先进CNN的强大分类能力。我们在检测提交中采用了类似的方法，但在这两个阶段都进行了改进，例如针对更高对象边界框调用的多框[5]预测，以及用于更好地分类边界框建议的集成方法。\n作者的相关工作的覆盖面，不仅仅很广， 而且在每一个部分分别指出了与自己的论文中工作的相关性，就是几乎没有废话，真的是大佬的文章，不佩服不行！\n3. Motivation and High Level Considerations提升深度学习网络性能的直接了当的方法是增加它的尺寸。它包括增加他的深度（神经网络的层数）以及他的宽度（每一层神经元的个数）。这是训练一个效果更好的网络的一种简单安全的方法，特别是当大量的已标注的数据是可以获得时候。然而这种简单的解决方法会带来两个缺点：\n更大的尺寸常常意味着更大的数量的参数量，这会增大神经网络过拟合的可能，尤其当带有标签的训练集是有限的时候。这是一个主要的瓶颈，因为获得标注好的数据是很吃力并且昂贵的，通常需要专业的人工评分员来区分不同的细粒度视觉类别，如图1所示的ImageNet（甚至是1000级ILSVRC子集）中的视觉类别。\n\n另一个缺点是均匀增加的网络尺寸会急剧的增加计算资源的使用量。例如在一个深度视觉神经网络中，如果两个卷积层是链式的，任何滤波器数量均匀的增长都会导致计算量的翻倍增长。如果加法的能力使用不当（例如大部分的权重都接近于0），会导致大量的计算资源的浪费。因为计算资源总是有限的，所以即使当主要的目标是提升模型的效果，一个有效的计算资源分布也是要好于不加选择的增加网络的尺寸。\n解决上面两个缺点的一个基本的方法是引入稀疏性，用稀疏的全连接层，替代普通的全连接层，甚至是在卷积的内部使用稀疏。包括模拟生物系统在内，因为 Arora 等人突破性的工作，这将胜过更严格的理论基础。它们的主要结论是如果一个数据集的概率分布是可以通过一个大的，非常稀疏的深度神经网络所表示，那么可以通过分析前一层激活的相关统计数据和具有高度相关输出的神经元聚类数据，构造出一个又一个最优的网络拓扑结构。虽然严格的数学证明需要非常强的假设，但事实上这个与著名的赫布原则（神经元激活在一起，连接在一起）产生了共鸣，意味着在实际中即使在不太严格的条件下其基本思想也是可以接受的。这也意味着确实存在这样的神经网络，并且从神经科学上可以找到一些依据，想表达的就是稀疏确实有用。\n然而不幸的是，如今（2015年）的运算基础架构在处理非均匀稀疏结构的数值运算时是效率低下的。即使（稀疏的表示使得）算术运算的数目减少了100 倍，查找和缓存未命中的开销将占主导地位：切换到稀疏矩阵可能没有回报。通过使用稳定改进和高度调整的计算库，允许极快的密集矩阵乘法，利用底层CPU或GPU硬件的微小细节，进一步扩大了差距（因为加速，所以密集型矩阵乘法变得更快了）。并且，非均匀的稀疏模型需要更复杂的工程和计算基础架构。最近的面向视觉的机器学习系统大多利用卷积来利用空间的稀疏性。然而，卷积是作为到早期层 patches 的密集连接的集合实现的。自[11]以来，convnets一直使用特征维度中的随机和稀疏连接表来打破对称性并改进学习，但为了进一步优化并行计算，趋势又变回了与[9]的完全连接。现在的 SOTA 的视觉网络结构有着对称的结构。大量的滤波器和更大的 batch size 允许更为高效的使用密集型计算。\n这引出了一个问题，是否存在这进行下一步的希望，一种折中的方法：如理论所建议的那样，使用这样的一种网络架构，他可以利用滤波器级别的稀疏能力，但利用我们目前的硬件，利用密集矩阵的计算。大量在稀疏矩阵计算上的文章建议，将稀疏矩阵聚类为相对密集的子矩阵，有助于获得稀疏矩阵乘法的竞争性能。认为在不久的将来，类似的方法将被用于非均匀深度学习体系结构的自动构建似乎并不牵强。\nInception 网络结构最初是一个案例研究，用于评估复杂网络拓扑结构构建算法的假设输出，该算法试图近似视觉网络的[2]所暗示的稀疏结构，并通过密集的、随时可用的组件覆盖假设结果。尽管这是一个高度投机的项目，但与基于[12]的参考网络相比，早期观察到了适度的收益。经过一点调整，差距变大了，并且事实证明在定位和检测的情况下，以 Inception 作为基础的网络结构尤其有用。有趣的是，虽然大多数最初的体系结构选择已经被分离地进行了彻底的质疑和测试，但结果证明它们接近于局部最优。有一个问题必须仔细的思考：虽然 Inception 在计算机视觉中获得了成功，但是是否可以归因为其构建的指导原则仍是一个疑问。确保这一点需要更彻底的分析和验证。\n实际上这部分就是在陈述构建 Inception 结构的动机，简单的增加神经网络的尺寸会引起两个缺点：过拟合与计算量过大，解决这个问题一个较好的方式是使用稀疏的网络结构，并且从赫本原理的角度说明了可行性。然而一方面现有的计算基础架构使得稀疏的计算效率低下；另一方面，通过使用随机和稀疏连接的方式又使得网络有变回全连接的趋势。所以作者剔除了这种折衷的方式，使用这样的一种网络架构，他可以利用滤波器级别的稀疏能力，但利用我们目前的硬件，利用密集矩阵的计算，即 Inception。\n4. Architectural DetailsInception 结构的主要想法在于考虑一个卷积视觉神经网络的最优局部稀疏结构是如何被现成的密集组件来近似和覆盖。值得注意的是，假设平移不变性意味着我们的网络将由卷积积木构建。 所有的我们所需要做的是找到最优的局部组织并在空间上重复它。 Arora 等人提出了一种逐层的构造方法，在这种方法中，应分析最后一层的相关统计数据，并将其聚类成具有高相关性的单元组。 这些簇构成下一层的单元，并连接到上一层的单元。我们假设来自早期层的每个单元对应于输入图像的某个区域，并且这些单元被分组到过滤器组中。 在较低层（靠近输入层）中，相关单元将集中在局部区域。因此，我们将以集中在单个区域的许多簇结束，并且它们可以被下一层1×1卷积的层覆盖，如[12]所示。然而，我们也可以预期，在更大的 patch 上，可以被卷积覆盖的更多空间分布的集群数量将会减少，在更大的区域，patch 数量也会减少。 为了避免块对齐的问题，现在的 Inception 网络结构的实现使用 1×1 1\\times11×1，3×3 3\\times33×3，5×5 5\\times55×5 尺寸大小的卷积核，这种决定是因为方便操作，而不是必须的。这也意味着，建议的架构是所有这些层与它们的输出滤波器组的组合，这些滤波器组连接成一个单独的输出向量，形成下一阶段的输入。 此外，由于池操作对于当前卷积网络的成功至关重要，因此它建议在每个这样的阶段添加所有外部池路径也应具有额外的效益，如图 2 (a) 所示\n\n由于这些“初始模块”相互堆叠在一起，它们的输出相关性统计数据必然会有所不同：随着更高层次捕获更高抽象的特征，它们的空间集中度预计会降低。 这表明，3×3和5×5的卷积比应该随着我们向更高层移动而增加。 在Inception中1x1考虑到local region，3x3和5x5则考虑到spatially spread out clusters。所以在lower的层中主要是local信息，所以1x1的output number要多一些，但在higher的层中往往捕捉的是features of higher abstraction，所以在higher layer中3x3和5x5的比例应该增大。\n上述模块的一个大问题，至少在这种形式下，是即使是少量的5×5卷积，在具有大量过滤器的卷积层的顶部也可能非常昂贵。一旦池化单元被加入到了里面这个问题就变得更加突出：因为输出滤波器的数量等于上一阶段滤波器的数量。池层的输出与卷积层的输出合并将不可避免地导致各个阶段输出数量的增加。虽然这种体系结构可以覆盖最优的稀疏结构，但它的效率非常低，导致在几个阶段内就会出现计算爆炸。\n这就引出了 Inception 结构的第二个想法：明智地减少维度，否则计算需求会增加很多。这是基于嵌入的成功：即使是低维度的嵌入也可能包含大量关于相对较大的图像 patch 的信息。然而，嵌入式以一种密集的、压缩的形式表示信息，而压缩的信息很难处理。在大多数地方(根据[2]条件的要求)，表示应该保持稀疏，并且只在需要对信号进行大规模聚集时才对其进行压缩。也就是说 1×1 1\\times11×1 的卷积在 3×3 3\\times33×3 和 5×5 5\\times55×5 之前降低了计算量。除了降低计算量，它们还包括使用矫正的线性激活，使它们具有双重用途。最后的结果图 2 的 (b) 所示。\n整体来说，总体来说一个 Inception 网络有上面所示的模块堆积起来组成，偶尔使用带stride 2的max-pooling层来将网格的分辨率减半。由于技术的原因（训练时的内存利用率），似乎仅仅在高层次开始使用 Inception 而在低层次保持使用传统的卷积风格会比较有益。这并不是完全必要的，只是反映了我们当前实现中的一些基础设施效率低下。\n该网络结构的一个有用的方面是，它允许在每个阶段显著增加单元的数量，而不会在后期的计算复杂性中出现无法控制的激增。这是通过在昂贵的卷积之前普遍使用降维来实现的。此外，该设计遵循的是一种实践直觉，即视觉信息应该在不同的尺度上进行处理，然后进行聚合，以便下一阶段能够同时从不同尺度上提取特征。\n改进了对计算资源的使用，可以在不遇到计算困难的情况下增加每个阶段的宽度和阶段的数量。您可以利用Inception架构来创建稍微逊色一些，但是在计算上更便宜的版本。我们发现所有可用的旋钮和杠杆允许控制计算资源的平衡，导致速度是表现相似但没有 Inception 模块的3−10倍，然而在这一点上需要仔细的手工设计。\n关于网络结构的个人理解首先是关于稀疏性的理解，下面的这句话是原文中关于稀疏性的解释\nInception 结构的主要想法在于考虑一个卷积视觉神经网络的最优局部稀疏结构是如何被现成的密集组件来近似和覆盖。\n具体的是利用滤波器级别的稀疏能力，但利用我们目前的硬件和密集矩阵的计算。那下面的网络结构与稀疏有什么关系呢？\n\n我们可以将 1×1 1\\times11×1 ，3×3 3\\times33×3 表示成如下的卷积\n\n实际上可以将 1×1 1\\times11×1 和 3×3 3\\times33×3 看成是 5×5 5\\times55×5 的稀疏表示，只不过是一种特殊的稀疏表示。因为如果是一般形式的稀疏表示的话，那么在 5×5 5\\times55×5 的矩阵中，哪个位置是 0 都是可以的，但是 1×1 1\\times11×1 和 3×3 3\\times33×3 却只有中心位置的数值是非零的，其余部分的数值都是 0。这也说明了为什么作者认为这是一种 “使用密集组建的 近似 和覆盖”。\n在论文中作者使用了 1×1 1\\times11×1 的卷积， 它可以降低维度，增加系统的非线性，这是使用了它的好处，但是为什么它是可行的？\n我们一层可能会有多个卷积核，在同一个位置但在不同通道的卷积核输出结果相关性极高。一个1×1的卷积核可以很自然的把这些相关性很高，在同一个空间位置，但不同通道的特征结合起来。而其它尺寸的卷积核（3×3，5×5）可以保证特征的多样性，因此也可以适量使用[2]。\nNew Version比Old version是如何减少参数量的？1×1 的卷积核和正常的滤波器完全是一样的，只不过它不再感受一个局部区域，不考虑像素与像素之间的关系。1×1的卷积本身就是不同feature channel的线性叠加。1×1的卷积最早出现在Network in Network这篇文章中，在Google的inception结构中也采用了大量1×1的卷积。\nNIN 论文中解释1×1的卷积实现了多个feature map的结合，从而整合了不同通道间的信息。（个人认为这个作用并不是特点，因为其它大小的卷积核也可以实现）\n1×1的卷积可以实现通道数量的升维和降维。并且是低成本的特征变换（计算量比3×3小很多）。是一个性价比很高的聚合操作。怎么理解1×1是性价比很高的升降通道数的操作呢？[2]\n\n\n原始结构：\n参数：(1×1×192×64) + (3×3×192×128) + (5×5×192×32) = 153600\n最终输出的feature map：64+128+32+192 = 416\n加入不同channel的1×1卷积后：\n参数：1×1×192×64+（1×1×192×96+3×3×96×128）+（1×1×192×16+5×5×16×32）=15872\n最终输出的feature map： 64+128+32+32=256\n所以加入1×1的卷积后，在降低大量运算的前提下，降低了维度。降低维度也是inception module一个非常明智的举措。\n5.GoogLeNetGoogLeNet 是 Inception 的一个具体实现，我们尝试过更深更宽质量稍好的 Inception，但是提升的效果并不明显。我们忽略具体的网络细节，因为实验表明，精确的网络结构参数的影响相对较小。表格 1 表明了我们在比赛中大部分共用的实例。在我们的集成模型中的 7 个模型，有 6 个网络使用了这样的（表格1）网络，这 6 个网络使用了不同的图像块采样方法进行训练。也就是说作者在使用 GoogLeNet 参加比赛的时候最后使用了模型集成的方法，并且还有一个模型我们不知道时使用了什么样的一种算法。\n\n在所有的卷积中，包括 Inception 中的卷积，使用的都是修正线性激活函数（ReLu）。神经网络的感受野是大小为 224×224 224\\times224224×224 均值为 0 彩色空间图像。在面上的表中，patchsize/ stride 表明卷积核的大小和步长，output size 表示输出的数据块的大小（当网络为传统卷积时还可以看出使用了多少个卷积核），depth 是该层重复了几次（具体来说是该行所表示的传统卷层重复了几次，或者是该行所表示的 Inception 重复了几次），#1× 1 表示 Inception 中最坐标的 1×1 大小的卷积核的数量，#3×3 reduce 表示在进行 3×3 的卷积之前，用来降维的 1×1 大小的卷积核的数量，#3×3 表示 3×3 大小卷积核的数量，#5×5 reduce 和 #5×5 同理，pool proj 表示最右侧经过池化之后 1×1 大小的卷积核的数量。\n在思想上网络设计得具有计算效率和实用性，以至于前向推理的时候可以在单个设备上运行推理，包括计算资源有限的设备，尤其是内存占用较低的设备。当仅仅计算有参数的层数时，网络是22层（如果加上池化是27层）。在网络中使用的独立模块大概有 100 个。具体的数量如何计算依赖于机器学习基础设施是如何计数的。在分类之前使用了均值池化是基于 [12] 的想法，虽然我们添加了一个额外的线性层。线性层可以简单的将我们的网络应用到其他标签上，然而这只是为了方便，它并不起到一个主要的作用。我们发现从全连接层到平均池化的改变提升了 top1 正确率 0.6%，然而即使去掉了全连接层，dropout 仍然是必要的。\n对于一个相对较深的神经网络，以一种有效的方式将剃度反向传播给所有层。浅层网络在梯度方向上反向传播的强大性能表明，网络中间层所产生的特征应该具有很强的识别性。通过在中间层添加辅助分类器，较低层分类器的识别性是可以期待的。辅助分类器被认为可以在提供正则化的同时，对抗梯度消失问题。这些分类器以小的卷积神经网络的形式放在了 Inception (4a) and (4d) 模块的上方。在训练过程中辅助分类器的损失被加权添加到总体的损失上（辅助分类器的损失权重设置为 0.3）。在进行前向推理的时候，辅助网络是禁用的。实验表明辅助网络的效果比较弱，仅仅使用一个辅助网络也可达到相同的效果。\n包括辅助分类器在内，在侧面的额外网络的准确结构如下所示\n(1) 卷积核大小为 5×5 5\\times55×5 步长为 3 的均值池化层，所以 (4a) 的输出为 4×4×512 4\\times4\\times5124×4×512，(4d) 的输出为 4×4×528 4\\times4\\times5284×4×528。\n(2) 大小为 1×1 1\\times11×1 的128 个用来降维的卷积核和 ReLu 激活函数.\n(3) 拥有 1024 个神经元的全连接层和 ReLu 激活函数\n(4) 丢弃输出层 70 % 的 dropout 层\n(5) 一个有 softmax 损失的线性层（预测与主分类器一样的 1000 个类别，但是在推理的时候会被去掉）。\n结果网络的示意图如图3所示。\n\n使用districess[4]分布式机器学习系统，使用适度的模型和数据并行性对googlenet网络进行培训。虽然我们只使用了基于CPU的实现，但粗略估计表明，可以在一周内使用少量高端GPU将谷歌网络训练为收敛，主要限制是内存使用。我们的培训采用了 0.9 动量的异步随机梯度下降[17]，固定的学习速率计划（每8个周期降低4%的学习速率）。Polyak Averaging[13]用于创建推理时使用的最终模型。\n在比赛的几个月中，图像采样方法已经发生了很大的变化，并且已经将模型与其他选项融合在一起，有时会与改变的超参数（如 dropout 和学习率）结合在一起。因此，很难对最有效的单一网络培训方式给出明确的指导。此外，为了使其更加复杂，一些模型是受[8]启发而设计的，其中一些模型是在较小的图像块中训练的，而另一些模型是在较大的图像块上的。尽管如此，有一个处方在比赛后证明效果很好，它包括对图像中大小均匀分布在图像区域8%到100%之间的各种大小的斑块进行采样，纵横比受间隔限制[3/4，4/3]。此外，我们还发现，安德鲁·霍华德（Andrew Howard）的光度畸变对克服训练数据成像条件的影响非常有用。\n7. ILSVRC 2014 Classiﬁcation Challenge Setup and ResultsILSVRC 2014分类挑战涉及到将图像分类为ImageNet层次结构中的1000叶节点类别的任务。训练图像约120万张，验证用图像约5万张，测试用图像约10万张。每幅图像都与一个 gt 类别相关联，并且性能是基于最高评分的更高级预测来衡量的。通常会报告两个数字：第一个准确率（将地面真实性与第一个预测类进行比较）和第五个错误率（将地面真实性与前五个预测类进行比较）：如果地面真实性在前五个预测类中，则不管图像中的等级如何，都认为图像是正确分类的。挑战使用前5个错误率进行排名。\n我们没有使用额外的数据参加挑战。除了本文前面提到的训练技术之外，我们在测试过程中采用了一套技术来获得更高的性能（可以理解为超级疯狂的模型集成和数据拓展），下面我们将对此进行描述。\n(1) 我们独立训练了同一个谷歌模型的7个版本（包括一个更广泛的版本），并与他们进行了模型集成。这些模型是用相同的初始化（甚至是相同的初始权重，由于一个监督）和学习率策略进行训练的。它们只在采样方法和随机输入图像顺序上有所不同。\n(2) 在测试期间我们采取了比 Krizhevsky 等人更为激进的裁剪方法。具体的我们将图像缩放到 4 中尺度，其中他们的短边长度分别是256，288，320，352，取出图像的左中右三个方形（对于肖像图像，我们取顶部、中间和底部的方形）。对于每一个方形，我们取出 4 个角和中心部分，同时也将方形部分缩放回 224*224，并且获得他们的镜像图像。这将导致我们在一张图像中取出 4×3×6×2 = 144 个图像块。安德鲁·霍华德（Andrew Howard）在上一年的比赛中中也采用了类似的方法，我们根据经验证明，该方法的表现略差于我们提出的策略。我们注意到，在实际应用中，这种激进的剪裁可能不是必要的，因为在出现合理数量的剪裁图片之后，更多剪裁的效益变得微乎其微（稍后我们将展示）。\n(3) softmax 的概率值是对所有的剪切出来的图像和所有的独立的分类器上得到的均值作为预测的结果。在验证集上我们分析了替代的方法，例如对单张图像的所有剪切图像的结果进行最大池化，然后对所有的分类器去均值，但是它们导致的性能比简单的平均差。\n在本文的其余部分中，我们分析了有助于最终提交的总体性能的多个因素。\n我们最后提交的挑战获得了6.67%的验证和测试数据的前5个错误，在其他参与者中排名第一。与2012年的训练方法相比，这是一个56.5%的相对减少，与上一年的最佳方法（Clarifai）相比，这是大约40%的相对减少，这两种方法都使用外部数据来训练网络。表2 显示了过去3年中一些表现最好的方法的统计数据。\n\n当预测一张图像的时候，我们通过改变模型的数量和剪裁的数量来分析和报告不同测试选择的效果，如表 3 所示。当我们使用一个模型时，我们选择了一个在验证数据上具有最低的前1个错误率的模型。所有数字都在验证数据集中报告，以避免超出测试数据统计的范围。\n\n8. ILSVRC 2014 Detection Challenge Setup andResultsILSVRC检测任务是在200个可能的类中，围绕图像中的对象生成边界框。如果检测到的对象与GroundTruth的类相匹配，并且它们的边界框重叠至少50%（使用JacCard索引），则这些对象算是正确的。外来检测被视为假阳性并受到处罚。与分类任务相反，每个图像可以包含多个对象，也可以不包含任何对象，其比例可能有所不同。使用平均精度（MAP）报告结果。googlenet所采用的检测方法与r-cnn的方法相似，但作为区域分类，随着初始模型的增加而增加。此外，通过将选择性搜索[20]方法与多框[5]预测相结合，改进了区域建议步骤，以实现更高的对象边界框调用。\n为了减少误报的数量，超级像素的大小增加了2倍。这使得来自选择性搜索算法的建议减半。我们增加了来自多框[5]的200个地区提案，总共占[6]所用提案的60%，同时将覆盖率从92%提高到93%。减少覆盖率增加的提案数量的总体效果是提高单个模型案例的平均精度1%。最后，在对每个区域进行分类时，我们使用6个谷歌地图的集合。这导致精确度从40%提高到43.9%。注意，与R-CNN相反，我们没有使用边界框回归，因为缺乏时间。\n我们首先报告最高检测结果，并显示自检测任务第一版以来的进展。与2013年的结果相比，精度几乎翻了一番。表现最好的团队都使用卷积网络。我们在表4中报告了财务得分以及每个团队的常用策略：使用外部数据、整体模型或上下文模型。外部数据通常是ILSVRC12分类数据，用于对模型进行预培训，该模型稍后将根据检测数据进行重新定义。一些团队还提到了本地化数据的使用。由于本地化任务边界框的很大一部分不包含在检测数据集中，因此可以使用此数据对通用边界框回归器进行预训练，就像在预训练中使用分类一样。googlenet条目没有使用本地化数据进行预培训。\n在表5中，我们只使用一个模型比较结果。最优秀的表演模型是由深刻的洞察力和令人惊讶的只有0.3分的提高与3个模型的合奏，而谷歌获得了显着更强的效果与合奏。\n9.Conclusions我们的结果提供了一个确凿的证据，证明用现有的密集型卷积计算近似期望的最优稀疏结构是改进计算机视觉神经网络的一种可行方法。这种方法的主要优点是，与较浅和较窄的体系结构相比，在计算需求适度增加的情况下，效果会显著提高。\n我们的对象检测工作具有竞争力，尽管没有使用上下文，也没有执行边界框回归，这进一步证明了初始体系结构的优势。\n对于分类和检测任务，可以想象得到获得和我们效果相当的结果需要跟多的昂贵的非 Inception 模块来组成相似的宽度和深度。尽管如此，我们的方法仍然提供了确凿的证据，证明迁移到更稀疏的架构总体上是可行的和有用的。这表明，未来将在[2]的基础上，以自动化方式创建更为稀疏和更复杂的结构，并将 Inception 结构的见解应用到其他领域。\n参考\n[1] Szegedy C , Liu N W , Jia N Y , et al. Going deeper with convolutions[C]// 2015 IEEE Conference on Computer Vision and Pattern Recognition (CVPR). IEEE Computer Society, 2015.\n[2] BookThief 简书 《Google Inception Net论文细读》\n","categories":["图像处理与机器学习"],"tags":["机器学习"]},{"title":"计算机专业必读哪些经典书籍？","url":"https://tanqingbo.cn/CS-Classic-Books/","content":"耗时一天，吐血整理的计算机经典书籍，包括计算机专业必读经典、 C、Java、Python学习的经典教材等， 从入门到进阶，各个阶段都有。文末附带免费获取方式，希望能有帮助~ \n必读经典深入理解计算机系统（原书第3版） 9.7分 2383人评价本书的最大优点是为程序员描述计算机系统的实现细节，帮助其在大脑中构造一个层次型的计算机系统，从最底层的数据在内存中的表示到流水线指令的构成，到虚拟存储器，到编译系统，到动态加载库，到最后的用户态应用。 \n\n现代操作系统（第3版） 8.9分 717人评价本书适合作为高等院校计算机专业操作系统课程教材，也是设计、开发操作系统的重要参考书。 \n\n计算机程序的构造和解释 : 原书第2版 9.5分 2229人评价 美国麻省理工学院(MIT)多年使用的教材。\n \n计算机网络（第4版） : 自顶向下方法 8.8分 734人评价本书采用了独创的自顶向下方法，即从应用层开始沿协议栈向下讲解计算机网络的基本原理，强调应用层范例和应用编程接口，内容深入浅出，注重教学方法，理论与实践相结合。 \n\n数据库系统概念 : 第五版 8.2分 417人评价本书是数据库系统方面的经典教材之一。国际上许多著名大学包括斯坦福大学、耶鲁大学、得克萨斯大学、康奈尔大学、伊利诺伊大学、印度理工学院等都采用本书作为教科书。 \n\n设计模式 : 可复用面向对象软件的基础 9.1分 2805人评价设计模式有多重要，等你工作的时候就明白了。 这本书结合设计实作例从面向对象的设计中精选出23个设计模式，总结了面向对象设计中最有价值的经验，并且用简洁可复用的形式表达出来。 \n\nC/C++1 The Design and Evolution of C++    8.5分\n\n首先肯定要读一读Bjarne Stroustrup的The Design and Evolution of C++，了解一下这个语言的历史。接下来就可以看别的书了，但要不停地回头看这本书，看到你不断地学到的新技术是怎么样一点点地被接纳到这个语言中去的。\n\n2 C++ Primer   9.3分\n\n第一本书因人而异，基础好一些的，可以看Stanley B. Lippman的C++ Primer，这本书非常地巨大，你打星号的部分可以不要看。基础不太好的，可以看Stanley B.Lippman的Essential C++，这本书份量要轻得多，不过四个C++的范型都讲了，而且讲得非常清楚。\n\n3 Thinking in C++    9.1分\n\n第二本书，就应该是Bruce Eckel写的、候捷译的Thinking in C++，这本书技术运用的非常高的境界，但是语言非常平实，只要认真地读，即使基础不行，也一定可以懂。\n\n4 Effective C++和More Effective C++     9.5分\n\n第三本应该静下心来看看Scott Meyers的Effective C++和More Effective C++，好好地整理一下，在程序设计中应该有哪些注意的事项。可以指导项目运作了，可以编写一切你想做的程序了，可以指出别人看起来不错的代码的大小问题了\n\nJavaJava基础\n1 Java编程思想(第4版)    9.1分\n\n本书赢得了全球程序员的广泛赞誉，即使是最晦涩的概念，在Bruce Eckel的文字亲和力和小而直接的编程示例面前也会化解于无形。从Java的基础语法到最高级特性（深入的面向对象概念、多线程、自动项目构建、单元测试和调试等），本书都能逐步指导你轻松掌握.\n\n2 Java核心技术 卷Ⅰ 基础知识(第8版)     8.7分\n\n这本书在Java领域是和Java编程思想齐名的一本书，很多知识点都讲的特别细，我初次看的时候发现课上好多没讲的基础知识这本书上都提到了，非常有助于你练好扎实的基础知识。\n\nJava中级\n1 大话设计模式    8.3分\n\n设计模式体现的是一种思想，思想是指导行为的一切。理解和掌握设计模式，记住23种或者更多的设计场景和解决策略是不够的，更要接受一种思想的熏陶和洗礼。\n本书通过故事讲述程序如何设计。希望能给渴望了解面向对象程序设计的初学者及困惑、无法复用的代码编程体验者一些好的建议和提示。\n\n2 分布式Java应用基础与实践   7.8分\n\n本书介绍分布式Java应用涉及的知识点，分为基于Java实现网络通信、RPC；基于SOA实现大型分布式Java应用；编写高性能Java应用；构建高可用、可伸缩的系统四个部分，共七章内容。\n\n3 Java并发编程实践   8.9分\n\n《JAVA并发编程实践》随着多核处理器的普及，使用并发成为构建高性能应用程序的关键。Java 5以及6在开发并发程序中取得了显著的进步，提高了Java虚拟机的性能以及并发类的可伸缩性，并加入了丰富的新并发构建块。在《JAVA并发编程实践》中，这些便利工具的创造者不仅解释了它们究竟如何工作、如何使用，还阐释了创造它们的原因，及其背后的设计模式。\n\nJava高级\n1大型网站技术架构：核心原理与案例分析    7.9分\n\n该书通过梳理大型网站技术发展历程，剖析大型网站技术架构模式，深入讲述大型互联网架构设计的核心原理。\n\n2 代码整洁之道    9.1分\n\n这本书重在对细节的关注。书的编排极其合理，从最小的点开始一点点往大处讲。感觉对刚开始工作的小朋友们，代码看得、写得还不够多，读设计模式之类的书可能还没什么体会。但这本代码细节的书，却是能立竿见影，直接用到工作中去的。\n\nPython1 Python核心编程(第二版)  7.7分\n\n本书是经典的Python[1] 指导书，在第一版的基础上进行了全面升级。全书分为两个部分：第1部分占据了大约三分之二的篇幅，阐释这门语言的“核心”内容，包括基本的概念和语句、语法和风格、Python对象、数字类型、序列类型、映射和集合类型、条件和循环、文件和输入/输出、错误和异常、函数和函数式编程、模块、面向对象编程、执行环境等内容：第2部分则提供了各种高级主题来展示可以使用Python做些什么，包括正则表达式、网络编程、网络客户端编程、多线程编程、图形用户界面编程、Web编程、数据库编程、扩展Python 和一些其他材料。\n\n2 Python高级编程   7.6分\n\n《Python高级编程》针对具备一定Python基础并希望通过在项目中应用最佳实践和新的开发技术来提升自己的Python开发人员。\n\n3 Python数据结构与算法   8.3分\n\n主要是介绍了如何使用Python实现常用的一些数据结构,例如堆栈、队列、二叉树等等。\n\n4 利用Python进行数据分析   8.5分\n\n从pandas库的数据分析工具开始利用高性能工具对数据进行加载、清理、转换、合并以及重塑；利用matpIotlib创建散点图以及静态或交互式的可视化结果；利用pandas的groupby功能对数据集进行切片、切块和汇总操作；处理各种各样的时间序列数据。\n\n上面整理的所有书籍，都可以在微信公众号：轮子工厂    中回复“1024”领取，一共21本！不要想太多，也别着急，任何大神都是从菜鸟开始的，只要你开始踏踏实实的去学习了，一定会有回报的。别忘了去微信上去领书啊！加油~ \n","categories":["编程资料"],"tags":["计算机专业","C","Java","Python"]},{"title":"机器学习必读经典书籍与论文下载","url":"https://tanqingbo.cn/ML-EBook-paper/","content":"部分经典机器学习书籍已经整理好了，在公众号【轮子工厂】后台回复“机器学习”可以领取，另外还配套有视频教程、课件和项目练习！\n入门书单1.《数学之美》作者吴军博士是我特备喜欢的以为人工智能专家，他的大部分我都看过，在本书中以极为通俗的语言讲述了数学在机器学习和自然语言处理等领域的应用。\n2.《集体智慧编程》作者Toby Segaran也是《数据之美：解密优雅数据解决方案背后的故事》的作者。这本书最大的优势就是里面没有理论推导和复杂的数学公式，是很不错的入门书。目前中文版已经脱销，对于有志于这个领域的人来说，英文的pdf是个不错的选择，因为后面有很多经典书的翻译都较差，只能看英文版，不如从这个入手。还有，这本书适合于快速看完，因为据评论，看完一些经典的带有数学推导的书后会发现这本书什么都没讲，只是举了很多例子而已。\n3.《智能web算法》作者Haralambos Marmanis、Dmitry Babenko。这本书中的公式比《集体智慧编程》要略多一点，里面的例子多是互联网上的应用，看名字就知道。不足的地方在于里面的配套代码是BeanShell而不是python或其他。总起来说，这本书还是适合初学者，与上一本一样需要快速读完，如果读完上一本的话，这一本可以不必细看代码，了解算法主要思想就行了。\n4.《统计学习方法》作者李航，是国内机器学习领域的几个大家之一，曾在MSRA任高级研究员，现在华为诺亚方舟实验室。书中写了十个算法，每个算法的介绍都很干脆，直接上公式，是彻头彻尾的“干货书”。每章末尾的参考文献也方便了想深入理解算法的童鞋直接查到经典论文；本书可以与上面两本书互为辅助阅读。\n5.《Machine Learning》（《机器学习》）作者Tom Mitchell是CMU的大师，有机器学习和半监督学习的网络课程视频。这本书是领域内翻译的较好的书籍，讲述的算法也比《统计学习方法》的范围要大很多。据评论这本书主要在于启发，讲述公式为什么成立而不是推导；不足的地方在于出版年限较早，时效性不如PRML。但有些基础的经典还是不会过时的，所以这本书现在几乎是机器学习的必读书目。\n6.《Mining of Massive Datasets》（《大数据》）作者Anand Rajaraman[3]、Jeffrey David Ullman，Anand是Stanford的PhD。这本书介绍了很多算法，也介绍了这些算法在数据规模比较大的时候的变形。但是限于篇幅，每种算法都没有展开讲的感觉，如果想深入了解需要查其他的资料，不过这样的话对算法进行了解也足够了。还有一点不足的地方就是本书原文和翻译都有许多错误，勘误表比较长，读者要用心了。\n7.《数据挖掘：实用机器学习技术》作者Ian H. Witten 、Eibe Frank是weka的作者、新西兰怀卡托大学教授。他们的《ManagingGigabytes》[4]也是信息检索方面的经典书籍。这本书最大的特点是对weka的使用进行了介绍，但是其理论部分太单薄，作为入门书籍还可，但是，经典的入门书籍如《集体智慧编程》、《智能web算法》已经很经典，学习的话不宜读太多的入门书籍，建议只看一些上述两本书没讲到的算法。\n8.《机器学习及其应用》周志华、杨强主编。来源于“机器学习及其应用研讨会”的文集。该研讨会由复旦大学智能信息处理实验室发起，目前已举办了十届，国内的大牛如李航、项亮、王海峰、刘铁岩、余凯等都曾在该会议上做过讲座。这本书讲了很多机器学习前沿的具体的应用，需要有基础的才能看懂。如果想了解机器学习研究趋势的可以浏览一下这本书。关注领域内的学术会议是发现研究趋势的方法嘛。\n\n进阶书单1.《Pattern Classification》（《模式分类》第二版）作者Richard O. Duda[5]、Peter E. Hart、David。模式识别的奠基之作，但对最近呈主导地位的较好的方法SVM、Boosting方法没有介绍，被评“挂一漏万之嫌”。\n2.《Pattern Recognition And Machine Learning》作者Christopher M. Bishop[6]；简称PRML，侧重于概率模型，是贝叶斯方法的扛鼎之作，据评“具有强烈的工程气息，可以配合stanford 大学 Andrew Ng 教授的 Machine Learning 视频教程一起来学，效果翻倍。”\n3.《统计学习基础：数据挖掘、推理与预测》第二版作者RobertTibshirani、Trevor Hastie、Jerome Friedman。“这本书的作者是Boosting方法最活跃的几个研究人员，发明的Gradient Boosting提出了理解Boosting方法的新角度，极大扩展了Boosting方法的应用范围。这本书对当前最为流行的方法有比较全面深入的介绍，对工程人员参考价值也许要更大一点。另一方面，它不仅总结了已经成熟了的一些技术，而且对尚在发展中的一些议题也有简明扼要的论述。让读者充分体会到机器学习是一个仍然非常活跃的研究领域，应该会让学术研究人员也有常读常新的感受。”\n4.《数据挖掘：概念与技术》第三版作者（美）Jiawei Han[8]、（加）Micheline Kamber、（加）Jian Pei，其中第一作者是华裔。本书毫无疑问是数据挖掘方面的的经典之作，不过翻译版总是被喷，没办法，大部分翻译过来的书籍都被喷，想要不吃别人嚼过的东西，就好好学习英文吧。\n5.《AI, Modern Approach 2nd》Peter Norvig，无争议的领域经典。\n6.《Foundations of Statistical Natural Language Processing》自然语言处理领域公认经典。\n7.《Statistical Learning Theory》Vapnik的大作，统计学界的权威，本书将理论上升到了哲学层面，他的另一本书《The Nature ofStatistical Learning Theory》也是统计学习研究不可多得的好书，但是这两本书都比较深入，适合有一定基础的读者。\n\n数学基础书单1.《矩阵分析》Roger Horn。矩阵分析领域无争议的经典\n2.《概率论及其应用》威廉·费勒。极牛的书，可数学味道太重，不适合做机器学习的\n3.《All Of Statistics》机器学习这个方向，统计学也一样非常重要。推荐All of statistics，这是CMU的一本很简洁的教科书，注重概念，简化计算，简化与Machine Learning无关的概念和统计内容，可以说是很好的快速入门材料。\n4.《Nonlinear Programming, 2nd》最优化方法，非线性规划的参考书。\n5.《Convex Optimization》Boyd的经典书籍，被引用次数超过14000次，面向实际应用，并且有配套代码，是一本不可多得的好书。\n6.《Numerical Optimization》第二版，Nocedal著，非常适合非数值专业的学生和工程师参考，算法流程清晰详细，原理清楚。\n7.《Introduction to Mathematical Statistics》第六版，Hogg著，本书介绍了概率统计的基本概念以及各种分布，以及ML，Bayesian方法等内容。\n8.《An Introduction to Probabilistic Graphical Models》Jordan著，本书介绍了条件独立、分解、混合、条件混合等图模型中的基本概念，对隐变量（潜在变量）也做了详细介绍，相信大家在隐马尔科夫链和用Gaussian混合模型来实现EM算法时遇到过这个概念。\n9.《Probabilistic Graphical Models-Principles and Techniques》Koller著，一本很厚很全面的书，理论性很强，可以作为参考书使用。\n大家的补充1. 线性代数 (Linear Algebra)：我想国内的大学生都会学过这门课程，但是，未必每一位老师都能贯彻它的精要。这门学科对于Learning是必备的基础，对它的透彻掌握是必不可少的。Introduction to Linear Algebra (3rd Ed.) by Gilbert Strang.\n的难度适中，讲解清晰，重要的是对许多核心的概念讨论得比较透彻。我个人觉得，学习线性代数，最重要的不是去熟练矩阵运算和解方程的方法——这些在实际工作中MATLAB可以代劳，关键的是要深入理解几个基础而又重要的概念：子空间(Subspace)，正交(Orthogonality)，特征值和特征向量(Eigenvalues and eigenvectors)，和线性变换(Linear transform)。从我的角度看来，一本线代教科书的质量，就在于它能否给这些根本概念以足够的重视，能否把它们的联系讲清楚。Strang的这本书在这方面是做得很好的。\n而且，这本书有个得天独厚的优势。书的作者长期在MIT讲授线性代数课(18.06)，课程的video在MIT的Open courseware网站上有提供。有时间的朋友可以一边看着名师授课的录像，一边对照课本学习或者复习。\nhttp://ocw.mit.edu/OcwWeb/Mathematics/18-06Spring-2005/CourseHome/index.htm8\n2.概率和统计 (Probability and Statistics):概率论和统计的入门教科书很多，我目前也没有特别的推荐。我在这里想介绍的是一本关于多元统计的基础教科书：\nApplied Multivariate Statistical Analysis (5th Ed.) by Richard A. Johnson and Dean W. Wichern\n这本书是我在刚接触向量统计的时候用于学习的，我在香港时做研究的基础就是从此打下了。实验室的一些同学也借用这本书学习向量统计。这本书没有特别追求数学上的深度，而是以通俗易懂的方式讲述主要的基本概念，读起来很舒服，内容也很实用。对于Linear regression, factor analysis, principal component analysis (PCA), and canonical component analysis (CCA)这些Learning中的基本方法也展开了初步的论述。\n之后就可以进一步深入学习贝叶斯统计和Graphical models。一本理想的书是\nIntroduction to Graphical Models (draft version). by M. Jordan and C. Bishop.\n我不知道这本书是不是已经出版了（不要和Learning in Graphical Models混淆，那是个论文集，不适合初学）。这本书从基本的贝叶斯统计模型出发一直深入到复杂的统计网络的估计和推断，深入浅出，statistical learning的许多重要方面都在此书有清楚论述和详细讲解。MIT内部可以access，至于外面，好像也是有电子版的。\n3.分析 (Analysis)：我想大家基本都在大学就学过微积分或者数学分析，深度和广度则随各个学校而异了。这个领域是很多学科的基础，值得推荐的教科书莫过于\nPrinciples of Mathematical Analysis, by Walter Rudin\n有点老，但是绝对经典，深入透彻。缺点就是比较艰深——这是Rudin的书的一贯风格，适合于有一定基础后回头去看。\n在分析这个方向，接下来就是泛函分析(Functional Analysis)。\nIntroductory Functional Analysis with Applications, by Erwin Kreyszig.\n适合作为泛函的基础教材，容易切入而不失全面。我特别喜欢它对于谱论和算子理论的特别关注，这对于做learning的研究是特别重要的。Rudin也有一本关于functional analysis的书，那本书在数学上可能更为深刻，但是不易于上手，所讲内容和learning的切合度不如此书。\n在分析这个方向，还有一个重要的学科是测度理论(Measure theory)，但是我看过的书里面目前还没有感觉有特别值得介绍的。\n4.拓扑 (Topology)：在我读过的基本拓扑书各有特色，但是综合而言，我最推崇：\nTopology (2nd Ed.) by James Munkres\n这本书是Munkres教授长期执教MIT拓扑课的心血所凝。对于一般拓扑学(General topology)有全面介绍，而对于代数拓扑(Algebraic topology)也有适度的探讨。此书不需要特别的数学知识就可以开始学习，由浅入深，从最基本的集合论概念（很多书不屑讲这个）到Nagata-Smirnov Theorem和Tychonoff theorem等较深的定理（很多书避开了这个）都覆盖了。讲述方式思想性很强，对于很多定理，除了给出证明过程和引导你思考其背后的原理脉络，很多令人赞叹的亮点——我常读得忘却饥饿，不愿释手。很多习题很有水平。\n5.流形理论 (Manifold theory)：对于拓扑和分析有一定把握时，方可开始学习流形理论，否则所学只能流于浮浅。我所使用的书是\nIntroduction to Smooth Manifolds. by John M. Lee\n虽然书名有introduction这个单词，但是实际上此书涉入很深，除了讲授了基本的manifold, tangent space, bundle, sub-manifold等，还探讨了诸如纲理论(Category theory)，德拉姆上同调(De Rham cohomology)和积分流形等一些比较高级的专题。对于李群和李代数也有相当多的讨论。行文通俗而又不失严谨，不过对某些记号方式需要熟悉一下。\n虽然李群论是建基于平滑流形的概念之上，不过，也可能从矩阵出发直接学习李群和李代数——这种方法对于急需使用李群论解决问题的朋友可能更加实用。而且，对于一个问题从不同角度看待也利于加深理解。下面一本书就是这个方向的典范：\nLie Groups, Lie Algebras, and Representations: An Elementary Introduction. by Brian C. Hall\n此书从开始即从矩阵切入，从代数而非几何角度引入矩阵李群的概念。并通过定义运算的方式建立exponential mapping，并就此引入李代数。这种方式比起传统的通过“左不变向量场(Left-invariant vector field)“的方式定义李代数更容易为人所接受，也更容易揭示李代数的意义。最后，也有专门的论述把这种新的定义方式和传统方式联系起来。\n机器学习领域经典论文除了以上推荐的书以外，出版在Foundations and Trends in Machine Learning上面的survey文章都值得一看。\n入门：\nPattern Recognition And Machine Learning\nChristopher M. Bishop\nMachine Learning : A Probabilistic Perspective\nKevin P. Murphy\nThe Elements of Statistical Learning : Data Mining, Inference, and Prediction\nTrevor Hastie, Robert Tibshirani, Jerome Friedman\nInformation Theory, Inference and Learning Algorithms\nDavid J. C. MacKay\nAll of Statistics : A Concise Course in Statistical Inference\nLarry Wasserman\n优化：\nConvex Optimization\nStephen Boyd, Lieven Vandenberghe\nNumerical Optimization\nJorge Nocedal, Stephen Wright\nOptimization for Machine Learning\nSuvrit Sra, Sebastian Nowozin, Stephen J. Wright\n核方法：\nKernel Methods for Pattern Analysis\nJohn Shawe-Taylor, Nello Cristianini\nLearning with Kernels : Support Vector Machines, Regularization, Optimization, and Beyond\nBernhard Schlkopf, Alexander J. Smola\n半监督：\nSemi-Supervised Learning\nOlivier Chapelle\n高斯过程：\nGaussian Processes for Machine Learning (Adaptive Computation and Machine Learning)\nCarl Edward Rasmussen, Christopher K. I. Williams\n概率图模型：\nGraphical Models, Exponential Families, and Variational Inference\nMartin J Wainwright, Michael I Jordan\nBoosting:\nBoosting : Foundations and Algorithms\nSchapire, Robert E.; Freund, Yoav\n贝叶斯:\nStatistical Decision Theory and Bayesian Analysis\nJames O. Berger\nThe Bayesian Choice : From Decision-Theoretic Foundations to Computational Implementation\nChristian P. Robert\nBayesian Nonparametrics\nNils Lid Hjort, Chris Holmes, Peter Müller, Stephen G. Walker\nPrinciples of Uncertainty\nJoseph B. Kadane\nDecision Theory : Principles and Approaches\nGiovanni Parmigiani, Lurdes Inoue\n蒙特卡洛：\nMonte Carlo Strategies in Scientific Computing\nJun S. Liu\nMonte Carlo Statistical Methods\nChristian P.Robert, George Casella\n信息几何：\nMethods of Information Geometry\nShun-Ichi Amari, Hiroshi Nagaoka\nAlgebraic Geometry and Statistical Learning Theory\nWatanabe, Sumio\nDifferential Geometry and Statistics\nM.K. Murray, J.W. Rice\n渐进收敛：\nAsymptotic Statistics\nA. W. van der Vaart\nEmpirical Processes in M-estimation\nGeer, Sara A. van de\n不推荐：\nStatistical Learning Theory\nVladimir N. Vapnik\nBayesian Data Analysis, Second Edition\nAndrew Gelman, John B. Carlin, Hal S. Stern, Donald B. Rubin\nProbabilistic Graphical Models : Principles and Techniques\nDaphne Koller, Nir Friedman\n机器学习经典论文/survey合集Active Learning\nTwo Faces of Active Learning50, Dasgupta, 2011\nActive Learning Literature Survey8, Settles, 2010\nApplications\nA Survey of Emerging Approaches to Spam Filtering9, Caruana, 2012\nAmbient Intelligence: A Survey3, Sadri, 2011\nA Survey of Online Failure Prediction Methods2, Salfner, 2010\nAnomaly Detection: A Survey3, Chandola, 2009\nMining Data Streams: A Review4, Gaber, 2005\nWorkflow Mining: A Survey of Issues and Approaches2, Aalst, 2003\nBiology\nSupport Vector Machines in Bioinformatics: a Survey12, Chicco, 2012\nComputational Epigenetics: The New Scientific Paradigm 3, Lim, 2010\nAutomated Protein Structure Classification: A Survey4, Hassanzadeh, 2009\nChemoinformatics - An Introduction for Computer Scientists3, Brown, 2009\nComputational Challenges in Systems Biology2, Heath, 2009\nComputational Epigenetics 3, Bock, 2008\nProgress and Challenges in Protein Structure Prediction3, Zhang, 2008\nA Review of Feature Selection in Bioinformatics4, Saeys, 2007\nMachine Learning in Bioinformatics: A Brief Survey and Recommendations for Practitioners6, Bhaskar, 2006\nBioinformatics - An Introduction for Computer Scientists1, Cohen, 2004\nComputational Systems Biology2, Kitano, 2002\nProtein Structure Prediction and Structural Genomics2, Baker, 2001\nRecent Developments and Future Directions in Computational Genomics1, Tsoka, 2000\nMolecular Biology for Computer Scientists1, Hunter, 1993\nClassification\nSupervised Machine Learning: A Review of Classification Techniques22, Kotsiantis, 2007\nClustering\nXML Data Clustering: An Overview4, Algergawy, 2011\nData Clustering: 50 Years Beyond K-Means6, Jain, 2010\nClustering Stability: An Overview5, Luxburg, 2010\nParallel Clustering Algorithms: A Survey4, Kim, 2009\nA Survey: Clustering Ensembles Techniques2, Ghaemi, 2009\nA Tutorial on Spectral Clustering4, Luxburg, 2007\nSurvey of Clustering Data Mining Techniques4, Berkhin, 2006\nSurvey of Clustering Algorithms4, Xu, 2005\nClustering of Time Series Data - A Survey3, Liao, 2005\nClustering Methods4, Rokach, 2005\nRecent Advances in Clustering: A Brief Survey2, Kotsiantis, 2004\nSubspace Clustering for High Dimensional Data: A Review2, Parsons, 2004\nUnsupervised and Semi-supervised Clustering: a Brief Survey3, Grira, 2004\nClustering in Life Sciences3, Zhao, 2002\nOn Clustering Validation Techniques2, Halkidi, 2001\nData Clustering: A Review3, Jain, 1999\nA Survey of Fuzzy Clustering4, Yang, 1993\nComputer Vision\nPedestrian Detection: An Evaluation of the State of the Art7, Dollar, 2012\nA Comparative Study of Palmprint Recognition Algorithms3, Zhang, 2012\nHuman Activity Analysis: A Review2, Aggarwal, 2011\nSubspace Methods for Face Recognition2, Rao, 2010\nContext Based Object Categorization: A Critical Survey2, Galleguillos, 2010\nObject tracking: A Survey3, Yilmaz, 2006\nDetecting Faces in Images: A Survey2, Yang, 2002\nDatabases\nData Fusion3, Bleiholder, 2008\nDuplicate Record Detection: A Survey2, Elmagarmid, 2007\nOverview of Record Linkage and Current Research Directions2, Winkler, 2006\nA Survey of Schema-based Matching Approaches3, Shvaiko, 2005\nDeep Learning\nRepresentation Learning: A Review and New Perspectives17, Bengio, 2012\nDimension Reduction\nDimensionality Reduction: A Comparative Review6, Maaten, 2009\nDimension Reduction: A Guided Tour4, Burges, 2009\nA Survey of Manifold-Based Learning Methods2, Huo, 2007\nToward Integrating Feature Selection Algorithms for Classification and Clustering3, Liu, 2005\nAn Introduction to Variable and Feature Selection3, Guyon, 2003\nA Survey of Dimension Reduction Techniques2, Fodor, 2002\nEconomics\nAuctions and Bidding: A Guide for Computer Scientists1, Parsons, 2011\nComputational Sustainability1, Gomes, 2009\nComputational Finance1, Tsang, 2004\nGame Theory\nComputer Poker: A Review4, Rubin, 2011\nGraphical Models\nAn Introduction to Variational Methods for Graphical Models5, Jordan, 1999\nKernel Methods\nKernels for Vector-Valued Functions: a Review4, Alvarez, 2012\nLearning Theory\nIntroduction to Statistical Learning Theory7, Bousquet, 2004\nMachine Learning\nA Few Useful Things to Know about Machine Learning7, Domingos, 2012\nA Tutorial on Bayesian Nonparametric Models4, Blei, 2011\nDecision Forests for Classification, Regression, Density Estimation, Manifold Learning and Semi-Supervised Learning2, Criminisi, 2011\nTop 10 Algorithms in Data Mining4, Wu, 2008\nSemi-Supervised Learning Literature Survey, Zhu, 2007\nInterestingness Measures for Data Mining: A Survey, Geng, 2006\nA Survey of Interestingness Measures for Knowledge Discovery1, McGarry, 2005\nA Tutorial on the Cross-Entropy Method, Boer, 2005\nA Survey of Kernels for Structured Data, Gartner, 2003\nSurvey on Frequent Pattern Mining, Goethals, 2003\nThe Boosting Approach to Machine Learning: An Overview1, Schapire, 2003\nA Survey on Wavelet Applications in Data Mining, Li, 2002\nMathematics\nTopology and Data3, Carlsson, 2009\nMulti-armed Bandit\nRegret Analysis of Stochastic and Nonstochastic Multi-armed Bandit Problems3, Bubeck, 2012\nNatural Computing\nReservoir Computing Approaches to Recurrent Neural Network Training, Jaeger, 2009\nArtificial Immune Systems, Aickelin, 2005\nA Survey of Evolutionary Algorithms for Data Mining and Knowledge Discovery, Freitas?? , 2003\nData Mining in Soft Computing Framework: A Survey, Mitra, 2002\nNeural Networks for Classification: A Survey1, Zhang, 2000\nNatural Language Processing\nProbabilistic Topic Models2, Blei, 2012\nOntology Learning From Text: A Look Back And Into The Future1, Wong, 2012\nMachine Transliteration Survey, Karimi, 2011\nTranslation Techniques in Cross-Language Information Retrieval, Zhou, 2011\nComprehensive Review of Opinion Summarization, Kim, 2011\nA Survey on Sentiment Detection of Reviews, Tang, 2009\nWord Sense Desambiguation: A Survey, Navigli, 2009\nTopic Models, Blei, 2009\nOpinion Mining and Sentiment Analysis, Pang, 2008\nInformation Extraction, Sarawagi, 2008\nStatistical Machine Translation, Lopez, 2008\nA Survey of Named Entity Recognition and Classification, Nadeau, 2007\nAdaptive Information Extraction, Turmo, 2006\nSurvey of Text Clustering, Jing, 2005\nMachine Learning in Automated Text Categorization, Sebastiani, 2002\nWeb Mining Research: A Survey, Kosala, 2000\nNetworks\nCommunity Detection in Graphs1, Fortunato, 2010\nA Survey of Statistical Network Models, Goldenberg, 2010\nCommunities in Networks, Porter, 2009\nGraph Clustering, Schaeffer, 2007\nGraph Mining: Laws, Generators, and Algorithms, Chakrabarti, 2006\nComparing Community Structure Identification, Danon, 2005\nLink Mining: A Survey1, Getoor, 2005\nDetecting Community Structure in Networks, Newman, 2004\nLink Mining: A New Data Mining Challenge, Getoor, 2003\nOn-Line Learning\nOn-Line Algorithms in Machine Learning1, Blum, 1998\nOthers\nA Survey of Very Large-Scale Neighborhood Search Techniques, Ahuja, 2001\nPlanning and Scheduling\nA Review of Machine Learning for Automated Planning1, Jimenez, 2009\nProbabilistic\nApproximate Policy Iteration: A Survey and Some New Methods, Bertsekas, 2011\nAn Introduction to MCMC for Machine Learning1, Andrieu, 2003\nProbabilistic Models\nAn Introduction to Conditional Random Fields1, Sutton, 2010\nRandomized Algorithms\nRandomized Algorithms for Matrices and Data1, Mahoney, 2011\nRecommender Systems\nRecent advances in Personalized Recommender Systems1, Liu, 2009\nMatrix Factorization Techniques for Recommender Systems1, Koren, 2009\nA Survey of Collaborative Filtering Techniques1, Su, 2009\nRegression\nEnsemble Approaches for Regression: a Survey4, Moreira, 2012\nReinforcement Learning\nA Survey of Reinforcement Learning in Relational Domains1, Otterlo, 2005\nReinforcement Learning: A Survey, Kaelbling, 1996\nRule Learning\nAssociation Mining, Ceglar, 2006\nAlgorithms for Association Rule Mining - A General Survey and Comparison, Hipp, 2000\nTesting\nControlled Experiments on the Web: Survey and Practical Guide, Kohavi, 2009\nTime Series\nTime-Series Data Mining2, Esling, 2012\nA Review on Time Series Data Mining1, Fu, 2011\nDiscrete Wavelet Transform-Based Time Series Analysis and Mining, Chaovalit, 2011\nTransfer Learning\nA Survey on Transfer Learning, Pan, 2010\nWeb Mining\nA Taxonomy of Sequential Pattern Mining Algorithms, Mabroukeh, 2010\nA Survey of Web Clustering Engines, Carpineto, 2009\nWeb Page Classification: Features and Algorithms, Qi, 2009\nMining Interesting Knowledge from Weblogs: A Survey, Facca, 2005\nAn Overview of Web Data Clustering Practices, Vakali, 2005\nA Survey of Web Metrics, Dhyani, 2002\nData Mining for Hypertext: A Tutorial Survey3, Chakrabarti, 2000\n","categories":["图像处理与机器学习"],"tags":["机器学习"]},{"title":"推荐10个堪称神器的网站","url":"https://tanqingbo.cn/10-website/","content":"私藏的十个网站，不看后悔系列，谁用谁知道~\n1、MSDN我告诉你（https://msdn.itellyou.cn/）想重装系统，但是不知道在哪下载系统镜像？这个网站不仅可以免费下载系统镜像，而且版本特别全，最重要的是没有广告，现在很多网上的电脑系统安装完成后，都会给你的电脑安装诸多你并不需要的全家桶，但这个网站上是真正的纯净版系统，一个插件都没有。\n\n2、在线设计平台Canva（https://www.canva.cn/templates/）花了很多时间和精力学习PS，却还是一头雾水？给你介绍一个真正值得你每天都看一眼的在线设计平台—Canva。\n\n这上面能找到PPT、Vlog视频封面、动态海报等多种模板和大量版权图片字体素材，实用且颜值高，在线设计不占内存，个人使用有很多是免费的，比起全网搜罗储存资源方便多了。\n\n选中模板和素材后，直接用网站内的智能抠图，编辑排版，动效、字体特效等功能，改个字换个图，3分钟就能做好一张图。\n同时，网站还会紧跟潮流热点，实时更新站内的素材和各种设计模板，让你从此告别网上过时老套的盗版资源，真的可以说是每天值得一看的网站了。\n3、办公资源网（https://www.bangongziyuan.com/ppt/）这是一个多功能办公资源网站，比如PPT模板、Word模板、Excel模板、音效模板等等，只要和办公相关的，这里都有。\n比如ppt模板，你能想到的各种场景PPT都有，每个都是几十页的选择范围。\n\n还有里面的音效和Excel模板都是免费的，之前想要做一个收支的记账表，找了很久都没找到心仪的，最后还是花了一百多买了个wps的会员。如果早点遇到这个网站就好了，有这种需要的，可以收藏起来哦！\n\n4、IT码农网（https://tanqingbo.cn/）这个是我自己搭建的个人程序员学习网站，收集了和程序员学习相关的各种教程和资料，主要包括：计算机专业必读经典书籍下载、工具介绍和下载、各种编程语言教程、机器学习教程等。\n这都是花钱都买不到的财富！\n\n5、大数据词云在线制作（www.kt1.com）喜欢有数据感的文案，这个生成词云图的网站绝不让你失望。\n\n只要输入你想挖掘的主题词，系统通过数百亿的互联网数据搜索，精准的为你找出近期最新热点数据或历史数据提取出的高频词汇，在丰富的背景图例库中找到符合主题的图案，搭配喜欢的字体，一分钟生成一张吸睛又酷炫带有数据感的图片。\n\n词云图片已被广泛使用在演讲发布会、PPT、新闻、新媒体配图、各类文案内容中，抛开了以往沉闷的形式，用吸引眼球的方式让大数据说话。\n6、自己整理的网站书签（ http://www.bewindoweb.com/dwg.php ）这是实验室一个师兄把他大部分能想到的、有用的网站都整理成了书签，其中包括了**写论文必备、程序员通用、数据源下载、在线工具网站、设计素材、办公常用、学生常用…….**你能想到的，想不到的有用的网站都收集在这里面了，一共100多个，当你需要学习工作的时候，直接去对应的网站找到你想要的东西，大大提升你的效率，具体看下面：\n①、写论文必备\n②、程序员通用\n③、数据下载源\n④、设计素材\n⑤、在线工具网站\n⑥、学生常用\n7、在线办公（ https://uzer.me/ ）不需要安装，就可以在线编辑Office，使用PS、Visio、Xmind、Matlab、Jupyter等等大型软件。\n还有CAD、WPS、SPSS等，有了它，我们的PC上就不需要装那么多软件了。\n\n8、PPT导航网站(http://www.hippter.com/)这个网站相当一个文件合集，对PPT的资源网站进行分门别类的整理。你见过的，没见过的，它都帮你找到了！解决你所有的素材资源问题！\n\n9、全球电视直播（http://bddn.cn/zb.htm）这是一个丰富眼界的网站，你想看看外国人看的电视内容都是什么吗？这里面统统都有，不仅包含港澳台、美国、西雅图、伦敦、俄罗斯的电视节目这里都有。\n\n10、格式转换大全（ https://cn.office-converter.com/ ）**office文档格式、视频格式、音频格式、图片格式、电子书格式…….**只有你想不到，没有你找不到，有所的格式都可以在这个网站上转换。你瞅瞅：\n\n\n甚至文件压缩也是可以在这个网站上完成的：\n\n11、geektyper（ http://geektyper.com/ ）这个是程序员装B神器，我们看过很多电影，里面的黑客随便敲击两下键盘，然后代码快速滚动，然后蹦出一个进度条，某个特别厉害的系统就被破解了，后者银行的钱就没了。这个网站就可以让你体验一下当黑客的感觉，看下面的图片，是不是似曾相似，对了想认真学习技术，可以戳下方卡片了解：\n\n\n12、谷歌插件网（ http://chromecj.com/ ）因为一些众所周知的原因，谷歌浏览器上面很多实用的插件都用不了，但是有了这个网站之后，无需科学上网也可以下载chrome浏览器插件。\n\n13、免费下载电子书（ https://tanqingbo.cn/CSBook001/ ）这是一个专注于计算机、软件工程等技术书籍的网站，所有资源均可免费下载。网站的分类做得非常棒，资源也很丰富，还能看到不少2020年新出版的新书。\n\n\n希望以上网站对你有用。\n最后，给大家推荐两本算法书，记得我上本科的时候，我们老师一直跟我们强调：“算法才是编程的灵魂，一定要把算法学好。”因为不管你是Java编程爱好者、还是python的忠实粉丝，亦或觉得PHP才是这个世界最好的编程语言，都跨不过算法这个门槛。所以给大家推荐两本书，帮大家搞定算法这个难题，一本适合新手入门，一本适合找工作进阶。\n1、《我的第一本算法书》这本书是京都大学一个计算机教授和朋友联合出品的动画讲解算法的App 所衍生出来的书籍，非常适合新手朋友们。里面没有枯燥的理论和复杂的公式，而是通过大量的步骤图帮助读者加深对数据结构原理和算法执行过程的理解，便于学习和记忆。将本书作为算法入门的第一步，是非常不错的选择。\n我的第一本算法书(图灵出品)京东¥ 48.70去购买\n\n建议大家购买正版，此外也给大家准备好了高清PDF下载地址：\n链接：https://pan.baidu.com/s/1r_lxqzfg7YTHvAEQhNJwnQ\n提取码：en9j\n2、《剑指offer》这本书如果是程序员的话一定如雷贯耳，基本上只要你是程序员就一定会用到这本书，书里面剖析了50个典型的程序员面试题，从基础知识、代码质量、解题思路、优化效率和综合能力五个方面系统整理了影响面试的5个要点，是程序员找工作必备的一本书。\n正版 剑指Offer 名企面试官精讲典型编程题 第2版 程序京东¥ 337.00去购买\n\n建议大家购买正版，此外也给大家准备好了高清PDF下载地址：\n链接：https://pan.baidu.com/s/1GD9yTglFZkn5n__965dKjA\n提取码：mas8\n","categories":["工具"],"tags":["网站","工具"]},{"title":"计算机网络体系与参考模型","url":"https://tanqingbo.cn/computer-network02/","content":"计算机网络分层结构\n计算机网络为什么要采用分层结构？计算机网络分层是为了更好的管理，当网络大时，就必须采取分层，并且每一层都要实现对应的功能，这样才会更好的发展。但是分层不能太多，否则会资源浪费。\n\n分层的好处：易于更新，易于调试。易于交流，易于抽象。易于标准化。\n\n实体：任何可以发送或接受消息的硬件或者软件。通常是一个特定的软件模块。\n\n对等层：不同机器上的同一层。\n\n对等实体：同一层上的实体。\n\n\n协议\n协议是一种规则，并且控制两个对等实体的通信，协议是水平的。\n\n协议组成：\n\n语义：对构成协议元素的含义的解释，即讲什么。\n语法：数据与控制信息的结构和格式。即怎么讲。\n同步：规定事件执行的顺序。接口\n\n\n接口又被称为服务访问点，从物理层开始。每一层都向上提供服务访问点（接口），所以没有接口就不能提供服务。\n\n服务数据单元（SDU）：第n层的服务数据单元记作 n-SDU。\n协议控制信息（PCI）:第n的协议控制信息，记作 n-PIC。\n接口控制信息（ICI）:第n层的接口控制信息，记作 n-ICI。\n协议数据单元（PDU）:第n层的服务数据单元（SDU）+第n层的协议控制信息（PCI）=第n层的协议数据单元（PDU）。表示的是同等层对等实体间传送的数据单元。接口数据单元（IDU）：第n层的服务数据单元（SDU）+第n层的接口控制信息(ICI)=第n层的接口数据单元（IDU）。表示的是在相邻层接口之间传送的数据单元。服务\n\n\n服务指下层为相邻上层提供的功能调用。协议是水平的，而服务是垂直的。即下层向上层通过接口提供服务。\n\n服务分3类：\n\n.面向连接的服务和面向无连接的服务： 面向连接的服务：当通信双方通信时，要事先建立一条通信线路，该通信线路包括建立连接，使用连接、释放连接三个过程。（TCP协议）\n面向无连接的服务：通信双方不需要事先建立通信线路，而是把每个带有目的地址的包传送到线路上，由系统选择线路进行传输，（IP协议、UDP协议）\n\n\n\n\n面向连接的服务与面向无连接的服务对照：2.有应答服务与无应答服务：\n有应答服务：指接收方在收到数据后向发送方给出相应的应答。无应答服务：指接收方在收到数据后不自动给出应答。\n3.可靠服务与不可靠服务：可靠服务：指网络具有检错，纠错，应答机制。能保证数据正确。可靠地传送到达目的地。不可靠服务：指网络不能保证数据正确、可靠地传送到达目的地，网络只能尽量正确，可靠，是一种“尽力而为”的服务.\niso/osi参考模型和TCP/IP参考模型：\n五层结构的总结：OSI参考模型具有7层结构，而TCP/IP参考模型只有4层结构（一般看成5层结构）。在OSI参考模型中表示层和会话层不是重点，只需掌握5层结构。\n\n5层结构参考模型各层的总结如下表：\n\nOSI参考模型和TCP/IP参考模型的区别：\n\n会话层与表示层的基本功能：会话层：在两个结点之间建立，维护和释放面向用户的连接，并对会话进行管理控制，保证会话数据可靠传送。表示层：负责处理在两个内部数据表示结构不同的通信系统交换信息的表示格式。为数据加密解密以及提高数据的传输速率提供必要的数据压缩和解压等功能。\n\n\n计算机网络的性能指标\n.时延：指数据从网络或链路的一端传送到另外一端所需要的时间。（也称延迟或迟延）(1)发送时延（传输时延）：主机或路由器发送数据帧所需要的时间，即从发送数据帧的第一位算起到该帧的最后一位发送完毕所需要的时间，因此。发送时延也被称为传输时延。公式为：              \n 发送时延=数据帧长度（bit）/发送速率（bit/s)\n\n  (2)传播时延：是指电磁波在信道通信中传播一定距离所需要的时间。公式为：    \n 传播时延=信道长度（m）/电磁波在信道上传播的速度（m/s）\n\n  (3)处理时延：是指主机或路由器在接收到分组时进行处理所需要的时间。\n  (4)排队时延： 分组在进行网络传输时，要经过许多的路由器，但分组在进入路由器后要先在输入队列中排队等待处理，在路由器确定了转发接口后，还需要在输出队列中排队等待转发，这就产生了排队时延。\n 总时延=发送时延+传播时延+处理时延+排队时延\n\n\n\n2.时延带宽积：时延带宽积又称为以比特为单位的链路长度。\n时延带宽积=传布时延  x  带宽\n\n3..往返时间：从发送方发送数据开始，到发送方收到来自接收方的确认消息总共经历的时间。\n4.利用率：包括信道利用率和网络利用率两种；\n信道利用率：指某个信道有百分之几的时间是被利用的（有数据通过），完全空闲时利用率为0.\n网络利用率：是指全网络的信道利用率的加权平均值，\n注意：不是信道利用率与网络利用率越高越好。因为利用率越高，会导致数据在路由器中转发延时越长。\n","categories":["计算机基础知识"],"tags":["网络"]},{"title":"操作系统的运行环境","url":"https://tanqingbo.cn/OS-run-environment/","content":"操作系统的运行机制\n计算机系统中，通常CPU执行两种不同性质的程序：一种是操作系统内核程序；另一种是用户自编程序或系统外层的应用程序。对操作系统而言，这两种程序的作用不同，前者是后者的管理者，因此“管理程序”要执行一些特权指令，而“被管理程序”出于安全考虑不能执行这些指令。所谓特权指令，是指计算机中不允许用户直接使用的指令，如I/O指令、 置中断指令，存取用于内存保护的寄存器、送程序状态字到程序状态字寄存器等指令。操作系统在具体实现上划分了用户态（目态）和核心态（管态)，以严格区分两类程序。\n\n现代计算机几乎都是层次结构，操作系统的各项功能分别设置在不同层次上，一些与硬件关联较紧密的模块，诸如时钟管理、中断处理、设备驱动等处于最底层。其次是运行频率较髙的程序，诸如进程管理、存储器管理和设备管理等。这两部分内容构成了操作系统的内核。这部分内容的指令操作工作在核心态。\n\n内核一般包括四个方面的内容：\n\n时钟管理：  在计算机的各种部件中，时钟是最关键的设备。  时钟的第一功能是计时，操作系统需要通过时钟管理，向用户提供标准的系统时间。另外，通过时钟中断的管理，可以实现进程的切换。诸如，在分时操作系统中，釆用时间片轮转调度的实现；在实时系统中，按截止时间控制运行的实现；在批处理系统中，通过时钟管理来衡量一个作业的运行程度等。因此，系统管理的方方面面无不依赖于时钟。\n\n中断机制引入中断技术的初衷是提高多道程序运行环境中CPU的利用率，而且主要是针对外部设备的。\n\n原语按层次结构设计的操作系统，底层必然是一些可被调用的公用小程序，它们各自完成一个规定的操作。其特点是：1.它们处于操作系统的最底层，是最接近硬件的部分。2.这些程序的运行具有原子性——其操作只能一气呵成3.这些程序的运行时间都较短，而且调用频繁。\n\n系统控制的数据结构及处理系统中用来登记状态信息的数据结构很多，比如作业控制块、进程控制块(PCB)、设备控制块、各类链表、消息队列、缓冲区、空闲区登记表、内存分配表等。为了实现有效的管理，系统需要一些基本的操作，常见的操作有以下三种：1.进程管理：进程状态管理、进程调度和分派、创建与撤销进程控制块等。2.存储器管理：存储器的空间分配和回收、内存信息保护程序、代码对换程序等。3.设备管理：缓冲区管理、设备分配和回收等。\n\n\n\n\n中断和异常的概念\n当中断或异常发生时，运行用户态的CPU会立即进入核心态，这是通过硬件实现的.\n中断(Interruption)，也称外中断，指来自CPU执行指令以外的事件的发生，如设备发出的I/O结束中断，表示设备输入/输出处理已经完成，希望处理机能够向设备发下一个输入 / 输出请求，同时让完成输入/输出后的程序继续运行。时钟中断，表示一个固定的时间片已到，让处理机处理计时、启动定时运行的任务等。这一类中断通常是与当前程序运行无关的事件，即它们与当前处理机运行的程序无关。\n异常(Exception)，也称内中断、例外或陷入(Trap)，指源自CPU执行指令内部的事件，如程序的非法操作码、 地址越界、算术溢出、虚存系统的缺页以及专门的陷入指令等引起的事件。对异常的处理一般要依赖于当前程序的运行现场，而且异常不能被屏蔽，一旦出现应立即处理。关于内中断和外中断的联系与区别如图1-2所示。\n\n\n系统调用\n所谓系统调用就是用户在程序中调用操作系统所提供的一些子功能，系统调用可以被看做特殊的公共子程序。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（如存储分配、进行I/0传输以及管理文件等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。通常，一个操作系统提供的系统调用命令有几十乃至上百条之多。\n\n这些系统调用按功能大致可分为如下几类：\n\n设备管理。完成设备的请求或释放，以及设备启动等功能。\n文件管理。完成文件的读、写、创建及删除等功能。\n进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。\n进程通信。完成进程之间的消息传递或信号传递等功能。\n内存管理。完成内存的分配、回收以及获取作业占用内存区大小及始址等功能。\n\n\n系统调用运行在系统的核心态。通过系统调用的方式来使用系统功能，可以保证系统的稳定性和安全性，防止用户随意更改或访问系统的数据或命令。系统调用命令是由操作系统提供的一个或多个子程序模块实现的。\n\n操作系统的运行环境可以理解为：用户通过操作系统运行上层程序（如系统提供的命令解释程序或用户自编程序)，而这个上层程序的运行依赖于操作系统的底层管理程序提供服务支持，当需要管理程序服务时，系统则通过硬件中断机制进入核心态，运行管理程序；也可能是程序运行出现异常情况，被动地需要管理程序的服务，这时就通过异常处理来进入核心态。当管理程序运行结束时，用户程序需要继续运行，则通过相应的保存的程序现场退出中断处理程序或异常处理程序，返回断点处继续执行。\n\n由用户态转向核心态的例子：\n\n\n\n用户程序要求操作系统的服务，即系统调用。\n发生一次中断。\n用户程序中产生了一个错误状态。\n用户程序中企图执行一条特权指令。\n从核心态转向用户态由一条指令实现，这条指令也是特权命令。一般是中断返回指令。\n\n","categories":["计算机基础知识"],"tags":["操作系统"]},{"title":"计算机网络五层协议中的第一层--物理层","url":"https://tanqingbo.cn/computer-network01/","content":"物理层一般有三种传输介质：有线（铜线和光纤）、无线（陆地无线电）和卫星。\n这里要说的是信号在物理层存在的两种方式，数字信号（电脑可以识别的0和1即比特），模拟信号是铜线和光纤等可以传输的电信号或者无线信号，在现实中模拟信号的存在方式诸如连续变化的电压，而在无线传输中类似光照强度或者声音强度。\n\n电话调制解调器：要在本地回路或任何其他物理信道上发送比特，必须把比特转换为可在信道上传输的模拟信号。执行数字比特流和模拟信号流（代表这些数字比特）之间转换的设备成为调制解调器（也就是传说中的mdoem，猫），调制解调器是调制器（modulator）和解调器（demodulator）的缩写。调制解调器分为许多类型：电话调制解调器、DSL调制解调器、有线电视调制解调器和无线调制解调器等。\n\n数据交换：电话系统中用到了两种不同的交换技术：电路交换和数据包交换。传统的电话系统基于电路交换技术，但随着IP技术之上的语音通信兴起，数据包交换已经取得了长足的进步。电路交换的一个重要特点是在发送数据之前需要建立一条端到端的路径。从拨完号码到开始响铃，这段时间可能需要10秒钟，长途电话和国际长途电话所需要的时间更长。数据包交换是电路交换的一个替代方案，它无须像电路交换那样要事先设立一条专门的路径。路由器使用存储-转发传输技术，把经由它的每个数据包发送到通往该包目的地的路径上。这个转发过程与电路交换不同，在电路交换中，连接的建立过程预留了从发送端到接收端一条路上的带路资源，该条电路上的所有数据将走相同的路径。另一方面，让所有的数据遵循同样的路径意味着它们到达接收端的顺序不可能出现混乱。而在数据包交换中，没有固定的路径，不同的数据包可以走不同的路径，路径的选择取决于它们被传输时的网络状况，所以它们到达接收端的顺序可能是混乱的。\n\n电路交换和数据包交换的区别：\n\n数据包和电路交换在其他方面也有所不同。因为数据包交换中没有为传输数据预留带宽，数据包可能不得不等待一段时间才能被转发。这样就引入了排队延迟（queuing delay），如果许多包要在同一时间被发送出去还会引入拥塞。在电话交换中拥塞发生在建立电路时，而在数据包交换中拥塞发生在转发数据包时。\n对于电路交换如果一条电路已经预留给了某一个特定的用户，但是并没有流量通过这条电路，那么这条电路的带宽就会浪费，类似电话两端的人都接通的了电话但是彼此都没有说话，那么用电路交换这种方式，无疑是对当前链路的一种浪费。数据包交换就不会浪费带宽，因此从整个系统角度来看数据包交换的效率更高。我们要做的权衡是：要么保证服务质量但是可能浪费资源，要么不保证服务质量，也不浪费资源。\n其次数据包交换比电路交换的容错性更好。事实上，这也是为什么数据包交换会被发明出来，并且最终替代电路交换的主要原因。在电路交换中，如果链路中间的一个交换机出现故障，那么经过这个交换机的所有链路都将被终止，而数据包交换，数据可以绕过死掉的交换机通过其他好的交换机转发出去。对于数据包交换，数据的走向是不确定的，它会选择合适的路径最终到达我们希望它去到的地方。\n最后电路交换和数据包交换使用的收费方式不同，电路交换是按时间收费，而数据包交换是按流量计费。\n 项目    电路交换    包交换\n呼叫建立    需要    不需要\n专用的物理路径    需要    不需要\n每个包遵循相同的路由    是    不是\n包按顺序到达    是    不是\n交换机崩溃是否致命    是    不是\n可用带宽    固定    动态\n可能拥塞的时间    呼叫建立时    在每个包排队时\n潜在浪费带宽    是    不是\n存储-转发传输    不是    是\n收费    按分钟就计费    按包计费\n\n通过上面的表格我们很容易发现包交换和电路交换相比还是有很多优势的。\n\n\n\nADSL和有线电视电缆有线电视使用了同轴电缆，而ADSL使用了双绞线\n\n\n注： ADSL:ADSL属于DSL技术的一种，全称Asymmetric Digital Subscriber Line（ 非对称数字用户线路），亦可称作非对称数字用户环路。是一种新的数据传输方式。ADSL技术采用频分复用技术把普通的电话线分成了电话、上行和下行三个相对独立的信道，从而避免了相互之间的干扰。用户可以边打电话边上网，不用担心上网速率和通话质量下降的情况。理论上，ADSL 可在5 km 的范围内，在一对铜缆双绞线上提供最高1 Mbps的的上行速率和最高8Mbps的下行速率（也就是我们通常说的带宽），能同时提供话音和数据业务。一般来说，ADSL 速率完全取决于线路的距离，线路越长，速率越低。\n","categories":["计算机基础知识"],"tags":["网络"]},{"title":"操作系统之进程与线程","url":"https://tanqingbo.cn/OS-processes-threads/","content":"任务调度大部分操作系统(如Windows、Linux)的任务调度是采用时间片轮转的抢占式调度方式，也就是说一个任务执行一小段时间后强制暂停去执行下一个任务，每个任务轮流执行。任务执行的一小段时间叫做时间片，任务正在执行时的状态叫运行状态，任务执行一段时间后强制暂停去执行下一个任务，被暂停的任务就处于就绪状态等待下一个属于它的时间片的到来。这样每个任务都能得到执行，由于CPU的执行效率非常高，时间片非常短，在各个任务之间快速地切换，给人的感觉就是多个任务在“同时进行”，这也就是我们所说的并发。\n进程\n应用程序是具有某种功能的程序，程序是运行于操作系统之上的。\n\n进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。\n\n进程一般由程序、数据集合和进程控制块三部分组成。程序用于描述进程要完成的功能，是控制进程执行的指令集；数据集合是程序在执行时所需要的数据和工作区；程序控制块(Program Control Block，简称PCB)，包含进程的描述信息和控制信息，是进程存在的唯一标志。\n\n进程具有的特征：\n\n动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；\n并发性：任何进程都可以同其他进程一起并发执行；\n独立性：进程是系统进行资源分配和调度的一个独立单位；\n结构性：进程由程序、数据和进程控制块三部分组成。\n\n\n\n线程\n线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间\n线程组成：\n线程ID\n当前指令指针(PC)\n寄存器和堆栈。\n\n而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。\n\n进程与线程的区别\n线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；\n一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；\n进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)，某进程内的线程在其它进程不可见；\n调度和切换：线程上下文切换比进程上下文切换要快得多。\n\n\n\n总之，线程和进程都是一种抽象的概念，线程是一种比进程更小的抽象，线程和进程都可用于实现并发。\n在早期的操作系统中并没有线程的概念，进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。它相当于一个进程里只有一个线程，进程本身就是线程。所以线程有时被称为轻量级进程\n\n多线程与多核\n多核(心)处理器是指在一个处理器上集成多个运算核心从而提高计算能力，也就是有多个真正并行计算的处理核心，每一个处理核心对应一个内核线程.\n内核线程（Kernel Thread， KLT）就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操作调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。\n\n进程与线程的生命周期\n当线程的数量小于处理器的数量时，线程的并发是真正的并发，不同的线程运行在不同的处理器上。但当线程的数量大于处理器的数量时，线程的并发会受到一些阻碍，此时并不是真正的并发，因为此时至少有一个处理器会运行多个线程。\n\n在单个处理器运行多个线程时，并发是一种模拟出来的状态。\n\n在早期只有进程的操作系统中，进程有五种状态，创建、就绪、运行、阻塞(等待)、退出。早期的进程相当于现在的只有单个线程的进程，那么现在的多线程也有五种状态，现在的多线程的生命周期与早期进程的生命周期类似。\n\n进程在运行过程有三种状态：就绪、运行、阻塞，创建和退出状态描述的是进程的创建过程和退出过程。创建：进程正在创建，还不能运行。操作系统在创建进程时要进行的工作包括分配和建立进程控制块表项、建立资源表格并分配资源、加载程序并建立地址空间；就绪：时间片已用完，此线程被强制暂停，等待下一个属于他的时间片到来；运行：此线程正在执行，正在占用时间片；阻塞：也叫等待状态，等待某一事件(如IO或另一个线程)执行完；退出：进程已结束，所以也称结束状态，释放操作系统分配的资源。\n\n线程的生命周期\n\n\n\n创建：一个新的线程被创建，等待该线程被调用执行；就绪：时间片已用完，此线程被强制暂停，等待下一个属于他的时间片到来；运行：此线程正在执行，正在占用时间片；阻塞：也叫等待状态，等待某一事件(如IO或另一个线程)执行完；退出：一个线程完成任务或者其他终止条件发生，该线程终止进入退出状态，退出状态释放该线程所分配的资源。\n","categories":["计算机基础知识"],"tags":["操作系统"]},{"title":"计算机网络之局域网搭建","url":"https://tanqingbo.cn/CS-network/","content":"局域网搭建配置以太网交换机的主机名、Console口令、远程登录口令、超级密码\n准备的内容：\n我们得知道交换机所在的位置？—-为交换机准备一个IP地址。&lt;br/1.1 交换机IP地址的配置在哪里？—-配置在虚拟端口VLAN1上需要访问交换机的端口：switchenable  ---  switch#  (config terminal---)switch(config)# (interface ID---) switch(config-if)#switch(config-if)#ip address 10.0.0.1 255.0.0.0\n\n\n\n\n配置本地主机，让其与交换机在同一个网段上。\n\n继续回到交换机做准备工作\n\n开放远程telnet访问：–配置虚拟终端访问协议,虚拟终端访问在交换机上通过虚拟终端线路设置来完成的，要在line模式下完成    \nswitch（config）#line vty 0 5switch（config-line）#password xxx    switch（config-line）#login\n\n\n\n\n\n\n\n继续设置我们的交换机开放交换机的特权命令，要求为enable命令设置一个密码\nswitch(config)enable password yyyy\n\n\n\nvlan划分\n观察当前交换机的划分形式，特权模式用show命令观察。\nSwitchenable  Switch#show vlan\tVLAN Name                                   Status    Ports\t 1    default  active    Fa0/2, Fa0/3, Fa0/4, Fa0/5\tFa0/6, Fa0/7, Fa0/8, Fa0/9\tFa0/10, Fa0/11, Fa0/12, Fa0/13\tFa0/14, Fa0/15, Fa0/16, Fa0/17\tFa0/18, Fa0/19, Fa0/20, Fa0/21\tFa0/22, Fa0/23, Fa0/24, Gig1/1\t\t\t\t\t\t\t\t\t\tGig1/2 100  VLAN0100                         active    Fa0/1 1002 fddi-default                     act/unsup  1003 token-ring-default               act/unsup    1004 fddinet-default                  act/unsup    1005 trnet-default                    act/unsup \n\n\n\n\n用特权模式打开vlan表Switch#vlan database#创建新的vlan端口Switch(vlan)#vlan 100、#为vlan添加成员端口Switch(vlan)#exit#进入全局模式Switch#configure terminal#设置端口Switch(config)#interface Fa0/1Switch(config-if)##也可以批量设置端口Switch(config)#interface range fa0/1 - 4Switch(config-if-range)##下面以单个端口演示，批量端口是一样的,将端口放在vlan 100下面Switch(config-if)#switchport access vlan 100\n上面的命令就可以将端口放到指定vlan下面，广播信号只能在同一个vlan下发送，能有效缩小广播范围\n删除vlan：先归还成员，在删除vlan\n Switch#vlan databaseno vlan 100\n\n\n\n\n跨交换机vlan划分\n必须保证相同vlan ID的端口间才可以通信\n\n公共端口必须工作在中继模式下\nSwitch(config-if)#switchport mode trunk #公共的两个端口都要这样设置\n\n\n\n\n\n访问控制列表（1~99）\n全局模式建立如下规则列表\nRouter(config)#access-list 1 deny 192.168.1.0 0.0.0.255Router(config)#access-list 1 permit any\n\n\n\n\n\n该规则含义为：拒绝IP地址前缀为192.168.1.的访问，然后允许除此之外的所有IP地址访问。接下来将此规则应用到某个接口上。\nRouter(config)#int fa1/0Router(config-if)#ip access-group 1 out注：进入路由器是 in    出路由器是  out\n\n\n\n扩展访问控制列表（100~199）\n全局模式建立如下规则列表\nRouter(config)#access-list 100 deny tcp host 192.168.1.2 host 200.11.180.2 eq 80Router(config)#access-list 100 permit tcp host 192.168.1.2 host 200.11.180.2 eq 21Router(config)#access-list 100 permit any any\n\n该规则含义为:不允许IP地址为192.168.1.2的主机通过http协议访问IP地址为200.11.180.2的主机，但是可以通过ftp的协议方式访问。\n该规则含义为:不允许IP地址为192.168.1.2的主机通过http协议访问IP地址为200.11.180.2的主机，但是可以通过ftp的协议方式访问。\n\n将该规则应用到某端口的方法同上。\nDNS域名解析\n\n\n想要通过域名访问外网某个web页面，得先在本网段建一个域名解析服务器。\n\n\n\n\n在域名服务器中-config-DNS中添加域名对应的IP地址。\n\n\n在发送请求的电脑的DNS Server 中填上域名服务器的IP地址。注：请求电脑和域名解析服务器得在同一个Vlan下。\n\n\n","categories":["计算机基础知识"],"tags":["计算机网络"]},{"title":"超详细最新版Chrome插件安装方法!","url":"https://tanqingbo.cn/Chrome-crx/","content":"一、 拖动安装(推荐)在地址栏输入 chrome://extensions/打开 开发者模式 的开关拖动 xxx.crx 文件到Chrome中间即可\n如下图，按住 xxxxxx.crx 拖动到chrome扩展中心\n弹出安装确认的提示框，说明操作成功，点击确定即可\n\n二、 暴力安装（不太推荐此方法，如果方法1拖动安装无效的情况下，可以尝试暴力安装）\n把下载好的xxx.crx 的扩展名改为 xxx.zip\n在地址栏输入 chrome://extensions/打开 开发者模式 的开关拖动 xxx.zip 文件到Chrome中间即可\n如下图，按住 xxxxxx.zip 拖动到chrome扩展中心\n安装完成后会直接看到，打开插件开关即可\n该方法大部分情况下可以一次成功，个别时候会收到浏览器安全提醒，忽略即可\n","categories":["工具"],"tags":["工具","Chrome"]},{"title":"从最大似然、贝叶斯估计到EM算法浅解","url":"https://tanqingbo.cn/Maximum-Likelihood-to-EM-algorithm/","content":"机器学习十大算法之一：EM算法。\n能评得上十大之一，让人听起来觉得挺NB的。什么是NB啊，我们一般说某个人很NB，是因为他能解决一些别人解决不了的问题。神为什么是神，因为神能做很多人做不了的事。那么EM算法能解决什么问题呢？或者说EM算法是因为什么而来到这个世界上，还吸引了那么多世人的目光。\n一、最大似然\n进入正题。假设我们遇到的是下面这样的问题：\n\n假设我们需要调查我们学校的男生和女生的身高分布。你怎么做啊？你说那么多人不可能一个一个去问吧，肯定是抽样了。假设你在校园里随便地活捉了100个男生和100个女生。他们共200个人（也就是200个身高的样本数据，为了方便表示，下面，我说“人”的意思就是对应的身高）都在教室里面了。那下一步怎么办啊？你开始喊：“男的左边，女的右边，其他的站中间！”。然后你就先统计抽样得到的100个男生的身高。假设他们的身高是服从高斯分布的。但是这个分布的均值u和方差∂2我们不知道，这两个参数就是我们要估计的。记作θ=[u, ∂]T。\n\n\n用数学的语言来说就是：在学校那么多男生（身高）中，我们独立地按照概率密度p(x|θ)抽取100了个（身高），组成样本集X，我们想通过样本集X来估计出未知参数θ。这里概率密度p(x|θ)我们知道了是高斯分布N(u,∂)的形式，其中的未知参数是θ=[u, ∂]T。抽到的样本集是X={x1,x2,…,xN}，其中xi表示抽到的第i个人的身高，这里N就是100，表示抽到的样本个数。\n\n由于每个样本都是独立地从p(x|θ)中抽取的，换句话说这100个男生中的任何一个，都是我随便捉的，从我的角度来看这些男生之间是没有关系的。那么，我从学校那么多男生中为什么就恰好抽到了这100个人呢？抽到这100个人的概率是多少呢？因为这些男生（的身高）是服从同一个高斯分布p(x|θ)的。那么我抽到男生A（的身高）的概率是p(xA|θ)，抽到男生B的概率是p(xB|θ)，那因为他们是独立的，所以很明显，我同时抽到男生A和男生B的概率是p(xA|θ)* p(xB|θ)，同理，我同时抽到这100个男生的概率就是他们各自概率的乘积了。用数学家的口吻说就是从分布是p(x|θ)的总体样本中抽取到这100个样本的概率，也就是样本集X中各个样本的联合概率，用下式表示：\n\n\n\n\n\n\n这个概率反映了，在概率密度函数的参数是θ时，得到X这组样本的概率。因为这里X是已知的，也就是说我抽取到的这100个人的身高可以测出来，也就是已知的了。而θ是未知了，则上面这个公式只有θ是未知数，所以它是θ的函数。这个函数放映的是在不同的参数θ取值下，取得当前这个样本集的可能性，因此称为参数θ相对于样本集X的似然函数（likehood function）。记为L(θ)。\n\n这里出现了一个概念，似然函数。还记得我们的目标吗？我们需要在已经抽到这一组样本X的条件下，估计参数θ的值。怎么估计呢？似然函数有啥用呢？那咱们先来了解下似然的概念。\n\n\n直接举个例子：\n某位同学与一位猎人一起外出打猎，一只野兔从前方窜过。只听一声枪响，野兔应声到下，如果要你推测，这一发命中的子弹是谁打的？你就会想，只发一枪便打中，由于猎人命中的概率一般大于这位同学命中的概率，看来这一枪是猎人射中的。\n\n这个例子所作的推断就体现了极大似然法的基本思想。\n\n再例如：下课了，一群男女同学分别去厕所了。然后，你闲着无聊，想知道课间是男生上厕所的人多还是女生上厕所的人比较多，然后你就跑去蹲在男厕和女厕的门口。蹲了五分钟，突然一个美女走出来，你狂喜，跑过来告诉我，课间女生上厕所的人比较多，你要不相信你可以进去数数。呵呵，我才没那么蠢跑进去数呢，到时还不得上头条。我问你是怎么知道的。你说：“5分钟了，出来的是女生，女生啊，那么女生出来的概率肯定是最大的了，或者说比男生要大，那么女厕所的人肯定比男厕所的人多”。看到了没，你已经运用最大似然估计了。你通过观察到女生先出来，那么什么情况下，女生会先出来呢？肯定是女生出来的概率最大的时候了，那什么时候女生出来的概率最大啊，那肯定是女厕所比男厕所多人的时候了，这个就是你估计到的参数了。\n\n从上面这两个例子，你得到了什么结论？\n\n回到男生身高那个例子。在学校那么男生中，我一抽就抽到这100个男生（表示身高），而不是其他人，那是不是表示在整个学校中，这100个人（的身高）出现的概率最大啊。那么这个概率怎么表示？哦，就是上面那个似然函数L(θ)。所以，我们就只需要找到一个参数θ，其对应的似然函数L(θ)最大，也就是说抽到这100个男生（的身高）概率最大。这个叫做θ的最大似然估计量，记为：\n\n\n有时，可以看到L(θ)是连乘的，所以为了便于分析，还可以定义对数似然函数，将其变成连加的：\n\n\n好了，现在我们知道了，要求θ，只需要使θ的似然函数L(θ)极大化，然后极大值对应的θ就是我们的估计。这里就回到了求最值的问题了。怎么求一个函数的最值？当然是求导，然后让导数为0，那么解这个方程得到的θ就是了（当然，前提是函数L(θ)连续可微）。那如果θ是包含多个参数的向量那怎么处理啊？当然是求L(θ)对所有参数的偏导数，也就是梯度了，那么n个未知的参数，就有n个方程，方程组的解就是似然函数的极值点了，当然就得到这n个参数了。\n\n最大似然估计你可以把它看作是一个反推。多数情况下我们是根据已知条件来推算结果，而最大似然估计是已经知道了结果，然后寻求使该结果出现的可能性最大的条件，以此作为估计值。比如，如果其他条件一定的话，抽烟者发生肺癌的危险时不抽烟者的5倍，那么如果现在我已经知道有个人是肺癌，我想问你这个人抽烟还是不抽烟。你怎么判断？你可能对这个人一无所知，你所知道的只有一件事，那就是抽烟更容易发生肺癌，那么你会猜测这个人不抽烟吗？我相信你更有可能会说，这个人抽烟。为什么？这就是“最大可能”，我只能说他“最有可能”是抽烟的，“他是抽烟的”这一估计值才是“最有可能”得到“肺癌”这样的结果。这就是最大似然估计。\n\n好了，极大似然估计就讲到这，总结一下：\n\n极大似然估计，只是一种概率论在统计学的应用，它是参数估计的方法之一。说的是已知某个随机样本满足某种概率分布，但是其中具体的参数不清楚，参数估计就是通过若干次试验，观察其结果，利用结果推出参数的大概值。最大似然估计是建立在这样的思想上：已知某个参数能使这个样本出现的概率最大，我们当然不会再去选择其他小概率的样本，所以干脆就把这个参数作为估计的真实值。\n\n\n求最大似然函数估计值的一般步骤：\n\n\n（1）写出似然函数；\n（2）对似然函数取对数，并整理；\n（3）求导数，令导数为0，得到似然方程；\n（4）解似然方程，得到的参数即为所求；\n二、EM算法\n好了，重新回到上面那个身高分布估计的问题。现在，通过抽取得到的那100个男生的身高和已知的其身高服从高斯分布，我们通过最大化其似然函数，就可以得到了对应高斯分布的参数θ=[u, ∂]T了。那么，对于我们学校的女生的身高分布也可以用同样的方法得到了。\n\n再回到例子本身，如果没有“男的左边，女的右边，其他的站中间！”这个步骤，或者说我抽到这200个人中，某些男生和某些女生一见钟情，已经好上了，纠缠起来了。咱们也不想那么残忍，硬把他们拉扯开。那现在这200个人已经混到一起了，这时候，你从这200个人（的身高）里面随便给我指一个人（的身高），我都无法确定这个人（的身高）是男生（的身高）还是女生（的身高）。也就是说你不知道抽取的那200个人里面的每一个人到底是从男生的那个身高分布里面抽取的，还是女生的那个身高分布抽取的。用数学的语言就是，抽取得到的每个样本都不知道是从哪个分布抽取的。\n\n这个时候，对于每一个样本或者你抽取到的人，就有两个东西需要猜测或者估计的了，一是这个人是男的还是女的？二是男生和女生对应的身高的高斯分布的参数是多少？\n\n只有当我们知道了哪些人属于同一个高斯分布的时候，我们才能够对这个分布的参数作出靠谱的预测，例如刚开始的最大似然所说的，但现在两种高斯分布的人混在一块了，我们又不知道哪些人属于第一个高斯分布，哪些属于第二个，所以就没法估计这两个分布的参数。反过来，只有当我们对这两个分布的参数作出了准确的估计的时候，才能知道到底哪些人属于第一个分布，那些人属于第二个分布。\n\n这就成了一个先有鸡还是先有蛋的问题了。鸡说，没有我，谁把你生出来的啊。蛋不服，说，没有我，你从哪蹦出来啊。（呵呵，这是一个哲学问题。当然了，后来科学家说先有蛋，因为鸡蛋是鸟蛋进化的）。为了解决这个你依赖我，我依赖你的循环依赖问题，总得有一方要先打破僵局，说，不管了，我先随便整一个值出来，看你怎么变，然后我再根据你的变化调整我的变化，然后如此迭代着不断互相推导，最终就会收敛到一个解。这就是EM算法的基本思想了。\n\n不知道大家能否理解其中的思想，我再来啰嗦一下。其实这个思想无处在不啊。\n\n例如，小时候，老妈给一大袋糖果给你，叫你和你姐姐等分，然后你懒得去点糖果的个数，所以你也就不知道每个人到底该分多少个。咱们一般怎么做呢？先把一袋糖果目测的分为两袋，然后把两袋糖果拿在左右手，看哪个重，如果右手重，那很明显右手这代糖果多了，然后你再在右手这袋糖果中抓一把放到左手这袋，然后再感受下哪个重，然后再从重的那袋抓一小把放进轻的那一袋，继续下去，直到你感觉两袋糖果差不多相等了为止。呵呵，然后为了体现公平，你还让你姐姐先选了。\n\n\nEM算法就是这样，假设我们想估计知道A和B两个参数，在开始状态下二者都是未知的，但如果知道了A的信息就可以得到B的信息，反过来知道了B也就得到了A。可以考虑首先赋予A某种初值，以此得到B的估计值，然后从B的当前值出发，重新估计A的取值，这个过程一直持续到收敛为止。\n\nEM的意思是“Expectation Maximization”，在我们上面这个问题里面，我们是先随便猜一下男生（身高）的正态分布的参数：如均值和方差是多少。例如男生的均值是1米7，方差是0.1米（当然了，刚开始肯定没那么准），然后计算出每个人更可能属于第一个还是第二个正态分布中的（例如，这个人的身高是1米8，那很明显，他最大可能属于男生的那个分布），这个是属于Expectation一步。有了每个人的归属，或者说我们已经大概地按上面的方法将这200个人分为男生和女生两部分，我们就可以根据之前说的最大似然那样，通过这些被大概分为男生的n个人来重新估计第一个分布的参数，女生的那个分布同样方法重新估计。这个是Maximization。然后，当我们更新了这两个分布的时候，每一个属于这两个分布的概率又变了，那么我们就再需要调整E步……如此往复，直到参数基本不再发生变化为止。\n\n这里把每个人（样本）的完整描述看做是三元组yi={xi,zi1,zi2}，其中，xi是第i个样本的观测值，也就是对应的这个人的身高，是可以观测到的值。zi1和zi2表示男生和女生这两个高斯分布中哪个被用来产生值xi，就是说这两个值标记这个人到底是男生还是女生（的身高分布产生的）。这两个值我们是不知道的，是隐含变量。确切的说，zij在xi由第j个高斯分布产生时值为1，否则为0。例如一个样本的观测值为1.8，然后他来自男生的那个高斯分布，那么我们可以将这个样本表示为{1.8, 1, 0}。如果zi1和zi2的值已知，也就是说每个人我已经标记为男生或者女生了，那么我们就可以利用上面说的最大似然算法来估计他们各自高斯分布的参数。但是它们未知，因此我们只能用EM算法。\n\n咱们现在不是因为那个恶心的隐含变量（抽取得到的每个样本都不知道是从哪个分布抽取的）使得本来简单的可以求解的问题变复杂了，求解不了吗。那怎么办呢？人类解决问题的思路都是想能否把复杂的问题简单化。好，那么现在把这个复杂的问题逆回来，我假设已经知道这个隐含变量了，哎，那么求解那个分布的参数是不是很容易了，直接按上面说的最大似然估计就好了。那你就问我了，这个隐含变量是未知的，你怎么就来一个假设说已知呢？你这种假设是没有根据的。呵呵，我知道，所以我们可以先给这个给分布弄一个初始值，然后求这个隐含变量的期望，当成是这个隐含变量的已知值，那么现在就可以用最大似然求解那个分布的参数了吧，那假设这个参数比之前的那个随机的参数要好，它更能表达真实的分布，那么我们再通过这个参数确定的分布去求这个隐含变量的期望，然后再最大化，得到另一个更优的参数，……迭代，就能得到一个皆大欢喜的结果了。\n\n这时候你就不服了，说你老迭代迭代的，你咋知道新的参数的估计就比原来的好啊？为什么这种方法行得通呢？有没有失效的时候呢？什么时候失效呢？用到这个方法需要注意什么问题呢？呵呵，一下子抛出那么多问题，搞得我适应不过来了，不过这证明了你有很好的搞研究的潜质啊。呵呵，其实这些问题就是数学家需要解决的问题。在数学上是可以稳当的证明的或者得出结论的。那咱们用数学来把上面的问题重新描述下。（在这里可以知道，不管多么复杂或者简单的物理世界的思想，都需要通过数学工具进行建模抽象才得以使用并发挥其强大的作用，而且，这里面蕴含的数学往往能带给你更多想象不到的东西，这就是数学的精妙所在啊）\n\n\n三、EM算法推导\n假设我们有一个样本集{x(1),…,x(m)}，包含m个独立的样本。但每个样本i对应的类别z(i)是未知的（相当于聚类），也即隐含变量。故我们需要估计概率模型p(x,z)的参数θ，但是由于里面包含隐含变量z，所以很难用最大似然求解，但如果z知道了，那我们就很容易求解了。\n\n对于参数估计，我们本质上还是想获得一个使似然函数最大化的那个参数θ，现在与最大似然不同的只是似然函数式中多了一个未知的变量z，见下式（1）。也就是说我们的目标是找到适合的θ和z让L(θ)最大。那我们也许会想，你就是多了一个未知的变量而已啊，我也可以分别对未知的θ和z分别求偏导，再令其等于0，求解出来不也一样吗？\n\n\n\n\n本质上我们是需要最大化（1）式（对（1）式，我们回忆下联合概率密度下某个变量的边缘概率密度函数的求解，注意这里z也是随机变量。对每一个样本i的所有可能类别z求等式右边的联合概率密度函数和，也就得到等式左边为随机变量x的边缘概率密度），也就是似然函数，但是可以看到里面有“和的对数”，求导后形式会非常复杂（自己可以想象下log(f1(x)+ f2(x)+ f3(x)+…)复合函数的求导），所以很难求解得到未知参数z和θ。那OK，我们可否对（1）式做一些改变呢？我们看（2）式，（2）式只是分子分母同乘以一个相等的函数，还是有“和的对数”啊，还是求解不了，那为什么要这么做呢？咱们先不管，看（3）式，发现（3）式变成了“对数的和”，那这样求导就容易了。我们注意点，还发现等号变成了不等号，为什么能这么变呢？这就是Jensen不等式的大显神威的地方。\n\nJensen不等式：\n设f是定义域为实数的函数，如果对于所有的实数x。如果对于所有的实数x，f(x)的二次导数大于等于0，那么f是凸函数。当x是向量时，如果其hessian矩阵H是半正定的，那么f是凸函数。如果只大于0，不等于0，那么称f是严格凸函数。\n\nJensen不等式表述如下：\n\n如果f是凸函数，X是随机变量，那么：E[f(X)]&gt;=f(E[X])\n\n特别地，如果f是严格凸函数，当且仅当X是常量时，上式取等号。\n\n如果用图表示会很清晰：\n\n\n图中，实线f是凸函数，X是随机变量，有0.5的概率是a，有0.5的概率是b。（就像掷硬币一样）。X的期望值就是a和b的中值了，图中可以看到E[f(X)]&gt;=f(E[X])成立。\n\n当f是（严格）凹函数当且仅当-f是（严格）凸函数。\n\nJensen不等式应用于凹函数时，不等号方向反向。\n\n\n\n\n回到公式（2），因为f(x)=log x为凹函数（其二次导数为-1/x2&lt;0）。\n\n（2）式中的期望，（考虑到E(X)=∑x*p(x)，f(X)是X的函数，则E(f(X))=∑f(x)*p(x)），又，所以就可以得到公式（3）的不等式了（若不明白，请拿起笔，呵呵）：\n\n\n\n\nOK，到这里，现在式（3）就容易地求导了，但是式（2）和式（3）是不等号啊，式（2）的最大值不是式（3）的最大值啊，而我们想得到式（2）的最大值，那怎么办呢？\n\n现在我们就需要一点想象力了，上面的式（2）和式（3）不等式可以写成：似然函数L(θ)&gt;=J(z,Q)，那么我们可以通过不断的最大化这个下界J，来使得L(θ)不断提高，最终达到它的最大值。\n\n\n\n\n见上图，我们固定θ，调整Q(z)使下界J(z,Q)上升至与L(θ)在此点θ处相等（绿色曲线到蓝色曲线），然后固定Q(z)，调整θ使下界J(z,Q)达到最大值（θt到θt+1），然后再固定θ，调整Q(z)……直到收敛到似然函数L(θ)的最大值处的θ*。这里有两个问题：什么时候下界J(z,Q)与L(θ)在此点θ处相等？为什么一定会收敛？\n\n首先第一个问题，在Jensen不等式中说到，当自变量X是常数的时候，等式成立。而在这里，即：\n\n\n\n\n再推导下，由于（因为Q是随机变量z(i)的概率密度函数），则可以得到：分子的和等于c（分子分母都对所有z(i)求和：多个等式分子分母相加不变，这个认为每个样例的两个概率比值都是c），则：\n\n\n\n至此，我们推出了在固定参数θ后，使下界拉升的Q(z)的计算公式就是后验概率，解决了Q(z)如何选择的问题。这一步就是E步，建立L(θ)的下界。接下来的M步，就是在给定Q(z)后，调整θ，去极大化L(θ)的下界J（在固定Q(z)后，下界还可以调整的更大）。那么一般的EM算法的步骤如下：\n\nEM算法（Expectation-maximization）：\n期望最大算法是一种从不完全数据或有数据丢失的数据集（存在隐含变量）中求解概率模型参数的最大似然估计方法。\n\nEM的算法流程：\n初始化分布参数θ；\n\n重复以下步骤直到收敛：\nE步骤：根据参数初始值或上一次迭代的模型参数来计算出隐性变量的后验概率，其实就是隐性变量的期望。作为隐藏变量的现估计值：\n\n\n\nM步骤：将似然函数最大化以获得新的参数值：\n\n\n\n这个不断的迭代，就可以得到使似然函数L(θ)最大化的参数θ了。那就得回答刚才的第二个问题了，它会收敛吗？\n\n感性的说，因为下界不断提高，所以极大似然估计单调增加，那么最终我们会到达最大似然估计的最大值。理性分析的话，就会得到下面的东西：\n\n\n\n\n具体如何证明的，看推导过程参考：Andrew Ng《The EM algorithm》:http://www.cnblogs.com/jerrylead/archive/2011/04/06/2006936.html\n\n四、EM算法另一种理解\n坐标上升法（Coordinate ascent）：\n\n\n\n图中的直线式迭代优化的路径，可以看到每一步都会向最优值前进一步，而且前进路线是平行于坐标轴的，因为每一步只优化一个变量。\n\n这犹如在x-y坐标系中找一个曲线的极值，然而曲线函数不能直接求导，因此什么梯度下降方法就不适用了。但固定一个变量后，另外一个可以通过求导得到，因此可以使用坐标上升法，一次固定一个变量，对另外的求极值，最后逐步逼近极值。对应到EM上，E步：固定θ，优化Q；M步：固定Q，优化θ；交替将极值推向最大。\n\n\n五、EM的应用\nEM算法有很多的应用，最广泛的就是GMM混合高斯模型、聚类、HMM等等。具体可以参考JerryLead的cnblog中的Machine Learning专栏：\n\n（EM算法）The EM Algorithm\n\n混合高斯模型（Mixtures of Gaussians）和EM算法\n\nK-means聚类算法\n\n\n六、贝叶斯估计\n统计学里有两个大的流派，一个是频率派，一个是贝叶斯派。时至今日，这两派还未就各自的观点达成统一。我们前面提到的最大似然估计就是频率派的典型思路，接下来再看看贝叶斯派的思路，到底跟频率派估计有何不同。 \n先来看几个相关的小公式： \n两个随机变量x,y的联合概率p(x,y)的乘法公式： \n\np(x,y)=p(x|y)p(y)=p(y|x)p(x)\n\n\n如果x,y是独立随机变量，上面的式子可以表示为: \n\np(x,y)=p(x)p(y)=p(y)p(x)\n\n\n\n那么条件概率就可以表示为：\n\np(x|y)=p(x,y)/p(y)p(y|x)=p(x,y)/p(x)\n\n\n\n\n\n对于一个完备事件组y1,y2,⋯,yn，可以使用全概率公式：\n\n\n\n由以上这些，可以得出贝叶斯公式：\n\n\n\n其中，p(yi|x)是后验概率。p(x|yi)是条件概率，或者说似然概率，这个概率一般都可以通过历史数据统计得出。而p(yi)是先验概率，一般也是根据历史数据统计得出或者认为给定的，贝叶斯里的先验概率，就是指p(yi)。对于p(x)，我们前面提到可以用全概率公式计算得出，但是在贝叶斯公式里面我们一般不care这个概率，因为我们往往只需要求出最大后验概率而不需要求出最大后验的具体值。\n\n七、最大似然估计与贝叶斯估计的区别\n细心的同学通过观察MLE与Bayes的公式，发现Bayes公式比MLE公式里就多了一项p(yi)(咱们先抛开p(x)不考虑)，而条件概率或者说似然概率的表达式是一致的。从数学表达式的角度来说，两者最大的区别就在这里：贝叶斯估计引入了先验概率，通过先验概率与似然概率来求解后验概率。而最大似然估计是直接通过最大化似然概率来求解得出的。\n\n换句话说，最大似然估计没有考虑模型本身的概率，或者说认为模型出现的概率都相等。而贝叶斯估计将模型出现的概率用先验概率的方式在计算过程中有所体现。\n\n举个大家上学时候就遇到的例子： \n\n假如人们会感染一种病毒，有一种测试方法，在被测试者已感染这个病毒时，测试结果 为阳性的概率为95%。在被测试者没有感染这个病毒时，测试结果为阳性的概率为2%。现在，有一个人的测试结果为阳性，问这个人感染了病毒吗？ \n\n如果用最大似然估计的方法，既然感染了病毒出现阳性的概率为95%，没感染出现阳性的概率为2%，本着谁大像谁的原则，那我就认为这个人已经感染了病毒。 \n\n但是如果用贝叶斯方法进行估计，如果我们得知有一个先验概率，比如整体人群中只有1%的人会感染此种病毒，那么由贝叶斯公式：\n\n\n \n\n其中，p(真阳性|检测为阳性)为后验概率，即我们通过检测出为阳性可以判断为真阳性的概率；p(真阳性)为先验概率，p(检测为阳性|真阳性)为条件概率，p(真阳性)p(检测为阳性|真阳性)+p(真阴性)p(检测为阳性|真阴性)为全概率，检测出为阳性是由一个完备事件组构成的：这个人要么是真阳性，要么是真阴性。 \n由此可见，在贝叶斯估计中，先验概率对结果的影响很大。在这种场景下，采用贝叶斯估计似乎更为合理一些。\n最后来个总结：从本质上来说，最大似然是对点估计，贝叶斯推断是对分布估计。即，假设求解参数θ，最大似然是求出最有可能的θ值，而贝叶斯推断则是求解θ的分布。\n\n八、线性判别分析\n参考这篇博文：线性判别分析（Linear Discriminant Analysis\n\n","categories":["图像处理与机器学习"],"tags":["最大似然","贝叶斯","EM算法"]},{"title":"非参数估计法之Parzen窗估计和k最近邻估计","url":"https://tanqingbo.cn/Parzen-and-KNE/","content":"1.非参数化概率密度的估计\n对于未知概率密度函数的估计方法，其核心思想是：一个向量x落在区域R中的概率可表示为：\n\n\n\n\n其中，P是概率密度函数p(x)的平滑版本，因此可以通过计算P来估计概率密度函数p(x)，假设n个样本x1,x2,…,xn，是根据概率密度函数p(x)独立同分布的抽取得到，这样，有k个样本落在区域R中的概率服从以下分布：\n\n\n\n\n其中k的期望值为：\n\n\n\n\nk的分布在均值附近有着非常显著的波峰，因此若样本个数n足够大时，使用k/n作为概率P的一个估计将非常准确。假设p(x)是连续的，且区域R足够小，则有：\n\n\n\n如下图所示，以上公式产生一个特定值的相对概率，当n趋近于无穷大时，曲线的形状逼近一个δ函数，该函数即是真实的概率。公式中的V是区域R所包含的体积。综上所述，可以得到关于概率密度函数p(x)的估计为：\n\n \n\n\n\n\n\n\n在实际中，为了估计x处的概率密度函数，需要构造包含点x的区域R1,R2,…,Rn。第一个区域使用1个样本，第二个区域使用2个样本，以此类推。记Vn为Rn的体积。kn为落在区间Rn中的样本个数，而pn (x)表示为对p(x)的第n次估计：\n\n\n\n欲满足pn(x)收敛：pn(x)→p(x)，需要满足以下三个条件：\n\n\n\n有两种经常采用的获得这种区域序列的途径，如下图所示。其中“Parzen窗方法”就是根据某一个确定的体积函数，比如Vn=1/√n来逐渐收缩一个给定的初始区间。这就要求随机变量kn和kn/n能够保证pn (x)能收敛到p(x)。第二种“k-近邻法”则是先确定kn为n的某个函数，如kn=√n。这样，体积需要逐渐生长，直到最后能包含进x的kn个相邻点。\n\n\n2.Parzen窗估计法\n已知测试样本数据x1,x2,…,xn，在不利用有关数据分布的先验知识，对数据分布不附加任何假定的前提下，假设R是以x为中心的超立方体，h为这个超立方体的边长，对于二维情况，方形中有面积V=h^2，在三维情况中立方体体积V=h^3，如下图所示。\n\n\n\n根据以下公式，表示x是否落入超立方体区域中：\n\n\n\n估计它的概率分布：\n\n\n\n其中n为样本数量，h为选择的窗的长度，φ(.)为核函数，通常采用矩形窗和高斯窗。\n\n3.k最近邻估计\n在Parzen算法中，窗函数的选择往往是个需要权衡的问题，k-最近邻算法提供了一种解决方法，是一种非常经典的非参数估计法。基本思路是：已知训练样本数据x1,x2,…,xn而估计p(x)，以点x为中心，不断扩大体积Vn，直到区域内包含k个样本点为止，其中k是关于n的某一个特定函数，这些样本被称为点x的k个最近邻点。\n当涉及到邻点时，通常需要计算观测点间的距离或其他的相似性度量，这些度量能够根据自变量得出。这里我们选用最常见的距离度量方法：欧几里德距离。\n最简单的情况是当k=1的情况，这时我们发现观测点就是最近的（最近邻）。一个显著的事实是：这是简单的、直观的、有力的分类方法，尤其当我们的训练集中观测点的数目n很大的时候。可以证明，k最近邻估计的误分概率不高于当知道每个类的精确概率密度函数时误分概率的两倍。\n\nmatlab实现Parzen和k最近邻估计Parzen窗方法研究\n采用3类满足正太分布的样本数据（w1,w2,w3）作为训练样本，编写程序，使用Parzen 窗估计方法对一个任意的测试样本点x 进行分类。对分类器的训练则使用（w1,w2,w3）的三维数据。同时修改窗口h的值，多次实验。用于分类的样本点为x1(0.5,1.0,0.0)，x2(0.31,1.51,-0.50)，x3(-0.3,0.44,-0.1)。\n训练样本数据（w1,w2,w3）分别为：  w1 = [ 0.28  1.31  -6.2           0.07  0.58  -0.78           1.54  2.01  -1.63          -0.44  1.18  -4.32          -0.81  0.21   5.73           1.52  3.16   2.77           2.20  2.42  -0.19           0.91  1.94   6.21           0.65  1.93   4.38          -0.26  0.82  -0.96];W2 = [0.011  1.03  -0.21           1.27  1.28   0.08           0.13  3.12   0.16          -0.21  1.23  -0.11          -2.18  1.39  -0.19           0.34  1.96  -0.16          -1.38  0.94   0.45          -0.12  0.82   0.17          -1.44  2.31   0.14           0.26  1.94   0.08];W3 = [ 1.36  2.17  0.14           1.41  1.45 -0.38           1.22  0.99  0.69           2.46  2.19  1.31           0.68  0.79  0.87           2.51  3.22  1.35           0.60  2.44  0.92           0.64  0.13  0.97           0.85  0.58  0.99           0.66  0.51  0.88];\nh=0.1时：\n\n\n\nh=0.5时：\n\n\n\nh=1时：\n\n\nK最近邻方法研究\n采用3类满足正太分布的样本数据（w1,w2,w3）作为训练样本，为了使实验更具有说服力，我们令训练样本数据的个数分别为10、20、30、40个样本，进行4次实验，其中w1的均值为0.2，方差为0.2，w2的均值为0，方差为0.1，w3的均值为0.1，方差为0.1。实验的训练样本都是程序随机生成的，我们将在实验结果分析的最后给出每次实验的训练样本数据。\n\n源码clear;close all;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Parzen窗估计和k最近邻估计%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%         w1(:,:,1) =  .2+sqrt(0.2)*randn(20,[3,1]);  %均值为0.2，方差为0.2的训练样本%         disp(w1(:,:,1));%         w1(:,:,2) =  0+sqrt(0.2)*randn(20,[3,.1]);  %均值为0，方差为0.1的训练样本%         disp(w1(:,:,2));%         w1(:,:,3) =  .1+sqrt(0.3)*randn(20,[3,0]);  %均值为0.1，方差为0.1的训练样本%         disp(w1(:,:,2));  w1(:,:,1) = [ 0.28  1.31  -6.2;...             0.07  0.58  -0.78;...             1.54  2.01  -1.63;...            -0.44  1.18  -4.32;...            -0.81  0.21   5.73;...             1.52  3.16   2.77;...             2.20  2.42  -0.19;...             0.91  1.94   6.21;...             0.65  1.93   4.38;...            -0.26  0.82  -0.96];w1(:,:,2) = [0.011  1.03  -0.21;...             1.27  1.28   0.08;...             0.13  3.12   0.16;...            -0.21  1.23  -0.11;...            -2.18  1.39  -0.19;...             0.34  1.96  -0.16;...            -1.38  0.94   0.45;...            -0.12  0.82   0.17;...            -1.44  2.31   0.14;...             0.26  1.94   0.08];w1(:,:,3) = [ 1.36  2.17  0.14;...             1.41  1.45 -0.38;...             1.22  0.99  0.69;...             2.46  2.19  1.31;...             0.68  0.79  0.87;...             2.51  3.22  1.35;...             0.60  2.44  0.92;...             0.64  0.13  0.97;...             0.85  0.58  0.99;...             0.66  0.51  0.88];x(1,:) = [0.5 1 0];x(2,:) = [0.31 1.51 -0.5];x(3,:) = [-0.3 0.44 -0.1];h = 1; % 重要参数p1 = Parzen(w1,x(1,:),h);%num1 = find(p1 == max(p1));p2 = Parzen(w1,x(2,:),h);%num2 = find(p2 == max(p2));p3 = Parzen(w1,x(3,:),h);%num3 = find(p3 == max(p3));disp(['点：[',num2str(x(1,:)),']落在三个类别的概率分别为：',num2str(p1)]);disp(['点：[',num2str(x(2,:)),']落在三个类别的概率分别为：',num2str(p2)]);disp(['点：[',num2str(x(3,:)),']落在三个类别的概率分别为：',num2str(p3)]);% 给定三类二维样本，画出二维正态概率密度曲面图验证h的作用num =1; % 第num类的二维正态概率密度曲面图，取值为1，2，3draw(w2,h,num); str1='当h=';str2=num2str(h);str3='时的二维正态概率密度曲面';SC = [str1,str2,str3];title(SC);% k近邻算法设计的分类器% x1和y1为测试样本x1 = [-0.91,0.32,0.48];x2 = [0.14,0.72, 1.1];x3 = [-0.81,0.61,-0.38];% x1 = [-0.41,0.82,0.88];% x2 = [0.14,0.72, 4.1];% x3 = [-0.81,0.61,-0.38];w = w1;%w = w1(:,1,3);k = 2;kNearestNeighbor(w,k,x1);kNearestNeighbor(w,k,x2);kNearestNeighbor(w,k,x3);% Parzen窗算法% w：c类训练样本% x：测试样本% h：参数% 输出p：测试样本x落在每个类的概率function p = Parzen(w,x,h)[xt,yt,zt] = size(w);p = zeros(1,zt);for i = 1:zt    hn = h;    for j = 1:xt        hn = hn / sqrt(j);        p(i) = p(i) + exp(-(x - w(j,:,i))*(x - w(j,:,i))'/ (2 * power(hn,2))) / (hn * sqrt(2*3.14));    end    p(i) = p(i) / xt;end% k-最近邻算法% w：c类训练样本% x：测试样本% k：参数function p = kNearestNeighbor(w,k,x)% w = [w(:,:,1);w(:,:,2);w(:,:,3)];[xt,yt,zt] = size(w);wt = [];%zeros(xt*zt, yt);if nargin==2   %判断输入变量的个数p = zeros(1,zt);    for i = 1:xt        for j = 1:xt        dist(j,i) = norm(wt(i,:) - wt(j,:));   % 计算向量范数（dist：欧式距离加权函数）        end        t(:,i) = sort(dist(:,i));        m(:,i) = find(dist(:,i) &lt;= t(k+1,i)); % 找到k个最近邻的编号    endend  if nargin==3    %判断输入变量的个数    for q = 1:zt    wt = [wt; w(:,:,q)];  %  把3个训练样本放到一个矩阵中    [xt,yt] = size(wt);    end        for i = 1:xt        dist(i) = norm(x - wt(i,:));        end        t = sort(dist); % 欧氏距离排序        [a,b] = size(t);        m = find(dist &lt;= t(k+1)); % 找到k个最近邻样本的编号，存到向量m中        num1 = length(find(m&gt;0 &amp; m&lt;11));        num2 = length(find(m&gt;10 &amp; m&lt;21));        num3 = length(find(m&gt;20 &amp; m&lt;31));if yt == 3        plot3(w(:,1,1),w(:,2,1),w(:,3,1), 'r.');        hold on;        grid on;        plot3(w(:,1,2),w(:,2,2),w(:,3,2), 'g.');        plot3(w(:,1,3),w(:,2,3),w(:,3,3), 'b.');if (num1 &gt; num2) || (num1 &gt; num3)    plot3(x(1,1),x(1,2),x(1,3), 'ro');    disp(['点：[',num2str(x),']属于第一类']);elseif (num2 &gt; num1) || (num2 &gt; num3)    plot3(x(1,1),x(1,2),x(1,3), 'go');    disp(['点：[',num2str(x),']属于第二类']);elseif (num3 &gt; num1) || (num3 &gt; num2)    plot3(x(1,1),x(1,2),x(1,3), 'bo');    disp(['点：[',num2str(x),']属于第三类']);else    disp('无法分类');endendif yt == 2        plot(w(:,1,1),w(:,2,1), 'r.');        hold on;        grid on;        plot(w(:,1,2),w(:,2,2), 'g.');        plot(w(:,1,3),w(:,2,3), 'b.');if (num1 &gt; num2) || (num1 &gt; num3)    plot(x(1,1),x(1,2), 'ro');    disp(['点：[',num2str(x),']属于第一类']);elseif (num2 &gt; num1) || (num2 &gt; num3)    plot(x(1,1),x(1,2), 'go');    disp(['点：[',num2str(x),']属于第二类']);elseif (num3 &gt; num1) || (num3 &gt; num2)    plot(x(1,1),x(1,2), 'bo');    disp(['点：[',num2str(x),']属于第三类']);else    disp('无法分类');endendendtitle('k-最近邻分类器');legend('第一类数据',...       '第二类数据',...       '第三类数据',...       '测试样本点');\n\n\n参考书籍：《模式分类》作者：RichardO.Duda，PeterE.Hart，DavidG.Stork\n\n","categories":["图像处理与机器学习"],"tags":["Parzen窗","k最近邻估计"]},{"title":"SPHARM-PDM与MEPP","url":"https://tanqingbo.cn/SPHARMPDM-MEPP/","content":"SPHARM-PDM\n形状分析已经成为医学界日益增长的兴趣，因为它有可能精确地定位健康和病理结构之间的形态学变化。 SPHARM-PDM是一种使用参数边界描述计算基于点的模型来计算形状分析的工具。 \n使用SPHARM-PDM工具计算的基于点的模型可以与UNC设计的统计工具形状分析MANCOVA结合使用，以对特定位置的结构变化进行定量形态学评估。\n自2017年7月起，SPHARM-PDM现在可作为3D切片扩展（ http://www.slicer.org ）和SlicerSALT（salt.slicer.org）的一部分。 通过SlicerSALT传播SPHARM-PDM现在是下载新版本SPHARM-PDM的主要传播方式。 \n有关问题，请参阅nitrc论坛，网址为：https://www.nitrc.org/projects/spharm-pdm \n\nSegPostProcessCLP\n⇒填充内孔。 \n⇒执行最小平滑操作 确保球形拓扑。SegPostProcessCLP参数解释：\n\n./SegPostProcessCLP label.nii brain-segout/label-segout.vtk --space 1.5,1.5,1.5\n\n\n\n\nSegPostProcessCLP --help 可以查看各种参数的意思。\n--space x,y and z 的方向（默认：0.75,0.75,0.75）\n--iter &lt;int&gt;LS平滑的迭代次数,默认50次\n--Gauss 0/1: if selected, do a Gaussian Filtering\n--RMS &lt;double&gt;LS平滑的均方根值误差\n\nGenParaMeshCLP\n⇒处理二进制分段是 转换为原始表面网格。 \n计算球面参数。GenParaMeshCLP参数解释：\n\n./GenParaMeshCLP brain-segout/label-segout.vtk brain-meshout/label-para.vtk brain-meshout/label-surf.vtk --label 1\n\n\n\n\n--label 1输入图像中的标签ID\n--iter &lt;int&gt;选择迭代的次数,默认是500次 \n--outLogName &lt;std::string&gt;：Output Log txtFile\n--logFile：write a .txt file with a log of events \n\n•ParaToSPHARMMeshCLP\n⇒具有固有的SPHARM描述 \n然后从中计算出对应关系 网格及其球形参数化。 \n⇒对应的三角曲面 （SPHARM-PDM）。 \n二十面体的球面参数化ParaToSPHARMMeshCLP参数解释：\n\n./ParaToSPHARMMeshCLP brain-meshout/label-para.vtk brain-meshout/label-surf.vtk brain-align/label\n\n\n\nMEPP\nMEPP旨在围绕新的网格处理技术构建一个框架。 面向模块化，它面向开发人员和GUI用户。 \nMEPP是基于CGAL类“多面体”的平台开发环境，用于网格和网格序列的处理和可视化。它允许加载多个网格或网格序列，进行处理和可视化。 它旨在为工程师，研究人员，也为快速入门的学生提供建议。\n\n特征：\nC ++，开源（GNU GPL v3）， \n多平台（Windows，Linux，Mac OS X） \n用CMake编译， \n安装快捷方便， \n安装文件，用户手册， \nVMware虚拟机与Ubuntu Linux“准备启动”， \n从一个应用程序窗口或从浏览器拖放对象。支持格式：\nobj (Wavefront), \noff (Object File Format), \nply (Polygon File Format), \nsmf (3D World Studio), \nx3d (XML based royalty-free open standard file format), \n3ds (3ds Max), \ndae (Collada), \nlwo (LightWave).\n\nExport：\n图像捕获， \n视频截取。\n\n显示功能：\n管理一个或多个窗口中的多个对象， \n使用“显示列表”加速显示。\n\nMEPP平台允许两种类型的加载：\n模式“空间”，其中将几个对象加载到同一场景中， \n模式“时间”，其中将几个对象作为网格序列加载。 \n\n然后可以通过VCR 3D + t可视化序列。\n组件 ：\n实现为具有自动检测和加载的插件， \n在编译时选择组件， \n从示例中轻松创建新组件。\n\n可用组件：\n基本网格处理：三角剖分，细分，简化， \n曲率分析， \n布尔运算：联合，交集，减法， \n分割（变形形状近似）， \n逐行压缩/水印， \n视觉质量指标， \nremeshing：规范简化， \n数学形态学， \n网格修复 \n\n通过创建新的组件来为平台做出贡献的可能性。\n组件“布尔运算”：\n组件“分割”：\n组件“曲率”：\n\n有关问题，请参观mepp的官网，网址：https://liris.cnrs.fr/mepp/\n\noff文件格式(Object File Format)\nObject File Format(off)文件通过描述物体表面的多边形来表示一个模型的几何结构。这些多边形可以包含任意数量的顶点。Princeton Shape Benchmark的off文件遵从以下标准：\n\noff文件为ASCII文件，以OFF关键字开头。\n\n下一行是该模型的顶点数，面数和边数。边数可以忽略，对模型不会有影响(可以为0)。\n\n顶点以x，y，z坐标列出，每个顶点占一行。\n\n在顶点列表之后是面列表，每个面占一行。对于每个边，首先指定其包含的顶点数，随后是这个面所包含的各顶点在前面顶点列表中的索引。\n\n\n\n下面是一个立方体的例子：\n\n\nOFF 8 6 0 -0.500000 -0.500000 0.500000 0.500000 -0.500000 0.500000 -0.500000 0.500000 0.500000 0.500000 0.500000 0.500000 -0.500000 0.500000 -0.500000 0.500000 0.500000 -0.500000 -0.500000 -0.500000 -0.500000 0.500000 -0.500000 -0.500000 4 0 1 3 2 4 2 3 5 4 4 4 5 7 6 4 6 7 1 0 4 1 7 5 3 4 6 0 2 4\n\n\n\n\n参考地址：http://shape.cs.princeton.edu/benchmark/documentation/off_format.html\n\n","categories":["图像处理与机器学习"],"tags":["SPHARM-PDM","MEPP"]},{"title":"Matlab实现Graph cut算法","url":"https://tanqingbo.cn/Matlab-Graph-cut/","content":"Matlab实现Graph cut最大流最小割\n最大流最小割最开始从图论的概念中引来，讲述一个带有起点与终点并且具有边权值的网络图中，如何进行边的切割，把这个网络图分成独立的两个部分（或者多个部分），使得这个切割中被切割的边的权值之和最小。比如现在有一个网络图如下：\n\n那么要把这个图分割成两部分，如上虚线就是一种切割方式，消耗的权值3+4=7，当然，切割的方式有很多种，不同的切割对应不同的切割边权值，而最大流最小割就是找到一种切割方式使得切割的边的权值之和最小。\n最大流最小割应用到图像分割\n图像简单来说就是矩阵，对于灰度图像，那么就是一般的二维矩阵，矩阵中值得大小就是改点的灰度值，那么图像分割问题就是寻找到图像的边界，而边界肯定在两个像素值差别很大的邻域间，如果把两个邻域间的像素值的差定义为该领域的边权值，那么分割问题就转化为如何切割这些边的问题了，这样的模型就和上述的最大流最小割对应上了。有点、有边、有边权值，那么就可以运用上述理论分割图像了。\n图割理论\n理论化介绍都是直观上的对图像的操作，而实际变成现实的时候是要事先转化到一维或者直接调用相应的函数才能对二维图像进行操作。先介绍一维图割操作，在介绍二维如何转为一维。\n\n源点s与汇点t\n\n如下图所示的由五个点site组成的一维情况，假设最终我们要分成两类，那么就把这两类认为是源点s与汇点t好了，那么一次类推，如果要分成多个类的话，就可以加相应的节点s或者t表示他们的类就可以了。\n\n\n点与点之间的权值Smoothcost\n\n从下图上也可以看出在这个一维点与点之间相连接的权值就是Smoothcost项，图中为了简化只是画出了相邻的两个点之间有一条线连接，也就是他们之间存在着权值（这里图为一个无向图，也就是权值是没有方向之分的），正常情况下，可能每两个点之间都可能存在着联系，比如如果点1与点3之间，你也可以看成他们是连接的，只不过他们之间的权值为0而已。这也是matlab里面表示这一项点与点权值的时候用一个n*n维矩阵的原因（n为点数），像这里，如果权值的大小如上图所示定义的话，那么这个图的Smoothcost项的权值矩阵可以表示:\n    0 5 0 0 05 0 4 0 00 4 0 3 00 0 3 0 20 0 0 2 0\n\n\n\n\n\n\n\n点与源汇点（类点）之间的权值Datacost\n\n除了上述的Smoothcost项之外，图割理论中还有一种项就是Datacost，表示的是各个点到源汇点（类点）之间的权值大小，这一项的权值同样对于分割至关重要。比如我们知道点1与点2属于s，其他点属于t的话，那么最终优化的结果就是1-s,2-s之间的权值可能很大，3-s,4-s,5-s之间的权值都很小，这对分割最后的形式很重要。Datacost也可以用矩阵表示，用c表示类的话（这里只有s与t那么c为2），n表示点的个数的话，那么Datacost可以表示为一个c*n的矩阵了：\n    1 2 3 4 55 4 3 2 1\n\n\n\n\n\n\n最大流最小割的实现过程\n关于具体怎么解最大流最小割的方法有很多种，假设在上述Smoothcost和Datacost都定死的情况下，具体有以下几种方法实现：\n\nFord-Fulkerson方法（增大路径最大流算法）\nEdmonds-Karp（EK）算法实现\nDinic算法\nSAP算法(最短路径增广算法)\nPreflow push method(预流-推进最大流方法）\n\n\n详细参考如右：\n\n里面有详细的c语言代码，可供详细研究实现这个的过程。\ngraph cut之图割工具箱GCO3.0\n有了前面的介绍，我们大致了解了分割的过程，下面下载GCO3.0的源码，下载地址：http://vision.csd.uwo.ca/code/,在这里找到对应的内容即可。\n\n解压源码包之后里面会有一些c编写的代码以及另一个matlab版文件夹，如图：\n\nmatlab文件夹中有很多.m文件和一个C文件\n\n注意在使用这些代码时，matlab文件夹和外面的c编写的代码文件相对位置不要发生改变，因为在程序的执行过程中.m文件会调用.cpp文件。\n\n我们主要用到的是matlab文件中提供的函数对图像进行分割，在正式分割之前我们需要先自己编写几个辅助函数：\n\nDatacost1函数：用来计算点与类的权值datacost，代码如下:            \n   function datacost = Datacost1(img,ctrs)[m,n] = size(img);num_lables = size(ctrs,1);totalsizes = m*n;datacost = zeros(totalsizes,num_lables);for i = 1:totalsizes    Ip = double(img(i));    for j = 1:num_lables         datacost(i,j) = (Ip - ctrs(j)).^2;  %计算datacost项    endend\n\n\n\n\n\n\n\nneighbours1函数：计算点与点之间的权值neighbours，代码如下：\n            %%-------------------\t%  每个点的灰度作为特征\t%%-------------------\tfunction Neighbours = neighbours1(img)\t[m,n] = size(img);\ttotalsizes = m*n;\tvar_img = var(img(:)); %图像方差\t%% 选择neigh=4四连通计算权值，neigh=8八连通计算权值\tneigh = 4;\t%%\tif neigh == 4\t    %构建索引向量--生成距离的稀疏矩阵\t    i1 = (1:totalsizes-m)';\t    j1 = i1+m;\t    for i = 1:n\t        i2_tem(:,i) = (i-1)*m + (1:m-1)';\t    end\t    i2 = i2_tem(:);\t    j2 = i2+1;\t    %对应边的值\t    ans1 = exp(-(img(i1(:))-img(j1(:))).^2/(2*var_img));\t    ans2 = exp(-(img(i2(:))-img(j2(:))).^2/(2*var_img));\t    %组合相应的向量：x位置，y位置，权值（注意必须都是列向量）\t    all = [[i1;i2],[j1;j2],[ans1;ans2]];\telse\t    %构建索引向量--生成距离的稀疏矩阵\t    i1 = (1:totalsizes-m)';  %正右权值\t    j1 = i1+m;\t    for i = 1:n  %正下权值\t        i2_tem(:,i) = (i-1)*m + (1:m-1)';\t    end\t    i2 = i2_tem(:);\t    j2 = i2+1;\t    for i = 1:n-1  %斜下权值\t        i3_tem(:,i) = (i-1)*m + (1:m-1)';\t    end\t    i3 = i3_tem(:);\t    j3 = i3+n+1;\t    i4 = i3+1; %斜上权值\t    j4 = i3+m;\t    %对应边的值\t    ans1 = exp(-(img(i1(:))-img(j1(:))).^2/(2*var_img));\t    ans2 = exp(-(img(i2(:))-img(j2(:))).^2/(2*var_img));\t    ans3 = exp(-(img(i3(:))-img(j3(:))).^2/(2*var_img));\t    ans4 = exp(-(img(i4(:))-img(j4(:))).^2/(2*var_img));    \t    %组合相应的向量：x位置，y位置，权值（注意必须都是列向量）\t    all = [[i1;i2;i3;i4],[j1;j2;j3;j4],[ans1;ans2;ans3;ans4]];\tend \t%matlab函数生成稀疏矩阵（这么做的速度最快） %----------------neighb = spconvert(all);\tneighb(totalsizes,totalsizes) = 0; \tNeighbours = neighb;\tend\n\n  ​    \n\n有了上述的工具函数之后，我们就可以编程调用这些函数实现图像分割了，    下面给出综合起来的主程序：\n           clc;clear;img = imread('b_04_95.jpg');img = double(img);% 定义分类数NumlablesNumlables = 2;% 定义Potts模型参数KPotts_K = 1500;[m,n] = size(img);totalsizes  =n*m;%k-means预分类找到中心与分类%init_lable预分类，列向量； ctrs-类中心灰度值值[init_lable,ctrs] = kmeans(img(:),Numlables);  %img通过索引转化为列向量可用ctrs_new = zeros(Numlables,1);% 生成目标体h = GCO_Create(totalsizes,Numlables);%设置初始标签GCO_SetLabeling(h,init_lable);%设置datacost项datacost = Datacost1(img,ctrs);datacost = datacost';GCO_SetDataCost(h,datacost);%设置smoothcost%不设置的时候默认使用potts模型SmoothCost = eye(Numlables);SmoothCost = 1 - SmoothCost;GCO_SetSmoothCost(h,SmoothCost);%设置neighbors项Neighbours = Potts_K*neighbours1(img);GCO_SetNeighbors(h,Neighbours);%显示输出结果GCO_SetVerbosity(h,2);%类标签运算顺序GCO_SetLabelOrder(h,randperm(Numlables));%膨胀算法GCO_Expansion(h);%获得该标签lablesLabeling = GCO_GetLabeling(h);  %列向量% 释放内存GCO_Delete(h);%显示graph cut分类for i = 1:length(Labeling)img1(i) = ctrs(Labeling(i));endimg1 = reshape(img1,m,n);%绘制分割图figure;%原图像subplot(1,2,1);imshow(img,[]);title('原始图像');%显示graph cut分类subplot(1,2,2);imshow(img1,[]);title(['Potts模型参数:',num2str(Potts_K)]); \n\n\n\n\n\n\n因为涉及到matlab和C语言的混合编程，因此在执行上述代码之前需要先安装好C语言编译器，通常安装了VS软件就没什么问题了，然后在执行时可能会出现一个如下的错误：\n  Error using mex (line 206) \t\tUnable to complete successfully.\n\n\n\n\n\n\n此时我们安装mex编译器，在matlab的命令行输入：\n\nmex -setup\n\n\n\n\n根据提示选择y    和需要的编译器就可以了，程序再执行就会出现结果了。如题所示：\n\n另外可以通过调节Potts_K参数的值，以实现不同的效果。    \n\n参考博客：\n\nmatlab实现Max-flow/min-cut的方法\n 图像分割之图割工具箱GCO3.0的使用（二）\nGCO3.0的图割分割算法应用(三)        \n\n\n\n","categories":["图像处理与机器学习"],"tags":["Matlab","Graph"]},{"title":"VTK图像处理（三） | 体绘制","url":"https://tanqingbo.cn/VTK03/","content":"前言\n体绘制，有时又称作三维重建，它能够通过设置不透明度值来显示提数据内部不同成分的细节。\n\n本篇讲述了一个标准的VTK体绘制渲染流程。其中最重要的两个内容分别是：vtkVolumeMapper 和 vtkVolume。\n\nvtkVolumeMapper机器子类实现了各种体绘制算法：\n\n光线投影法，如：vtkVolumeRayCastMapper、vtkFixedPointVolumeRayCastMapper、vtkGPUVolumeRayCastMapper；\n基于纹理绘制算法，如：vtkVolumeRayTestureMapper2D、vtkVolumeRayTestureMapper3D;\n\n\nvtkVolume负责组合体绘制管线，处理包含一个Mapper对象外，还需要vtkVolumeProperty对象来体绘制的颜色映射，如不透明度函数、颜色传输函数、梯度不透明函数以及设置阴影效果等。\n\n\n\n\nvtkVolumeMapper\nvtkVolumeMapper是所有体绘制Mapper类的虚基类，提供接口函数，并由其子类实现具体功能。\nvtkVolumeRayCastMapper\n光线投影法是一种基于图像序列的直接体绘制方法，其基本原理是从投影图像平面的每个像素沿着视线方向发射一条穿过体数据的射线，然后在射线上按照一定的步长进行等距采样，对每个采样点采用插值技术计算其体素值，根据颜色传输函数和不透明度传输函数来获取相应的颜色值和不透明度，最后利用光线吸收模型将颜色值进行累加，直至光线穿过体数据，即可得到当前平面像素的渲染颜色，生成最终显示图像。\n\n优点：能够精确的模拟原始数据；\n缺点：计算量大，对计算机硬件要求较高。\n\n\nvtkVolumeRayCastMapper类中有两个中最要的函数：\n\nSetInput(vtkImageData*)：用于设置输入图像数据；\nSetVolumeRayCastFunction(vtkVolumeRayCastFunction*)：设置光线投射函数。\n\n\n光线投射函数vtkVolumeRayCastFunction是一个虚基类，它由3个子类：\n\nvtkVolumeRayCastCompositeFunction：通过Alpha合成技术生成每个像素的颜色值。对每个采样点采用插值技术计算其体素值，根据颜色传输函数和不透明度传输函数来获取相应的颜色值和不透明度，最后对所有采样点用Alpha合成方法计算最终的颜色。\n另外，该方式还可以设置插值优先和分类优先：\n插值优先设置函数：SetCompositeMethodToInterpolateFirst()；\n分类优先设置函数：SetCompositeMethodToClassfyFirst()；\n从显示效果上看，插值优先具有较好的显示效果。\n\n\n\n\nvtkVolumeRayCastMIPFunction：最大密度投影函数，主要用于对体数据中搞灰度值的结构进行可视化。当光线穿过体数据时，在光线上进行等距采样。取采样点中属性最大值为该条光线的输出。\n\nvtkVolumeRayCastIsosurfaceFunction：等值面绘制函数能够渲染数据中的特定等值面，其中：SetValue(double)函数用于设置等值面的值，在进行体绘制时，所有小于该值的像素不透明度都设置为。\n\n从效果上看，光线投射法体绘制效果最好，最大密度投射法缺乏深度信息，二等值面投射法体绘制可以对体数据的某个等值面进行显示和观察，于面绘制效果类似。\n\n光线投射中，投射光线上的采样步长是一个很重的参数，设置函数：SetSampleDistance(float)，步长越小，采样点越多，效果越好。但计算量变大。当数据变化剧烈时，应该减少采样步长以获得更好的效果。\n\n另外，还可以设置图像采样间距，即投射光线的间隔，设置函数：SetImageSampleDistance(float)，使用该函数时，必须先关闭自动调节采样距离功能，SetAutoAdjustSampleDistances(int),设置为0关闭功能。\n\n\n\n\nvtkFixedPointVolumeRayCastMapper\n该类能够实现基于Aplha合成的体绘制方法和最大密度投影体绘制方法，能够支持任意类型的一元或者独立多元数据。该类使用了空间跳跃技术来加速体绘制渲染过程，而且在内部计算时统一使用了float数据类。\nvtkFixedPointVolumeRayCastMapper与vtkVolumeRayCastMapper用法基本相同。\n\nvtkGPUVolumeRayCastMapper\n实现了基于GPU加速的光线投射体绘制算法，与vtkVolumeRayCastMapper用法基本相同。\n\n纹理映射体绘制\n主要原理是将3维体数据作为纹理载入图像硬件缓存中，利用硬件来实现插值以及图像合成操作，以提高绘制效率。\n\n主要利用硬件的三线性过滤插值能力，通过渲染多个与视线垂直的面片来重建整个三维结构。\n\n二维纹理映射：\n\n在光线投射时，选择与当前视线方向垂直的一组纹理图像，在硬件中进行插值和合成运算以实现体绘制。类vtkVolumeTextureMapper2D可用于实现基于二维纹理映射的体绘制方法。\n\n\n三维纹理映射：\n\nvtkVolumeTextureMapper3D类实现3维纹理映射，当数据传递给vtkVolumeTextureMapper3D后，在内部会进行重采样，以确保图像大小能满足当前纹理空间。\n\n\n\n裁剪\nvtkVolumeMapper提供了两种裁剪技术，分别是Cropping和Clipping。\n\nCropping技术只支持vtkImageData数据的裁剪，该方法在每个坐标轴上定义了两个裁剪面，共6个平面(xmin,xmax,ymin,ymax,zmin,zmax)将3维空间分成27个区域。\n\nvtkVolumeMapper中定义了Cropping方法的接口函数：\n\nSetCropping()：打开Cropping方法；\nSetCroppingRegionPlanes()：设置三个坐标轴6个裁剪面的位置；\nSetCroppingRegionFlags()：设置显示区域标记。\n还提供了几个常用的显示区域设置函数，见《VTK图形图像开发进阶》7.2.5节。\n\n\nClipping技术可以由任意方向将图像切开，便于观察内部细节，只需要定义一个vtkPlane类型的裁剪平面对象，然后通过vtkVolumeMapper类的AddClippingPlane()函数将该平面添加至Mapper对象即可。\n\n\n法向编码\n在vtkImageData的部分体绘制Mapper对象中，可以使用法向编码减少存储量。\n\nvtkVolume\nvtkVolume类似于集合渲染中的vtkActor,用于表示渲染场景中的对象。内部存储了两个重要的对象，分别是vtkAbstractVolumeMapper对象和vtkVolumeProperty对象。相应函数如下：SetMapper(vtkAbstractVolumeMapper*)和SetProperty(vtkVolumeProperty*)。\n\n不透明传输函数\n不透明传输函数是一个分段线性标量映射函数，利用该函数可将光线投射过程中的采样点灰度值映射为不同的不透明度值，以决定最终的颜色值。\n  SetScalarOpacity(vtkPiecewiseFunction*);\n\nvtkPiecewiseFunction类定义线性分段函数：\n\nAddPoint(double x,double y)：第一个参数x为自变量，这里是指灰度值，y则指映射值，这里指不透明度；\nRemovePoint(double x)：将自变量值为x的断点删除。\nRemoveAllPoint(double x)：删除所有断点。\n\n\n利用不透明函数可以有选择的对图像中的对象进行显示，对于部显示的对象只需将其对应的灰度范围的不透明度映射为0即可。\n\n\n梯度不透明函数\n该函数将梯度模值映射为一个不透明度乘子，从而增强过度区域显示效果，同样是使用vtkPiecewiseFunction类实现。\n\nSetGradientOpacity(vtkPiecewiseFunction*);\n\n\n函数设置类似于不透明传输函数的设置，不过意义不同，详情参见见《VTK图形图像开发进阶》7.3.2节\n\n颜色传输函数\n颜色传输函数与不透明传输函数类似，不同之处是颜色传输函数是将一个标量值映射为一个颜色值，VTK中用vtkColorTransferFunction类实现，其函数为：        \n  AddRGBPoint(double x,double r,double g,double b);AddHSVPoint(double x,double h,double s,double v);\n其中x代表灰度值，r,g,b和h,s,v代表颜色分量。vtkVolumeProperty中设置颜色传输函数的函数原型如下：\n  SetColor(vtkColorTransferFunction*);\n光照与阴影\n通过vtkVolumeProperty可以设置体绘制的阴影效果，阴影效果主要受环境光系数、散射光系数、反射光系数和高光强度4个参数影响。\n  SetDiffuse()  //设置散射光系数SetAmbient()  //设置环境光系数SetSpecular() //设置反射光系数\n一般情况下，着三个系数之和为1.\n\n高光强度系数用于控制体绘制外观平滑程度，使用SetSpecularPower()函数设置。\n\nvtkVolumeProperty中默认是关闭阴影效果，因此需要显示调用ShadeOn()函数来打开阴影效果。\n\n\nvtkLODProp3D\n对一个大数据来讲，体绘制是一个计算量非常庞大、非常耗时的操作，为了提高绘制速度，引入vtkLODProp3D来解决这个问题。\nvtkLODProp3D在渲染过程中，会为每个Mapper估计一个渲染时间，并选择一个最优的实现渲染。用法与vtkVolume类似。\n\n不规则网格数据体绘制\n不规则网格的体绘制渲染流程与规则网格绘制的流程一致，不同的是需要选择应用于不规则网格数据的Mapper对象。所有支持不规则网格体绘制的Mapper类都继承自vtkUnstructuredGridVolumeMapper：\nvtkUnstructureGridVolumeRayCastMapper实现了基于软件实现的不规则网格光线投射算法，该Mapper仅支持4面体数据，非4面体数据需要借助Filter转换一下。该方法需要较大的内存，不适合大数据渲染处理。\nvtkUnstructureGridVolumeRayZSweepMapper实现了一种在任何平台下运行的体绘制方法，是不规则网格数据体绘制方法中最慢的一种，内存需求较小，可以用来渲染大数据。\nvtkProjectTetrahedraMapper实现了经典的投影四面体法。\nvtkHAVSVolumeMapper实现了HAVS算法，能够快速渲染大数据，但由于该类中使用了较多显卡的高级技术，因此只有在支持这些技术的显卡中才能运行该方法。\n\n\n对比4种类的渲染效果，其中ZSweep方法渲染速度最慢，而投影四面体方法较其他两种方法快，但ZSweep方法渲染结果最精确。\n\n更多内容参见《VTK 图形图像开发进阶》。该书得下载地址如下：\n链接：https://pan.baidu.com/s/1hG9js6eZkTqL6Fh-b_C-Dg提取码：cod8 \n推荐阅读：\nVTK图像处理（一）–基本函数介绍以及对应功能\nVTK图像处理（二）–vtkPolyData数据处理\nVTK图像处理（三） | 体绘制 \n\n","categories":["ITK与VTK"],"tags":["ITK","VTK","体绘制"]},{"title":"VTK图像处理（二）--vtkPolyData数据处理","url":"https://tanqingbo.cn/VTK02/","content":"前言\nvtkPolyData数据是一种广泛使用的vtk数据结构，可以用来表示很多常用的数据结构，如点云数据、面片模型等。本文章先分析vtkPolyData数据的基本组成，创建方法和显示管线，结果介绍了一些基本操作，如距离、面积、包围盒、法向量以及符号化等。这些都是高级图像图像处理，此外还着中分析了图形平滑、封闭性检测、连通性分析、多分辨率处理、表面重建、点云配准、纹理映射等内容。掌握这些内容便可以解决许多实际性的工程问题。\n\n详细内容参见《VTK 图形图像开发进阶》第六章。该书得下载地址如下：\n链接：https://pan.baidu.com/s/1hG9js6eZkTqL6Fh-b_C-Dg提取码：cod8 \nvtkPolyData数据生成与显示\nvtkPolyData数据由几何结构数据、拓扑结构数据和属性数据组成。几何结构数据主要是组成模型的点集，拓扑结构数据是点按一定关系组成的单元数据，属性数据与几何结构数据和拓扑结构数据想关联，可以标量、向量、张量，可以用来间接表示图像的颜色。\n\nGetNumberOfPoints()和GetNumberOfCells()可以分别获取图形的点数和单元数目；\nvtkPolyData数据显示时需要定义vtkPolyDataMapper对象，用来接受vtkPolyData数据以实现图形数据到渲染图元的转换。VTK常见的vtkPolyData数据源类vtkPolyData数据的创建\n\n\n需要先定义一个点集和一个单元集合，单元的类型可以是点、三角形、矩形、多边形等基本图形。只有定义了单元数据才能显示该图形数据。\n\n具体创建代码见6.1.2节。\nvtkPolyData属性数据\n图形的颜色与vtkPolyData属性数据息息相关，可为点数据和单元数据分别指定属性数据。\n\n点和单元属性数据分别存储咋vtkPointData和vtkCellData中，可以通过调用GetCellData()函数获取一个vtkCellData类型单元数据指针，在通过SetScalars()函数设置颜色数据。\n\n由于可以同时设置点和单元设置属性，那么怎么用点和单元来控制颜色呢？这就需要使用vtkPolyDataMapper类的方法。\n\nSetScalarModeToDefault()，默认设置，该设置下首先使用点的标量数据控制颜色，若点标量数据不可用时，则使用单元数据。\nSetScalarModeToUsePointData(),使用点的标量数据控制颜色，若点标量数据不可用也不会使用其他数据。\nSetScalarModeToUseCellData(),使用单元的标量数据控制颜色，若单元标量数据不可用也不会使用其他数据。\nSetScalarModeToUsePointFieldData()/SetScalarModeToUseCellFieldData()，点数据和标量数据都不会用来着色，而是使用属性数据中场数据数组。可以通过名字来指定进行颜色渲染的数据。\n\n\n在某些情况下，需要对点属性数据和单元属性数据进行转换，这需要用到两个类vtkCellDataToPointData和vtkPointDataToCellData。转换原理是：当由带属性向单元属性转换时，每个单元属性数据为组成该单元的点对应的属性的平均值；当单元属性数据向点属性数据转换时，点属性为使用该点的单元的属性平均值。\n\n\n基本图形操作\nVTK提供了多种基本图形操作：\n\nvtkLine提供了点与线、线与线间的距离计算；\nvtkTriangle提供了面积、外接圆、法向量的计算，点与三角形位置关系的判断；\nvtkPolygen提供了法向量、重心、面积的计算、点与多边形位置的判断、点与多边形、多边形与多边形相交判断；\nvtkTetra实现了四面体体积计算、重心计算；\nvtkMassProperties实现三角网格的表面积和体积计算，但要求网格必须时封闭的三角网格；\nvtkTriangleFilter可以实现多边形网格向三角网格转换。\n\n\n测地距离：三维模型上两个点的测地距离是指沿着模型表面两者之间的最短距离，通常采用Dijkstra算法近似求解，VTK中的vtkDijkstraGraphGeodesicPath类可实现测地距离求解。通过GetGeodesicLenght()函数可以获取当前计算的两点测地距离的数值。\n\n包围盒是指能够包围模型的最小立方体，常用于模型的碰撞检测中。vtkOutlineFilter提供一个方便的方法来生成包围盒。\n\n\n法向量计算\n三维平面的法向量是指垂直该平面的向量。某点的法向量为垂直该点切平面的法向量。\n在计算网格法向量时，单元法向量可以通过组成每个单元的任意两条边的叉乘向量归并化来表示；二点的法向量则是由使用该点的单元单元法向量的平均值表示。\nVTK中计算法向量的类为vtkPolyDataNormals,可以通过SetComputeCellNormals()和SetComputePointNormals()来设置需要计算的法向量类型，默认计算点法向量。\n计算单元法向量时，要保持单元法向量一致才能得到合理的法向量。SetConsistency()可以自动调整单元点的顺序；SetAutoOrientNormals()可以自动调整法向量方向。\n类vtkPolyDataNormals自动开启对锐边缘处理，如果检测到锐边缘，会将其分裂，使图形更加平滑，可通过SetSplitting()函数关闭该功能。符号化Glyphing\n通过符号化（Glyphing）技术将法向量图形化显示。VTK中使用vtkGlyph3D类实现该功能，并支持图形缩放、着色、设置空间姿态等，需要接受两个输入：几何数据点集合、Glyph图形数据（vtkPolyData数据）。几何数据点集合来自求完法向量的图像，Glyph图形数据用于在点集合处显示法向量。曲率计算\n曲率时曲面弯曲程度的一种度量，是几何体的一种重要局部特征。计算曲面M点曲率，考虑经过M的法线的一个平面与曲面相交，可得到一条二维曲线，经过M的法线的平面可以有很多，与曲面相交时可得到多条曲线，取曲率最大和最小的曲线，若其对应曲率为k1和k2，称为主曲率，而该点的高斯曲率为k1*k2,平均曲率为：(k1+k2)/2。\nVTK中vtkCurvatures类实现了4种网格模型曲率计算方法：\nSetCurvatureTypeToMaximum()：计算最大主曲率；\nSetCurvatureTypeToMinimum()：计算最小主曲率；\nSetCurvatureTypeToGaussian()：计算高斯曲率；\nSetCurvatureTypeToMean()：计算平均曲率。\n\n\n\n网格平滑\n拉普拉斯平滑是一种网格平滑算法，将每个点用其邻域点的中心来代替，通过不断迭代，得到较为光滑的网格。\nvtkSmoothPolyDataFilter类，实现了拉普拉斯平滑算法，用SetNumberOfIterations()控制平滑次数，次数越大，平滑越厉害。\nBoundarySmoothing控制是否对边界点平滑；\nFeatureEdgeSmoothing控制是否对特征边上的点平滑，通过调用SetFeatureAngle()函数设置特征角阈值。\n\n\nvtkSmoothPolyDataFilter类通过拉普拉斯不断迭代，模型会不断向网格中心收缩。\nvtkWindowedSincPolyDataFilter类，使用窗口函数Sinc实现网格平滑，能够最下程度避免收缩，使用方法与vtkSmoothPolyDataFilter类相同。\n\n封闭性检测与填补漏洞\n如果一条边只被一个多边形包含，那这条边就是边界边，是否存在边界边是检测网格模型是否封闭的重要特征。\n\nvtkFeatureEdges类能够提取多边形网格模型中4种类型的边：\n\n边界边；\n非流形边；\n特征边；\n流形边；\n\n\n可以通过判断边界边的数目来网格是否封闭。\n\n检测出网格是否封闭之后可以通过类vtkFillHoleFilter将漏洞填补起来。\n\n\n连通区域分析\nvtkAppendPolyData类可以实现vtkPolyData的合并，使用该类可以方便地构造含有多个连通区域的数据。\nvtkPolyDataConnectivityFilter类用于实现连通区域分析：\nSetExtractionModeToLargestRegion()：用于提取具有最多点的连通区域；\nSetExtractionModeToAllRegion():用于连通区域标记，配合函数ColorRegionsOn()一起使用；\nSetExtractionModeToSpecifiedRegion():用于提取一个或多个连通区域，需要通过AddSpecifiedRegion()来添加需要提取的边界号；\n\n\n\n多分辨率处理网格抽取\n抽取的作用是减少模型数据中的点数据和单元数据，便于后续处理和交互渲染。\nVTK中有3种网格抽取类：\nvtkDecimatePro：用一种塌陷的方法删除点和单元，处理速度快、可以方便的控制网格抽取幅度，得到不同级别的模型数据；\nvtkQuadricDecimation:最终简化率并非严格等于程序中设置的简化率；\nvtkQuadricClustering:3种模型中抽取速度最快的一种，能够处理大数据模型；\n\n\n\n网格细化\n网格细化是利用一定的细化规则，在给定的初始网格中插入新的点，从而不断细化处新的网格单元，在极限细化情况下，该网格能够收敛于一个光滑的平面。\n\nVTK中有3种网格细化类,如下，它们都继承自类vtkInterpolatingSubdivisionFilter,它内部提供了SetnumberOfSubdivisions()函数来设置细化次数，其中每次细化后模型的三角面片的个数将是细化前的4倍。\n\nvtkLinearSubdivisionFilter：实现了一种线性细分算法；\nvtkLoopSubdivisionFilter：实现了Loop细分算法，能够生成光滑连续曲面；\nvtkButterSubdivisionFilter：实现了蝶形细分算法；\n\n\nvtkLoopSubdivisionFilter与vtkButterSubdivisionFilter结果优于vtkLinearSubdivisionFilter。\n\n\n表面重建\n利用表面重建技术将点云数据重建为面模型。三角剖分\n三角剖分将一些散乱的点云数据剖分为一系列三角网格，最常用的三角剖分技术是Delaunay三角剖分，主要用于二维三角剖分，三维数据通常使用点云重建。\nvtkDelaunay2D类实现了2维三角剖分。\nvtkDelaunay3D类实现了3维三角剖分。得到的结果并非三角网格，而是四面体网格，因此，其输出数据类型为vtkUnstructuredGrid.\n\n等值面提取\n类似与面绘制，通过等值面提取提取技术，仅提取感兴趣的一个或者几个组织轮廓，并生成网格模型以供后续处理和显示。\n\n等值面提取算法多基于Marching Cubes算法实现：\n\nvtkImageMarchingCubes主要处理三维图像数据；\nvtkMarchingCubes主要针对规则体数据生成等值面；\nvtkMarchingSquares针对二维规则网格数据生成等值线。\n\n\n通常需要搭配图形平滑、抽取等操作来对等值面数据进行后处理。\n\n\n点云重建\nvtkSurfaceReconstructionFilter实现了一种隐式曲面重建方法，该方法需要对点云数据进行网格划分，然后估算每个点的切平面方向，并以每个点与最近的切平面距离来近似表面距离。用vtkContourFilter来提取面距离来近似表面距离。\n\n点云配准\n点云配准即是对一组原点云数据应用一个空间变换，使得变换后的数据与目标点云数据能够一一映射，使两组数据之间的平均距离误差最小。\n\nvtkLandmarkTransform类实现了标记点配准算法，使得两个点集在配准后平均距离误差最小。通过SetSourceLandmarks()和SetTargetLandmarks()函数分别设置源标记点集和目标标记点集。\n\nSetModeToRigidBody()：函数用于设置其配准变换的类型为刚体变换；\nSetModeToAffine()：设置其配准变换的类型为放射变换；\nSetModeToSimilarity()：设置相似变换，即平移、旋转和放缩变换。\n\n\nvtkVertexGlyphFilter类显示点集；\n\nvtkTransformPolyDataFilter用来对面源标记点进行变换来显示配准后的点集。\n\n点云数据配准最经典的方法是迭代最近点算法（ICP）：每次迭代中对于源数据点P找到目标点集Q中的最近点，然后基于最小二乘原理求解当前的变换T。通过不断迭代直至收敛，即完成了点集的配准。\n\nvtkIterativeClosesPointTransform类中内部定义了一个vtkLandmarkTransform指针，用于就算ICP迭代中最佳匹配点集，可以通过GetLandmarkTransform()函数获取，并通过vtkLandmarkTransform指针设置相应的变换类型。SetMaximumNumberOfIterations()函数用于设置ICP算法迭代次数，StartByMatchingCentroidsOn()函数则用于设置配准之前先计算两个点集重心，并平移源点集使得两者重心重合。配置完毕可以通过GetMatrix()函数来获取相应的变换矩阵。\n\n\n\n纹理映射\n纹理映射是将纹理空间中的纹理像素映射到屏幕空间中的过程。主要是建立纹理空间与模型空间、模型空间与屏幕空间之间的映射关系。\nVTK中定义了许多个类实现纹理空间到模型空间的映射：\nvtkTextureMapToPlane：通过一个平面建立纹理空间到模型空间的映射关系；\nvtkTextureMapToCylinder：通过圆柱面建立映射关系；\nvtkTextureMapToSphere：通过球面建立映射关系；\nvtkTexture：实现加载纹理；\nvtkTransformTextureCoords：实现纹理坐标的平移和缩放；\n\n\n\n推荐阅读：\nVTK图像处理（一）–基本函数介绍以及对应功能\nVTK图像处理（二）–vtkPolyData数据处理\nVTK图像处理（三） | 体绘制 \n\n","categories":["ITK与VTK"],"tags":["ITK","VTK","vtkPolyData"]},{"title":"VTK图像处理（一）--基本函数介绍以及对应功能","url":"https://tanqingbo.cn/VTK01/","content":"前言\n该篇只简单整理VTK图像处理的函数以及对应的功能，详细内容以及具体源码参见《VTK图形图像开发进阶》第五章。\n\n《VTK图形图像开发进阶》下载地址：\n链接：https://pan.baidu.com/s/1hG9js6eZkTqL6Fh-b_C-Dg提取码：cod8 \n1.图像创建\n图像源Source\n\nVTK内置了很多创建图像的Source类，可以创建点、线段、圆、矩形等图像。\nvtkImageCanvasSousce2D:创建画布（空白图像）；\nvtkImageEllipsoidSousce:创建前景为椭圆的二值图像；\nvtkImageGaussianSousce:高斯分布图像；\nvtkImageGridSousce:网格图像；\nvtkImageSinusoidSousce:像素值有正弦函数决定的图像；\n\n\n直接创建图像\n\n手动生成vtkImageData图像数据，再给像素赋值。2.图像显示\n\n\nvtkImageViewer2\n\n该类提供主要的交互操作有图像缩放、窗框窗位的调节、切片选择、切片方向设置。\n可以根据设置不同的切片方向显示不同方向的切面。\n\n\n3维医学图像二视图\n\n在医学图像中，不同方向的切面都有特定的名字；\n矢状面（Sagital Plane）：沿着身体前后径所做的与地面垂直的切面；\n冠状面（Coronal Plane）：沿着身体左右径所做的与地面垂直的切面；\n横断面（Transverse/Axial Plane）：与地面平行的切面。\n\n\nvtkImageActor\n\n是一个3维图像渲染Actor，通过纹理映射将图像映射到一个多边形上进行显示。功能类似于vtkImageViewer2。\n\n\n图像融合\n\n类vtkImageBlend实现图像融合，它可以接收多个图像输入，并输出其融合图像，即把几张图像融合叠在一起显示。\n\n\n\n3.VTK图像基本操作\n图像信息访问与修改\n\n利用vtkImageData的方法：它提供了多个用于信息访问的函数，例如：\n\nGetDimensions()，获取图像维数；\nGetOrigin(),获取图像原点；\nGetSpacing()，获取图像像素间隔；\n还有多个Set函数用于设置图像信息。\n\n\n利用类vtkChangeImageInformation:利用这个类可以修改图像原点，像素间隔以及范围，还可以实现图像平移及缩放等操作。\n\n\n\n\n\n图像像素的访问与修改\n\nvtkImageData中提供了GetScalarPointer()函数数据数组指针，该函数有三种形式：\n\nvirtual void *GetScalarPointer(int coordinates[3]):返回第（x,y,z）个像素的地址；\nvirtual void *GetScalarPointer(int x,int y,int z):返回第（x,y,z）个像素的地址；\nvirtual void *GetScalarPointer():返回图像数据的头指针；\nGetScalarPointer()返回的是void*类型，需要根据图像的具体数据类型强制转换，然后在根据返回的地址修改像素值。\n\n\n用vtkImageIterator类实现迭代器方法访问图像像素，使用时需要提供迭代的图像像素类型以及迭代的区域大小。\n\n\n\n图像类型转换\n\n类vtkImageCast:只需要把该类的函数SetOutputScalarTypeToXXX()设置相应输出类型即可。\n类vtkImageShiftScale:可以指定偏移和比例参数来对输入图像数据进行类型转换操作。\n\n\n图影颜色映射\n\n灰度图像映射 \n类vtkImageLuminance：负责将RGB彩色图像转化为单分组的灰度图像，\n\n\n提取颜色分组\n类vtkImageExtractComponents:提取彩色图像的各个颜色组分，使用该类时只需要设置要提取的组分序号即可。\n\n\n图像彩色映射\n类vtkImageMapToColors:实现图像彩色映射，以vtkLookUpTable类生成颜色查找表。原理时先生成颜色查找表，然后根据图像像素的一个标量值在颜色查找表中查找对应的颜色。\n\n\n颜色合成\n前面提到彩色图像的各个颜色组分，VTK也支持将多个灰度图像合并成一个彩色图像，类vtkImageAppendComponents类可以用来合成彩色图像。其输入需要提供三个灰度图像。合成效果为三个图像中对应的三个像素点的像素值合成一个RGB值，如三个图像中100像素的像素值分别为255，0，0，那么合成图像中该点像素值为（255，0，0），为红色。\n\n\n\n\n区域提取\n\n提取感兴趣的区域\n感兴趣区域（Volume of Interest,VOI）是图像内部的一块子区域，在VTK中vtkExtractVOI类可根据用户指定的区域提取子图像。\n\n\n三维图像切面提取\nVTK中vtkImageReslice类图像切面的提取。\n\n\n\n\n直方图统计\n\n灰度图像直方图\nvtkImageAccumulate类用于实现直方图统计功能，他将每个分组的数值范围离散的间隔，然后统计每个灰度间隔上的像素数目。虽然vtkImageAccumulate输出的类型为vtkImageData，但是不能直接一图像的方式显示。\nvtkBarChartActor类用来显示条形图，可以利用它来显示直方图，但该接受的数据类型为vtkDataObject类型，所以在显示之前需要类型转换。\n\n\n彩色图像直方图\n彩色图像有3个颜色通道，因此需要提取RGB3个通道数据分别计算直方图。每个通道计算直方图的方法与灰度图像直方图的计算方法一致。\n\n\n\n\n图像重采样\n\n图像重采样是指对数字图像按所需的像素位置或像素间距重新采样，以构成几何变换后的新图像。当重采样图像维数小于源图像时，称为降采样，当重采样图像维数大于源图像时，称为升采样。\n类vtkImageShrink3D用于实现图像降采样，图像会更模糊。\n类vtkImageMagnify用于实现图像升采样。\n\n\n图像运算\n\n数学运算：vtkImageMathematics提供了基本的一元二元数学操作。\n逻辑运算：vtkImageLogic接受一个或两个图像进行布尔逻辑运算，该类只要支持与、或、异或、与非、或非、非等操作。\n上述两个操作，两个输入的图像输入图像的类型必须保持一致。\n\n\n图像二值化\n\n图像二值化是一个最简单的图像分割模型，设置一个灰度阈值，将图像中阈值以下的像素设置为背景，阈值以上的设置为前景，即可得到一副二值图像。\nvtkImageThreshold类可实现图像阈值化处理：\nThresholdByUpper()：取大于阈值的灰度范围为有效范围；\nThresholdByLower()：取小于阈值的灰度范围为有效范围；\nThresholdBetween()：取大于UpperThreshold和LowerThreshold之间的部分为有效范围；\n\n\n\n\n\n推荐阅读：\nVTK图像处理（一）–基本函数介绍以及对应功能\nVTK图像处理（二）–vtkPolyData数据处理\nVTK图像处理（三） | 体绘制 \n\n","categories":["ITK与VTK"],"tags":["ITK","VTK"]},{"title":"VTK数据读写","url":"https://tanqingbo.cn/VTKRead-write/","content":"前言\n具体内容参见《VTK图形图像开发进阶》第4章.\n\nReader与Writer\n主要介绍vtkImageData,vtkPloyData,vtkRectilinearGrid等数据类型的Reader/Writer类。\nvtkImageData类型\nvtkImageData类型的数据是按照规则排列在矩形方格中的点和单元集合。\n\nvtkImageData类型的Reader/Writer类如下：\n\n读取RAW格式数据时，该类型图像没有文件信息，因此读取此类图像时，需要指定图像的各个维度大小、字节顺序、存储像素值等信息。\n\n.mha与.mhd：这两个格式差不多，只不过MHA格式图像把图像信息头与实际的像素值等信息写入了同一个文件，而MHD的图像信息头与实际像素值分别存在两个文件（即*.mhd和*.raw/*.zraw,zraw表示有压缩）\n\n*.mhd图像格式信息：\n  ObjectType = Image\t\tNDims = 3                            //表示该图像的维数；\t\tBinaryData = True\t\tBinaryDataByteOrderMSB = False\t\tCompressedData = True\t\tCompressedDataSize = 1961160\t\tTransformMatrix = 1 0 0 0 1 0 0 0 1\t\tOffset = 0 0 0\t\tCenterOfRotation = 0 0 0\t\tAnatomicalOrientation = RAI\t\tElementSpacing = 1 1 1               //像素间的间隔\t\tDimSize = 256 256 41                 //图像各维的大小；\t\tElementType = MET_UCHAR              //存储图像像素值所用的类型\t\tElementDataFile = img-41.zraw        //存储像素数据的文件位置\n读取单个图像：如果无法确定所读取的图像时什么格式，可以用类vtkImageReader2Factory来读取导入的文件。\n\n有图像显示的例子。\n\n\n读取序列图像文件：Reader类有提供SetFileNames()来设置斗个图像文件名，利用该方法可以实现序列图像的读取。\n\n\nvtkPolyData类型\n详见《VTK图形图像开发进阶》第6章。\n\n《VTK图形图像开发进阶》下载地址：\n链接：https://pan.baidu.com/s/1hG9js6eZkTqL6Fh-b_C-Dg提取码：cod8 \n\n\n推荐阅读：\nVTK图像处理（一）–基本函数介绍以及对应功能\nVTK图像处理（二）–vtkPolyData数据处理\nVTK图像处理（三） | 体绘制 \n\n","categories":["ITK与VTK"],"tags":["ITK","VTK"]},{"title":"window下运行VTK程序","url":"https://tanqingbo.cn/window-run-VTK/","content":"前言前面介绍了如何在Windows下配置ITK和VTK的环境：window下利用VS安装与搭建ITK环境，这篇文章介绍如何在Windows下运行VTK程序。\n\n通常一个简单的VTK工程由两部分组成，一个是C++的源码文件，后缀通常是“.cxx”或”.cpp”，这个文件中是编写的VTK程序代码。还有一个是CMakeLists.txt配置文件，每一个VTK工程都必须有一个名字为CMakeLists.txt的配置文件，方便程序在编译的时候找到VTK库。\n\n\n\n打开CMake软件，在Where is the source code:和Where to build the binaries:这两个框中选中VTK工程的目录（也就是包含上面两个文件的目录），如下图所示：\n\n\n\n点击左下角Configure按钮，选择默认的编译器，等几十秒之后再中间部分会出现三行红色的文字，将CMAKE_INSTALL_PREFIX后面的目录改成源程序的路径，也就是和Where is the source code:后面的路径一致，同时将VTK_DIR的路径改成VTK_build所在的路径，然后再重新点击左下角Configure按钮，之后再点击Generte按钮，若最下面的框框中显示Configuring done和Generating done字样，就表示程序配置编译成功了。如下图：\n\n\n\n此时源程序的文件夹中就会多了很多文件，双击打开后缀为.sln的文件，VS会自动打开该文件。\n\n\n\n之后比那可以在VS中自由修改代码以及运行程序了。\n\n\n","categories":["ITK与VTK"],"tags":["ITK","VTK"]},{"title":"ITK与VTK混合编程之ItkVtkGlue","url":"https://tanqingbo.cn/ITK-VTK-ItkVtkGlue/","content":"前言做医学图像处理的时候，通常都是利用ITK做图像处理，VTK做可视化，所以在图像处理的过程中有时需要ITK与VTK混合编程。该文档是基于Linux系统的，VTK在Linux下安装与ITK的安装很相似，ccmake的时候默认配置就好，具体参见Linux 下配置ITK.\n在ITK与VTK混合编程的时候需要安装另外一个工具ItkVtkGlue。下面就开始介绍如何安装ItkVtkGlue。\nItkVtkGlue\n首先需要下载ItkVtkGlue的源码包，下载地址： download ItkVtkGlue\n\n将ItkVtkGlue的源码包解压到ITK目录下，并在ITK目录下新建ItkVtkGlue-bin目录用来存放ItkVtkGlue的源码包的编译文件。\n  ~/ITK/itkvtkglue-bin$ ccmake ../ItkVtkGlue\t\t~/ITK/itkvtkglue-bin$ make\n配置与编译ItkVtkGlue的源码的方式和配置编译ITK程序的方式一样。\nCMakeLists.txt\n每一个ITK或者VTK程序都需要一个CMakeLists.txt文件，并放在同一个目录下，该文件包含了cmake的版本信息、程序执行的环境信息以及整个工程的信息，所以在执行ITK和VTK程序是必须要有CMakeLists.txt文件。\n\nITK与VTK混合编程时，CMakeLists.txt文件的信息如下：\n\n\ncmake_minimum_required(VERSION 2.8)project(SubtractImageFilter)find_package(ITK REQUIRED)include(${ITK_USE_FILE})if (ITKVtkGlue_LOADED)  find_package(VTK REQUIRED)  include(${VTK_USE_FILE})else()  find_package(ItkVtkGlue REQUIRED)  include(${ItkVtkGlue_USE_FILE})  set(Glue ItkVtkGlue)endif()add_executable(SubtractImageFilter MACOSX_BUNDLE SubtractImageFilter.cxx)target_link_libraries(SubtractImageFilter  ${Glue}  ${VTK_LIBRARIES} ${ITK_LIBRARIES})\n\n\n在ccmake配置的时候会提示输入ItkVtkGlue的目录，类似输入ITK编译后的目录一样，在提示itkvtkglue目录路径的地方输入itkvtkglue-bin文件所在的目录就好了，然后程序就能正常编译了。找不到“itkImageToVTKImageFilter.h”的问题\n在程序的头文件中如果引入’itkImageToVTKImageFilter.h’头文件，会提示找不到该文件，这时需要下载一个工具包：InsightApplications.zip，下载地址：download InsightApplications。\n解压InsightApplications.zip文件，将itkImageToVTKImageFilter.h，itkImageToVTKImageFilter.txx从\\InsightApplications\\Auxiliary\\vtk文件夹找出添加到正在执行的工程文件，然后再编译就不会有错了。\n\n","categories":["ITK与VTK"],"tags":["ITK","VTK","ItkVtkGlue"]},{"title":"window下利用VS安装与搭建ITK环境","url":"https://tanqingbo.cn/ITK-VS-install/","content":"前言ITK（ Insight Segmentation and Registration Toolkit）是一款医学图像处理软件包，是一个开源的、跨平台的影像分析扩展软件工具。对于从事医学图像处理的工作的人来说，ITK是一款必不可缺的工具。\n本文介绍了如何在Windows环境下利用vs安装ITK。\n工具下载链接以及说明\n下载CMake:http://www.cmake.org/cmake/resources/software.html选择与电脑对应的版本，然后默认安装。\n\n下载ITK压缩包：http://www.itk.org/ITK/resources/software.html,   InsightToolkit-4.10.1.zip\n\n在 D 盘新建文件夹: D:/I_VTK/ITK , 之所以要多建立一个 ITK 文件夹, 是为了以后 ITK, VTK 混合编程,这里暂时只编译 ITK.\n\n解压InsightToolkit-4.10.1.zip到  D:/I_VTK/ITK\n\n再建立一文件夹 ITK_bin, 作为 ITK 编译目标. D:\\I_VTK\\ITK\\ITK_bin\n编译过程\n打开之前安装好的 CMAKE 进行配（ 假设你已经安装好 VS）：Where is the source code: 点击 Browse, 选择刚才 ITK 源码目录: D:\\I_VTK\\ITK\\InsightToolkit-4.10.1Where to build the binaries: 点击 Browse, 选择 ITK 编译目标: D:\\I_VTK\\ITK\\ITK_bin\n\n点击Configure，选择“Visual Studio 10”编译器（如图2），点击Finish。\n\n勾选Advanced之后更改CMAKE_INSTALL_PREFIX（表示编译ITK后生成的 lib 及头文件等安装路径）目录可以设置为 D:/I_VTK/ITK\n\n再次点击 Configure, 直至所有条目都变成灰色,表示配置成功, 点击 Generate确认。\n\n在ITK_bin文件下找到ITK.sln,右击选择VS打开，点击生成-&gt;生成解决方案，这个过程大概需要1个多小时。如果没有错误的话找到“INSTALL”文件右击，选择“仅生成项目”-&gt;“仅生成INSTALL”。如果没有错误就会在ITK文件夹下出现如下图所示的文件夹：\n\n然后设置ITK的环境变量：如：D:\\ITK\\ITK_bin,把bin下面的dll文件复制到c:\\windows\\system32 中。\n\n\n测试是否安装成功\n从ITK\\InsightToolkit-4.5.0\\Examples\\Installation目录下直接复制HelloWorld文件和所需的CMakeLists.txt文件。如在ITK文件下创建test文件夹，然后再test文件夹下创建Hello和Hello_bin文件夹，然后把前面复制的两个文件放入Hello文件夹中，启动cmake,按第二步的生成方法，把HelloWorld.cxx放入第一栏，把CMakeLists.txt放入第二栏，点击“Configure”，没错误直接点击“Generate”，然后用到Hello_bin中用VS打开HelloWorld,sln文件，右击HelloWorld，选择”设为启动项目“，然后点击运行即可。至此，ITK安装成功。\n\n","categories":["ITK与VTK"],"tags":["ITK","VTK","VS"]},{"title":"Windows和Ubuntu系统如何远程连接Linux服务器","url":"https://tanqingbo.cn/xshell-connect-Linux/","content":"前言\n因为很多实验都要在工作站上面运行，为了避免拿着装着数据的硬盘在自己电脑和工作站之间来回跑，我简单总结一下在windows和Ubuntu系统下远程访问Linux服务器的过程吧，也方便大家参考。\n\nWindows连接Ubuntu服务器准备工作xshell软件下载地址：\n链接：http://pan.baidu.com/s/1c1Woj2C \n密码：l6hg\n安装xshell:**正常安装就行，注意用途不要选择商业版，商业版收费，选择教学/学生版就行**。\n\nxshell连接Ubuntu安装openssh-server\n安装完xshell后要先在连接的Ubuntu主机下开启SSH服务，因为xshell是用ssh服务连接Ubuntu的，当然也可以配置免密码登陆Ubuntu，但那个稍微要复杂一点，我们只介绍用账号密码登陆。\n\n一般需要先安装openssh-server，才能开启ssh服务，在Ubuntu机器上运行：\n  sudo apt-get install openssh-server\n然后开启ssh服务：\n ps -e | grep ssh\n一般建议服务器24小时开机，这样就不用每次都要启动ssh了.\n\n\nxshell会话\n打开xshell软件，点击左上角 新建，输入连接名称，Ubuntu机器的IP地址，注意协议选择ssh,端口是22.\n\n\n\n单击确定按钮，再单击连接按钮，之后会跳出一个窗口，让你输入用户名和密码，可以选择记住用户名和密码，这样省得下次重新输入了。\n\n\n\n然后单击确定按钮，就可以看到你已经连接上Ubuntu系统了。\n然后你对服务器的一切操作都可以再这个终端操作了。既然选择了Linux系统，应该适应这种纯命令行操作，熟悉之后效率会高很多。\n\n文件传输\n这是最重要的一部分，既然要在服务器上跑数据，那就得吧数据传到服务器上吧。\n\n文件传输得方法有很多，我之前用过filezilla传文件，后来我发现一种更简单的传文件方法。可以用上传下载工具包rz及sz上传和下载文件。\n\n先安装工具包，在xshell命令框种输入：\n  sudo apt-get install lrzsz\n安装完之后，从Windows上传文件，命令为rz,如图：\n\n\n\n\n从服务器上下载文件到Windows的命令为sz，后面要跟下载文件的文件名：\n  sz 2017-谭庆波.doc\n这条命令执行的时候会让你选择文件保存的路径，然后点击确定按钮就可以了。\n\n因为是局域网，用这种方法传大文件应该也没有什么压力。\n\n\nUbuntu连接Linux服务器\n在连接之前还是要保证Linux服务器上装有openssh-server啦，怎么安装参见上面~\n\n在Linux服务器上修改ssh的配置文件，这个文件 /etc/ssh/sshd_config，在里面将PermitRootLogin的值改成yes,然后在重启一下ssh服务。\n  PermitRootLogin yes\tservice sshd restart\n之后就可以在你的Ubuntu机器上远程登陆这台服务器了。方式如下：\nssh rootusername@IP\n\nrootusername是你服务器的用户名，IP是你服务器的IP地址，之后在输入密码，就可以登陆上去了。\nUbuntu文件传输\n上传文件：\n  scp 文件名 rootusername@IP：/tmp\n由于文件系统的权限问题，只能将本系统的文件上传到服务器的/tmp文件夹下，然后再从tmp文件夹中拷到需要的目录中去。\n\n下载文件：\n\n如果把文件从远程机器拷贝到本机当前目录用这个命令：\nscp rootusername@IP:/home/a.tar.tz \n\n拷贝远程机器的整个目录下的文件：\n  scp -r rootusername@IP：/home/* ./\n注意，文件传输命令都是在本地机终端上运行。\n\n\n","categories":["Linux"],"tags":["Linux","Windows","xshell"]},{"title":"程序员面试必备经典书籍","url":"https://tanqingbo.cn/IT-interview-basic/","content":"大家都知道，计算机是现在当之无愧的高薪行业，但是所谓的高新前提是你得有能力在这个行业找到一份满意的工作，否则其他都是白扯，所以我花了几天的时间整理了一份和程序员面试相关的经典书籍，每一本的评价都很不错，希望能帮助你在面试的过程中少走弯路，找到自己满意的工作。\n1、《程序员面试白皮书》这本书是程序员和IT从业人员的面试求职指南。结合面试实例，详细介绍了数据结构、算法以及计算机基础知识在面试的过程中侧重的考查重点。书的内容也比较全面，覆盖了网络、操作系统、编译器、算法和数据结构等等各个领域的知识。因为程序员面试是对于面试者计算机知识的全面检测，所以这本书还是很值得看的。\n下载地址：\n链接：https://pan.baidu.com/s/1IdWBB7QPRbeqngNv9FZANw提取码：b799 \n\n2、《程序员面试宝典》这本书取材于各大公司面试的真题，包括笔试、口试、电话面试、英语面试，以及逻辑测试和智商测试等，详细分析了应聘计算机专业相关职位的常见考点。不仅对传统的C系语言考点做了详尽解释，还根据外企出题最新特点，新增了对友元、Static、图形/音频、树、栈、ERP等问题的深入讲解。\n下载地址：\n链接：https://pan.baidu.com/s/1g6GBbSmHB0F_TZJiE293Tg提取码：g5uv \n\n3、《剑指offer》这本书大家一定如雷贯耳吧，基本上只要你是程序员就一定会用到这本书，面试必刷，书里面剖析了50个典型的程序员面试题，从基础知识、代码质量、解题思路、优化效率和综合能力五个方面系统整理了影响面试的5个要点，是程序员找工作必备的一本书。\n下载地址：\n链接：https://pan.baidu.com/s/1xwssbrCGU-7eYr4zj7cZkA提取码：8zvu \n\n4、《Java程序员面试笔试宝典》Java程序员目前就业形势较好，因为Java的应用太广泛了，从网页开发到手机安卓开发，都离不开Java。本书紧扣面试精髓，对各种技术剖析一针见血，是想找工作的Java程序员和刚毕业学生的面试宝典。\n下载地址：\n链接：https://pan.baidu.com/s/1Px1bXv8eC7_90aBsA2kJvA提取码：o5j8 \n\n5、《C和C++程序员面试秘籍》大家都知道，很多高级语言都是在C/C++的基础上封装的，所以说学好C/C++的语言基础对从事软件开发的人员来说非常重要。本书是一本解析C/C++面试题的书，可以帮助求职者更好地准备面试。\n下载地址：\n链接：https://pan.baidu.com/s/1qPR1UhV8z3fxyrMUO1biMA提取码：89s5 \n\n6、《Android高薪之路：Android程序员面试宝典》这本书取材于各大IT公司面试真题，所给出的试题尽可能地覆盖了Android应用开发的各个方面，而且大多数试题都有解析部分，读者可以通过这部分更深入地理解试题中所包含的技术内容，希望真正做到由点成线，举一反三。特别适合想从事Android开发的同学阅读。\n下载地址：\n链接：https://pan.baidu.com/s/1lXDmMvwtAsr6kDHtCV1j5g提取码：tksg \n\n7、《软技能：代码之外的生存指南》通过上面那些书找到满意的工作之后，接下来就该修炼代码之外的“软技能”了。对大多数软件开发人员而言，编码才是有趣的，而如何与客户、同事以及经理们打交道，如何保证工作效率，如何保障财务安全，如何保持自己的体形，如何找到真爱……这些则统统被视为畏途。本书恰恰可以在这些方面帮到你！哈哈~\n下载地址：\n链接：https://pan.baidu.com/s/1jw5IY-BThswHUACFJKz-aQ提取码：a41v \n\n","categories":["编程资料"],"tags":["程序员面试","offer"]},{"title":"牛逼，看完它，你就会全网爬虫了","url":"https://tanqingbo.cn/python爬虫教程/","content":"前言：最近后台有人留言问：有没有python爬虫的相关教程，爬虫不是我专业方向，很多不是很熟悉，而网上很多资料讲的过于散乱，不能很好的系统性学习爬虫，而且水平参差不齐。特委托一位熟悉爬虫的小伙伴，帮忙把关，将网上现有资料进行整合，整理了一份相对比较系统的资料。小伙伴感兴趣可以自取~\n此外，我还花钱买了两本python爬虫相关的电子书《Python 3网络爬虫开发实战》和《用Python写网络爬虫》，下载地址：\n链接：https://pan.baidu.com/s/1Tn8ovbY_1qBT0yr2nqh-iQ\n提取码：xgf1\n进入正题：对于入门的小伙伴，首先需要解决四个问题：\n\n熟悉Python编程；\n\n了解HTML;\n\n了解网络爬虫的基本原理；\n\n学习使用Python爬虫库.\n\n\n若不知道自己是否满足入门条件，也没关系，这儿有份资料：《入门爬虫》小伙伴可以据此进行一下自我判断、或简单入门，emm…培养一下爬虫兴趣也是很棒的！！如果觉得太复杂了，这儿有份10分钟Python爬虫菜鸟教程。\n循序渐进教程篇：来源于https://cuiqingcai.com/1052.html一、爬虫入门\nPython爬虫入门一之综述\n\nPython爬虫入门二之爬虫基础了解\n\nPython爬虫入门三之Urllib库的基本使用\n\nPython爬虫入门四之Urllib库的高级用法\n\nPython爬虫入门五之URLError异常处理\n\nPython爬虫入门六之Cookie的使用\n\nPython爬虫入门七之正则表达式\n\n\n二、爬虫实战\nPython爬虫实战一之爬取糗事百科段子\n\nPython爬虫实战二之爬取百度贴吧帖子\n\nPython爬虫实战三之实现山东大学无线网络掉线自动重连\n\nPython爬虫实战四之抓取淘宝MM照片\n\nPython爬虫实战五之模拟登录淘宝并获取所有订单\n\nPython爬虫实战六之抓取爱问知识人问题并保存至数据库\n\nPython爬虫实战七之计算大学本学期绩点\n\nPython爬虫实战八之利用Selenium抓取淘宝匿名旺旺\n\n\n三、爬虫利器\nPython爬虫利器一之Requests库的用法\n\nPython爬虫利器二之Beautiful Soup的用法\n\nPython爬虫利器三之Xpath语法与lxml库的用法\n\nPython爬虫利器四之PhantomJS的用法\n\nPython爬虫利器五之Selenium的用法\n\nPython爬虫利器六之PyQuery的用法\n\n\n四、爬虫进阶\nPython爬虫进阶一之爬虫框架概述\n\nPython爬虫进阶二之PySpider框架安装配置\n\nPython爬虫进阶三之爬虫框架Scrapy安装配置\n\nPython爬虫进阶四之PySpider的用法\n\nPython爬虫进阶五之多线程的用法\n\nPython爬虫进阶六之多进程的用法\n\nPython爬虫进阶七之设置ADSL拨号服务器代理\n\n\n高端段位实战篇：来源：https://zhuanlan.zhihu.com/p/73742321\nPython 岗位分析报告\n\nSelenium介绍\n\n抖音App视频抓包\n\nBilibili 用户\n\nBilibili 视频\n\nBilibili 小视频\n\nBing美图爬虫\n\nB站760万视频信息爬虫\n\n博客园(node.js)\n\n百度百科(node.js)\n\n北邮人水木清华招聘\n\n百度云网盘\n\n琉璃神社爬虫\n\nBoss 直聘\n\n贝壳网找房爬虫\n\n暗网爬虫(Go)\n\n豆瓣读书\n\n豆瓣爬虫集\n\n豆瓣害羞组\n\n豆瓣图书广度爬取\n\nDNS记录和子域名\n\nDHT网络磁力种子爬虫\n\n抖音\n\n爱丝APP图片爬虫\n\n京东\n\n京东搜索+评论\n\n京东商品+评论\n\n机票\n\n煎蛋妹纸\n\n煎蛋妹纸selenium版本\n\n今日头条，网易，腾讯等新闻\n\n计算机书籍控图书\n\nQQ空间\n\nQQ 群\n\n清华大学网络学堂爬虫\n\n去哪儿\n\n前程无忧Python招聘岗位信息爬取分析\n\nsoundcloud\n\nStackoverflow 100万问答爬虫\n\nShadowsocks 账号爬虫\n\nspider163 网易云音乐爬虫\n\n时光网电影数据和海报爬虫\n\ntumblr\n\n下载tumblr喜欢内容\n\nTuShare\n\n天猫双12爬虫\n\nTaobao mm\n\nTmall 女性文胸尺码爬虫\n\n淘宝直播弹幕爬虫(node)\n\n天涯论坛文章\n\n天眼查爬虫\n\n乌云公开漏洞\n\n微信公众号\n\n“代理”方式抓取微信公众号文章\n\n网易新闻\n\n网易精彩评论\n\n微博主题搜索分析\n\n网易云音乐\n\n新.网易热评\n\n唯品会商品\n\nZOL 手机壁纸爬虫\n\n知乎(python)\n\n知乎(php)\n\n知网\n\n知乎妹子\n\n自如实时房源提醒\n\n中国大陆高校列表爬虫\n\n游戏直播行业真的如你想象般暴利？\n\n五一不看人人人人人人，哪儿耍合适？\n\n大碗宽面 VS 律师函警告，情感分析吴亦凡自黑式圈粉！\n\n没经验没学历的外教为啥能拿1.4W+的高薪？\n\n大胆，都是哪些程序员在反对996？！\n\n儿科医生的眼泪，全被数据看见了\n\n用大数据扒一扒蔡徐坤的真假流量粉\n\n北上广深租房图鉴\n\n六万条数据全面解析，城市春节禁放烟花爆竹真的有用吗？\n\n十万条评论告诉你，给《流浪地球》评1星的都是什么心态？\n\n开年表情包局部富有指南，盘它！\n\n看完这篇分析，楼下的Tony和Kevin都改名了！\n\n回复“实习僧”CTO之换种姿势爬取实习僧网站\n\n【20G】Kaggle数据集强势分析“绝地求生”，攻略吃鸡！\n\n50行代码教你打造一个公众号文章采集器\n\n《我是大侦探》到底怎么了？(上：数据爬取篇)\n\n《我是大侦探》到底怎么了？（下：情感分析篇）\n\n帮了个小忙|破解“实习僧”网站字体加密\n\n“小忙”连载篇|实习僧网站数据分析\n\nFacebook模拟登录\n\n微博网页版模拟登录\n\n知乎模拟登录\n\nQQZone模拟登录\n\nCSDN模拟登录–已恢复\n\n淘宝爬虫–重构中\n\nBaidu模拟登录一\n\n果壳爬虫程序\n\nJingDong 模拟登录和自动申请京东试用\n\n163mail–已恢复\n\n拉钩模拟登录–已失效\n\nBilibili模拟登录\n\n\n附录：1. Python网络爬虫知识架构\n","categories":["Python"],"tags":["Python","爬虫"]},{"title":"Python爬虫基础知识总结","url":"https://tanqingbo.cn/Python-crawler/","content":"Python爬虫\n爬虫：一段自动抓取互联网信息的程序\n价值：互联网数据，为我所用。爬虫运行原理\nURL管理器：管理待抓取的URL集合和已抓取URL，防止重复和循环抓取。URL管理器实现：\n\n\n用ｓｅｔ（）集合存放待爬取和已爬取得ＵＲＬ。\nmysql数据库存放待爬取和已爬取得ＵＲＬ，url（url,is_crewled）\n缓存数据库存放待爬取和已爬取得ＵＲＬ。网页下载器\n\n\n网页下载器是将互联网上的url对应的网页下载到本地的工具。\nPython的网页下载器：urllib2urllib2下载网页方法1：最简洁方法  import urillb2 \n  response=urilb2.urlopen('http:www.baidu.com')//直接请求 \n  printf response.getcode()//获取状态码(如果是200，表示获取成功) \n  cont = response.read()//读取内容\nurllib2下载网页方法2：添加data  http  header  import urillb2 \n  request=urilb2.Request(url)//创建request对象\n  request.add_data('a','1')//添加数据\n  request.add_header('User-Agent','Mozilla/5.0')//添加http的header\n response = urllib2.urlopen(request)//发送获取结果\nurllib2下载网页方法3:添加特俗情景的处理器import urllib2,cookielibcj=cookielib.CookieJar()//创建cookie容器opener=urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))//创建一个openerurllib2.install_opener(opener)//给urllib2安装openerres=urllib2.urlopen(\"http://www.baidu.com\")//使用带有cookie的urllib2访问网页\n\n\n\n\n在Eclipse中安装PyDev\n在Eclipse中：Help-Install New Software\n然后在弹出的Install窗口中，点击Add去添加仓库。\n然后就可以看到Eclipse去搜索了，很快，就可以找到PyDev了\n取消掉那个：Contact all update sites during install to find required software\n然后一直next就行哈！\n\n网页解析器\n网页解析器的种类：正则表达式   html.parser    Beautiful Soup插件（最强大）     lxml插件（除正则表达式外，其他都是结构化解析）\n安装Beautiful Soup\nBeautiful Soup是Python的第三方库，用于从HTML和xml中提取数据\n\n官网：http://www.crummy.com/software/BeautifulSoup/bs4/doc/\n从cmd中进入到Python的安装目录下的Scripts，执行： pip install beautifulsoup4\n安装好之后，eclipse执行： #coding:utf-8\n import bs4\n print bs4\n\n结果不报错，则安装成功\nBeautiful Soup语法\n由html网页内容创建Beautiful Soup对象，有两个方法：find_all(寻找所有满足要求的节点)，find（寻找第一个满足要求的节点），两个方法的参数一模一样。\n\n通过节点在访问节点名称、属性、文字。\n\n\n创建Beautiful Soup对象      from bs4 import BeautifulSoup​    #根据网页内容创建BeautifulSoup对象​     soup =BeautifulSoup(​              html_doc,             # html文档字符​              'html.parser',         # HTML解析器​              from_encoding='utf8'  # HTML文档编码​                  )\n\n\n搜索节点\nfind_all(name,attrs,string)\n\n访问节点信息  node.name    #获取节点标签名\n  node['href']  #获取节点href属性\n  node.get_text()  #获取节点文字\nBeautiful Soup实例 #coding:utf-8\n from bs4 import BeautifulSoup\n from setuptools.package_index import HREF\n import re\n\n html_doc = \"\"\"\n &lt;html&lt;head&lt;titleThe Dormouse's story&lt;/title&lt;/head\n &lt;body\n &lt;p class=\"title\"&lt;bThe Dormouse's story&lt;/b&lt;/p\n\n &lt;p class=\"story\"Once upon a time there were three little sisters; and their names were\n &lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"Elsie&lt;/a,\n &lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"Lacie&lt;/a and\n &lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"Tillie&lt;/a;\n and they lived at the bottom of a well.&lt;/p\n\n &lt;p class=\"story\"...&lt;/p\n \"\"\"\n\n\n     soup =BeautifulSoup(\n            html_doc,             # html文档字符\n            'html.parser',         # HTML解析器\n           from_encoding='utf8'  # HTML文档编码\n                )\n print '获取所有链接'\n links = soup.find_all('a')\n for link in links:\n     print link.name,link['href'],link.get_text()\n\n\n print '获取lacie的链接'\n link_node = soup.find('a',href='http://example.com/lacie')\n print link_node.name,link_node['href'],link_node.get_text()\n\n\n print \"正则匹配\"\n link1 = soup.find('a',href=re.compile(r\"ill\"))\n print link1.name,link1['href'],link1.get_text()\n\n\n print \"获取P段落文字\"\n p_node = soup.find('p',class_=\"title\")\n print p_node.name,p_node.get_text()       \n实例爬虫 #coding:utf-8\n import urllib2\n import cookielib\n\n url = \"http://www.baidu.com\"\n\n print \"第一种方法\"\n response1 = urllib2.urlopen(url)\n print \"打印状态码，200即为请求成功\"\n print response1.getcode()\n print \"打印网页内容的长度\"\n print len(response1.read())\n\n print '第二种方法'\n request = urllib2.Request(url)\n request.add_header(\"user-agent\",\"Mozilla/5.0\")\n response2 = urllib2.urlopen(request)\n print response2.getcode()\n print len(response2.read())\n\n\n\n print '第三种方法'\n cj = cookielib.CookieJar()\n opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))\n urllib2.install_opener(opener)\n response3 = urllib2.urlopen(url)\n print response3.getcode()\n print cj\n print \"打印网页内容\"\n print response3.read()  \n目标：百度百科Python词条相关词条网页入口页：http://baike.baidu.com/view/21087.htmlURL格式：\n词条页面URL：/view/125370.htm数据格式：\n标题：\n\n&lt;dd class=\"lemmaWgt-lemmaTitle-title\"&lt;h1****&lt;/h1&lt;/dd\n\n\n\n\n简介：\n   \"&lt;div class=\"lemma-summary\" label-module=\"lemmaSummary\"***&lt;/div\"\n\n\n\n\n页面编码：UTF-8实例代码：爬取百度百科Python词条相关1000个页面数据\n代码下载链接：github下载\n\n","categories":["Python"],"tags":["Python","爬虫"]},{"title":"你应该知道什么是爬虫？","url":"https://tanqingbo.cn/What-is-crawler/","content":"本回答针对初学者，我会用最简单的案例告诉你如何入门python爬虫！想要入门Python 爬虫首先需要解决四个问题熟悉python编程了解HTML了解网络爬虫的基本原理学习使用python爬虫库一、你应该知道什么是爬虫？网络爬虫，其实叫作网络数据采集更容易理解。就是通过编程向网络服务器请求数据（HTML表单），然后解析HTML，提取出自己想要的数据。归纳为四大步：根据url获取HTML数据解析HTML，获取目标信息存储数据重复第一步这会涉及到数据库、网络服务器、HTTP协议、HTML、数据科学、网络安全、图像处理等非常多的内容。但对于初学者而言，并不需要掌握这么多。二、python要学习到什么程度如果你不懂python，那么需要先学习python这门非常easy的语言（相对其它语言而言）。编程语言基础语法无非是数据类型、数据结构、运算符、逻辑结构、函数、文件IO、错误处理这些，学起来会显枯燥但并不难。刚开始入门爬虫，你甚至不需要去学习python的类、多线程、模块之类的略难内容。找一个面向初学者的教材或者网络教程，花个十几天功夫，就能对python基础有个三四分的认识了，这时候你可以玩玩爬虫喽！当然，前提是你必须在这十几天里认真敲代码，反复咀嚼语法逻辑，比如列表、字典、字符串、if语句、for循环等最核心的东西都得捻熟于心、于手。教材方面比较多选择，我个人是比较推荐python官方文档以及python简明教程，前者比较系统丰富、后者会更简练。三、为什么要懂HTML前面说到过爬虫要爬取的数据藏在网页里面的HTML里面的数据，有点绕哈！维基百科是这样解释HTML的超文本标记语言（英语：HyperTextMarkupLanguage，简称：HTML）是一种用于创建网页的标准标记语言。HTML是一种基础技术，常与CSS、JavaScript一起被众多网站用于设计网页、网页应用程序以及移动应用程序的用户界面[3]。网页浏览器可以读取HTML文件，并将其渲染成可视化网页。HTML描述了一个网站的结构语义随着线索的呈现，使之成为一种标记语言而非编程语言。总结一下，HTML是一种用于创建网页的标记语言，里面嵌入了文本、图像等数据，可以被浏览器读取，并渲染成我们看到的网页样子。所以我们才会从先爬取HTML，再 解析数据，因为数据藏在HTML里。学习HTML并不难，它并不是编程语言，你只需要熟悉它的标记规则，这里大致讲一下。HTML标记包含标签（及其属性）、基于字符的数据类型、字符引用和实体引用等几个关键部分。HTML标签是最常见的，通常成对出现，比如&lt;h1&gt;与&lt;/h1&gt;。这些成对出现的标签中，第一个标签是开始标签，第二个标签是结束标签。两个标签之间为元素的内容（文本、图像等），有些标签没有内容，为空元素，如&lt;img&gt;。以下是一个经典的Hello World程序的例子：&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;This is a title&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;p&gt;Hello world!&lt;/p&gt;\n  &lt;/body&gt;\n&lt;/html&gt;HTML文档由嵌套的HTML元素构成。它们用HTML标签表示，包含于尖括号中，如&lt;p&gt;[56]在一般情况下，一个元素由一对标签表示：“开始标签”&lt;p&gt;与“结束标签”&lt;/p&gt;。元素如果含有文本内容，就被放置在这些标签之间。四、了解python网络爬虫的基本原理在编写python爬虫程序时，只需要做以下两件事：发送GET请求，获取HTML解析HTML，获取数据 这两件事，python都有相应的库帮你去做，你只需要知道如何去用它们就可以了。五、用python库爬取百度首页标题和图片首先，发送HTML数据请求可以使用python内置库urllib，该库有一个urlopen函数，可以根据url获取HTML文件，这里尝试获取百度首页“https://www.baidu.com/”的HTML内容# 导入urllib库的urlopen函数\nfrom urllib.request import urlopen \n# 发出请求，获取html\nhtml = urlopen(\"https://www.baidu.com/\")\n# 获取的html内容是字节，将其转化为字符串\nhtml_text = bytes.decode(html.read())\n# 打印html内容\nprint(html_text)看看效果：输出html内容部分截取我们看一下真正百度首页html是什么样的，如果你用的是谷歌浏览器，在百度主页打开设置&gt;更多工具&gt;开发者工具，点击element，就可以看到了：在谷歌浏览器中查看HTML对比一下你就会知道，刚才通过python程序获取到的HTML和网页中的一样！获取了HTML之后，接下就要解析HTML了，因为你想要的文本、图片、视频都藏在HTML里，你需要通过某种手段提取需要的数据。python同样提供了非常多且强大的库来帮助你解析HTML，这里以著名的python库BeautifulSoup为工具来解析上面已经获取的HTML。BeautifulSoup是第三方库，需要安装使用。在命令行用pip安装就可以了：pip install bs4BeautifulSoup会将HTML内容转换成结构化内容，你只要从结构化标签里面提取数据就OK了：比如，我想获取百度首页的标题“百度一下，我就知道”，怎么办呢？这个标题是被两个标签套住的，一个是一级标签&lt;head&gt;&lt;head&gt;,另一个是二级标签&lt;title&gt;&lt;title&gt;，所以只要从标签中取出信息就可以了# 导入urlopen函数\nfrom urllib.request import urlopen\n# 导入BeautifulSoup\nfrom bs4 import BeautifulSoup as bf\n# 请求获取HTML\nhtml = urlopen(\"https://www.baidu.com/\")\n# 用BeautifulSoup解析html\nobj = bf(html.read(),'html.parser')\n# 从标签head、title里提取标题\ntitle = obj.head.title\n# 打印标题\nprint(title)看看结果：这样就搞定了，成功提取出百度首页的标题。如果我想要下载百度首页logo图片呢？第一步先获取该网页所有图片标签和url，这个可以使用BeautifulSoup的findAll方法，它可以提取包含在标签里的信息。一般来说，HTML里所有图片信息会在“img”标签里，所以我们通过findAll(\"img\")就可以获取到所有图片的信息了。# 导入urlopen\nfrom urllib.request import urlopen\n# 导入BeautifulSoup\nfrom bs4 import BeautifulSoup as bf\n# 请求获取HTML\nhtml = urlopen(\"https://www.baidu.com/\")\n# 用BeautifulSoup解析html\nobj = bf(html.read(),'html.parser')\n# 从标签head、title里提取标题\ntitle = obj.head.title\n# 使用find_all函数获取所有图片的信息\npic_info = obj.find_all('img')\n# 分别打印每个图片的信息\nfor i in pic_info:\n    print(i)看看结果：打印出了所有图片的属性，包括class（元素类名）、src（链接地址）、长宽高等。其中有百度首页logo的图片，该图片的class（元素类名）是index-logo-src。[&lt;img class=\"index-logo-src\" height=\"129\" hidefocus=\"true\" src=\"//www.baidu.com/img/bd_logo1.png\" usemap=\"#mp\" width=\"270\"/&gt;, &lt;img alt=\"到百度首页\" class=\"index-logo-src\" src=\"//www.baidu.com/img/baidu_jgylogo3.gif\" title=\"到百度首页\"/&gt;]可以看到图片的链接地址在src这个属性里，我们要获取图片链接地址：# 导入urlopen\nfrom urllib.request import urlopen\n# 导入BeautifulSoup\nfrom bs4 import BeautifulSoup as bf\n# 请求获取HTML\nhtml = urlopen(\"https://www.baidu.com/\")\n# 用BeautifulSoup解析html\nobj = bf(html.read(),'html.parser')\n# 从标签head、title里提取标题\ntitle = obj.head.title\n# 只提取logo图片的信息\nlogo_pic_info = obj.find_all('img',class_=\"index-logo-src\")\n# 提取logo图片的链接\nlogo_url = \"https:\"+logo_pic_info[0]['src']\n# 打印链接\nprint(logo_url)结果：获取地址后，就可以用urllib.urlretrieve函数下载logo图片了# 导入urlopen\nfrom urllib.request import urlopen\n# 导入BeautifulSoup\nfrom bs4 import BeautifulSoup as bf\n# 导入urlretrieve函数，用于下载图片\nfrom urllib.request import urlretrieve\n# 请求获取HTML\nhtml = urlopen(\"https://www.baidu.com/\")\n# 用BeautifulSoup解析html\nobj = bf(html.read(),'html.parser')\n# 从标签head、title里提取标题\ntitle = obj.head.title\n# 只提取logo图片的信息\nlogo_pic_info = obj.find_all('img',class_=\"index-logo-src\")\n# 提取logo图片的链接\nlogo_url = \"https:\"+logo_pic_info[0]['src']\n# 使用urlretrieve下载图片\nurlretrieve(logo_url, 'logo.png')最终图片保存在'logo.png'六、结语本文用爬取百度首页标题和logo图片的案例，讲解了python爬虫的基本原理以及相关python库的使用，这是比较初级的爬虫知识，还有很多优秀的python爬虫库和框架等待后续去学习。当然，掌握本文讲的知识点，你就已经入门python爬虫了。加油吧，少年！","categories":["Python"],"tags":["Python","爬虫"]},{"title":"彻底理解python中的yeild","url":"https://tanqingbo.cn/python-yeild/","content":"\n在用DSN分割3D肝脏的时候，如果把数据全部加载到内存的话，内存一下就爆了， 因此用到了yield关键字，它的功能类似于return，但是不同之处在于它返回的是生成器。\n生成器是通过一个或多个yield表达式构成的函数，每一个生成器都是一个迭代器（但是迭代器不一定是生成器）。\n如果一个函数包含yield关键字，这个函数就会变为一个生成器。\n生成器并不会一次返回所有结果，而是每次遇到yield关键字后返回相应结果，并保留函数当前的运行状态，等待下一次的调用。\n由于生成器也是一个迭代器，那么它就应该支持next方法来获取下一个值。\n\n\n通常的for…in…循环中，in后面是一个数组，这个数组就是一个可迭代对象，类似的还有链表，字符串，文件。它可以是mylist=[1, 2, 3]，也可以是mylist = [x*x for x in range(3)]。 它的缺陷是所有数据都在内存中，如果有海量数据的话将会非常耗内存。\n生成器是可以迭代的，但只可以读取它一次。因为用的时候才生成。比如mygenerator = (x*x for x in range(3))，注意这里用到了()，它就不是数组，而上面的例子是[]。\n我理解的生成器(generator)能够迭代的关键是它有一个next()方法，工作原理就是通过重复调用next()方法，直到捕获一个异常。可以用上面的mygenerator测试。\n带有 yield 的函数不再是一个普通函数，而是一个生成器generator，可用于迭代，工作原理同上。\nyield 是一个类似 return 的关键字，迭代一次遇到yield时就返回yield后面的值。重点是：下一次迭代时，从上一次迭代遇到的yield后面的代码开始执行。\n简要理解：yield就是 return 返回一个值，并且记住这个返回的位置，下次迭代就从这个位置后开始。\n带有yield的函数不仅仅只用于for循环中，而且可用于某个函数的参数，只要这个函数的参数允许迭代参数。比如array.extend函数，它的原型是array.extend(iterable)。\nsend(msg)与next()的区别在于send可以传递参数给yield表达式，这时传递的参数会作为yield表达式的值，而yield的参数是返回给调用者的值。——换句话说，就是send可以强行修改上一个yield表达式值。比如函数中有一个yield赋值，a = yield 5，第一次迭代到这里会返回5，a还没有赋值。第二次迭代时，使用.send(10)，那么，就是强行修改yield 5表达式的值为10，本来是5的，那么a=10\nsend(msg)与next()都有返回值，它们的返回值是当前迭代遇到yield时，yield后面表达式的值，其实就是当前迭代中yield后面的参数。\n第一次调用时必须先next()或send(None)，否则会报错，send后之所以为None是因为这时候没有上一个yield(根据第8条)。可以认为，next()等同于send(None)。\n\n代码示例        #encoding:UTF-8  \n        def yield_test(n):  \n            for i in range(n):  \n                yield call(i)  \n                print(\"i=\",i)  \n            #做一些其它的事情      \n            print(\"do something.\")      \n            print(\"end.\")  \n\n        def call(i):  \n            return i*2  \n\n        #使用for循环  \n        for i in yield_test(5):  \n            print(i,\",\")\n\n结果是：\n      &gt;&gt;&gt;\n  &gt;&gt;   0 ,  \n  &gt;&gt;   i= 0  \n  &gt;&gt;   2 ,  \n  &gt;&gt;   i= 1  \n  &gt;&gt;   4 ,  \n  &gt;&gt;   i= 2  \n  &gt;&gt;   6 ,  \n  &gt;&gt;   i= 3  \n  &gt;&gt;   8 ,  \n  &gt;&gt;   i= 4  \n  &gt;&gt;   do something.  \n  &gt;&gt;   end.  \n  &gt;&gt;\n  &gt;&gt;   &gt;\n\n\n\n理解的关键在于：下次迭代时，代码从yield的下一跳语句开始执行。 for循环就用到了next(),所以到yield能再执行。\n\n需要注意的是，在python3.X里面类的迭代器方法next()改名为__next__()，所以在使用yeild的时候，如果是python2.x，用next(),如果是python3.x，用__next__()函数。\n\n\n","categories":["Python"],"tags":["Python","yeild"]},{"title":"Python基础知识总结","url":"https://tanqingbo.cn/Python-base/","content":"lambda表达式\nlambda表达式是起到一个函数速写的作用。允许在代码内嵌入一个函数的定义。它只是一个表达式，函数体比def简单很多。\n\n3个数求和的例子：\n f = lambda x,y,z:x+y+z\tf(1,2,3)\t6\n\n而如何要用正常函数实现上述功能的话，需要先用def定义函数名，代码如下:\n  def f(x,y,z):\t \treturn x+y+z\tn = f(1,2,3)\t6\n\n\nfilter()、map()和reduce()函数的区别\nfilter（）函数\n\n包括两个参数，分别是function和list。该函数根据function参数返回的结果是否为真来过滤list参数中的项，最后返回一个新列表，如下例所示：\n a=[1,2,3,4,5,6,7]\tb=filter(lambda x:x&gt;5, a)\tprint b\t[6,7]\n\n如果filter参数值为None，就使用identity（）函数，list参数中所有为假的元素都将被删除。如下所示：\n a=[0,1,2,3,4,5,6,7]\tb=filter(None, a)\tprint b\t[1,2,3,4,5,6,7]\n\nmap（）函数\n\nmap()的两个参数一个是函数名，另一个是列表或元组。\n  map(lambda x:x+3, a) #这里的a同上[3,4,5,6,7,8,9,10]\n  \t#另一个例子\ta=[1,2,3]b=[4,5,6]\tmap(lambda x,y:x+y, a,b)\t[5,7,9]\n\n在刷题的过程中，map()函数通常可以结合输入一起使用，例如在一行中输入3个整数，可用如下语句：\n a,b,c = map(int, input().split())\n\nreduce()函数\n\nreduce()函数接收的参数和 map()类似，一个函数 f，一个list，但行为和 map()不同，reduce()传入的函数 f 必须接收两个参数，reduce()对list的每个元素反复调用函数f，并返回最终结果值。\n\n例如，编写一个f函数，接收x和y，返回x和y的和：\n  def f(x, y):    return x + y\n\n调用 reduce(f, [1, 3, 5, 7, 9])时，reduce函数将做如下计算：\n\n先计算头两个元素：f(1, 3)，结果为4；\n再把结果和第3个元素计算：f(4, 5)，结果为9；\n再把结果和第4个元素计算：f(9, 7)，结果为16；\n再把结果和第5个元素计算：f(16, 9)，结果为25；\n由于没有更多的元素了，计算结束，返回结果25。\n\n\n\nrange() 函数用法\nrange() 函数可创建一个整数列表，一般用在 for 循环中。语法如下：\n  range(start, stop, step)\n\n实例：\n  range(10)        # 从 0 开始到 10\t\t[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\t\t range(1, 11)     # 从 1 开始到 11\t\t[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\t\t range(0, 30, 5)  # 步长为 5\t\t[0, 5, 10, 15, 20, 25]\t\t range(0, 10, 3)  # 步长为 3\t\t[0, 3, 6, 9]\t\t range(0, -10, -1) # 负数\t\t[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]\t\t range(0)\t\t[]\t\t range(1, 0)\t\t[]\n\nrange 在 for 中的使用：\n  for i in range(n):      # 正序遍历，表示i的取值从0到n-1\tfor i in range(n,0,-1): # 倒序遍历，表示i的取值从n到1\n\n\ndict字典\ndict字典使用键-值（key-value）存储，具有极快的查找速度。在Java中也称为map。\n\n举个例子，假设要根据同学的名字查找对应的成绩，如果用list实现，需要两个list：\n      names = ['Michael', 'Bob', 'Tracy']\t\tscores = [95, 75, 85]\n\n\n\n给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，list越长，耗时越长。\n\n如果用dict实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用Python写一个dict如下：\n   d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}\t d['Michael']\t95\n\n\n\n我在刷题的时候，遇到一个问题就是需要在循环中动态往dict添加数据，但是没有找到添加的函数，其实不用插入函数，循环中动态往dict添加数据也很简单，如下所示：\n      dt = {}  #先定义一个字典，注意是{}，如果定义数组是[]\t\tfor i in range(n):\t\t\tdt[key[i]] = value[i]\n\n\nsort与sorted的排序问题\nsort参数说明\n L.sort(cmp=None, key=None, reverse=False) \n\n\n\n\n\n\nsorted参数说明\n  sorted(iterable, cmp=None, key=None, reverse=False) –&gt; new sorted list\n\n\n+ iterable：是可迭代类型，通常为一个集合; \n+ cmp：用于比较的函数，比较什么由key决定,有默认值，迭代集合中的一项; \n+ key：用列表元素的某个属性和函数进行作为关键字，有默认值，迭代集合中的一项; \n+ reverse：排序规则. reverse = True 表示降序 或者 reverse = False 表示升序，默认值为False。\n\n使用sort()方法对list排序会修改list本身,不会返回新list，使用方法如下：\n  my_list = [3, 5, 1, 4, 2]\tmy_list.sort()    \tprint my_list\t#输出： [1, 2, 3, 4, 5]\n\n\n\n而使用sorted()方法排序时会返回一个新的list：\n  my_list = [3, 5, 1, 4, 2]\tresult = sorted(my_list)   #返回一个新的list\tprint result\n  ​    \n  #输出： [1, 2, 3, 4, 5]\n\n\n常用的一些零散的小知识\n求实数的多少次幂\n\n正常在java和C语言中，求一个数的幂需要调用一个求幂的函数，但是Python中直接一个运算符就可以搞定了：\n  #Python求幂\t10**2  #10的平方\t10**4  #10的4次方\n\n\n\nprint(‘xx’,end=’’)中end问题\n\nend是print（）函数的一个参数。end 是输出语句结束以后附加的字符串，它的默认值是换行（’\\n’）。如果输出的时候不需要换行需要显示的给end赋值。\n\n例如输出一个数组，每个数之间以空格隔开，可以用如下语句：\n      for i in range(n):\t\t\tprint(data[i],end=' ')  #end值为空格\n\n\n\n如果只是单纯的想要输出不换行，可以令end=''，end值为空字符串\n\n// 与 / 的区别\n\n“ / “  表示浮点数除法，返回浮点结果;\n\n“ // “ 表示整数除法,返回不大于结果的一个最大的整数\n\n【code】\n  print(\"6 // 4 = \" + str(6 // 4))\tprint(\"6 / 4 =\" + str(6 / 4))\n\n\n\n【result】\n 6 // 4 = 1\t6 / 4 =1.5\n\n\n\n\n\n\n记得用set去除重复元素\n\n如果一个数组中有很多重复元素，根据需求需要去除重复元素的话，可以使用set集合，类似于Java的HashSet。\n\n语法很简单，只需一行代码就可以去重，如下所示：\n\n【code】\n a = [1,1,2,2,3,4,5]\ta = set(a)\tprint(a)\n\n\n\n\n\n\n【result】\n  {1, 2, 3, 4, 5}\n\n\n","categories":["Python"],"tags":["Python","函数"]},{"title":"学习Python的博客","url":"https://tanqingbo.cn/python-Blog/","content":"1、廖雪峰Python教程如果是刚入门的小白，想从第一个“Holle world”学起，推荐看廖雪峰老师的Python教程博客，他的博客非常系统有条理，从Python安装开始讲起，特别适合小白从零开始学起。\n我本科学校没有开Python的课，我就是看他的Python教程入门的。\n\n2、Python菜鸟教程菜鸟教程，从名字就可以看出是入门级的教程，但是内容详细到令人发指的地步，对菜鸟来说可以当做字典来查询。\n\n3、崔庆才Python爬虫系列崔庆才老兄写的Python爬虫系列教程不仅很棒，而且还很火，访问量超百万，不少人是看他的博客入门的爬虫。\n\n4、the5fire的Python博客the5fire是《Django企业开发实战》这本书的作者，而Django是用python写的web框架。他的python技术博客也很值得看。\n\n5、小明明S À DOMICILE小明明是《Python-Web开发实战》的作者，他的python技术博客也值得学习。\n\n6、Python官方文档库这个绝对要压轴推荐，写的非常详细，而且都有代码例子示范，学一门语言，一定要学会查阅官方文档。\n\n7、IT码农 - 一个专注于程序员成长的网站这个是我自己搭建的个人程序员学习网站，收集了和程序员学习相关的各种教程和资料，主要包括：计算机专业必读经典书籍下载、工具介绍和下载、各种编程语言教程、机器学习教程等。\n这都是花钱都买不到的财富！\n\n","categories":["Python"],"tags":["Python","博客"]},{"title":"怎么学习Python？","url":"https://tanqingbo.cn/How2learn-Python？/","content":"如果是零基础学习编程的话，从python开始是一个非常不错的选择，虽然很多人最开始学习编程的时候都是从C语言开始的，但是C语言有点底层，对零基础的人来说不太友好，而且现在很多学校都已经将Python作为入门的编程语言了，在目前特别火的机器学习、人工智能领域，Python可以说是标配的编程语言。\n所以我由浅入深的整理了一些Python的资源和路线，建议从前往后阅读，看完之后肯定对你有帮助！\nPython基础Python基础01  安装Python\nPython基础02  第一个Python程序\nPython基础03  Python 变量类型\nPython基础04  Python 运算符\nPython基础05  Python 循环语句\nPython基础06  Python 条件语句\nPython基础07  Python 列表(List)\nPython基础08  Python 函数\nPython基础09  Python 模块\nPython基础10 Python 文件I/O\nPython基础11 Python File(文件) 方法\nPython基础12  Python 异常处理\nPython进阶Python基进阶01  Python 面向对象\nPython基进阶02  Python 正则表达式\nPython基进阶03  Python CGI 编程 \nPython基进阶04  Python 操作 MySQL 数据库  \nPython基进阶05  Python 网络编程\nPython基进阶06  Python SMTP发送邮件\nPython基进阶07  Python 多线程\nPython基进阶08  Python XML 解析 \nPython基进阶09  Python GUI 编程(Tkinter) \nPython基进阶10  Python JSON\nPython高级到目前为止，如果你看完了上面的内容，那么你对Python应该有了基本的认识，接下来可以用Python来做一些小项目来巩固你学过的东西。\n下面分享几个提供Python项目实践的网站！\n实验楼实验楼提供在线编程及在线实训学习平台，有很多项目都是免费的。\n\n自强学堂 Django教程Django 是用Python开发的一个免费开源的Web框架，可以用于快速搭建高性能，优雅的网站！\n\n崔庆才Python爬虫系列崔庆才老兄写的Python爬虫系列教程不仅很棒，而且还很火，访问量超百万，不少人是看他的博客入门的爬虫。\n\nPython IDE（集成开发环境）学完了Python基础，有了可以练手的项目，好用的 IDE（集成开发环境）当然也必不可少了！\nPyCharmPyCharm 是由 JetBrains 打造的一款 Python IDE。\nPyCharm 具备一般 Python IDE 的功能，比如：调试、语法高亮、项目管理、代码跳转、智能提示、自动完成、单元测试、版本控制等。\n另外，PyCharm 还提供了一些很好的功能用于 Django 开发，同时支持 Google App Engine，更酷的是，PyCharm 支持 IronPython。\n效果图查看：\n\n下载地址（包含Windows和Linux两个版本）：\n链接：https://pan.baidu.com/s/11HvkeJEyiQs5yG_lJTmiUQ\n提取码：feug\nSublime TextSublime Text 具有漂亮的用户界面和强大的功能，例如代码缩略图，Python 的插件，代码段等。还可自定义键绑定，菜单和工具栏。\nSublime Text 的主要功能包括：拼写检查，书签，完整的 Python API ， Goto 功能，即时项目切换，多选择，多窗口等等。\nSublime Text 是一个跨平台的编辑器，同时支持 Windows、Linux、Mac OS X等操作系统。\n\n下载地址：链接：https://pan.baidu.com/s/1ofzmnqSMA3oGIsOgCQh40w\n提取码：4fz1\n推荐的Python书籍1 Python核心编程(第二版)\n\n本书是经典的Python[1] 指导书，在第一版的基础上进行了全面升级。全书分为两个部分：第1部分占据了大约三分之二的篇幅，阐释这门语言的“核心”内容，包括基本的概念和语句、语法和风格、Python对象、数字类型、序列类型、映射和集合类型、条件和循环、文件和输入/输出、错误和异常、函数和函数式编程、模块、面向对象编程、执行环境等内容：第2部分则提供了各种高级主题来展示可以使用Python做些什么，包括正则表达式、网络编程、网络客户端编程、多线程编程、图形用户界面编程、Web编程、数据库编程、扩展Python 和一些其他材料。\n\n2 Python高级编程\n\n《Python高级编程》针对具备一定Python基础并希望通过在项目中应用最佳实践和新的开发技术来提升自己的Python开发人员。\n\n3 Python数据结构与算法\n\n主要是介绍了如何使用Python实现常用的一些数据结构,例如堆栈、队列、二叉树等等。\n\n4 利用Python进行数据分析\n\n从pandas库的数据分析工具开始利用高性能工具对数据进行加载、清理、转换、合并以及重塑；利用matpIotlib创建散点图以及静态或交互式的可视化结果；利用pandas的groupby功能对数据集进行切片、切块和汇总操作；处理各种各样的时间序列数据。\n\n以上推荐的书籍下载地址：\n链接：https://pan.baidu.com/s/1qZWpNrAXjJjwePeD813SiQ\n提取码：mwpz\n","categories":["Python"],"tags":["编程","Python"]},{"title":"Mysql数据库优化以及如何防止sql注入","url":"https://tanqingbo.cn/Mysql-database/","content":"mysql数据库优化\n利用LIMIT 1取得唯一行,这样数据库引擎发现只有1后将停止扫描，而不是去扫描整个表或索引。\n保证连接的索引是相同的类型\n不要使用BY RAND()命令,MySQL可能会为表中每一个独立的行执行BY RAND()命令（这会消耗处理器的处理能力），然后给你仅仅返回一行。\n尽量避免SELECT *命令:从表中读取越多的数据，查询会变得更慢。\n准备好的sql语句\n视情况确定存储类型\n永远为每张表设置一个ID\n使用ENUM而不是VARCHAR，ENUM类型是非常快和紧凑的。\n无缓冲的查询\n固定长度的表会更快,表中没有如下类型的字段： VARCHAR，TEXT，BLOB,则为固定长度的表\n垂直分割，垂直分割是一种把数据库中的表按列变成几张表的方法，这样可以降低表的复杂度和字段的数目，从而达到优化的目的。\n\nMySQL数据引擎\nInnoDB和MyISAM是在使用MySQL最常用的两个表类型，各有优缺点，视具体应用而定。\n\n基本差别：MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持。MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快，但是不提供事务支持，而InnoDB提供事务支持以及外部键等高级数据库功能。\n\nMyIASM是IASM表的新版本，有如下扩展：\n      二进制层次的可移植性。 \n      NULL列索引。 \n      对变长行比ISAM表有更少的碎片。 \n      支持大文件。\n      更好的索引压缩。\n      更好的键吗统计分布。\n      更好和更快的auto_increment处理。\n\n\nSQL注入攻击\n程序员在编写代码的时候，没有对用户输入数据的合法性进行判断，使应用程序存在安全隐患。用户可以提交一段数据库查询代码，根据程序返回的结果，获得某些他想得知的数据，这就是所谓的SQL Injection，即SQL注入。\n\n例子：\n      某个网站的登录验证的SQL查询代码为：\n  strSQL = \"SELECT * FROM users WHERE (name = '\" + userName + \"') and (pw = '\"+ passWord +\"');\" 恶意填入userName = \"1' OR '1'='1\";或者passWord = \"1' OR '1'='1\";时，将导致原本的SQL字符串被填为strSQL = \"SELECT * FROM users WHERE (name = '1' OR '1'='1') and (pw = '1' OR '1'='1');\"也就是实际上运行的SQL命令会变成下面这样的strSQL = \"SELECT * FROM users;\"\n\n  因此达到无账号密码，亦可登录网站。所以SQL注入攻击被俗称为黑客的填空游戏。\n\n应对办法(数据库防火墙,虚拟补丁技术)从安全技术手段上来说，可以通过数据库防火墙实现对SQL注入攻击的防范，因为SQL注入攻击往往是通过应用程序来进攻，可以使用虚拟补丁技术实现对注入攻击的SQL特征识别，实现实时攻击阻断。\n\n\n","categories":["计算机基础知识"],"tags":["数据库","MYSQL"]},{"title":"Linux下安装java以及opencv","url":"https://tanqingbo.cn/linux-java-opencv/","content":"安装jdk\nJava环境可选择 Oracle 的 JDK，或是 OpenJDK,为图方便，这边直接通过命令安装 OpenJDK 8。\n  sudo apt-get install openjdk-7-jre openjdk-7-jdk\n\n通过上述命令安装 OpenJDK，默认安装位置为 /usr/lib/jvm/java-8-openjdk-amd64\n\n接着需要配置一下 JAVA_HOME 环境变量，为方便，我们在 ~/.bashrc 中进行设置\n  vim ~/.bashrc\n\n在文件最前面添加如下单独一行（注意 = 号前后不能有空格），并保存：\n  export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64\n\n接着还需要让该环境变量生效，执行如下代码：\n  source ~/.bashrc    # 使变量设置生效\n\n\nlinux编译安装opencv\n安装gcc以及cmake等等乱七八糟的软件,opencv的版本建议使用2.4.x的版本，新出的版本好多方法都没法用了，需要重新编译其他源码包，比较麻烦。例如基于surf和sift匹配算法在2.4以上的版本里面就没有了。\n  sudo apt-get install build-essential python-dev cmake\n\n下载opencv并解压缩\n  tar -zxvf opencv.tar.gz\n\n创建编译目录，并在此目录下执行如下命令：\n      cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local ..\n\n上面的CMAKE_BUILD_TYPE =RELEASE指明编译的版本是Release版，CMAKE_INSTALL_PREFIX=/usr/local指明编译后的可执行程序的存放目录。\n\n执行make和install：\n      make\n      sudo make install\n\n如果没有出错的话，OpenCV的整个编译过程就完成了！ 如果有错误，那就复制错误内容，到网上查找解决办法，一般来说这是个很痛苦的过程，所以希望你有好运气，一次编译就能过.\n\n\n","categories":["Linux"],"tags":["Linux","Java","opencv"]},{"title":"Linux_Ubuntu系统安装搜狗输入法","url":"https://tanqingbo.cn/Ubuntu-install-sougou/","content":"前言\n初次使用Ubuntu系统的新手，肯定会遇到各种各样的问题，输入法的问题肯定没少折磨过大家，因为Ubuntu默认只有英文输入，没有中文输入。别着急，我马上就教大家如何在Ubuntu下安装搜狗输入法。\n准备工作\nLinux搜狗输入法安装包，下载地址：http://pinyin.sogou.com/linux/;\n\n根据自己的系统下载对应位数的安装包；\n\n如果你是首次使用Ubuntu，请先更新一下源，按ctrl+alt+t键打开终端，执行如下语句：\n      sudo apt-get update\n\n\n开始安装\n进入到搜狗输入法安装包的目录，我把安装包放在Download目录下，所以我想进入到Download目录，然后使用dpkg语句安装，执行命令如下：\n  cd Download\tsudo dpkg -i sogoupinyin_2.1.0.0086_i386.deb\n\n\n\n\n到此输入法算是安装完了，但是现在还使用不了，还需要配置一下。\n\n点击右上角的小齿轮，选择System Settings，然后单击Language Support。\n\n\n    \n\n初次点击Language Support，会提示执行sudo apt-get install -f，在终端中执行该条语句，跳出来的提示选择Y，等几分钟然语句执行完，然后重新打开Language Support，选择install Language Support，如下图：\n\n\n\nKeyboard input method system选择  fcitx。然后重启系统，重启之后会在右上角看到输入法的符号，但是现在还不能用，还得在配置一下，依次点击 输入法符号-》配置-》加号-》去掉Only Show Current language的红勾。\n\n    \n\n然后滑倒最下面，选择Sogou Pinyin，再点击右下角的OK键就打工告成了。\n\n\n\n之后按Ctrl+空格键切换输入法，就可以正常使用搜狗输入法了。\n\n\n","categories":["Linux"],"tags":["Linux","Ubuntu","搜狗"]},{"title":"Linux系统下配置ITK环境","url":"https://tanqingbo.cn/Linux-ITK/","content":"前言对于一个程序员来说，linux系统相对与window来说有很多不可描述的优势，很多在window下不能跑的程序都能在Linux下跑，所以就有了这篇在Linux下配置ITK的博文，一方面是为来记录下来这次安装过程，方便以后自己查阅，同时也是希望当大家在Linux下配置时能提供一点帮助。\n准备工作\n安装cmake:用来编译ITK用的\n\n下载ITK源码包：http://www.itk.org/ITK/resources/software.html,下载最新版本的.tar.gz格式源码包就行。如：InsightToolkit-4.10.1.tar.gz\n安装cmake和ccmake\n第一次使用Linux时需要更新安装源，更新过可以忽略这个条，更新指令如下：\nsudo apt-get update\n可以手动安装，也可以直接使用apt-get 安装，此处我使用后者,即：\nsudo apt-get install cmakesudo apt-get install cmake-curses-gui\n接着：\n  sudo apt-get install build-essential\n配置ITK1.1 为ITK创建目录，我建在/home目录下，命令如下     #cd /home\n\n     #mkdir ITK               //存放ITK源码                                     \n\n     #mkdir ITK/ITK-bin       //做为 ITK 编译目录\n1.2 解压　InsightToolkit-3.14.0.tar.gz 到目录 ITK\n可以在图形界面直接右键解压，然后拷贝到ITK目录\n\n也可以使用命令加压：\n   tar -xf InsightToolkit-4.10.1.tar.gz  /home/ITK\n1.3 设置编译器环境变量\n在命令框中输入如下指令：\n  export CC=/usr/bin/gcc;  export CXX=/usr/bin/g++\n1.4 使用 CMake 配置 ITK\n进入到ITK编译目录    \n      cd /home/ITK/ITK-bin\n\n编译ITK源码：\n   #ccmake ../InsightToolkit-4.10.1\n\n然后根据 CMake 下面的提示, 按 c 键, 进行 配置，接着出现类似 windows 下的选择界面，按照默认的设置就行，然后再按键 c 配置, 成功后按键 g 生成 ITK 编译文件。\n\n最后输入make命令编译ITK,这个过程大概需要20分钟。\n#make\n到此Linux下配置ITK基本完成。\n\n\n测试是否配置成功\n在ITK目录下创建test测试目录\ncd /home/ITK  mkdir test               //用于编译 ITK 代码, 为了目录结构清晰  mkdir test/src         //存放源代码  mkdir test/bin         //示例编译目标  mkdir test/src/HelloWorld  \tmkdri test/bin/HelloWorld\n\n到 /home/ITK/InsightToolkit-4.10.1/Examples/Installation/中将HelloWorld.CXX 以及 CMakelists.txt拷贝到 test/src/HelloWorld 中\n\n进入到test/bin/HelloWorld目录中编译源码:\n cd test/bin/HelloWorldccmake   ../../src/HelloWorld\n 这时,可能提示找不到 ITK_DIR, ITK_DIR_NOTFOUND,使用箭头选择此项,然后按 enter 编辑,输入 ITK-bin 路径, 我的为 /home/ITK/ITK-bin,然后按 c 键进行配置, 按 g 键生成编译文件\n\n最后 #make    生成 HelloWorld 可执行文件\n\n生成的可执行文件如下图：\n\n执行该文件：\n      ./HelloWrold\n\n如图：\n\n\n\n\n显示ITK Hello World ! 证明ITK配置成功了。\n\n","categories":["Linux"],"tags":["Linux","ITK"]},{"title":"Linux下配置vim以及编译C语言","url":"https://tanqingbo.cn/Linux-Compile-C/","content":"Linux下配置vim以及编译C语言安装vim编辑器\n在命令行敲入“vi”后按”tab”键，可以看  到目前 系统中只安装了vi和vim.tiny。\n\nubuntu系统：普通用 户下输入命令：sudo apt-get install vim-gtk\n\ncentos系统：普通用户下输入命令：yum -y install vim*\nvim的配置\n刚安装的VIM，可能界 面并不是十分友好，这就需要我们 去更改vim的配置文件，按照我们的需求去修改它。\n\n在命令 行下，输入 命令：sudo vim /etc/vim/vimrc\n\n必须加上sudo，否则你是没有 权限编辑vimrc的。\n\n\n\n在这个文件中，会有这么一句：\nsyntax on\n\n意思是语法高亮，如果您的被注释掉了，请“让它出来”。\n请在您的VIM的最后一行，输入他们，可以让您的VIM变得更漂亮、舒服。set nu                           // 在左侧行号set tabstop                  //tab 长度设置为 4set nobackup               //覆盖文件时不备份set cursorline               //突出显示当前行set ruler                       //在右下角显示光标位置的状态行set autoindent             //自动缩进 保存之后，配置完毕。上面的配置，其实是非常简单的，比如一些配色方案等，小编并没有写入，如果您还有其他需求的话，建议百度。\n\n\n\n编译C\nGCC编译器（GNU C Compiler ）：经过了这么多年的发展，GCC 已经不仅仅能支持 C 语言；它现在还支持 Ada 语言、C++ 语言、Java 语言、Objective C 语言、Pascal 语言、COBOL语言。\n简单编译\n\n示例程序如下：\n//test.c#include &lt;stdio.h&gt;int main(void){    printf(\"Hello World!\\n\");    return 0;}\n\n这个程序，一步到位的编译指令是:\n    gcc test.c -o test\n    ./test\n实质上，上述编译过程是分为四个阶段 进行的，即预 处理(也称预编译，Preprocessing)、编译(Compilation)、汇编 (Assembly)和连接(Linking)。\n\n预处理      \n\ngcc -E test.c -o test.i 或 gcc -E test.c\n\n\n可以输出test.i文件中存放着test.c经 预处理之后 的代码。预处理结 果就是将stdio.h 文件中的内容插入到test.c中了。\n\n编译为汇编代码(Compilation)\n预处理之后，可直接对生成的test.i文件编译，生成汇编代码：\n   gcc -S test.i -o test.s\n\n\ngcc的-S选项，表示在程序编译期间，在生成汇编代码后，停止，-o输出汇编代码文件。  3. 汇编(Assembly)\n对于上一小节中生成的汇编代码文件test.s，gas汇编器负责 将其编译为目标文件，如下：\n  gcc -c test.s -o test.o\n\n连接(Linking)\n  gcc test.o -o test\n\n  最后在命令行窗口中，执行./test, 让它说HelloWorld吧！\n\n\n","categories":["Linux"],"tags":["Linux","C语言","vim"]},{"title":"C语言中的Dll详解","url":"https://tanqingbo.cn/Dll/","content":"Dll\n链接库分为动态和静态两种，后缀分别是.dll和.lib\n使用GetProcAddress获取Dll中导出函数的指针\n使用FreeLibrary卸载指定dllVS下,Dll分为3类\n\n\n非MFC的Dll  即使用SDK API进行编程，能被其他所有语言调用\nMFC规则DLL   可以使用MFC进行编程，能被其他语言调用\nMFC扩展DLL  可以使用MFC进行编程，但只能被MFC编写的程序调用。学第一种。DLL的编写\n\n\nDLL的导出, DLL的导出函数使用extern \"C\"_declspec(dllexport)\n\n\n\n\n而导入函数使用extern \"C\" _declspec (dllimport ) extern \"C\"：作为一种编译约定 #pragma once：表示制备编译一次，而不会因重复包含而重复编译\n\n\n\n线程注入：\n目标进程-&gt;传入DLL地址-&gt;开启远程线程-&gt;加载DLL-&gt;实现DLL注入\n实现线程注入，依次使用以下函数：OpenProcess  //获取已知进程的句柄VirtualAllocEx  //在进程中申请空间WriteProcessMemory //向进程中写入东西GetProcAddress  //取得函数在DLL中地址 CreateRemoteThreadEx //在其他进程中创建新进程\n\n\n\n\n\n往期精彩文章\nC++ string函数的用法\n浅谈三种加密算法【DES、IDEA、MD5】\nC/C++、Java和Python开发工具一网打尽\nJava开发工具下载\nJava 学习线路图是怎样的？\n版本控制之git的简易教程\n程序员常用设计模式之代理模式\n程序员常用设计模式之原型模型\n程序员常用设计模式之外观模式\n字符串匹配之kmp算法\n\n","categories":["C与C✙✙"],"tags":["C语言","C✙✙","Dll"]},{"title":"C++ string函数的用法","url":"https://tanqingbo.cn/C++-string-function/","content":"C++ string函数的用法\nstd::string 相当于string\nstring::npos  取值由实现决定，一般是-1find_first_of()和 find_last_of()\n函数find_first_of()和 find_last_of() 执行简单的模式匹配，如在字符串中查找单个字符c。函数find_first_of() 查找在字符串中第1个出现的字符c，而函数find_last_of()查找最后一个出现的c。匹配的位置是返回值。如果没有匹配发生，则函数返回-1.substr(off,count)\n第一个参数off表示下标，count是子串的长度。如果没有越界异常，返回一个[off，off+count)的字符串。　　erase函数的原型如下：\nstring&amp; erase ( size_t pos = 0, size_t n = npos );\niterator erase ( iterator position );\niterator erase ( iterator first, iterator last );也就是说有三种用法：\nerase(pos,n); 删除从pos开始的n个字符，比如erase(0,1)就是删除第一个字符\nerase(position);删除position处的一个字符(position是个string类型的迭代器)\nerase(first,last);删除从first到last之间的字符（first和last都是迭代器）\n\n\n\n示例代码：\n#include &lt;string&gt;#include &lt;iostream&gt;using namespace std; int main (){    string str (\"This is an example phrase.\");    string::iterator it;    //第（1）种方法    str.erase (10,8);    cout &lt;&lt; str &lt;&lt; endl;        // \"This is an phrase.\"    //第（2）种方法    it=str.begin()+9;    str.erase (it);    cout &lt;&lt; str &lt;&lt; endl;        // \"This is a phrase.\"    //第（3）种方法    str.erase (str.begin()+5, str.end()-7);    cout &lt;&lt; str &lt;&lt; endl;        // \"This phrase.\"    return 0;}\n\nC++编程里面每种容器都定义了一对命名为begin和end的函数，用于返回迭代器，如果容器中有元素的话，由begin返回的迭代器指向第一个元素,由end操作返回的迭代器指向容器的“末端元素的下一个”。\nc_str()\nc_str()函数返回一个指向正规c字符串的指针,内容和string类的本身对象是一样的,通过string类的c_str()函数能够把string对象转换成c中的字符串的样式\n\n操作c_str()函数的返回值时,只能使用c字符串的操作函数,如:strcpy()等函数.因为,string对象可能在使用后被析构函数释放掉,那么你所指向的内容就具有不确定性.\n  eg:\tchar * name[20];\tstring ptr = \"tongnono\";\tstrcpy(name,ptr.c_str());//c_str()返回的是一个临时的指针变量,不能对其操作.\n\n\nC语言提供了几个标准库函数，可以将任意类型(整型、长整型、浮点型等)的数字转换为字符串。● itoa()：将整型值转换为字符串。● ltoa()：将长整型值转换为字符串。● ultoa()：将无符号长整型值转换为字符串。● gcvt()：将浮点型数转换为字符串，取四舍五入。● ecvt()：将双精度浮点型值转换为字符串，转换结果中不包含十进制小数点。● fcvt()：指定位数为转换精度，其余同ecvt()。\n\n\n除此外，还可以使用sprintf系列函数把数字转换成字符串，其比itoa()系列函数运行速度慢\n\nC/C++语言提供了几个标准库函数，可以将字符串转换为任意类型(整型、长整型、浮点型等)。● atof()：将字符串转换为双精度浮点型值。● atoi()：将字符串转换为整型值。● atol()：将字符串转换为长整型值。● strtod()：将字符串转换为双精度浮点型值，并报告不能被转换的所有剩余数字。● strtol()：将字符串转换为长整值，并报告不能被转换的所有剩余数字。● strtoul()：将字符串转换为无符号长整型值，并报告不能被转换的所有剩余数字。\n\nfind()\nstring类的查找函数： \n  int find(char c, int pos = 0) const;//从pos开始查找字符c在当前字符串的位置\tint find(const char *s, int pos = 0) const;//从pos开始查找字符串s在当前串中的位置\tint find(const char *s, int pos, int n) const;//从pos开始查找字符串s中前n个字符在当前串中的位置\tint find(const string &amp;s, int pos = 0) const;//从pos开始查找字符串s在当前串中的位置\t//查找成功时返回所在位置，失败返回string::npos的值 \n\n\n往期精彩文章\n浅谈三种加密算法【DES、IDEA、MD5】\n\nC/C++、Java和Python开发工具一网打尽\n\nJava开发工具下载\n\nJava 学习线路图是怎样的？\n\n版本控制之git的简易教程\n\n程序员常用设计模式之代理模式\n\n程序员常用设计模式之原型模型\n\n程序员常用设计模式之外观模式\n\n字符串匹配之kmp算法\n\n数据结构之二叉树的四种遍历方法\n\n\n","categories":["C与C✙✙"],"tags":["C语言","C✙✙","string"]},{"title":"浅谈三种加密算法【DES、IDEA、MD5】","url":"https://tanqingbo.cn/Encryption-Algorithm/","content":"DES算法\nDES全称为Data Encryption Standard，即数据加密标准，是一种使用密钥加密的块算法。\nDES算法入口参数\nDES算法的入口参数有三个:Key、Data、Mode。其中Key为7个字节共56位,是DES算法的工作密钥;Data为8个字节64位,是要被加密或被解密的数据;Mode为DES的工作方式,有两种:加密或解密。\n算法步骤：\nDES算法把64位的明文输入块变为64位的密文输出块,它所使用的密钥也是56位，其算法主要分为两步：\n\n初始置换 其功能是把输入的64位数据块按位重新组合,并把输出分为L0、R0两部分,每部分各长32位,其置换规则为将输入的第58位换到第一位,第50位换到第2位……依此类推,最后一位是原来的第7位。L0、R0则是换位输出后的两部分，L0是输出的左32位,R0是右32位,例:设置换前的输入值为D1D2D3……D64,则经过初始置换后的结果为:L0=D58D50……D8;R0=D57D49……D7。\n其置换规则见下表：58,50,42,34,26,18,10,2,60,52,44,36,28,20,12,4,62,54,46,38,30,22,14,6,64,56,48,40,32,24,16,8,57,49,41,33,25,17,9,1,59,51,43,35,27,19,11,3,61,53,45,37,29,21,13,5,63,55,47,39,31,23,15,7,\n\n\n\n\n\n\n2. **逆置换**\n    经过16次迭代运算后,得到L16、R16,将此作为输入,进行逆置换,逆置换正好是初始置换的逆运算，由此即得到密文输出。\n    此算法是对称加密算法体系中的代表,在计算机网络系统中广泛使用.\nIDEA算法原理：\nIDEA 它也是对64bit大小的数据块加密的分组加密算法密钥长度为128位它基于”相异代数群上的混合运算”设计思想。\n\n产生密钥：\n\n算法用了52个子密钥(8轮中的每一轮需要6个，其他4个用与输出变换)。\n\n\n\n\n将128-位密钥分成8个16-位子密钥。这些是算法的第一批8个子密钥（第一轮六个，第二轮的头两个）。然后，密钥向左环移25位后再分成8个子密钥。开始4个用在第二轮，后面4个用在第三轮。密钥再次向左环移25位产生另外8个子密钥，如此进行直到算法结束。具体是： IDEA总共进行8轮迭代操作，每轮需要6个子密钥,另外还需要4个额外子密钥,所以总共需要52个子密钥，这个52个子密钥都是从128位密钥中扩展出来的。\n\n\n加密过程：\n\n输入的64-位数据分组被分成4个16-位子分组：xl，X2，x3和x4。\n这4个子分组成为算法的第一轮的输入，总共有8轮。在每一轮中，这4个子分组相互相异或，相加，相乘，且与6个16-位子密钥相异或，相加，相乘。\n\n\n\n在每一轮中，执行的顺序如下：　\n　(1)X1和第一个子密钥相乘。　　(2)x2和第二个子密钥相加。　　(3)X3和第三个子密钥相加。　　(4)x4和第四个子密钥相乘。　　(5)将第(1)步和第(3)步的结果相异或。 .　　(6)将第(2)步和第(4)步的结果相异或。　　(7)将第(5)步的结果与第五个子密钥相乘。　　(8)将第(6)步和第(7)步的结果相加。　　(9)将第(8)步的结果与第六个子密钥相乘。　　(10)将第(7)步和第(9)步的结果相加。　　(11)将第(1)步和第(9)步的结果相异或。　　(12)将第(3)步和第(9)步的结果相异或。　　(13)将第(2)步和第(10)步的结果相异或。　　(14)将第(4)步和第(10)步的结果相异或。　　每一轮的输出是第(11)、(12)、(13)和(14) 步的结果形成的4个子分组。将中间两个分组分组交换(最后一轮除外)后，即为下一轮的输入。　　经过8轮运算之后，有一个最终的输出变换：　　(1) X1和第一个子密钥相乘。　　(2) x2和第二个子密钥相加。　　(3) x3和第三个子密钥相加。　　(4) x4和第四个子密钥相乘。\n\n\n\n\nIDEA算法的密钥长度为128位。设计者尽最大努力使该算法不受差分密码分析的影响。\nMD5加密算法\nMD5加密是一种不可逆的加密算法。\nMd5加密算法原理\nMD5加密算法以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。\n\n在MD5加密算法中，首先需要对信息进行填充，使其字节长度对512求余数的结果等于448。因此，信息的字节长度（Bits Length）将被扩展至N512+448，即N64+56个字节（Bytes），N为一个正整数。\n\n填充的方法如下：在信息的后面填充一个1和无数个0，直到满足上面的条件时才停止用0对信息的填充。然后再在这个结果后面附加一个以64位二进制表示的填充前的信息长度。经过这两步的处理，现在的信息字节长度=N*512+448+64=(N+1)*512，即长度恰好是512的整数倍数。这样做的原因是为满足后面处理中对信息长度的要求。\n\nMD5中有四个32位被称作链接变量（Chaining Variable）的整数参数，他们分别为：\n\n\nA=0x01234567\tB=0x89abcdefC=0xfedcba98D=0x76543210\n\n\n当设置好这四个链接变量后，就开始进入算法的四轮循环运算，循环的次数是信息中512位信息分组的数目。\n\n将上面四个链接变量复制到另外四个变量中：A到a，B到b，C到c，D到d。 主循环有四轮（MD4只有三轮），每轮循环都很相似。第一轮进行16次操作。每次操作对a、b、c和d中的其中三个作一次非线性函数运算，然后将所得结果加上第四个变量（文本中的一个子分组和一个常数）。\n\n再将所得结果向右环移一个不定的数，并加上a、b、c或d中之一。最后用该结果取代a、b、c或d中之一。 以一下是每次操作中用到的四个非线性函数（每轮一个）。\n F(X,Y,Z)=(X∧Y)∨(( X)∧Z)\tG(X,Y,Z)=(X∧Z)∨(Y∧( Z))\tH(X,Y,Z)=X?Y?Z\tI(X,Y,Z)=Y?(X∨( Z))\t其中，?是异或，∧是与，∨是或， 是反符号。\n\n如果X、Y和Z的对应位是独立和均匀的，那么结果的每一位也应是独立和均匀的。F是一个逐位运算的函数。即，如果X，那么Y，否则Z。函数H是逐位奇偶操作符。所有这些完成之后，将A，B，C，D分别加上a，b，c，d。然后用下一分组数据继续运行算法，最后的输出是A，B，C和D的级联。最后得到的A，B，C，D就是输出结果，A是低位，D为高位，DCBA组成128位输出结果。\n\n\nMd5加密算法的应用\nMD5加密算法由于其具有较好的安全性，加之商业也可以免费使用该算法，因此该加密算法被广泛使用，md5加密算法主要运用在数字签名、文件完整性验证以及口令加密等方面。\n\n往期精彩文章\nC/C++、Java和Python开发工具一网打尽\nJava开发工具下载\nJava 学习线路图是怎样的？\n版本控制之git的简易教程\n程序员常用设计模式之代理模式\n程序员常用设计模式之原型模型\n程序员常用设计模式之外观模式\n字符串匹配之kmp算法\n数据结构之二叉树的四种遍历方法\n八大经典排序算法–Java实现\n\n","categories":["数据结构与算法"],"tags":["算法","Java","加密"]},{"title":"C/C++、Java和Python开发工具一网打尽","url":"https://tanqingbo.cn/C-Java-DevelopTools/","content":"前言在我们埋头于代码死磕的时候，会发现一个好的开发工具往往会起到事半功倍的效果，本帖子总结了C语言与Java几个比较流行的开发工具，希望能对大家有用。\n另外，本文将持续汇总各种开发语言中使用的优质工具，欢迎小伙伴推荐，互利互助，发我邮件：17B903027@stu.hit.edu.cn\n格式要求：工具名，工具介绍，网盘地址\nJava开发工具IntelliJ IDEA\nIDEA 全称 IntelliJ IDEA，是java语言开发的集成环境，IntelliJ在业界被公认为最好的java开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE支持、各类版本工具(git、svn、github等)、JUnit、CVS整合、代码分析、 创新的GUI设计等方面的功能可以说是超常的。IDEA是JetBrains公司的产品，这家公司总部位于捷克共和国的首都布拉格，开发人员以严谨著称的东欧程序员为主。它的旗舰版本还支持HTML，CSS，PHP，MySQL，Python等。免费版只支持Java等少数语言。获取地址\n链接：http://pan.baidu.com/s/1pKPbhMz\n密码：e8la\n\nmyeclipse\nMyEclipse 是一个十分优秀的用于开发Java, J2EE的 Eclipse 插件集合，MyEclipse的功能非常强大，支持也十分广泛，尤其是对各种开源产品的支持十分不错。MyEclipse可以支持Java Servlet，AJAX，JSP，JSF，Struts，Spring，Hibernate，EJB3，JDBC数据库链接工具等多项功能。可以说MyEclipse是几乎囊括了目前所有主流开源产品的专属eclipse开发工具。获取地址\n链接：http://pan.baidu.com/s/1eRC2pUy \n密码：bgr0\n\neclipse\nEclipse 是一个开放源代码的、基于Java的可扩展开发平台。就其本身而言，它只是一个框架和一组服务，用于通过插件组件构建开发环境。幸运的是，Eclipse 附带了一个标准的插件集，包括Java开发工具（Java Development Kit，JDK）。获取地址\n链接：http://pan.baidu.com/s/1bp8KSs3 \n密码：tyut\n\nC/C++开发工具Visual Studio 2017\nVisual Studio 2017是微软于2017年3月8日正式推出的新版本，是迄今为止 最具生产力 的 Visual Studio 版本。其内建工具整合了 .NET Core、Azure 应用程序、微服务（microservices）、Docker 容器等所有内容。获取地址\n链接：http://pan.baidu.com/s/1nuHDGXN \n密码：fm84\n\nCode::Blocks\nCode::Blocks 是一个开放源码的全功能的跨平台C/C++集成开发环境。 Code::Blocks是开放源码软件。Code::Blocks由纯粹的C++语言开发完成，它使用了著名的图形界面库wxWidgets(2.6.2 unicode)版。对于追求完美的C++程序员，不必忍受Visual Studio的庞大和高昂的价格。获取地址\n链接：http://pan.baidu.com/s/1qY6Yzgg \n密码：tbah\n\npython开发工具Pycharm\nPyCharm是一种Python IDE，带有一整套可以帮助用户在使用Python语言开发时提高其效率的工具，比如调试、语法高亮、Project管理、代码跳转、智能提示、自动完成、单元测试、版本控制。此外，该IDE提供了一些高级功能，以用于支持Django框架下的专业Web开发。获取地址\n链接：http://pan.baidu.com/s/1dFb6KU1 \n密码：x9vm\n\n往期精彩文章\nJava开发工具下载\n\nJava 学习线路图是怎样的？\n\n版本控制之git的简易教程\n\n程序员常用设计模式之代理模式\n\n程序员常用设计模式之原型模型\n\n程序员常用设计模式之外观模式\n\n字符串匹配之kmp算法\n\n数据结构之二叉树的四种遍历方法\n\n八大经典排序算法–Java实现\n\nSpring整合hibernate和Struts\n\n\n","categories":["工具"],"tags":["工具","C✙✙","C","Java"]},{"title":"Java开发工具下载","url":"https://tanqingbo.cn/Java-development-tools/","content":"Eclipse IDE for Java EE Developers\n该版本集成了Java ee开发常用插件，方便动态web网站开发。适合Java web开发者使用。集成了XML编辑器、数据库查看工具，提供jsp可视化编辑器。获取地址\n链接：http://pan.baidu.com/s/1hsBZi2g \n密码：y05m\n\njdk（包含1.7和1.8两个版本）\nJDK是 Java 语言的软件开发工具包，主要用于移动设备、嵌入式设备上的java应用程序。JDK是整个java开发的核心，它包含了JAVA的运行环境（JVM+Java系统类库）和JAVA工具。获取地址\n链接：http://pan.baidu.com/s/1nu96J3N \n密码：4wfv\n\ntomcat（包含7.0和8.0两个版本）\nTomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。对于一个初学者来说，可以这样认为，当在一台机器上配置好Apache 服务器，可利用它响应HTML（标准通用标记语言下的一个应用）页面的访问请求。获取地址\n链接：http://pan.baidu.com/s/1miRzXXI \n密码：hg24\n\nmysql数据库\nMySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件。获取地址\n链接：http://pan.baidu.com/s/1gfJ2Jar \n密码：sucw\n\nnavicat for mySQL破解版\nNavicat是一套快速、可靠并价格相当便宜的数据库管理工具，专为简化数据库的管理及降低系统管理成本而设。获取地址\n链接：http://pan.baidu.com/s/1nvoOu97 \n密码：8swq\n\n往期精彩文章\nJava 学习线路图是怎样的？\n版本控制之git的简易教程\n程序员常用设计模式之代理模式\n程序员常用设计模式之原型模型\n程序员常用设计模式之外观模式\n字符串匹配之kmp算法\n数据结构之二叉树的四种遍历方法\n八大经典排序算法–Java实现\nSpring整合hibernate和Struts\nSping入门\n\n","categories":["工具"],"tags":["工具","Java","jdk"]},{"title":"Java的数组与集合排序问题","url":"https://tanqingbo.cn/Java-array-and-collection-sorting/","content":"Java的数组与集合排序问题数组排序\n先实现Comparable接口\n\n重写compareTo函数\n public class Main implements Comparable{\t\t\t\t long sid;\t\t\t\t int dgra;\t\t\t\t int cgra;\t\t\t\t int sum;\t\t\tpublic int compareTo(Object o) {\t\t\t\t\t Main p=(Main)o;\t\t\t\t\t  int n= sum&lt;p.sum?1:(sum==p.sum?0:-1);\t\t\t\t\t  if(n==0)\t\t\t\t\t  {\t\t\t\t\t   n=dgra&lt;p.dgra?1:(dgra==p.dgra?0:-1);\t\t\t\t\t   if(n==0)\t\t\t\t\t\t   n=sid&gt;p.sid?1:-1;\t\t\t\t\t  }\t\t\t\t\t  return n;\t\t\t\t}\t\t\t\tpublic static void main(String[] args) {\t\t\t\t\tMain[] stu2 = new Main[k];\t\t\t\t\tArrays.sort(stu1);\t\t\t\t}\t\t\t}\n\n\n\n\n\n\n集合排序\n先实现Comparable接口\n\n重写compareTo函数\n 1. public class Main implements Comparable&lt;Main&gt;{   \t long sid;   \t\t int dgra;   \t\t int cgra;   \t\t int sum;   \t@Override   \t\tpublic int compareTo(Main o) {   \t\t\tMain p=o;   \t\t\t  int n= sum&lt;p.sum?1:(sum==p.sum?0:-1);   \t\t\t  if(n==0)   \t\t\t  {   \t\t\t   n=dgra&lt;p.dgra?1:(dgra==p.dgra?0:-1);   \t\t\t   if(n==0)   \t\t\t\t   n=sid&gt;p.sid?1:-1;   \t\t\t  }   \t\t\t  return n;   \t\t}   \t\tpublic static void main(String[] args) {   \t\t\t\t\t\t\tList&lt;Main&gt; stu1 = new ArrayList&lt;Main&gt;();   \t\t\t\t\t\t\tCollections.sort(stu1);   \t\t\t\t\t\t}   \t}\t\n\n\n\n\n\n往期精彩文章\nJava 学习线路图是怎样的？\n版本控制之git的简易教程\n程序员常用设计模式之代理模式\n程序员常用设计模式之原型模型\n程序员常用设计模式之外观模式\n字符串匹配之kmp算法\n数据结构之二叉树的四种遍历方法\n八大经典排序算法–Java实现\nSpring整合hibernate和Struts\nSping入门\nJava必读电子书_文档教程_高清PDF下载\n\n","categories":["Java"],"tags":["算法","排序"]},{"title":"归并排序的原理及时间复杂度","url":"https://tanqingbo.cn/Merge-sort-algorithm/","content":"归并排序的原理及时间复杂度\n归并排序的定义：归并排序算法采用的是分治算法,即先把要排序的数组分成两个(或两个以上)有序表，然后再合并成一个新的有序表,即把待排序的序列分成若干个子序列,每个子序列都是有序的,然后把有序子序列合并成整体有序序列,这个过程也称为2-路归并.注意:归并排序的一种稳定排序,即相等元素的顺序不会改变.\n\n归并排序的原理将待排序的数组分成前后两个部分，再递归的将前半部分数据和后半部分的数据各自归并排序，得到的两部分数据，然后使用merge合并算法（算法见代码）将两部分算法合并到一起。例如：如果N=1；那么只有一个数据要排序，N=2，只需要调用merge函数将前后合并，N=4，………..  也就是将一个很多数据的数组分成前后两部分，然后不断递归归并排序，再合并，最后返回有序的数组。\n\n归并排序的时间复杂度归并排序的最好、最坏和平均时间复杂度都是O(nlogn)，而空间复杂度是O(n)，比较次数介于(nlogn)/2和(nlogn)-n+1，赋值操作的次数是(2nlogn)。因此可以看出，归并排序算法比较占用内存，但却是效率高且稳定的排序算法。\n\n代码：\n  public class MergeSort {\tprivate static void mergeSort(int[] array,int[] tmp,int left,int right){\t\tif(left&lt;right){\t\t\tint center = ( left + right ) / 2;//取数组的中点\t\t\tmergeSort(array,tmp,left,center);//归并排序数组的前半部分\t\t\tmergeSort(array,tmp,center+1,right);//归并排序数组的后半部分\t\t\tmerge(array,tmp,left,center+1,right);//将数组的前后半部分合并\t\t}\t}\t/*\t * 超简单的合并函数\t */\tprivate static void merge(int[] array, int[] tmp, int leftPos, int rightPos, int rightEnd) {\t\t// TODO Auto-generated method stub\t\tint leftEnd = rightPos - 1;\t\tint tmpPos = leftPos;\t\tint numElements = rightEnd - leftPos + 1;\t\twhile(leftPos &lt;= leftEnd &amp;&amp; rightPos &lt;= rightEnd){\t\t\tif(array[leftPos]&lt;=array[rightPos]){\t\t\t\ttmp[tmpPos++] = array[leftPos++];\t\t\t}else{\t\t\t\ttmp[tmpPos++] = array[rightPos++];\t\t\t}\t\t}\t\twhile(leftPos &lt;= leftEnd){\t\t\ttmp[tmpPos++] = array[leftPos++];\t\t}\t\twhile(rightPos &lt;= rightEnd){\t\t\ttmp[tmpPos++] = array[rightPos++];\t\t}\t\tfor(int i=0;i&lt;numElements;i++,rightEnd--){\t\t\tarray[rightEnd] = tmp[rightEnd];\t\t}\t}\tpublic static void mergeSort(int[] array){\t\tint[] tmp = new int[array.length];//声明一个用来合并的数组\t\tmergeSort(array,tmp,0,array.length-1);//调用排序函数，传入数字的起点和终点\t}}\n\n\n\n\n\n往期精彩文章\nitext制作pdf表格 \nJava 学习线路图是怎样的？\n版本控制之git的简易教程\n程序员常用设计模式之代理模式\n程序员常用设计模式之原型模型\n程序员常用设计模式之外观模式\n字符串匹配之kmp算法\n数据结构之二叉树的四种遍历方法\n八大经典排序算法–Java实现\nSpring整合hibernate和Struts\n\n","categories":["数据结构与算法"],"tags":["算法","Java","排序"]},{"title":"itext制作pdf表格","url":"https://tanqingbo.cn/itext-makes-pdf-form/","content":"itext制作pdf表格添加单元格\n把下面这几项顺次的加入到表格中，当一行充满时候自动换行到下一行  PdfPTable table = new PdfPTable(3);            table.addCell(\"1.1\");            table.addCell(\"1.2\");            table.addCell(\"1.3\");            table.addCell(\"2.1\");            table.addCell(\"2.2\");            table.addCell(\"2.3\");\n\n\n\n\n\n\n以上程序运行结果将显示三行二列的表格。\n添加单元格的内容还可以是以下几种形式。\n\npublic void addCell(PdfPCell cell);          public void addCell(PdfPTable table);          public void addCell(Phrase phrase);          public void addCell(String text);          public void addCell(Paragraph paragraph); \n\n\n\n\n本文用的是最后一种。 \n\n合并单元格\niText合并单元格的过程如下，首先创建一个cell，设置这个单元格的跨度，\n\n如果是横向合并，则通过\ncell.setColspan(n);  //n代表从当前单元格的位置开始，合并的单元格数\n如果是纵向合并，\ncell.setRowspan(n);//n代表从当前单元格的位置开始，合并的单元格数\n\n代码举例：（一开始是用数组添加单元格的，后来改成直接添加了，更简洁了）\npackage com.pdf;\t\timport java.io.FileOutputStream;\t\timport com.itextpdf.text.Document;\timport com.itextpdf.text.Element;\timport com.itextpdf.text.Font;\timport com.itextpdf.text.Image;\timport com.itextpdf.text.Paragraph;\timport com.itextpdf.text.Phrase;\timport com.itextpdf.text.pdf.BaseFont;\timport com.itextpdf.text.pdf.PdfPCell;\timport com.itextpdf.text.pdf.PdfPTable;\timport com.itextpdf.text.pdf.PdfWriter;\t\tpublic class pdf_Table {\tpublic static void main(String[] args) {\t Document document = new Document();\t try {\t \tBaseFont bfChinese = BaseFont.createFont(\"C:\\\\Windows\\\\Fonts\\\\simkai.ttf\",\t\t\tBaseFont.IDENTITY_H,false); // 中文处理       Font titleChinese = new Font(bfChinese, 20, Font.BOLD);      Font font = new Font(bfChinese, 20, Font.ITALIC);// 模板抬头的字体         Font moneyFontChinese = new Font(bfChinese, 11, Font.ITALIC); // 币种和租金金额的小一号字体          PdfWriter.getInstance(document,              new FileOutputStream(\"text1.pdf\"));      document.open();      PdfPTable table = new PdfPTable(1);//创建一个有1列的表格       table.setTotalWidth(15);//设置表格的各列宽度      PdfPCell cell1 = new PdfPCell(new Paragraph(\"招聘人员登记表\", titleChinese));      cell1.setHorizontalAlignment(Element.ALIGN_CENTER);      table.addCell(cell1);      document.add(table);      float f[] = {2,3,2,3,2};      PdfPTable table1 = new PdfPTable(5);      table1.setTotalWidth(f);      String str1[] = {\"姓名\",\"出生年月\",\"婚否\",\"专业\",\"健康状况\",\"政治面貌\",\"家庭住址\",\"简历\",\"家庭情况\"};      String str2[] = {\"性别\",\"学历\",\"名族\",\"毕业学校\",\"户籍所在地\",\"身份证号\",\"姓名\",\"亲属关系\",\"年龄\",\"健康状况\"};      PdfPCell ce1 = null;      PdfPCell ce2 = null;      PdfPCell ce3 = null;          ce1 = new PdfPCell(new Paragraph(str1[0],moneyFontChinese));      ce1.setHorizontalAlignment(Element.ALIGN_CENTER);      table1.addCell(ce1);      table1.addCell(\"\");      ce2 = new PdfPCell(new Paragraph(str2[0],moneyFontChinese));      ce2.setHorizontalAlignment(Element.ALIGN_CENTER);      table1.addCell(ce2);      table1.addCell(\"\");      ce3 = new PdfPCell(new Paragraph(\"照片\",moneyFontChinese));      ce3.setHorizontalAlignment(Element.ALIGN_CENTER);//水平居中      ce3.setUseAscender(true);//垂直居中      ce3.setVerticalAlignment(ce3.ALIGN_MIDDLE);//垂直居中      ce3.setRowspan(4); //合并同一行的四个格      Image img = Image.getInstance(\"E:\\\\我的电脑备份\\\\照片\\\\照片素材\\\\旅行\\\\长城\\\\IMG_20140727_095516.jpg\");//选择图片      //   img.setAlignment(1);       //  img.scaleAbsolute(110,150);//控制图片大小      ce3.setImage(img);      table1.addCell(ce3);    \t  for(int i=1;i&lt;4;i++){     \t ce1 = new PdfPCell(new Paragraph(str1[i],moneyFontChinese));          ce1.setHorizontalAlignment(Element.ALIGN_CENTER);          table1.addCell(ce1);          table1.addCell(\"\");          ce2 = new PdfPCell(new Paragraph(str2[i],moneyFontChinese));          ce2.setHorizontalAlignment(Element.ALIGN_CENTER);          table1.addCell(ce2);          table1.addCell(\"\");      }     for(int i=4;i&lt;6;i++){     \t ce1 = new PdfPCell(new Paragraph(str1[i],moneyFontChinese));          ce1.setHorizontalAlignment(Element.ALIGN_CENTER);          table1.addCell(ce1);          table1.addCell(\"\");          ce2 = new PdfPCell(new Paragraph(str2[i],moneyFontChinese));          ce2.setHorizontalAlignment(Element.ALIGN_CENTER);          table1.addCell(ce2);          ce3 = new PdfPCell(new Paragraph(\"\"));          ce3.setColspan(2); //合并同一行的2个格          table1.addCell(ce3);     }     ce1 = new PdfPCell(new Paragraph(str1[6],moneyFontChinese));     ce1.setHorizontalAlignment(Element.ALIGN_CENTER);     table1.addCell(ce1);     ce3 = new PdfPCell(new Paragraph(\"\"));     ce3.setColspan(4); //合并同一行的2个格     table1.addCell(ce3);     ce1 = new PdfPCell(new Paragraph(str1[8],moneyFontChinese));     ce1.setHorizontalAlignment(Element.ALIGN_CENTER);     ce1.setUseAscender(true);//垂直居中     ce1.setVerticalAlignment(ce1.ALIGN_MIDDLE);//垂直居中     ce1.setRowspan(5); //合并同一行的四个格     table1.addCell(ce1);          for(int i=0;i&lt;4;i++){     \tce2 = new PdfPCell(new Paragraph(str2[i+6],moneyFontChinese));         ce2.setHorizontalAlignment(Element.ALIGN_CENTER);         table1.addCell(ce2);     }     for(int i=0;i&lt;16;i++){     \t  table1.addCell(\" \");     }     ce1 = new PdfPCell(new Paragraph(str1[7],moneyFontChinese));     ce1.setMinimumHeight(90);     ce1.setHorizontalAlignment(Element.ALIGN_CENTER);     ce1.setUseAscender(true);//垂直居中     ce1.setVerticalAlignment(ce1.ALIGN_MIDDLE);//垂直居中     table1.addCell(ce1);     ce2 = new PdfPCell(new Paragraph(\" \"));     ce2.setColspan(4);     table1.addCell(ce2);   String str = \"1.多说几句话身份和空间分割法与人文u影的交付该雕。\"   \t\t+\"2.活动官方发布没办法长三角和环境事故。\"   \t\t\t\t+ \"3,白癜风是快捷方便和技术快递费\";     ce1 = new PdfPCell(new Paragraph(\"注意事项\",moneyFontChinese));     ce1.setMinimumHeight(90);     ce1.setHorizontalAlignment(Element.ALIGN_CENTER);     ce1.setUseAscender(true);//垂直居中     ce1.setVerticalAlignment(ce1.ALIGN_MIDDLE);//垂直居中     table1.addCell(ce1);     ce2 = new PdfPCell(new Paragraph(str,moneyFontChinese));     ce2.setHorizontalAlignment(Element.ALIGN_CENTER);     ce2.setUseAscender(true);//垂直居中     ce2.setVerticalAlignment(ce2.ALIGN_MIDDLE);//垂直居中     ce2.setColspan(4);     table1.addCell(ce2);         //        Image img = Image.getInstance(\"E:\\\\我的电脑备份\\\\照片\\\\照片素材\\\\旅行\\\\长城\\\\IMG_20140727_095516.jpg\");//选择图片    //        img.setAlignment(1);    //        img.scaleAbsolute(100,100);//控制图片大小    //        img.setAbsolutePosition(0,200);//控制图片位置    //        table1.addCell(img);                //        ce3 = new PdfPCell(new Paragraph(\"\"));    //        ce3.setColspan(4); //合并同一行的2个格    //        table1.addCell(ce3);    //         for(int i=1;i&lt;9;i++){    //        \t if(i&lt;6){    //         ce1[i] = new PdfPCell(new Paragraph(str1[i],moneyFontChinese));    //         ce1[i].setHorizontalAlignment(Element.ALIGN_CENTER);    //         ce2[i] = new PdfPCell(new Paragraph(\"\"));    //          ce3[i] = new PdfPCell(new Paragraph(str2[i],moneyFontChinese));    //          ce3[i].setHorizontalAlignment(Element.ALIGN_CENTER);    //         ce4[i] = new PdfPCell(new Paragraph(\"\"));    //          ce5[i] = new PdfPCell(new Paragraph(\"  \"));    //        \t }    //        \t else {    //        \t\t ce1[i] = new PdfPCell(new Paragraph(str1[i],font));    //                 ce1[i].setHorizontalAlignment(Element.ALIGN_CENTER);    //                 ce2[i] = new PdfPCell(new Paragraph(\"\"));    //                  ce3[i] = new PdfPCell(new Paragraph(str2[i],font));    //                  ce3[i].setHorizontalAlignment(Element.ALIGN_CENTER);    //                 ce4[i] = new PdfPCell(new Paragraph(\"\"));    //                  ce5[i] = new PdfPCell(new Paragraph(\"\"));    //        \t }    //       //  document.add(table1[i]);    //         }    //             //      //   ce5[0].setRowspan(4);    //         ce4[4].setColspan(2);  //合并同一行的两个格    //         ce4[5].setColspan(2);    //         ce2[6].setColspan(4);  //合并同一行的四个格    //         ce2[7].setColspan(4);    //         ce2[8].setColspan(4);    //         for(int i=0;i&lt;9;i++){    //        \t  table1[i].addCell(ce1[i]);    //              table1[i].addCell(ce2[i]);    //              table1[i].addCell(ce3[i]);    //              table1[i].addCell(ce4[i]);    //              if(i&gt;0)    //              table1[i].addCell(ce5[i]);    //        \t document.add(table1[i]);    //         }             document.add(table1);    \t\t  document.close();         } catch (Exception e) {             e.printStackTrace();         }     }    }\n效果如下：\n\n\n\n往期精彩文章\nJava 学习线路图是怎样的？ |  IT码农 (tanqingbo.cn)\n版本控制之git的简易教程\n程序员常用设计模式之代理模式\n程序员常用设计模式之原型模型\n程序员常用设计模式之外观模式\n字符串匹配之kmp算法\n数据结构之二叉树的四种遍历方法\n八大经典排序算法–Java实现\nSpring整合hibernate和Struts\nSping入门\n\n","categories":["Java"],"tags":["itext"]},{"title":"Java 学习线路图是怎样的？","url":"https://tanqingbo.cn/Java-learning-route-map/","content":"学习是一个循序渐进的过程，也是一个非常难坚持的过程，而Java由于其良好的封装性和稳定性，在web开发和大数据方向常年都占据霸主地位，很多大型科技公司都愿意采用Java解决方案，所以如果你真的准备学习Java，就请一定坚持下去，找到一份好工作绝对不是问题。\n我这边也由浅入深整理一份Java的学习资源和路线图，帮助你更好的学习Java。\n1、Java基础基本的程序语法是入门一个编程语言的必经之路，而且学好基础的语法还可以帮助小白迅速建立编程逻辑思维，学好基础语法之后，便要理解Java面向对象的编程逻辑，训练自己以对象的方式去写Java的程序。\n这里推荐大家去看《Head First Java》这本书，一本真正为零基础小白写的Java入门的书，里面的插图很多，内容风趣且通俗易懂，基本上涵盖了所有Java相关的基础知识，对于基础不行的小白、又不喜欢看大段文字的人来说再适合不过了。\n此外在基础阶段《Java 核心技术卷 1/2》这本书也强烈建议去看一下，对于 Java8 新特性的东西，我建议你基础学好之后可以看一下，暂时看不太明白也没关系，后面抽时间再回过头来看。\n看完之后，你可以用自己学的东西实现一个简单的 Java 程序，也可以尝试用 Java 解决一些编程问题，以此来将自己学到的东西付诸于实践。\n记得多总结！打好基础！把自己重要的东西都记录下来。 API 文档放在自己可以看到的地方，以备自己可以随时查阅。为了能让自己写出更优秀的代码。\n学习完之后可以看一下下面这几篇文章，检查一下自己的学习情况：\n\nJava面试题–基础知识汇总(一)\nJava面试题–设计模式与继承多态(二)\nJava面试题–重点总结(三)\nJava八大基本数据类型详解\nJava内存模型及GC原理(Java内存分配、GC基本原理)\n\n《Head First Java》和《Java 核心技术卷 1/2》下载地址：\n链接：https://pan.baidu.com/s/1kx2A5MSlnJCxahAP86zISw\n提取码：ku9m\n2、多线程的简单使用学完了Java基础语法知识就需要学点多线程与并发的知识了，因为Java作为主流的后端语言，经常需要处理系统传来的各种线程和并发的问题，而且找工作的时候面试官也肯定会问。推荐 看《Java高并发编程详解》 或者 《Java并发编程实践》这两本书。\n学习完多线程之后可以通过下面这些问题检测自己是否掌握。\nJava 多线程知识基础:\n\n什么是线程和进程?\n请简要描述线程与进程的关系,区别及优缺点？\n说说并发与并行的区别?\n为什么要使用多线程呢?\n使用多线程可能带来什么问题?\n说说线程的生命周期和状态?\n什么是上下文切换?\n什么是线程死锁?如何避免死锁?\n说说 sleep() 方法和 wait() 方法区别和共同点?\n为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？\n\nJava 多线程知识进阶：\n\nsynchronized 关键字:① 说一说自己对于 synchronized 关键字的了解；② 说说自己是怎么使用 synchronized 关键字，在项目中用到了吗;③ 讲一下 synchronized 关键字的底层原理；④ 说说 JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗；⑤ 谈谈 synchronized 和 ReentrantLock 的区别。\nvolatile 关键字： ① 讲一下 Java 内存模型；② 说说 synchronized 关键字和 volatile 关键字的区别。\nThreadLocal：① 简介；② 原理；③ 内存泄露问题。\n线程池：① 为什么要用线程池？；② 实现 Runnable 接口和 Callable 接口的区别；③ 执行 execute() 方法和 submit() 方法的区别是什么呢？；④ 如何创建线程池。\nAtomic 原子类: ① 介绍一下 Atomic 原子类；② JUC 包中的原子类是哪 4 类?；③ 讲讲 AtomicInteger 的使用；④ 能不能给我简单介绍一下 AtomicInteger 类的原理。\nAQS ：① 简介；② 原理；③ AQS 常用组件。\n\n《Java高并发编程详解》和 《Java并发编程实践》下载地址：\n链接：https://pan.baidu.com/s/1BSq4kOESgl0IMenXoU0ZZQ\n提取码：xuul\n3、计算机网络为了保证系统安全可靠的传输，你还需要了解到HTTP，TCP协议，什么是三次握手，四次挥手。计算机网络方面的学习，我觉得掌握基本的知识就行了，不需要太深究，一般面试对这方面要求也不高，毕竟不是专门做网络的。推荐 《网络是怎样连接的》 、《图解 HTTP》 这两本书来看，这两本书都属于比较有趣易懂的类型，也适合没有基础的人来看。\n《网络是怎样连接的》 和《图解 HTTP》下载地址： \n链接：https://pan.baidu.com/s/1oP9P8sgi1vmDBCoDmoZdbQ\n提取码：76ha\n4、数据结构与算法如果你想进入大厂的话，我推荐你在学习完 Java 基础或者多线程之后，就开始每天抽出一点时间来学习算法和数据结构。因为算法才是编程的灵魂，不管学的什么语言都跨不过算法这个门槛。\n对于想要入门算法和数据结构的朋友，建议看这两本书 《算法图解》 和 《大话数据结构》，这两本书虽然算不上很经典的书籍，但是比较有趣，对于刚入门算法和数据结构的朋友非常友好。\n除了上面两本书之外，《剑指 offer》 和《编程之美》 这两本书也可以看一下，对于算法面试非常有帮助。\n下载地址：\n链接：https://pan.baidu.com/s/1FTvU-nJwR78LtYeKPC7Pjg\n提取码：rz4w\n5、数据库数据库可能是整个系统中最值钱的部分了，大家应该经常听到删库跑路的笑话，对于互联网公司来说，数据库差多不约等于公司所有资源，所以数据库这部分一定要好好学。基本的增删改查，索引、存储过程、事务隔离级别，主被同步，读写分离这些都需要学一下！推荐书籍 《MySQL 必知必会》和《高性能MySQL》。\n下载地址：\n链接：https://pan.baidu.com/s/1KSJrthecsyjjc8Ms3QwLWg\n提取码：fjyf\n6、常用工具\nMaven ：建议学习常用框架之前可以提前花半天时间学习一下Maven的使用。（到处找 Jar 包，下载 Jar 包是真的麻烦费事，使用 Maven 可以为你省很多事情）。\n\nGit ：基本的 Git 技能也是必备的，试着在学习的过程中将自己的代码托管在 Github 上。（Git 入门）\n\n\n7、常用框架Spring、SpringMVC、Hibernate、Mybatis、shiro 这些框架都需要了解一下， 尤其是 Spring 原理，大厂面试必问，然后很有必要学习一下 SpringBoot ，很多公司对于应届生都是直接上手 SpringBoot。记住Spring 真的很重要！ 一定要搞懂 AOP 和 IOC 这两个概念。Spring 中 bean 的作用域与生命周期、SpringMVC 工作原理详解等等知识点都是非常重要的，一定要搞懂。推荐看《Spring技术内幕》和《Spring实战》这两本书。\n《Spring技术内幕》和《Spring实战》下载地址：\n链接：https://pan.baidu.com/s/19J3xeuJqpk4EtalEDpnuxw\n提取码：zc3z\n最后我觉得学习一门新的知识，最优的学习路径应该是这样的：\n\n官网（大概率是英文，不推荐初学者看）。\n书籍（知识更加系统完全，推荐）。\n视频（比较容易理解，推荐，B站上有很多学习视频，大概率能找到你想要的学习视频）。\n网上博客（解决某一知识点的问题的时候可以看看）。\n\n相信你看到这，大概能理解为什么程序员的工资会这么高了，因为要学的东西确实很多，而且技术更新还很快，需要不断学习新的东西，但是也别慌，只要你合理安排自己的时间，搞清楚哪些东西是重点，哪些东西仅仅了解就够了。这样你学习起来就会有侧重点，效率也会提升很多。\n往期精彩文章\n版本控制之git的简易教程\n程序员常用设计模式之代理模式\n程序员常用设计模式之原型模型\n程序员常用设计模式之外观模式\n字符串匹配之kmp算法\n数据结构之二叉树的四种遍历方法\n八大经典排序算法–Java实现\nSpring整合hibernate和Struts\nSping入门\nJava必读电子书_文档教程_高清PDF下载\n\n","categories":["Java"],"tags":["Java","框架"]},{"title":"版本控制之git的简易教程","url":"https://tanqingbo.cn/Git-Learning/","content":"版本控制为什么要进行版本控制？  最简单的例子，当我们用文字处理软件工作时（如Word）时需要进行修改，而有时候又不确定修改的内容是不是需要的，因此会产生许多个文件，如图：  \n\n每一个文件都是在之前的文件基础上进行微小的修改，久而久之，不但文件冗杂，而且还不清楚修改的内容是什么，是一种很杂乱的方式。\n而版本控制就是解决这一问题——通过记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。\n采取版本控制后，你可以将文件还原到之前的状态，比较各状态之间的细节从而查出是修改了哪个地方，找出哪里出了问题。甚至你可以随意删改项目中的文件，照样可以恢复到之前的样子，因而增加了容错率，提供了更多可能性。\n版本控制有三种，第一种是本地式版本控制，也就是在本地的硬盘上用数据库记录历代文件；第二种是集中式版本控制，通过一个服务器，多个用户连接到服务器进行文件的记录。而第三种是我们着重介绍的分布式版本控制，它将前两种结合起来，在本地和服务器都建立数据库，每次工作时从服务器克隆（clone）下来，同时又与服务器交互，从而兼顾协同性和安全性。\n我们所说的git就是一个分布式版本控制软件，GitHub就是一个git的托管服务。\n​    \ngit本地操作git设计简单，是完全分布式，允许成千上万个并行开发的分支(Branch)，有能力管理超大规模的项目，是目前首选的版本控制软件。\n一、工作流程git的三个工作区域，对应着三种状态：git 工作流程如下：    \n\n在工作目录中修改文件。（modified）  \n\n暂存文件，将文件的快照放入暂存区域。（staged）  \n\n提交更新，找到暂存区域的文件，将快照永久性存储到 git 仓库目录。（committed）\n\n\n这是最基本的流程，需要时刻记住。  \n二、安装gitgit官方网站下载对应自己电脑的版本，按照指引进行安装。\n三、git使用知识首先我们需要在本地创建一个仓库，用于存放历代版本。\n1.命令行中运用cd指令进入项目的目录，输入  \n$ git init  \n\n这将创建一个名为.git的隐藏子目录。    \n2.git status:查看哪些文件处于什么状态  \n$ git statusOn branch masternothing to commit, working directory clean（创建git仓库后目录下没有文件时的情况）  \n\n   创建一个文件（test）后再使用git status命令，将会看到一个新的提示  \n$ git statusOn branch masterYour branch is up-to-date with 'origin/master'.Untracked files:(use \"git add &lt;file&gt;...\" to include in what will be committed)testnothing added to commit but untracked files present (use \"git add\" to track)（新建的“test”文件出现在Untracked files下）\n\n3.git add：跟踪文件运行     \n$ git add test\n\n\n此时再运行git status，会看到test文件已被跟踪，处于暂存状态(staged)，显示Changes to be committed    \n$ git statusOn branch masterYour branch is up-to-date with 'origin/master'.Changes to be committed:(use \"git reset HEAD &lt;file&gt;...\" to unstage)test\n\n4.git commit：提交更新至仓库  \n先用git status命令确定暂存区域准备妥当，再运行$git commit -m ”提交信息”（提交信息指本次提交的说明，类似于注释）    \n$ git commit -m \"first\"[master 5e43df6] first 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 test \n\n\n此时会显示提交成功的信息。  \n5.git diff：显示尚未暂存的改动（并不是所有改动）\n6.git rm test：删除暂存区域中的文件test\n7.git log:查看提交历史  \n$ git logcommit 5e43df6b6d003ea70444ee3125456fd75b066803Author: *** &lt;****@gmail.com&gt;Date:   Thu Mar 16 19:37:52 2017 +0800firstcommit 1c83e2a07f0279ea510e2a323fada53166c3c657Author: *** &lt;****@gmail.com&gt;Date:   Thu Mar 16 19:16:26 2017 +0800test  \n\n8.版本回退  \n  在git log命令中我们可以看到类似5e43……6803的一大串字符，那就是版本号（commit id）我们可以用 git reset命令回退到之前任何一个版本:    \n$ git reset --hard 1c83e2a0  HEAD is now at 1c83e2a test\n\n\n（版本号不必补全，Git会自动去查找）\n以上就是git的本地基本操作，包括创建一个仓库，更改、暂存和提交，查看仓库的提交历史，版本回退。  \n分支分支是把工作从主线上分离开来，以免影响开发主线。在不同的分支上你可以尝试各种各样的增删改，实现不同的设想。而git的分支模型是它最突出的特点，也是git脱颖而出的原因。\n一、分支概念在版本回退里，你可以回溯到之前的任意版本，而这些版本都是处于一条时间线上，这条时间线就是一个分支。默认的分支为master分支，本身可以看做一个指针，HEAD指针则指向master指针，如图：    \n\n每次提交都会多出一个节点，指针也随之移动。当我们创建新的分支时，也就创建了一个新的指针，我们通过命令将HEAD指针移到新指针上：\n新提交一次后，新指针向前移动，master指针不变，这就产生了分支：我们可以将两条分支合并，之后可以删掉新分支。\n这样就完成了分支的合并。\n二、分支使用1.git branch：查看当前所有分支      \n$ git branch* master\n\n\n（*标示当前分支，默认处于master分支）  \n2.git branch testing : 创建testing分支      \n$ git branch testing\n\n\n此时创建了testing分支，运行git branch命令验证       \n$git branch    *mastertesting\n\n3.git checkout testing： 切换到testing分支      \n$ git checkout testingSwitched to branch 'testing'\n\n\n此时主分支位于testing，运行git branch命令验证   \n$ git branch  master* testing\n\n4.git merge testing：将master分支和testing分支合并（假设处于master分支）      \n$ git merge testingAlready up-to-date.\n\n\n如果在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，则会产生冲突从而无法合并，只能手动解决后再合并。    \n5.git branch -d删除分支  \n$ git branch -d testingDeleted branch testing (was 1c83e2a).  \n\n使用GitHubGitHub 是最大的 Git 版本库托管商，尽管这不是 Git 开源项目的直接部分，但如果想要专业地使用 Git，你将不可避免地与 GitHub 打交道。  \n创建帐户及配置1.访问https://github.com进行注册  \n2.SSH访问：    \n$ cd ~/.ssh$ ls id_rsa\t\tid_rsa.pub\tknown_hosts  \n\n 寻找到id_rsa命名的文件，.pub文件是公钥，另一个是私钥。    \n 如果找不到，可以运行如下命令创建它们    \n$ ssh-keygen  \n\n 进入github的帐户设置，点击左侧的SSH and GPG keys，将~/.ssh/id_rsa.pub公钥文件的内容粘贴到文本区，然后点击”Add key”    \n SSH访问配置成功     \n创建、维护和管理你自己的项目。1.点击页面右上角的＋号，点击New repository按钮  \nRespository name是必填项目，而其余都是选填项，可以默认。点击Create respository按钮  ，即创建了一个新的仓库这时候可以将项目分享给其他人，通过HTTP和SSH的形式。\n 2.对仓库进行操作，使本地和github同步  \n $ git remote add origin     **********（仓库地址）   （添加远程仓库至本地） $ git pull --rebase origin master    （更新远程更新到本地） $ git push -u origin master  （将本地仓库和远程仓库合并）\n\n 在今后的项目工作中就是用以上命令同步本地和Github，需要记住。  \n 3.克隆仓库 我们可以将远程仓库的内容克隆到本地\n $ git clone git@github.com:Liuwt1997/github-photo.gitCloning into 'github-photo'...remote: Counting objects: 3, done.remote: Compressing objects: 100% (3/3), done.remote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0Receiving objects: 100% (3/3), 196.28 KiB | 67.00 KiB/s, done.Checking connectivity... done.\n\n\n   此时远程仓库的文件全部克隆至本地。\n 4.添加合作者点击边栏的 “Settings” 链接，然后从左侧菜单中选择 “Collaborators” 。 然后，在输入框中填写用户名，点击 “Add collaborator.” 此时可以给予他们提交的权限。  \n  \n5.Fork按钮可以将他人项目派生下来，在你的空间中创建一个完全属于你的项目副本。  \n\n如何对项目做出贡献呢？    \n\n将派生出的副本克隆到本地\n\n创建出名称有意义的分支\n\n修改代码\n\n检查改动\n\n将改动提交到分支中\n\n将新分支推送到 GitHub 的副本中    \n\n\n现在到 GitHub 上查看之前的项目副本，可以看到 GitHub 提示我们有新的分支，并且显示了一个大大的绿色按钮让我们可以检查我们的改动，并给源项目创建合并请求。    \n如果你点击了那个绿色按钮，就会看到一个新页面，在这里我们可以对改动填写标题和描述，让项目的拥有者考虑一下我们的改动。通常花点时间来编写个清晰有用的描述是个不错的主意，这能让作者明白为什么这个改动可以给他的项目带来好处，并且让他接受合并请求。  \n以上就是简单的Github的使用方法。    \n往期精彩文章\n程序员常用设计模式之代理模式\n程序员常用设计模式之原型模型\n程序员常用设计模式之外观模式\n字符串匹配之kmp算法\n数据结构之二叉树的四种遍历方法\n八大经典排序算法–Java实现\nSpring整合hibernate和Struts\nSping入门\nJava必读电子书_文档教程_高清PDF下载\n\n","categories":["计算机基础知识"],"tags":[]},{"title":"程序员常用设计模式之装饰模式","url":"https://tanqingbo.cn/Decorative-pattern/","content":"上一篇给大家分享了《程序员常用设计模式之代理模式》,这篇文章接着给大家分享程序员常用设计模式之装饰模式。\n装饰模式装饰模式之前的面向对象原则介绍\n单一职责原则：就一个类而言，应该仅有一个引起它变化的原因。也就是说功能要单一。\n优点： 灵活性，可复用性。\n如果一个类承担的职责太多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者阻碍其他职责能力，这种耦合会导致脆弱的设计，当变化发生时，设计会发生意想不到的变化。\n\n\n开放封闭原则：软件应该可以扩展，但不可以修改。对于扩展是开放的，对于更改是封闭的。\n面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有代码，这就是开放封闭原则的精神所在。\n优点：可扩展  可复用  灵活性好\n\n\n依赖倒转原则：抽象不应该依赖细节，细节不应该依赖抽象。针对对接口编程，不要对实现编程。即高层模块不依赖底层模块，底层模块不依赖高层模块。\n其实就是谁也不依赖谁，除了约定的接口，大家都可以灵活自如。\n\n\n里氏代换原则：子类型必须能够替换掉他们的父类型，只有当子类可以替换掉父类，软件单位功能不受影响时，父类才能真正倍复用。\n\n装饰模式\n装饰模式：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。\n\n装饰模式是为已有功能动态的添加更多功能的一种方式。\n\n代码实现：\n\n\n//需要被装饰的对象\t\tpublic class Person {\t\t\tprivate String name;\t\t\tpublic Person(String name) {\t\t\t\tsuper();\t\t\t\tthis.name = name;\t\t\t}\t\t\tpublic Person() {\t\t\t\tsuper();\t\t\t}\t\t\tpublic void show(){\t\t\t\tSystem.out.println(\"装扮的\"+name);\t\t\t}\t\t}\t\t//功能的抽象类\t\tpublic class Finery extends Person{\t\t\tprotected Person component;\t\t\t//打扮\t\t\tpublic void Decorate(Person component){\t\t\t\tthis.component = component;\t\t\t}\t\t\t@Override\t\t\tpublic void show(){\t\t\t\tif(component != null){\t\t\t\t\tcomponent.show();\t\t\t\t}\t\t\t}\t\t}\t\t//继承功能类\t\tpublic class BigTrouser extends Finery {\t\t\t@Override\t\t\tpublic void show(){\t\t\t\tSystem.out.println(\"垮裤\");\t\t\t\tsuper.show();\t\t\t}\t\t}\t\t//继承功能类\t\tpublic class TShirts extends Finery {\t\t\t@Override\t\t\tpublic void show(){\t\t\t\tSystem.out.println(\"大T恤\");\t\t\t\tsuper.show();\t\t\t}\t\t}\t\t//继承功能类\t\tpublic class WearSneakers extends Finery {\t\t\t@Override\t\t\tpublic void show(){\t\t\t\tSystem.out.println(\"破球鞋\");\t\t\t\tsuper.show();\t\t\t}\t\t}\t\t//继承功能类\t\tpublic class WearSuit extends Finery{\t\t\t@Override\t\t\tpublic void show(){\t\t\t\tSystem.out.println(\"西装\");\t\t\t\tsuper.show();\t\t\t}\t\t}\t\t//动态给对象添加功能\t\tpublic class Test {\t\t\tpublic static void main(String[] args) {\t\t\t\tPerson xc = new Person(\"小菜\");\t\t\t\tSystem.out.println(\"第一种装扮：\");\t\t\t\tWearSneakers w = new WearSneakers();\t\t\t\tWearSuit ws = new WearSuit();\t\t\t\tBigTrouser bt = new BigTrouser();\t\t\t\t/*\t\t\t\t * 首先实例化person对象\t\t\t\t * 再用WearSneakers类包装person\t\t\t\t * 再用WearSuit类来包装WearSneakers对象\t\t\t\t * 再用BigTrouser类包装WearSuit对象\t\t\t\t * 最终执行BigTrouser的show方法。\t\t\t\t * \t\t\t\t */\t\t\t\tw.Decorate(xc);   \t\t\t\tws.Decorate(w);\t\t\t\tbt.Decorate(ws);\t\t\t\tbt.show();\t\t}\t\t}\n\n输出结果：\n      第一种装扮：\n      垮裤\n      西装\n      破球鞋\n      装扮的小菜\n\n什么时候使用装饰模式：\n\n当系统需要新功能时，是向旧的类中添加新的代码，这些新代码通常装饰了原有的核心职责或主要行为。\n\n\n把每个要装饰的功能放在单独的类中，并让这个类包装它所有装饰的对象。\n\n优点：\n\n把类的核心职责和装饰功能区分开来，去除相关类中重复的装饰逻辑。\n简化原有类。\n\n\n\n往期精彩文章\n程序员常用设计模式之简单工厂模式与策略模式\n程序员常用设计模式之代理模式\n程序员常用设计模式之原型模型\n程序员常用设计模式之外观模式\n程序员常用设计模式之装饰模式\n字符串匹配之kmp算法\n数据结构之二叉树的四种遍历方法\n八大经典排序算法–Java实现\nSpring整合hibernate和Struts\nSping入门\nJava必读电子书_文档教程_高清PDF下载\n深入理解Java中的List、Set与Map集合\n由浅入深，解析Java Servlet开发以及工作的过程\n\n","categories":["设计模式"],"tags":["算法","设计模式"]},{"title":"程序员常用设计模式之代理模式","url":"https://tanqingbo.cn/Agency-model/","content":"上一篇给大家分享了《程序员常用设计模式之原型模型》,这篇文章接着给大家分享程序员常用设计模式之代理模式。\n代理模式\n代理模式：为其他对象提供一种代理，以控制对这个对象的访问。\n\n代理应用的场合：\n\n远程代理：也就是为一个对象在不同的地址空间提供局部代理，这样可以隐藏一个对象存在于不同地址空间的事实。\n虚拟代理：是根据需要创建很大的对象，通过它来代理来存放实例化需要很长时间的真实对象，例如：网页加载图片。\n安全代理：用来控制真实对象访问时的权限，一般用于对象应有不同的访问权限的时候。\n智能指引：是指当调用真实对象时，代理处理另外一些事情。\n\n\n代码：（通过代理去追妹子的例子）\n      public interface IGiveGift {\t\t\tvoid GiveDolls();\t\t\tvoid GiveFlowers();\t\t\tvoid GiveChocolate();\t\t}\t\t//此类中的@Data用到了lombok的注解，可以自动提供get  set方法，节省代码量\t\t//请参考“eclipse使用lombok”博客。\t\timport lombok.Data;\t\tpublic @Data class SchoolGirl {\t\t\tString name;\t\t}\t\tpublic class Pursuit implements IGiveGift {\t\t\tSchoolGirl mm;\t\t\tpublic Pursuit(SchoolGirl mm) {\t\t\t\tsuper();\t\t\t\tthis.mm = mm;\t\t\t}\t\t\tpublic Pursuit() {\t\t\t\tsuper();\t\t\t}\t\t\t@Override\t\t\tpublic void GiveDolls() {\t\t\t\t// TODO Auto-generated method stub\t\t\t\tSystem.out.println(mm.getName()+\"送你洋娃娃。\");\t\t\t}\t\t\t@Override\t\t\tpublic void GiveFlowers() {\t\t\t\t// TODO Auto-generated method stub\t\t\t\tSystem.out.println(mm.getName()+\"送你鲜花。\");\t\t\t}\t\t\t@Override\t\t\tpublic void GiveChocolate() {\t\t\t\t// TODO Auto-generated method stub\t\t\t\tSystem.out.println(mm.getName()+\"送你巧克力。\");\t\t\t}\t\t}\t\tpublic class Proxy implements IGiveGift {\t\t\tPursuit gg;\t\t\tpublic Proxy() {\t\t\t\tsuper();\t\t\t}\t\t\tpublic Proxy(SchoolGirl mm) {\t\t\t\tsuper();\t\t\t\tthis.gg = new Pursuit(mm);\t\t\t}\t\t\t@Override\t\t\tpublic void GiveDolls() {\t\t\t\t// TODO Auto-generated method stub\t\t\t\tgg.GiveDolls();\t\t\t}\t\t\t@Override\t\t\tpublic void GiveFlowers() {\t\t\t\t// TODO Auto-generated method stub\t\t\t\tgg.GiveFlowers();\t\t\t}\t\t\t@Override\t\t\tpublic void GiveChocolate() {\t\t\t\t// TODO Auto-generated method stub\t\t\t\tgg.GiveChocolate();\t\t\t}\t\t}\t\tpublic class Test {\t\t\tpublic static void main(String[] args) {\t\t\t\tSchoolGirl mm = new SchoolGirl();\t\t\t\tmm.setName(\"小美\");\t\t\t\tProxy daili = new Proxy(mm);\t\t\t\tdaili.GiveDolls();\t\t\t\tdaili.GiveFlowers();\t\t\t\tdaili.GiveChocolate();\t\t\t}\t\t}\n\n\n代理模式结构图\n\nSubject接口，定义了RealSubject和Proxy的共用接口，这样就在任何使用RealSubject的地方都可以使用Proxy。\n  public interface Subject{\t\tpublic void request();\t}\n\n\n\nRealSubject定义Proxy所代表的真实实体，实现了Subject接口。\n public RealSubject implement Subject{\t\tpublic void request(){\t\t\t//真实请求\t\t}\t}\t\n\n\n\n\n\n\nProxy类，保存一个实体的引用使得代理可以访问实体，并实现Subject的接口，这样就可以用来代替实体。\n public class Proxy implement Subject{\t\tRealSubject realSubject;\t\tpublic Proxy(){\t\t\trealSubject = new RealSubject();\t\t}\t\tpublic void request(){\t\t\trealSubject.request();\t\t\t\t}\t}\n\n\n\n\n\n\n客户端代码：\n  public static void main(String[] args) {\t\tProxy proxy = new Proxy();\t\tproxy.request();\t}\n\n\n往期精彩文章\n程序员常用设计模式之简单工厂模式与策略模式\n\n程序员常用设计模式之代理模式\n\n程序员常用设计模式之原型模型\n\n程序员常用设计模式之外观模式\n\n程序员常用设计模式之装饰模式\n\n字符串匹配之kmp算法\n\n数据结构之二叉树的四种遍历方法\n\n八大经典排序算法–Java实现\n\nSpring整合hibernate和Struts\n\nSping入门\n\nJava必读电子书_文档教程_高清PDF下载\n\n\n","categories":["设计模式"],"tags":["算法","设计模式"]},{"title":"程序员常用设计模式之原型模型","url":"https://tanqingbo.cn/Prototype-mode/","content":"上一篇给大家分享了《设计模式之外观模式》,这篇文章接着给大家分享程序员常用设计模式之原型模型。\n原型模型\n原型模式其实就是从一个对象基础上再创建另外一个可定制的对象，而且不需要知道任何创建的细节。\n\n原型模型可以大大提高效率。一般在初始化的信息不发生变化的情况下，克隆是最好的办法，即隐藏了创建对象的细节，又对性能有大大的提升。\n\n看代码就知道怎么回事了。以书写简历为例：\n  public class Resume implements Cloneable{\t\tString name;\t\tString sex;\t\tString age;\t\tString timearea;\t\tString company;\t\tpublic Resume(String name) {\t\t\tsuper();\t\t\tthis.name = name;\t\t}\t\tpublic Resume() {\t\t\tsuper();\t\t}\t\t//设置个人信息\t\tpublic void setPersonInfo(String sex,String age){\t\t\tthis.sex = sex;\t\t\tthis.age = age;\t\t}\t\t//设置个人信息\t\tpublic void setWorkExperience(String timearea,String company){\t\t\tthis.timearea = timearea;\t\t\tthis.company = company;\t\t}\t\t@Override\t\tpublic String toString() {\t\t\treturn  name + \"  \" + sex + \"  \" + age + \"\\n工作经历：\" + timearea + \"   \"\t\t\t\t\t+ company;\t\t}\t\tpublic Object Clone() throws Exception{\t\t\treturn this.clone();\t\t}\t}\tpublic class Test {\t\tpublic static void main(String[] args) throws Exception {\t\t\tResume a = new Resume(\"大鸟\");\t\t\ta.setPersonInfo(\"男\", \"20岁\");\t\t\ta.setWorkExperience(\"2013-2017\", \"东北林业大学\");\t\t\tResume b = (Resume)a.Clone();\t\t\tb.setWorkExperience(\"2017-2022\", \"哈尔滨工业大学\");\t\t\tResume c = (Resume)a.Clone();\t\t\tc.setWorkExperience(\"2022-2030\", \"google\");\t\t\tSystem.out.println(a);\t\t\tSystem.out.println(b);\t\t\tSystem.out.println(c);\t\t}\t}\n\n\n\n输出结果：\n  大鸟  男  20岁\n  工作经历：2013-2017   东北林业大学\n  大鸟  男  20岁\n  工作经历：2017-2020   哈尔滨工业大学\n  大鸟  男  20岁\n  工作经历：2020-2022   google\n\n注：上述代码是原型模型的浅复制，只能复制值类型的数据，对于引用类型的对象不能复制。\n\n如果将工作经历也单独做一个类，然后在resume类中应用工作经历，就会输出3条一模一样的结果。\n\n浅复制被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都任指向原来的对象。\n\n将工作经历也单独做一个类的代码：\n  public class WorkExperience {\t\tString timearea;\t\tString company;\t\tpublic String getTimearea() {\t\t\treturn timearea;\t\t}\t\tpublic void setTimearea(String timearea) {\t\t\tthis.timearea = timearea;\t\t}\t\tpublic String getCompany() {\t\t\treturn company;\t\t}\t\tpublic void setCompany(String company) {\t\t\tthis.company = company;\t\t}\t\t@Override\t\tpublic String toString() {\t\t\treturn \"\\n工作经历\" + timearea + \"  \" + company;\t\t}\t}\tpublic class Resume implements Cloneable{\t\tString name;\t\tString sex;\t\tString age;\t\tWorkExperience work;\t\tpublic Resume(String name) {\t\t\tsuper();\t\t\tthis.name = name;\t\t\twork = new WorkExperience();\t\t}\t\tpublic Resume() {\t\t\tsuper();\t\t}\t\t//设置个人信息\t\tpublic void setPersonInfo(String sex,String age){\t\t\tthis.sex = sex;\t\t\tthis.age = age;\t\t}\t\tpublic void setWorkExperience(String timearea,String company){\t\t\twork.timearea  = timearea;\t\t\twork.company = company;\t\t}\t\t@Override\t\tpublic String toString() {\t\t\treturn name + \"  \" + sex + \"  \" + age + work ;\t\t}\t\tpublic Object Clone() throws Exception{\t\t\treturn this.clone();\t\t}\t}\n\n\n\n输出结果\n  大鸟  男  20岁\n  工作经历：2020-2022   google\n  大鸟  男  20岁\n  工作经历：2020-2022   google\n  大鸟  男  20岁\n  工作经历：2020-2022   google\n\n深复制：把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。\n\n二层深复制的代码：\n  public class WorkExperience implements Cloneable{\t\tString timearea;\t\tString company;\t\tpublic String getTimearea() {\t\t\treturn timearea;\t\t}\t\tpublic void setTimearea(String timearea) {\t\t\tthis.timearea = timearea;\t\t}\t\tpublic String getCompany() {\t\t\treturn company;\t\t}\t\tpublic void setCompany(String company) {\t\t\tthis.company = company;\t\t}\t\t@Override\t\tpublic String toString() {\t\t\treturn \"\\n工作经历\" + timearea + \"  \" + company;\t\t}\t\tpublic Object Clone() throws Exception{\t\t\treturn this.clone();\t\t}\t}\tpublic class Resume implements Cloneable{\t\tString name;\t\tString sex;\t\tString age;\t\tWorkExperience work;\t\tpublic Resume(String name) {\t\t\tsuper();\t\t\tthis.name = name;\t\t\twork = new WorkExperience();\t\t}\t\tpublic Resume() {\t\t\tsuper();\t\t}\t\tprivate Resume(WorkExperience work) throws Exception {\t\t\tsuper();\t\t\tthis.work = (WorkExperience)work.Clone();\t\t}\t\t//设置个人信息\t\tpublic void setPersonInfo(String sex,String age){\t\t\tthis.sex = sex;\t\t\tthis.age = age;\t\t}\t\tpublic void setWorkExperience(String timearea,String company){\t\t\twork.timearea  = timearea;\t\t\twork.company = company;\t\t}\t\t@Override\t\tpublic String toString() {\t\t\treturn name + \"  \" + sex + \"  \" + age + work ;\t\t}\t\tpublic Object Clone() throws Exception{\t\t\tResume obj = new Resume(this.work);\t\t\tobj.name = this.name;\t\t\tobj.age = this.age;\t\t\tobj.sex = this.sex;\t\t\treturn obj;\t\t}\t}\n\n\n\n输出结果：\n      大鸟  男  29岁\n      工作经历2013-2017  东北林业大学\n      大鸟  男  29岁\n      工作经历2017-2020  腾讯\n      大鸟  男  29岁\n      工作经历2020-2022  google\n\n代码改动的地方：\n\n让WorkExperience类也实现了Cloneable的接口，并增加了clone()方法。\n在resume类中新增了一个私有的构造方法。\n修改了resume的clone()的方法。\n\n\n\n往期精彩文章\n程序员常用设计模式之简单工厂模式与策略模式\n程序员常用设计模式之代理模式\n程序员常用设计模式之原型模型\n程序员常用设计模式之外观模式\n程序员常用设计模式之装饰模式\n字符串匹配之kmp算法\n数据结构之二叉树的四种遍历方法\n八大经典排序算法–Java实现\nSpring整合hibernate和Struts\nSping入门\nJava必读电子书_文档教程_高清PDF下载\n\n","categories":["设计模式"],"tags":["算法","设计模式"]},{"title":"程序员常用设计模式之外观模式","url":"https://tanqingbo.cn/Appearance-mode/","content":"外观模式定义\n外观模式(Facade Pattern)：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。外观模式结构图\n\n\n代码实现        public class SubSystemOne {\n            public void MethodOne(){\n                System.out.println(\"子系统方法一\");\n            }\n        }\n        public class SubSystemTwo {\n            public void MethodTwo(){\n                System.out.println(\"子系统方法二\");\n            }\n        }\n        public class SubSystemThree {\n            public void MethodThree(){\n                System.out.println(\"子系统方法三\");\n            }\n        }\n        public class Facade {\n            SubSystemOne one;\n            SubSystemTwo two;\n            SubSystemThree three;\n            public Facade() {\n                one = new SubSystemOne();\n                two = new SubSystemTwo();\n                three = new SubSystemThree();\n            }\n            public void MethodA(){\n                System.out.println(\"方法组A（）\");\n                one.MethodOne();\n                two.MethodTwo();\n            }\n            public void MethodB(){\n                System.out.println(\"方法组B（）\");\n                two.MethodTwo();\n                three.MethodThree();\n            }\n        }\n        public class Client {\n            public static void main(String[] args) {\n                Facade facade = new Facade();\n                facade.MethodA();\n                facade.MethodB();\n            }\n        }\n外观模式优点\n对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易。通过引入外观模式，客户代码将变得很简单，与之关联的对象也很少。\n实现了子系统与客户之间的松耦合关系，这使得子系统的组件变化不会影响到调用它的客户类，只需要调整外观类即可。\n降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程，因为编译一个子系统一般不需要编译所有其他的子系统。一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。\n只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类。\n\n外观模式缺点\n不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。\n在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。何时使用外观模式\n\n\n在设计初期阶段，应该有意识的将不同的两个层分离；\n在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂，增加Facade可以提供一个简单的接口，减少他们之间的依赖。\n在维护一个遗留的大型系统时，可能这个系统已经非常难以维护和扩展了，为新系统开发一个外观Facade类，来提供设计粗糙或高度复杂的遗留代码的比较清晰简单接口，让新系统与Facade对象交互，Facade与遗留代码交互所有复杂工作。\n\n往期精彩文章\n程序员常用设计模式之简单工厂模式与策略模式\n\n程序员常用设计模式之代理模式\n\n程序员常用设计模式之原型模型\n\n程序员常用设计模式之外观模式\n\n程序员常用设计模式之装饰模式\n\n字符串匹配之kmp算法\n\n数据结构之二叉树的四种遍历方法\n\n八大经典排序算法–Java实现\n\nSpring整合hibernate和Struts\n\nSping入门\n\nJava必读电子书_文档教程_高清PDF下载\n\n深入理解Java中的List、Set与Map集合\n\n\n","categories":["设计模式"],"tags":["算法","设计模式"]},{"title":"程序员常用设计模式之简单工厂模式与策略模式","url":"https://tanqingbo.cn/Factory-and-strategy-mode/","content":"简单工厂模式与策略模式前言\n设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。\n\n使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。\n\n在介绍设计模式之前需要先介绍一下面向对象的特性和UML类图。\n面向对象的特点\n封装、继承、多态。\nUML类图\n在UML类图中，常见的有以下几种关系: 泛化（Generalization）,  实现（Realization），关联（Association)，聚合（Aggregation），组合(Composition)，依赖(Dependency)\n\n在UML类图中矩形框表示一个类，类分三层，第一层是；类的名称，如果是抽象类，则用斜体显示，第二层表示特性，是字段和属性，第三层表示操作，通常是方法和行为。\n\n注意前面符号，“+”表示public，“-”表示private，“#”表示protected。\n\n【泛化关系】：是一种继承关系，表示一般与特殊的关系，它指定了子类如何具体化父类的所有特征和行为。例如：老虎是动物的一种，即有老虎的特性也有动物的共性。\n【箭头指向】：带三角箭头的实线，箭头指向父类\n\n\n\n\n【实现关系】：是一种类与接口的关系，表示类是接口所有特征和行为的实现.\n【箭头指向】：带三角箭头的虚线，箭头指向接口\n\n\n\n\n【关联关系】：是一种拥有的关系，它使一个类知道另一个类的属性和方法；如：老师与学生，丈夫与妻子关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。【代码体现】：成员变量【箭头及指向】：带普通箭头的实心线，指向被拥有者\n\n\n\n【聚合关系】：是整体与部分的关系，且部分可以离开整体而单独存在。如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。【代码体现】：成员变量【箭头及指向】：带空心菱形的实心线，菱形指向整体\n\n\n\n【组合关系】：是整体与部分的关系，但部分不能离开整体而单独存在。如公司和部门是整体和部分的关系，没有公司就不存在部门。组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。\n\n【代码体现】：成员变量\n【箭头及指向】：带实心菱形的实线，菱形指向整体\n\n\n【依赖关系】：是一种使用的关系，即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖.\n\n【代码表现】：局部变量、方法的参数或者对静态方法的调用\n【箭头及指向】：带箭头的虚线，指向被使用者\n\n\n各种关系的强弱顺序：\n     泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖 \n\n下面这张UML图，比较形象地展示了各种类图关系：\n\n\n\n简单工厂模式\n工厂模式介绍\n\n工厂模式专门负责将大量有共同接口的类实例化，工厂模式可以动态决定将哪一个类实例化，不必事先知道要实例化那一个类。\n\n\n工厂模式的几种形态：\n\n简单工厂模式：又称静态工厂方法模式。\n工厂方法模式：又称多态性工厂模式。\n抽象工厂模式：又称 工具箱模式。\n\n\n简单工厂模式的举例  \n       //抽象产品角色  \t\tpublic interface Car{  \t\t      public void drive();  \t\t}  \t\t//具体产品角色  \t\tpublic class Benz implements Car{  \t\t      public void drive() {  \t\t         System.out.println(\"Driving Benz \");  \t\t      }  \t\t}  \t\tpublic class Bmw implements Car{  \t\t      public void drive() {  \t\t       System.out.println(\"Driving Bmw \");  \t\t      }  \t\t}  \t\t//工厂类角色  \t\tpublic class Driver{  \t            //工厂方法.注意 返回类型为抽象产品角色  \t             public static Car driverCar(String s)throws Exception{  \t                   //判断逻辑，返回具体的产品角色给Client  \t                   if(s.equalsIgnoreCase(\"Benz\"))  \t                        return new Benz();  \t                   else if(s.equalsIgnoreCase(\"Bmw\"))  \t                            return new Bmw();  \t                     else throw new Exception();  \t           }  \t\t}  \n\n\n策略模式\n定义：它定义了算法家族，分别封装起来，让他们之间可以可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。\n\n\n\nStrategy类，定义了所有的支持的算法的公共接口。\n   abstract class Strategy{\t\t\t\t//算法方法\t\t\t\tpublic void AlgorithmInterface();\t\t\t}\n\n\n\n\n\n\nConcreteStrategy类封装了具体的算法或行为，继承Strategy类。\n  public class ConcreteStrategyA extend Strategy{\t\t\t//算法A实现方法\t\t\tpublic void AlgorithmInterface(){\t\t\t\t\t//算法A实现方法\t\t\t}\t\t}\t\tpublic class ConcreteStrategyB extend Strategy{\t\t\t//算法B实现方法\t\t\tpublic void AlgorithmInterface(){\t\t\t\t\t//算法B实现方法\t\t\t}\t\t}\n\n\n\n\n\n\nContext类，用一个ConcreteStrategy来配置，维护一个对Strategy对象的引用。\n\npublic class Context{\t\t\tStrategy strategy;\t\t\tpublic Context(Strategy strategy){  //初始化时，传入具体的策略对象\t\t\t\tthis.strategy = strategy;\t\t\t}\t\t\t//上下文接口\t\t\tpublic void ContextInterface(){    //根据具体的策略对象调用其算法方法\t\t\t\tstrategy.AlgorithmInterface();\t\t\t}\t\t} \t\t//主函数代码：\t\tpublic static void main(String[] args) {\t\t\tContext context；\t\t\t//由于实例化不同的策略，在调用context.AlgorithmInterface();时，所获得的结果也不同。\t\t\tcontext = new Context(new ConcreteStrategyA());\t\t\tcontext.AlgorithmInterface();\t\t\tcontext = new Context(new ConcreteStrategyB());\t\t\tcontext.AlgorithmInterface();\t\t}\n策略与工厂结合\n修改Context类\n  public class Context{\t\t\tStrategy strategy = null;  //声明一个接口对象\t\t\tpublic Context(String type){  //初始化时，在Context类中实现简单工厂的应用。\t\t\t\tswitch(type){\t\t\t\tcase \"需求一\"：\t\t\t\t\tStrategy s1 = new ConcreteStrategyA();\t\t\t\t\tstrategy = s1;\t\t\t\t\tbreak;\t\t\t\tcase \"需求二\"：\t\t\t\t\tStrategy s2 = new ConcreteStrategyB();\t\t\t\t\tstrategy = s2;\t\t\t\t\tbreak;\t\t\t\t}\t\t\t}\t\t\tpublic double GetResult(){\t\t\t\treturn strategy..AlgorithmInterface();\t\t\t}\t\t}\n\n\n\n\n\n\n简单工厂模式与策略与工厂结合的客户端代码对比\n  //工厂模式用法\t\tStrategy s = StrategyFactory.createStrategy(type);\t\t... = s.GetResult();\t\t//策略与工厂结合\t\tContext c = Context(type);\t\t... = c.GetResult();\n\n\n\n\n\n\n总结：简单工厂模式，客户端需要两个类，Strategy和StrategyFactory，而策略与工厂结合只需要一个类，Context类。降低了耦合性。策略模式解析\n策略模式是一种定义一系列算法的方法，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合。\n优点：\n简化单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试，\n将一系列行为封装到一个个类中时，可以在这些行为的类中消除条件语句。\n\n\n只要在分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑运用策略模式处理这种可能性变化。\n\n往期精彩文章\n程序员常用设计模式之简单工厂模式与策略模式\n\n程序员常用设计模式之代理模式\n\n程序员常用设计模式之原型模型\n\n程序员常用设计模式之外观模式\n\n程序员常用设计模式之装饰模式\n\n字符串匹配之kmp算法\n\n数据结构之二叉树的四种遍历方法\n\n八大经典排序算法–Java实现\n\nSpring整合hibernate和Struts\n\nSping入门\n\nJava必读电子书_文档教程_高清PDF下载\n\n\n","categories":["设计模式"],"tags":["算法","设计模式"]},{"title":"字符串匹配之kmp算法-C语言实现","url":"https://tanqingbo.cn/kmp-algorithms/","content":"字符串匹配之kmp算法原理\n字符串匹配是计算机的基本任务之一。\n\n举例来说，有一个字符串”BBC ABCDAB ABCDABCDABDE”，我想知道，里面是否包含另一个字符串”ABCDABD” \n\n首先，字符串”BBC ABCDAB ABCDABCDABDE”的第一个字符与搜索词”ABCDABD”的第一个字符，进行比较。因为B与A不匹配，所以搜索词后移一位。\n\n因为B与A不匹配，搜索词再往后移。\n\n就这样，直到字符串有一个字符，与搜索词的第一个字符相同为止。\n\n接着比较字符串和搜索词的下一个字符，还是相同。\n\n直到字符串有一个字符，与搜索词对应的字符不相同为止。\n\n这时，最自然的反应是，将搜索词整个后移一位，再从头逐个比较。这样做虽然可行，但是效率很差，因为你要把”搜索位置”移到已经比较过的位置，重比一遍。\n\n一个基本事实是，当空格与D不匹配时，你其实知道前面六个字符是”ABCDAB”。KMP算法的想法是，设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率。\n\n怎么做到这一点呢？可以针对搜索词，算出一张《部分匹配表》（Partial Match Table）。这张表是如何产生的，后面再介绍，这里只要会用就可以了。\n\n已知空格与D不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符B对应的”部分匹配值”为2，因此按照下面的公式算出向后移动的位数：\n                         移动位数 = 已匹配的字符数 - 对应的部分匹配值\n因为 6 - 2 等于4，所以将搜索词向后移动4位。\n\n\n10. 因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（”AB”），对应的”部分匹配值”为0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移2位。\n11.因为空格与A不匹配，继续后移一位。\n12.逐位比较，直到发现C与D不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动4位。\n13.逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 = 7 - 0，再将搜索词向后移动7位，这里就不再重复了。\n14.下面介绍《部分匹配表》是如何产生的。 首先，要了解两个概念：”前缀”和”后缀”。 “前缀”指除了最后一个字符以外，一个字符串的全部头部组合；”后缀”指除了第一个字符以外，一个字符串的全部尾部组合。\n\n\n\n\n15.\n“部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例:\n​​              －　“A”的前缀和后缀都为空集，共有元素 的长度为0；​        　   　－　“AB”的前缀为[A]，后缀为[B]，共有元素的长度为0；\n    　   　－　\"ABC\"的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；\n\n    　   　－　\"ABCD\"的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；\n\n    　   　－　\"ABCDA\"的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为\"A\"，长度为1；\n\n    　　   －　\"ABCDAB\"的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为\"AB\"，长度为2；\n\n    　    　－　\"ABCDABD\"的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。\n16.“部分匹配”的实质是，有时候，字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么它的”部分匹配值”就是2（”AB”的长度）。搜索词移动的时候，第一个”AB”向后移动4位（字符串长度-部分匹配值），就可以来到第二个”AB”的位置。\nnext数组的求解思路\n通过上文完全可以对kmp算法的原理有个清晰的了解，那么下一步就是编程实现了，其中最重要的就是如何根据待匹配的模版字符串求出对应每一位的最大相同前后缀的长度。我先给出我的代码：\n\nvoid makeNext(const char P[],int next[])\t  {\t      int q,k;//q:模版字符串下标；k:最大前后缀长度\t      int m = strlen(P);//模版字符串长度\t      next[0] = 0;//模版字符串的第一个字符的最大前后缀长度为0\t      for (q = 1,k = 0; q &lt; m; ++q)//for循环，从第二个字符开始，依次计算每一个字符对应的next值\t      {\t          while(k &gt; 0 &amp;&amp; P[q] != P[k])//递归的求出P[0]···P[q]的最大的相同的前后缀长度k\t              k = next[k-1];          //不理解没关系看下面的分析，这个while循环是整段代码的精髓所在，确实不好理解  \t         if (P[q] == P[k])//如果相等，那么最大相同前后缀长度加1\t         {\t             k++;\t         }\t         next[q] = k;\t     }\t } \n\n\n\n\n\n附代码：    #include&lt;stdio.h&gt;\t\t  #include&lt;string.h&gt;\t\t  void makeNext(const char P[],int next[])\t\t  {\t\t      int q,k;\t\t      int m = strlen(P);\t\t      next[0] = 0;\t\t      for (q = 1,k = 0; q &lt; m; ++q)\t\t      {\t\t         while(k &gt; 0 &amp;&amp; P[q] != P[k])\t\t             k = next[k-1];\t\t        if (P[q] == P[k])\t\t         {\t\t             k++;\t\t         }\t\t         next[q] = k;\t\t     }\t\t }\t\t int kmp(const char T[],const char P[],int next[])\t\t {\t\t     int n,m;\t\t     int i,q;\t\t     n = strlen(T);\t\t     m = strlen(P);\t\t     makeNext(P,next);\t\t     for (i = 0,q = 0; i &lt; n; ++i)\t\t     {\t\t         while(q &gt; 0 &amp;&amp; P[q] != T[i])\t\t             q = next[q-1];\t\t         if (P[q] == T[i])\t\t         {\t\t             q++;\t\t         }\t\t         if (q == m)\t\t         {\t\t             printf(\"Pattern occurs with shift:%d\\n\",(i-m+1));\t\t         }\t\t     }    \t\t }\t\t int main()\t\t {\t\t     int i;     int next[20]={0};\t\t     char T[] = \"ababxbababcadfdsss\";\t\t     char P[] = \"abcdabd\";\t\t     printf(\"%s\\n\",T);\t\t     printf(\"%s\\n\",P );\t\t     // makeNext(P,next);\t\t     kmp(T,P,next);\t\t     for (i = 0; i &lt; strlen(P); ++i)\t\t     {\t\t         printf(\"%d \",next[i]);\t\t     }\t\t     printf(\"\\n\");\t\t     return 0;\t\t }\n\n\n往期精彩文章\n数据结构之二叉树的四种遍历方法\n八大经典排序算法–Java实现\nSpring整合hibernate和Struts\nSping入门\nJava必读电子书_文档教程_高清PDF下载\n深入理解Java中的List、Set与Map集合\n由浅入深，解析Java Servlet开发以及工作的过程\nJava Map使用多个映射案例\n推荐7款好用的终端工具\n\n","categories":["数据结构与算法"],"tags":["算法","字符串","kmp"]},{"title":"数据结构之二叉树的四种遍历方法","url":"https://tanqingbo.cn/Binary-tree-traversal/","content":"二叉树的遍历\n我用下图的树为例，做树的遍历：\n\n\n树节点的定义：\n public class TreeNode {\t\tint val = 0;\t    TreeNode left = null;\t    TreeNode right = null;\t    public TreeNode(int val) {\t        this.val = val;\t    }\t\tpublic TreeNode(int val, TreeNode left, TreeNode right) {\t\t\tsuper();\t\t\tthis.val = val;\t\t\tthis.left = left;\t\t\tthis.right = right;\t\t}\t}\n\n\n\n\n\n\n树的结构的代码实现：\n  public static void main(String[] args) {\t   TreeNode e = new TreeNode(1);\t   TreeNode g = new TreeNode(2);\t   TreeNode h = new TreeNode(3);\t   TreeNode i = new TreeNode(4);\t   TreeNode d = new TreeNode(5,null,g);\t   TreeNode f = new TreeNode(6,h,i); \t   TreeNode b = new TreeNode(7,d,e);\t   TreeNode c = new TreeNode(8,f,null);\t   TreeNode root = new TreeNode(9,b,c);}\n\n\n\n\n\n\n中序遍历\n先处理左子树，然后处理当前节点，再处理右子树。\n\n对于一颗二叉查找树，所有的信息都是有序排列的，中序遍历可以是信息有序输出，且运行时间为O（n）。\n\n递归实现中序遍历：\n  public static void printTree(TreeNode t){\t\t\tif(t!=null){\t\t\t\tprintTree(t.left);\t\t\t\tSystem.out.print(t.val+\" \");\t\t\t\tprintTree(t.right);\t\t\t}\t\t}\n\n\n\n\n\n\n输出结果：\n  5 2 7 1 9 3 6 4 8 \n\n\n\n后序遍历\n先处理左右子树，然后再处理当前节点，运行时间为O（n）。\n\n递归实现后序遍历：\n public static void printTree(TreeNode t){\tif(t!=null){\t\tprintTree(t.left);\t\tprintTree(t.right);\t\tSystem.out.print(t.val+\" \");\t}}\n\n\n\n\n\n\n输出结果：\n  2 5 1 7 3 4 6 8 9 \n\n\n\n\n\n先序遍历\n先处理当前节点，在处理左右子树。\n\n递归实现先序遍历：\n     public static void printTree(TreeNode t){\tif(t!=null){\t\tSystem.out.print(t.val+\" \");\t\tprintTree(t.left);\t\tprintTree(t.right);\t}}\n\n\n\n\n\n\n输出结果：\n  9 7 5 2 1 8 6 3 4 \n\n\n\n\n\n\n有没有觉得树的先序，中序，后序遍历都非常简单，递归三行代码就搞定了。好吧，下边厉害的要来了\n\n层序遍历\n层序遍历:所有深度为D的节点要在深度为D+1的节点之前进行处理，层序遍历与其他类型的遍历不同的地方在于它不是递归地执行的，它用到队列，而不使用递归所默示的栈。\n\n算法思想：\n\n定义节点 TreeNode lastNode指向当前行最有节点，TreeNode nlastNode指向下一行最右节点。\n利用队列，首先将根节点入队,再循环里出队,并将其子节点入队,定义TreeNode tmpNode节点指向当前出队列的节点，当tmpNode==lastNode时，代表当前行遍历结束，输出换行，再令lastNode=nlastNode，nlastNode在子节点入队列时指向下一行最右节点。循环直到对列为空就行。 \n\n\n层序遍历代码：\n  package Tree;\timport java.util.ArrayList;\timport java.util.LinkedList;\timport java.util.List;\timport java.util.Queue;\t/*\t * 层序遍历\t * \t */\tpublic class TreePrinter1 {\t\t public static int[][] printTree(TreeNode root) {\t\t\t List&lt; List&lt;Integer&gt; &gt; list = new ArrayList&lt; List&lt;Integer&gt; &gt;();\t\t\t list.add(new ArrayList&lt;Integer&gt;());\t\t\t Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();\t\t        queue.add(root);\t\t        TreeNode lastNode = root;\t// 当前行最右节点\t\t        TreeNode nlastNode = root;\t// 下一行最右节点\t\t        TreeNode tmpNode = null; \t\t        int hight = 0;\t\t\t\t// 树的高度\t\t        while(!queue.isEmpty()){\t\t        \ttmpNode = queue.poll();\t\t        \tif(tmpNode!=null){\t\t        \t\tlist.get(hight).add(tmpNode.val);\t\t        \t}\t\t        \tif(tmpNode.left!=null){\t\t        \t\tqueue.add(tmpNode.left);\t\t        \t\tnlastNode = tmpNode.left;\t\t        \t}\t\t        \tif(tmpNode.right!=null){\t\t        \t\tqueue.add(tmpNode.right);\t\t        \t\tnlastNode = tmpNode.right;\t\t        \t}\t\t        \tif(tmpNode == lastNode){\t\t        \t\tlastNode = nlastNode;\t\t        \t\thight++;\t\t        \t\tlist.add(new ArrayList&lt;Integer&gt;());\t\t        \t}\t\t        }\t\t        int[][] data = new int[list.size()][];\t\t        for(int i=0;i&lt;list.size();i++){\t\t        \tfor(int j=0;j&lt;list.get(i).size();j++){\t\t        \t\tdata[i][j] = list.get(i).get(j);\t\t        \t}\t\t        }\t\t        \t\t\treturn data;\t\t }\t\t public static void main(String[] args) {\t\t\t   TreeNode e = new TreeNode(1);\t\t\t   TreeNode g = new TreeNode(2);\t\t\t   TreeNode h = new TreeNode(3);\t\t\t   TreeNode i = new TreeNode(4);\t\t\t   TreeNode d = new TreeNode(5,null,g);\t\t\t   TreeNode f = new TreeNode(6,h,i);\t\t\t   TreeNode b = new TreeNode(7,d,e);\t\t\t   TreeNode c = new TreeNode(8,f,null);\t\t\t   TreeNode root = new TreeNode(9,b,c);\t\t\t   int[][] data  =TreePrinter.printTree(root);\t\t\t   for(int s=0;s&lt;data.length;s++){\t\t\t\t   for(int j=0;j&lt;data[s].length;j++){\t\t\t\t\t   System.out.print(data[s][j]+\" \");\t\t\t\t   }\t\t\t\t   System.out.println();\t\t\t   }\t\t}\t}\n\n\n\n\n\n\n\n输出结果：\n\n9 7 8 5 1 6 2 3 4 \n\n\n\n往期精彩文章\n八大经典排序算法–Java实现\nSpring整合hibernate和Struts\nSping入门\nJava必读电子书_文档教程_高清PDF下载\n深入理解Java中的List、Set与Map集合\n由浅入深，解析Java Servlet开发以及工作的过程\nJava Map使用多个映射案例\n推荐7款好用的终端工具\n\n","categories":["数据结构与算法"],"tags":["算法","树"]},{"title":"八大经典排序算法--Java实现","url":"https://tanqingbo.cn/Eight-sorting-algorithms/","content":"八大排序算法–Java实现插入排序\n基本思想：每步将一个待排序的纪录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。\n算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。\n代码：\n\npublic static void insertionSort(int[] array){\t\t\t\tint tmp;\t\t\t\tfor(int i=1;i&lt;array.length;i++){\t\t\t\t\ttmp = array[i];  //将当前位置的数给tmp\t\t\t\t\tint j = i;\t\t\t\t\tfor(;j&gt;0&amp;&amp;array[j-1]&gt;tmp;j--){\t\t\t\t\t/*\t\t\t\t\t往右移，腾出左边的位置,\t\t\t\t\tarray[j-1]&gt;tmp:大于号是升序排列，小于号是降序排列\t\t\t\t   */\t\t\t\t\tarray[j] = array[j-1];\t\t\t}\t\t\t//将当前位置的数插入到合适的位置\t\t\tarray[j] = tmp;\t\t}\t}\n\n\n\n冒泡排序\n基本思想：持续比较相邻的元素。如果第一个比第二个大，就交换他们两个。直到没有任何一对数字需要比较。\n冒泡排序最好的时间复杂度为O(n)。冒泡排序的最坏时间复杂度为O(n^2)。因此冒泡排序总的平均时间复杂度为O(n^2)。\n算法适用于少量数据的排序，是稳定的排序方法。\n代码： public static void bubbleSort(int[] array){\tint tmp;\tboolean flag = false;  //设置是否发生交换的标志\tfor(int i = array.length-1;i &gt;= 0;i--){\t\tfor(int j=0;j&lt;i;j++){          //每一轮都找到一个最大的数放在右边\t\t\tif(array[j]&gt;array[j+1]){\t\t\t\ttmp = array[j];\t\t\t\tarray[j] = array[j+1];\t\t\t\tarray[j+1] = tmp;\t\t\t\tflag = true;   //发生了交换\t\t\t}\t\t}\t\tif(!flag)  break;   //这一轮循环没有发生交换，说明排序已经完成，退出循环\t}}\n\n\n\n\n\n选择排序\n基本思想：每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。\n选择排序是不稳定的排序方法。时间复杂度 O(n^2)。\n代码：public static void selectSort(int[] array){\t\tfor(int i = 0;i&lt;array.length-1;i++){\t\t\tint\tmin = array[i];\t\t\tint minindex = i;\t\t\tfor(int j = i;j&lt;array.length;j++){\t\t\t\tif(array[j]&lt;min){  //选择当前最小的数\t\t\t\t\tmin = array[j];\t\t\t\t\tminindex = j;\t\t\t\t}\t\t\t}\t\t\tif(i != minindex){ //若i不是当前元素最小的，则和找到的那个元素交换\t\t\t\tarray[minindex] = array[i];\t\t\t\tarray[i] = min;\t\t\t}\t\t}\t}\n\n\n\n\n\n希尔排序\n基本思想：先取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量d2&lt;d1重复上述的分组和排序，直至所取的增量dt=1(dt&lt;dt-1…&lt;d2&lt;d1)，即所有记录放在同一组中进行直接插入排序为止。\n在使用增量dk的一趟排序之后，对于每一个i，我们都有a[i]&lt;=a[i+dk],即所有相隔dk的元素都被排序。\n如图：增量序列为5，3，1，每一趟排序之后，相隔对应增量的元素都被排序了。当增量为1时，数组元素全部被排序。\n希尔排序不稳定，时间复杂度 平均时间 O(nlogn) 最差时间O(n^2) \n代码：public static void shellSort(int[] array){\t\t\tint j;\t\t\tfor(int gap = array.length/2; gap&gt;0; gap /= 2){\t\t\t\t//定义一个增长序列，即分割数组的增量,d1=N/2   dk=(d(k-1))/2\t\t\t\tfor(int i = gap; i&lt;array.length;i++){\t\t\t\t\tint tmp = array[i];\t\t\t\t\tfor( j =i; j&gt;=gap&amp;&amp;tmp&lt;array[j-gap]; j -= gap){\t\t\t\t\t\t//将相距为Dk的元素进行排序\t\t\t\t\t\tarray[j] = array[j-gap];\t\t\t\t\t}\t\t\t\t\tarray[j] = tmp;\t\t\t\t}\t\t\t}\t\t}\n\n\n\n\n\n堆排序\n预备知识：\n\n二叉堆是完全二元树（二叉树）或者是近似完全二元树（二叉树）。二叉堆有两种：最大堆和最小堆。大根堆：父结点的键值总是大于或等于任何一个子节点的键值；小根堆：父结点的键值总是小于或等于任何一个子节点的键值。二叉堆一般用数组来表示。例如，根节点在数组中的位置是0，第n个位置的子节点分别在2n+1和 2n+2。因此，第0个位置的子节点在1和2，1的子节点在3和4。以此类推。这种存储方式便於寻找父节点和子节点。例如初始要排序的数组为：49, 38, 65, 97, 76, 13, 27, 49构造成大根堆之后的数组为：97 76 65 49 49 13 27 38实际树形结构如图（最大堆）：\n\n\n堆排序基本思想：在排序过程中，将R[l..n]看成是一棵完全二叉树的顺序存储结构，利用完全二叉树中双亲结点和孩子结点之间的内在关系【参见二叉树的顺序存储结构】，在当前无序区中选择关键字最大(或最小)的记录。堆排序利用了大根堆(或小根堆)堆顶记录的关键字最大(或最小)这一特征，使得在当前无序区中选取最大(或最小)关键字的记录变得简单。\n\n堆排序是一种选择排序,其时间复杂度为O(nlogn)。堆排序是不稳定的\n\n代码：\n  /*\t\t * 堆排序\t\t * 调整最大堆，交换根元素和最后一个元素。\t\t * 参数说明：\t\t *     a -- 待排序的数组\t\t */\t\tpublic static void heapSort(int[] a) {\t\t    int n = a.length;\t\t    int i,tmp;\t\t    // 从(n/2-1) --&gt; 0逐次遍历。遍历之后，得到的数组实际上是一个(最大)二叉堆。\t\t    for (i = n / 2 - 1; i &gt;= 0; i--)\t\t        maxHeapDown(a, i, n-1);\t\t    // 从最后一个元素开始对序列进行调整，不断的缩小调整的范围直到第一个元素\t\t    for (i = n - 1; i &gt; 0; i--) {\t\t        // 交换a[0]和a[i]。交换后，a[i]是a[0...i]中最大的。\t\t        tmp = a[0];\t\t        a[0] = a[i];\t\t        a[i] = tmp;\t\t        // 调整a[0...i-1]，使得a[0...i-1]仍然是一个最大堆。\t\t        // 即，保证a[i-1]是a[0...i-1]中的最大值。\t\t        maxHeapDown(a, 0, i-1);\t\t    }\t\t}\t\t/*\t\t * 注：数组实现的堆中，第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。\t\t *     其中，N为数组下标索引值，如数组中第1个数对应的N为0。\t\t *\t\t * 参数说明：\t\t *     a -- 待排序的数组\t\t *     start -- 被下调节点的起始位置(一般为0，表示从第1个开始)\t\t *     end   -- 截至范围(一般为数组中最后一个元素的索引)\t\t */\t\tpublic static void maxHeapDown(int[] a, int start, int end) {\t\t    int c = start;            // 当前(current)节点的位置\t\t    int l = 2*c + 1;        // 左(left)孩子的位置\t\t    int tmp = a[c];            // 当前(current)节点的大小\t\t    for (; l &lt;= end; c=l,l=2*l+1) {\t\t        // \"l\"是左孩子，\"l+1\"是右孩子\t\t        if ( l &lt; end &amp;&amp; a[l] &lt; a[l+1])\t\t            l++;        // 左右两孩子中选择较大者，即m_heap[l+1] \t\t        if (tmp &gt;= a[l])\t\t            break;        // 调整结束\t\t        else {            // 交换值\t\t            a[c] = a[l];\t\t            a[l]= tmp;\t\t        }\t\t    }\t\t}\n\n\n\n\n\n\n归并排序\n归并排序的原理\n\n将待排序的数组分成前后两个部分，再递归的将前半部分数据和后半部分的数据各自归并排序，得到的两部分数据，然后使用merge合并算法（算法见代码）将两部分算法合并到一起。例如：如果N=1；那么只有一个数据要排序，N=2，只需要调用merge函数将前后合并，N=4，………..  也就是将一个很多数据的数组分成前后两部分，然后不断递归归并排序，再合并，最后返回有序的数组。\n\n\n归并排序的时间复杂度\n\n归并排序的最好、最坏和平均时间复杂度都是O(nlogn)，而空间复杂度是O(n)，比较次数介于(nlogn)/2和(nlogn)-n+1，赋值操作的次数是(2nlogn)。因此可以看出，归并排序算法比较占用内存，但却是效率高且稳定的排序算法。\n\n\n代码：\npublic class MergeSort {\t\tprivate static void mergeSort(int[] array,int[] tmp,int left,int right){\t\t\tif(left&lt;right){\t\t\t\tint center = ( left + right ) / 2;//取数组的中点\t\t\t\tmergeSort(array,tmp,left,center);//归并排序数组的前半部分\t\t\t\tmergeSort(array,tmp,center+1,right);//归并排序数组的后半部分\t\t\t\tmerge(array,tmp,left,center+1,right);//将数组的前后半部分合并\t\t\t}\t\t}\t\t/*\t\t * 超简单的合并函数\t\t */\t\tprivate static void merge(int[] array, int[] tmp, int leftPos, int rightPos, int rightEnd) {\t\t\t// TODO Auto-generated method stub\t\t\tint leftEnd = rightPos - 1;\t\t\tint tmpPos = leftPos;\t\t\tint numElements = rightEnd - leftPos + 1;\t\t\twhile(leftPos &lt;= leftEnd &amp;&amp; rightPos &lt;= rightEnd){\t\t\t\tif(array[leftPos]&lt;=array[rightPos]){\t\t\t\t\ttmp[tmpPos++] = array[leftPos++];\t\t\t\t}else{\t\t\t\t\ttmp[tmpPos++] = array[rightPos++];\t\t\t\t}\t\t\t}\t\t\twhile(leftPos &lt;= leftEnd){\t\t\t\ttmp[tmpPos++] = array[leftPos++];\t\t\t}\t\t\twhile(rightPos &lt;= rightEnd){\t\t\t\ttmp[tmpPos++] = array[rightPos++];\t\t\t}\t\t\tfor(int i=0;i&lt;numElements;i++,rightEnd--){\t\t\t\tarray[rightEnd] = tmp[rightEnd];\t\t\t}\t\t}\t\tpublic static void mergeSort(int[] array){\t\t\tint[] tmp = new int[array.length];//声明一个用来合并的数组\t\t\tmergeSort(array,tmp,0,array.length-1);//调用排序函数，传入数字的起点和终点\t\t}\t}\n\n\n\n\n\n快速排序\n快速排序原理：\n\n如果数组S中元素是0或者1，则返回；\n区数组S中任一元素v，称之为枢纽元；\n将S-{v}（S中剩余的元素）划分成连个不相交的集合：S1={S-{v}|x&lt;=v}和S2={S-{v}|x&gt;=v};\n返回{quicksort(s1)}后跟v，继而返回{quicksort(S2)}。\n\n\n选取枢纽元（三数中值分割法）\n\n一般的做法是使用左端、右端和中心位置上的三个元素的中值作为基元。分割策略：在分割阶段吧所有小元素移到数组的左边，大元素移到数组右边。，大小是相对于枢纽元素而言的。当i在j的左边时，将i右移，移过哪些小于枢纽元的元素，并将j左移，已过那些大于枢纽元的元素，当i和j停止时，i指向一个大元素，而j指向一个小元素，如果i在j的左边，那么将这两个元素交换，其效果是把一个大元素推向右边，而把小元素推向左边。效果如图：\n\n\n\n\n快速排序平均时间复杂度为O(nlogn)，最坏情况为O(n^2)，n越大，速度越快。不是稳定的排序算法。\n代码：/*\t * 快速排序\t * 两个方向，左边的i下标一直往右走，当a[i] &lt;= a[center_index]，\t * 其中center_index是中枢元素的数组下标，而右边的j下标一直往左走，当a[j] &gt; a[center_index]\t * 如果i和j都走不动了，i &lt;= j, 交换a[i]和a[j],重复上面的过程，直到i&gt;j\t * 交换a[j]和a[center_index]，完成一趟快速排序\t * 枢轴采用三数中值分割法可以优化\t */\t//递归快速排序\tpublic static void quickSort(int a[]){\t    qSort(a, 0, a.length - 1);\t}\t//递归排序，利用两路划分\tpublic static void qSort(int a[],int low,int high){\t    int pivot = 0;\t    if(low &lt; high){\t        //将数组一分为二\t        pivot = partition(a,low,high);\t        //对第一部分进行递归排序\t        qSort(a,low,pivot);\t        //对第二部分进行递归排序\t        qSort(a,pivot + 1,high);\t    }\t}\t//partition函数，实现三数中值分割法\tpublic static int partition(int a[],int low,int high){\t    int pivotkey = a[low];   //选取第一个元素为枢轴记录\t    while(low &lt; high){\t        //将比枢轴记录小的交换到低端\t        while(low &lt; high &amp;&amp; a[high] &gt;= pivotkey){\t            high--;\t        }\t        //采用替换而不是交换的方式操作\t        a[low] = a[high];\t        //将比枢轴记录大的交换到高端\t        while(low &lt; high &amp;&amp; a[low] &lt;= pivotkey){\t            low++;\t        }\t        a[high] = a[low];\t    }\t    //枢纽所在位置赋值\t    a[low] = pivotkey;\t    //返回枢纽所在的位置\t    return low;\t}\n\n\n\n\n\n\n桶式排序\n桶式排序不再是一种基于比较的排序方法，它是一种比较巧妙的排序方式，但这种排序方式需要待排序的序列满足以下两个特征：待排序列所有的值处于一个可枚举的范围之类；待排序列所在的这个可枚举的范围不应该太大，否则排序开销太大。\n\n排序的具体步骤如下：\n(1)对于这个可枚举范围构建一个buckets数组，用于记录“落入”每个桶中元素的个数；(2)将（1）中得到的buckets数组重新进行计算，按如下公式重新计算：\n\n\nbuckets[i] = buckets[i] +buckets[i-1] (其中1&lt;=i&lt;buckets.length);\n\n\n\n\n桶式排序是一种非常优秀的排序算法，时间效率极高，它只要通过2轮遍历：第1轮遍历待排数据，统计每个待排数据“落入”各桶中的个数，第2轮遍历buckets用于重新计算buckets中元素的值，2轮遍历后就可以得到每个待排数据在有序序列中的位置，然后将各个数据项依次放入指定位置即可。\n桶式排序的空间开销较大，它需要两个数组，第1个buckets数组用于记录“落入”各桶中元素的个数，进而保存各元素在有序序列中的位置，第2个数组用于缓存待排数据.\n桶式排序是稳定的。如果待排序数据的范围在0~k之间，那么它的时间复杂度是O(k+n)的.\n但是它的限制多，比如它只能排整形数组。而且当k较大，而数组长度n较小，即k&gt;&gt;n时，辅助数组C[k+1]的空间消耗较大。当数组为整形，且k和n接近时, 可以用此方法排序。 \n代码实现：//min的值为0，max的值为待排序数组中最大值+1public static void bucketSort(int[] data, int min, int max) {  \t        // 缓存数组  \t        int[] tmp = new int[data.length];  \t        // buckets用于记录待排序元素的信息  \t        // buckets数组定义了max-min个桶  \t        int[] buckets = new int[max - min];  \t        // 计算每个元素在序列出现的次数  \t        for (int i = 0; i &lt; data.length; i++) {  \t            buckets[data[i] - min]++;  \t        }  \t        // 计算“落入”各桶内的元素在有序序列中的位置  \t        for (int i = 1; i &lt; max - min; i++) {  \t            buckets[i] = buckets[i] + buckets[i - 1];  \t        }  \t        // 将data中的元素完全复制到tmp数组中  \t        System.arraycopy(data, 0, tmp, 0, data.length);  \t        // 根据buckets数组中的信息将待排序列的各元素放入相应位置  \t        for (int k = data.length - 1; k &gt;= 0; k--) {  \t            data[--buckets[tmp[k] - min]] = tmp[k];  \t        }  \t    }  \n\n\n\n\n\n总结\n下面是一个总的表格，大致总结了我们常见的所有的排序算法的特点。\n\n排序法平均时间最差情形稳定度额外空间备注\n冒泡O(n2)  O(n2) 稳定O(1)n小时较好\n选择O(n2)  O(n2) 不稳定O(1)n小时较好\n插入O(n2)  O(n2) 稳定O(1)大部分已排序时较好\nShell(希尔)O(nlogn)O(ns) 不稳定O(1)    s是所选分组\n快速O(nlogn)  O(n2) 不稳定O(nlogn)n大时较好\n归并O(nlogn)  O(nlogn) 稳定O(1)n大时较好\n堆O(nlogn)  O(nlogn) 不稳定O(1)n大时较好\n桶式O(k+n)  O(k+n) 稳定O(1)只能排整形数组\n\n性能测试\n  \n\n\n往期精彩文章\nSpring整合hibernate和Struts\nSping入门\nJava必读电子书_文档教程_高清PDF下载\n深入理解Java中的List、Set与Map集合\n由浅入深，解析Java Servlet开发以及工作的过程\nJava Map使用多个映射案例\n推荐7款好用的终端工具\n8张图 带你理解Java内存区域\nJava八大基本数据类型详解\n\n","categories":["数据结构与算法"],"tags":["算法","Java","排序"]},{"title":"Spring整合hibernate和Struts","url":"https://tanqingbo.cn/Spring-integrates-hibernate-Struts/","content":"上一篇给大家分享了《Sping入门》的一些知识,这篇文章分享spring如何整合hibernate和Struts。\nSpring整合hibernate整合hibernate的思想\ndao\nservice:控制事务整合的步骤\n\n\n加入Spring的支持\n\n加入hibernate的支持，最好是将hibernate的配置信息放在applicationContext.xml中\n\n如果使用的是myeclipse2014，生成的数据源中缺少driverClassName的配置，自己加上即可\n\n在配置文件中，生成了四个bean，分别是：数据库连接池 　　 Session工厂  　　 定义事物管理器对象   　　　 使用事物驱动的Annotation注解\n\n注：在数据库连接池的数据库连接字符串后面记得加上字符转码\n   &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test?characterEncoding=utf-8\"&gt;&lt;/property&gt;\n\n\n编写PO，HBM及DAO；如果使用生成的DAO，将@TRANSACTION去掉，不要在DAO中控制事务\n\n编写Service接口，在接口中控制事务，可以在接口或接口的方法中增加@Transtraction\n\n编写service实现类；在service实现类中注入dao；\n事务：transaction\n\n\n事务是用户自定义的一个操作序列，是一个最小的执行单元，不能再分自定义Dao(推荐使用的方法)\nBaseDao：所有Dao中实现的方法，是个接口\nBaseDaoImpl：具体实现\nXXXDaoImp：具体实体类的dao；整合struts2\n\n\n在web.xml中增加一个监听器，这个监听器再启动工程时加载applicationContext.xml配置文件;\n并将此BeanFactory存储到Application作用于对象中；\n增加一个struts-spring-plugin.jar的插件；\n在struts.xml配置文件中配置action时，class属性的值应该是由spring创建的Action实例解决hibernate的懒加载\n\n\n将lazy改成false:每次代码执行时，自动将数据库所有数据加载到对象，不管需不需要使用，效率慢。\n可以采用迫切左外连语句\n延迟session的关闭时间（jsp显示完毕后才关闭）\n通过OpenSessionInView的过滤器来实现,在web.xml中配置，配置时，应该放在第一个Filter的位置上；\n      &lt;filter&gt;\n          &lt;filter-name&gt;openSession&lt;/filter-name&gt;\n     &lt;filter-class&gt;org.springframework.orm.hibernate4.support.OpenSessionInViewFilter&lt;/filter-class&gt;\n      &lt;/filter&gt;\n      &lt;filter-mapping&gt;\n          &lt;filter-name&gt;openSession&lt;/filter-name&gt;\n          &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n      &lt;/filter-mapping&gt;\n\n\n\n分页实现\n      1.sql语句；\n            查询当前页的数据库的分页sql;在hibernate中可以使用setMaxResult,setFristResult两个方法来进行设置；\n            查询总记录数；\n        //分页\n        @Override\n        public void getAll(Class&lt;T&gt; clazz, PageInfo info) {\n            //设置总记录数\n            info.setRecordCount(this.getCount(clazz));\n            //设置总页数\n            info.setPageCount( info.getRecordCount()%info.getPageSize()==0 ? \n            info.getRecordCount()/info.getPageSize() : info.getRecordCount()/info.getPageSize()+1 );\n            Criteria c =  this.getSession().createCriteria(clazz);\n            //每页的记录数\n            c.setMaxResults(info.getPageSize());\n            c.setFirstResult((info.getCurrentPage()-1)*info.getPageSize());\n            //查询，并将查询结果赋给info\n            info.setList(c.list());\n        }\n        2.封装分页信息；\n            PageInfo;\n                action;总记录数，总页数；当前页号，当页的数据；等\n        3.将页面封装起来；\n            @include\n            @自定义标记；\n        eg:&lt;%@ include file=\"subPage.jsp\" %&gt;\n\n实例代码下载往期精彩文章\nSping入门\nJava必读电子书_文档教程_高清PDF下载\n深入理解Java中的List、Set与Map集合\n由浅入深，解析Java Servlet开发以及工作的过程\nJava Map使用多个映射案例\n推荐7款好用的终端工具\n8张图 带你理解Java内存区域\nJava八大基本数据类型详解\n如何学习Java多线程（超详细总结）\n\n","categories":["Java"],"tags":["Java","框架","Sping","hibernate","Struts"]},{"title":"JavaEE框架学习之Sping入门","url":"https://tanqingbo.cn/Spring-basics/","content":"上一篇给大家分享了《Web 常见服务器错误代码》,这篇文章整理了一些Java spring的知识。\nSping入门一些资源\nsping.io\nprojects.spring.io/spring-framework\n其他Spring是什么\nSpring是一个开源框架，为了解决企业应用开发的复杂性而创建的，但是现在已经不止于应用于企业应用\n是一个轻量级的控制反转（IoC）和面向切面的容器框架\n在Spring上开发应用更简单、方便、快捷，Spring带来了复杂的javaee开发的春天\n\nSpring作用\n容器\n提供了多种技术支持（JMS   MQ支持  UnitTest）\nAOP(事务管理、日志等)\n提供了众多方便应用的辅助类（JDBC Template等）\n对主流应用框架（Hibernate等）提供了良好的支持\nspring是一个一站式的框架；\nspring主要有两个思想：IOC和AOP；\nspring的主要的功能是整合其它框架；适应范围\n构建企业应用（SpringMVC+Spring+Hibernate/mybatis）\n单独使用Bean容器（Bean管理）\n单独使用AOP进行切面处理\n其他的Spring功能，如：对消息的支持等\n在互联网中应用\n抽象类代表一个概念（例如：飞机），接口代表一种能力（会飞的）ioc是反转控制；\n指的就是组件和组件之间的关系并不是由任意一端来进行维护的，而有由第三方来维护的；第一个Spring程序\n创建工程，增加spring支持\n在applicationContext.xml文件中定义bean\n创建工厂\n创建一个Spring工厂\nBeanFactory factory=new ClassPathXmlApplicationContext(\"aplicationContxt.xml\");\n在工厂重获对象,默认bean是单例模式\nfactory.getBean(\"name\");\n\n\n\n关于bean的配置\n默认bean是单例的（scope=”singleton”），但可以通过 scope属性修改成prototype;\nspring工厂赋值在init方法之前装配方式\n\n\n属性装配\n构造方法装配装配的内容\n\n\nbean\nnull\n集合\nmap\nref\nvalue自动装配的方式(四种)\n案例代码下载\n default-autowire = byName\n          byType\n          constructor\n          autoDetect\n\n\n\nAnnotation的配置方法\n案例代码下载\n\n控制层 　　　业务层      　　　　    持久层\n\naction     　　　  service   　　　　  dao\nannotation的配置步骤\n在配置文件中增加一个schema ，名子是context;\n\n使用&lt;context:componet-scan &gt;标记来扫描包；\n\n#这个配置可以自动扫描com.dao,service,com.action三个包中的类，并且实例化\n&lt;context:component-scan base-package=\"com.dao,service,com.action\"&gt;&lt;/context:component-scan&gt;\n\n用于创建bean的注解      @Component    三层都可以  \n      @Repository   写dao  （持久层）\n\n      eg:\n      @Repository(\"DeptDao\")（如果只是@Repository，\n      则factory.getBean(\"deptDaoImpl\");中的\"deptDaoImpl\"和源类名不一样，第一个字母是小写）\n      public class DeptDaoImpl implements DeptDao {\n          ......\n      }\n      这样就可以在主函数里获得DeptDaoImpl类的实例：\n      DeptDao dao =  (DeptDao) factory.getBean(\"DeptDao\");\n\n      @Service      写service （业务层 ） \n      @Controller   写action（控制层）\n用于控制bean的作用域注解，可将单例变成非单例      @Scope(\"prototype\")\n      eg：\n      @Controller\n      @Scope(\"prototype\")\n      public class DeptAction {...}\n用于装配的注解，为类中的其他类属性实例化          @Autowired  :建议使用\n          @Resource\n          @Inject\n\n          eg:\n          @Autowired   //实例化类DeptServise\n          DeptServise deptService;\n\n\n往期精彩文章\nJava必读电子书_文档教程_高清PDF下载\n深入理解Java中的List、Set与Map集合\n由浅入深，解析Java Servlet开发以及工作的过程\nJava Map使用多个映射案例\n推荐7款好用的终端工具\n8张图 带你理解Java内存区域\nJava八大基本数据类型详解\n如何学习Java多线程（超详细总结）\nJavaWeb中文编码问题\n\n","categories":["Java"],"tags":["Java","框架","Sping"]},{"title":"程序员面试相关经典书籍免费下载","url":"https://tanqingbo.cn/CSBook012/","content":"本帖子致力于汇总程序员在面试过程中需要看的书，包括程序员面试宝典、阿里巴巴Java面试问题大全、大厂面试真题、Java面试突击、剑指offer等经典书籍，帮助程序员轻松应对面试，拿下offer。\n面试相关经典书籍下载\n\n\n书籍名称\n百度网盘下载地址\n提取码\n\n\n\n阿里巴巴Java面试问题大全\n百度云下载链接\n密码:oh43\n\n\n程序员面试宝典\n百度云下载链接\n密码:82tj\n\n\n大厂面试真题\n百度云下载链接\n密码:z347\n\n\nJava面试突击\n百度云下载链接\n密码:pgur\n\n\n剑指offer\n百度云下载链接\n密码:ws8z\n\n\nAndroid高薪之路：Android程序员面试宝典\n百度云下载链接\n密码:1cvo\n\n\nC和C++程序员面试秘籍\n百度云下载链接\n密码:6rbn\n\n\n程序员面试白皮书\n百度云下载链接\n密码:hurk\n\n\n软技能：代码之外的生存指南\n百度云下载链接\n密码:acch\n\n\nJava程序员面试笔试宝典\n百度云下载链接\n密码:f4iq\n\n\n其他电子书下载\nJava电子书_文档教程_高清PDF下载\nPython电子书_文档教程_高清PDF下载\nC/C++电子书_文档教程_高清PDF下载\nLinux电子书_Linux书籍_高清PDF下载\n数据结构与算法相关书籍_PDF电子版下载\n计算机基础_操作系统_汇编语言_计算机网络-电子书PDF下载\n机器学习，人工智能经典必读电子书（PDF）下载\n设计模式经典图书电子书下载\nMYSQL、MongoDB数据库经典电子书下载\nGo语言经典电子书pdf下载\n\n","categories":["编程资料"],"tags":["程序员面试","offer"]},{"title":"Go语言经典电子书pdf下载","url":"https://tanqingbo.cn/CSBook011/","content":"Go 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。\n对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了。基于此本文汇总了几本Go语言从入门到深入的书籍，帮助大家更好的学习Go语言，戳对应链接便可直接下载。\nGo语言电子书下载\n\n\n书籍名称\n百度网盘下载地址\n提取码\n\n\n\n学习Go语言\n百度云下载链接\n密码:bph1\n\n\nGo语言实战\n百度云下载链接\n密码:2cqn\n\n\nGo web编程\n百度云下载链接\n密码:90wa\n\n\n其他电子书下载\nJava电子书_文档教程_高清PDF下载\nPython电子书_文档教程_高清PDF下载\nC/C++电子书_文档教程_高清PDF下载\nLinux电子书_Linux书籍_高清PDF下载\n数据结构与算法相关书籍_PDF电子版下载\n计算机基础_操作系统_汇编语言_计算机网络-电子书PDF下载\n机器学习，人工智能经典必读电子书（PDF）下载\n设计模式经典图书电子书下载\nMYSQL、MongoDB数据库经典电子书下载\n程序员面试相关经典书籍免费下载\n\n","categories":["编程资料"],"tags":["Go语言"]},{"title":"MYSQL、MongoDB数据库经典电子书下载","url":"https://tanqingbo.cn/CSBook010/","content":"本帖子致力于汇总数据库学习过程中需要用到的图书（电子书）、教程、文档，所有相关资料均提供电子版免费下载，涵盖高性能MySQL、深入浅出MySQL、MongoDB权威指南、MySQL必知必会、MySQL技术内幕InnoDB存储引擎、SQL查询的艺术、SQLite 权威指南等，帮助开发者全面学习了解﻿数据库的编程知识！如果没有找到你想要的书籍也可以文末给我留言。\n数据库电子书下载\n\n\n书籍名称\n百度网盘下载地址\n提取码\n\n\n\n高性能MySQL\n百度云下载链接\n密码:fy0y\n\n\n深入浅出MySQL\n百度云下载链接\n密码:1lel\n\n\nMongoDB权威指南\n百度云下载链接\n密码:vz6t\n\n\nMySQL必知必会\n百度云下载链接\n密码:42gd\n\n\nMySQL技术内幕InnoDB存储引擎\n百度云下载链接\n密码:bq4c\n\n\nSQL查询的艺术\n百度云下载链接\n密码:eubk\n\n\nSQLite 权威指南\n百度云下载链接\n密码:ea02\n\n\n其他电子书下载\nJava电子书_文档教程_高清PDF下载\nPython电子书_文档教程_高清PDF下载\nC/C++电子书_文档教程_高清PDF下载\nLinux电子书_Linux书籍_高清PDF下载\n数据结构与算法相关书籍_PDF电子版下载\n计算机基础_操作系统_汇编语言_计算机网络-电子书PDF下载\n机器学习，人工智能经典必读电子书（PDF）下载\n设计模式经典图书电子书下载\n程序员面试相关经典书籍免费下载\nGo语言经典电子书pdf下载\n\n","categories":["编程资料"],"tags":["数据库","MySQL","MongoDB"]},{"title":"计算机设计模式经典图书电子书下载","url":"https://tanqingbo.cn/CSBook009/","content":"不会设计模式的程序员不算真正入门编程，设计模式就像是编程中的招式、套路一样，你在开发的过程中遇到的大多数问题都有对应的招式帮你解决，这样我们做起事情来就会轻松许多，将来别人来维护你以前写的代码也会更容易一些。基于此，我整理了一些设计模式的经典书籍，帮助大家快速入门学习设计模式，点击对应链接便可免费下载。\n设计模式电子书下载\n\n\n书籍名称\n百度网盘下载地址\n提取码\n\n\n\n图解设计模式\n百度云下载链接\n密码:aer0\n\n\n研磨设计模式\n百度云下载链接\n密码:xth6\n\n\nHead First设计模式\n百度云下载链接\n密码:fef8\n\n\n大话设计模式\n百度云下载链接\n密码:dfyf\n\n\n其他电子书下载\nJava电子书_文档教程_高清PDF下载\nPython电子书_文档教程_高清PDF下载\nC/C++电子书_文档教程_高清PDF下载\nLinux电子书_Linux书籍_高清PDF下载\n数据结构与算法相关书籍_PDF电子版下载\n计算机基础_操作系统_汇编语言_计算机网络-电子书PDF下载\n机器学习，人工智能经典必读电子书（PDF）下载\n程序员面试相关经典书籍免费下载\nMYSQL、MongoDB数据库经典电子书下载\nGo语言经典电子书pdf下载\n\n","categories":["编程资料"],"tags":["设计模式"]},{"title":"机器学习，人工智能经典必读电子书（PDF）下载","url":"https://tanqingbo.cn/CSBook008/","content":"如今，机器学习和人工智能已成为计算机领域中最重要的发展趋势之一。深入影响着社会的各行各业，为了帮助大家入门机器学习，我整理了一些机器学习和人工智能的电子书。直接点击下方对应的网盘地址就可以免费下载，整理不易，记得分享给身边有需要的伙伴~\n如果没有找到你想要的书，也可以文末给我留言！\n机器学习，人工智能电子书下载\n\n\n书籍名称\n百度网盘下载地址\n提取码\n\n\n\n贝叶斯思维统计建模的Python学习法\n百度云下载链接\n密码:esay\n\n\n机器学习实战\n百度云下载链接\n密码:lvsp\n\n\nPython机器学习及实践\n百度云下载链接\n密码:kqdb\n\n\nTensorflow实战Google深度学习框架\n百度云下载链接\n密码:6gf2\n\n\n深度学习_中文版\n百度云下载链接\n密码:ekx5\n\n\n机器学习笔记\n百度云下载链接\n密码:coft\n\n\nTensorFlow实践与智能系统\n百度云下载链接\n密码:r5b5\n\n\n用Python进行自然语言处理\n百度云下载链接\n密码:1sm7\n\n\nkeras中文文档\n百度云下载链接\n密码:oahz\n\n\n其他电子书下载\nJava电子书_文档教程_高清PDF下载\nPython电子书_文档教程_高清PDF下载\nC/C++电子书_文档教程_高清PDF下载\nLinux电子书_Linux书籍_高清PDF下载\n数据结构与算法相关书籍_PDF电子版下载\n计算机基础_操作系统_汇编语言_计算机网络-电子书PDF下载\n程序员面试相关经典书籍免费下载\n设计模式经典图书电子书下载\nMYSQL、MongoDB数据库经典电子书下载\nGo语言经典电子书pdf下载\n\n","categories":["编程资料"],"tags":["机器学习","电子书下载","人工智能","AI"]},{"title":"计算机基础_操作系统_汇编语言_计算机网络-电子书PDF下载","url":"https://tanqingbo.cn/CSBook007/","content":"新技术决定你走多快，但是计算机基础能决定你能走多远，本文汇总了各种计算机基础知识书籍，涵盖操作系统、汇编语言、计算机网络的书籍，每一本都是经典，提供pdf免费下载。\n计算机基础操作系统\n\n\n书籍名称\n百度网盘下载地址\n提取码\n\n\n\n30天填自制操作系统\n百度云下载链接\n密码:qi3i\n\n\n操作系统之哲学原理\n百度云下载链接\n密码:j06p\n\n\n程序是怎样跑起来的\n百度云下载链接\n密码:zso3\n\n\n深入理解计算机操作系统\n百度云下载链接\n密码:c73a\n\n\n现代操作系统\n百度云下载链接\n密码:rmce\n\n\n汇编语言\n\n\n书籍名称\n百度网盘下载地址\n提取码\n\n\n\n汇编语言（注：王爽写的，我觉得写的很好，适合入门）\n百度云下载链接\n密码:6set\n\n\n计算机网络\n\n\n书籍名称\n百度网盘下载地址\n提取码\n\n\n\n计算机网络：自顶向下\n百度云下载链接\n密码:i6oh\n\n\n图解HTTP\n百度云下载链接\n密码:gcrd\n\n\n图解TC/IP\n百度云下载链接\n密码:ores\n\n\n网络是怎样连接的\n百度云下载链接\n密码:fl5f\n\n\nHTTP权威指南\n百度云下载链接\n密码:vr1m\n\n\nUNIX网络编程\n百度云下载链接\n密码:bwyt\n\n\n其他电子书下载\nJava电子书_文档教程_高清PDF下载\nPython电子书_文档教程_高清PDF下载\nC/C++电子书_文档教程_高清PDF下载\nLinux电子书_Linux书籍_高清PDF下载\n数据结构与算法相关书籍_PDF电子版下载\n程序员面试相关经典书籍免费下载\n机器学习，人工智能经典必读电子书（PDF）下载\n设计模式经典图书电子书下载\nMYSQL、MongoDB数据库经典电子书下载\nGo语言经典电子书pdf下载\n\n","categories":["编程资料"],"tags":["计算机网络","电子书下载","操作系统","汇编语言"]},{"title":"数据结构与算法相关书籍_PDF电子版下载","url":"https://tanqingbo.cn/CSBook006/","content":"不管你是Java编程爱好者、还是python的忠实粉丝，亦或觉得PHP才是这个世界最好的编程语言，都跨不过算法这个门槛。甚至可以说，懂算法的程序员才是一个合格的程序员，大部分互联网企业笔试环节必考算法，面试的时候也会让你手写算法，所以本文汇总了几十本计算机领域数据结构和算法的书籍，每一本都是经典，提供电子版下载，帮大家搞定算法。\n数据结构与算法相关书籍\n\n\n书籍名称\n百度网盘下载地址\n提取码\n\n\n\n挑战程序设计竞赛\n百度云下载链接\n密码:t9a7\n\n\nJava数据结构和算法\n百度云下载链接\n密码:05ay\n\n\n算法图解\n百度云下载链接\n密码:h2ng\n\n\n算法导论\n百度云下载链接\n密码:l4lc\n\n\n算法第四版\n百度云下载链接\n密码:z7ep\n\n\n剑指offer\n百度云下载链接\n密码:ws8z\n\n\n计算机程序设计艺术1-3卷\n百度云下载链接\n密码:9smu\n\n\n大话数据结构\n百度云下载链接\n密码:ydat\n\n\n程序员代码面试指南：IT名企算法与数据结构\n百度云下载链接\n密码:nk9i\n\n\n编程珠玑\n百度云下载链接\n密码:4te7\n\n\n编程之美\n百度云下载链接\n密码:p6l4\n\n\n啊哈算法\n百度云下载链接\n密码:ew4i\n\n\n程序员的算法趣题\n百度云下载链接\n密码:52lr\n\n\n我的第一本算法书\n百度云下载链接\n密码:wbgf\n\n\ncookbook-LeetCode\n百度云下载链接\n密码:2pjc\n\n\nleetcode-solution\n百度云下载链接\n密码:nb9k\n\n\n其他电子书下载\nJava电子书_文档教程_高清PDF下载\nPython电子书_文档教程_高清PDF下载\nC/C++电子书_文档教程_高清PDF下载\nLinux电子书_Linux书籍_高清PDF下载\n程序员面试相关经典书籍免费下载\n计算机基础_操作系统_汇编语言_计算机网络-电子书PDF下载\n机器学习，人工智能经典必读电子书（PDF）下载\n设计模式经典图书电子书下载\nMYSQL、MongoDB数据库经典电子书下载\nGo语言经典电子书pdf下载\n\n","categories":["编程资料"],"tags":["算法","电子书下载","数据结构"]},{"title":"Linux电子书_Linux书籍_高清PDF下载","url":"https://tanqingbo.cn/CSBook005/","content":"本帖子致力于汇总C/C++学习过程中需要用到的图书（电子书）、教程、文档，所有相关资料均提供电子版免费下载，包括Linux入门、Linux学习、Linux系统、Linux常用命令、Shell脚本、Linux防火墙等相关电子书下载，帮助Linux入门学习者快速进阶提高。如果没有找到你想要的书籍也可以文末给我留言。\nLinux\n\n\n书籍名称\n百度网盘下载地址\n提取码\n\n\n\n精通正则表达式\n百度云下载链接\n密码:shti\n\n\n鸟哥的Linux私房菜基础篇和服务器篇\n百度云下载链接\n密码:r2bk\n\n\n深入Linux内核架构\n百度云下载链接\n密码:rr81\n\n\nLinux宝典\n百度云下载链接\n密码:i0ks\n\n\nLinux常用命令大全\n百度云下载链接\n密码:lcf9\n\n\nLinux防火墙\n百度云下载链接\n密码:w63w\n\n\nLinux高级程序设计\n百度云下载链接\n密码:lg85\n\n\nLinux环境编程\n百度云下载链接\n密码:0dnz\n\n\nLinux命令详解词典\n百度云下载链接\n密码:juh4\n\n\n汇编语言基于linux环境第3版\n百度云下载链接\n密码:g8we\n\n\nVim 从入门到精通\n百度云下载链接\n密码:ni72\n\n\n其他电子书下载\nJava电子书_文档教程_高清PDF下载\nPython电子书_文档教程_高清PDF下载\nC/C++电子书_文档教程_高清PDF下载\n程序员面试相关经典书籍免费下载\n数据结构与算法相关书籍_PDF电子版下载\n计算机基础_操作系统_汇编语言_计算机网络-电子书PDF下载\n机器学习，人工智能经典必读电子书（PDF）下载\n设计模式经典图书电子书下载\nMYSQL、MongoDB数据库经典电子书下载\nGo语言经典电子书pdf下载\n\n","categories":["编程资料"],"tags":["电子书下载","Linux图书"]},{"title":"C/C++电子书_文档教程_高清PDF下载","url":"https://tanqingbo.cn/CSBook004/","content":"本帖子致力于汇总C/C++学习过程中需要用到的图书（电子书）、教程、文档，所有相关资料均提供电子版免费下载，提供最新最全的C/C++经典电子书籍及参考手册资料，涵盖C语言实例教程、入门基础教程、自学手册、语言开发、程序开发案例、编程设计、进阶、高级编程开发等！\nC语言\n\n\n书籍名称\n百度网盘下载地址\n提取码\n\n\n\n经典C程序100例\n百度云下载链接\n密码:pbyt\n\n\nC Primer Plus\n百度云下载链接\n密码:98gd\n\n\nC程序设计语言（包括课后答案等）\n百度云下载链接\n密码:5qt2\n\n\nC和指针\n百度云下载链接\n密码:3mjt\n\n\nC语言编程精粹\n百度云下载链接\n密码:979u\n\n\nC语言参考手册\n百度云下载链接\n密码:nyj7\n\n\nC语言函数大全\n百度云下载链接\n密码:rppz\n\n\nC语言解析教程\n百度云下载链接\n密码:1pih\n\n\nC语言深度剖析\n百度云下载链接\n密码:5gyc\n\n\nC专家编程\n百度云下载链接\n密码:4097\n\n\n深入探索C对象模型\n百度云下载链接\n密码:be4s\n\n\nC陷阱与缺陷\n百度云下载链接\n密码:zioq\n\n\n程序设计实践\n百度云下载链接\n密码:q1mz\n\n\nC 程序设计语言第2版\n百度云下载链接\n密码:47vs\n\n\nC++\n\n\n书籍名称\n百度网盘下载地址\n提取码\n\n\n\n代码大全\n百度云下载链接\n密码:9ca6\n\n\nC++ Primer\n百度云下载链接\n密码:m6gx\n\n\nC++编程思想\n百度云下载链接\n密码:k9f1\n\n\nC++对象模型\n百度云下载链接\n密码:yqey\n\n\n深入探索C++对象模型\n百度云下载链接\n密码:ixog\n\n\nC++ Templates\n百度云下载链接\n密码:uwi2\n\n\nC++编程规范-101条规则准则与最佳实践\n百度云下载链接\n密码:g8ix\n\n\nC++沉思录中文第2版\n百度云下载链接\n密码:t1as\n\n\nC++设计新思维-泛型编程与设计之应用\n百度云下载链接\n密码:lwm8\n\n\nEffective STL 中文版\n百度云下载链接\n密码:734k\n\n\nMore Effective C++中文版\n百度云下载链接\n密码:4ggd\n\n\nSTL源码剖析\n百度云下载链接\n密码:hain\n\n\n泛型编程与STL中文版\n百度云下载链接\n密码:mgn4\n\n\n大规模c++程序设计\n百度云下载链接\n密码:78ud\n\n\nThinking In C++中文版\n百度云下载链接\n密码:zq6w\n\n\nMore Exceptional C++中文版\n百度云下载链接\n密码:lci3\n\n\nEffective C++中文版\n百度云下载链接\n密码:gzij\n\n\nC++语言的设计和演化\n百度云下载链接\n密码:4ltg\n\n\nC++标准程序库自修教程与参考手册\n百度云下载链接\n密码:20hu\n\n\n其他电子书下载\nJava电子书_文档教程_高清PDF下载\nPython电子书_文档教程_高清PDF下载\n程序员面试相关经典书籍免费下载\nLinux电子书_Linux书籍_高清PDF下载\n数据结构与算法相关书籍_PDF电子版下载\n计算机基础_操作系统_汇编语言_计算机网络-电子书PDF下载\n机器学习，人工智能经典必读电子书（PDF）下载\n设计模式经典图书电子书下载\nMYSQL、MongoDB数据库经典电子书下载\nGo语言经典电子书pdf下载\n\n","categories":["编程资料"],"tags":["电子书下载","C++图书","C语言图书"]},{"title":"Python电子书_文档教程_高清PDF下载","url":"https://tanqingbo.cn/CSBook003/","content":"本帖子致力于汇总python学习过程中需要用到的图书（电子书）、教程、文档，所有相关资料均提供电子版免费下载，涵盖Python语法、入门基础教程、自学手册、语言开发、进阶、高级编程开发、数据分析、网络python爬虫等！格式有：pdf/chm。帮助开发者全面学习了解﻿python编程知识！如果没有找到你想要的书籍也可以文末给我留言。\n目录\nPython\n1、Python基础\n2、数据分析\n3、Python爬虫\n\n\n\nPythonPython基础\n\n\n书籍名称\n百度网盘下载地址\n提取码\n\n\n\n编程小白的第一本Python入门书\n百度云下载链接\n密码:hmtm\n\n\nHead First Python（中文版）\n百度云下载链接\n密码:ew7g\n\n\nPython编程初学者指南\n百度云下载链接\n密码:0dbk\n\n\nPython高级编程\n百度云下载链接\n密码:21od\n\n\nPython Cookbook\n百度云下载链接\n密码:mi32\n\n\nPython UNIX和Linux系统管理指南\n百度云下载链接\n密码:t8ti\n\n\nPython数据结构与算法\n百度云下载链接\n密码:fbb6\n\n\nPython网络编程基础\n百度云下载链接\n密码:s0qi\n\n\nPython学习手册\n百度云下载链接\n密码:g1u1\n\n\n《流畅的Python》高清中文版\n百度云下载链接\n密码:0z6v\n\n\n用Python进行自然语言处理\n百度云下载链接\n密码:1sm7\n\n\nPython开发实战\n百度云下载链接\n密码:tkej\n\n\nPython灰帽子\n百度云下载链接\n密码:hk9c\n\n\nPython开发技术详解\n百度云下载链接\n密码:razs\n\n\n简明Python教程\n百度云下载链接\n密码:ma5t\n\n\n数据分析\n\n\n书籍名称\n百度网盘下载地址\n提取码\n\n\n\n数据科学入门\n百度云下载链接\n密码:yrfr\n\n\nPython数据处理\n百度云下载链接\n密码:4gam\n\n\nPython数据分析实战\n百度云下载链接\n密码:7z61\n\n\nPython数据科学手册\n百度云下载链接\n密码:wpx3\n\n\nPython数据可视化编程实战\n百度云下载链接\n密码:vg99\n\n\n利用Python进行数据分析\n百度云下载链接\n密码:6bkh\n\n\nPython爬虫\n\n\n书籍名称\n百度网盘下载地址\n提取码\n\n\n\n用Python写网络爬虫\n百度云下载链接\n密码:v9rp\n\n\n精通Scrapy网络爬虫\n百度云下载链接\n密码:0qwe\n\n\n其他电子书下载\nJava电子书_文档教程_高清PDF下载\n程序员面试相关经典书籍免费下载\nC/C++电子书_文档教程_高清PDF下载\nLinux电子书_Linux书籍_高清PDF下载\n数据结构与算法相关书籍_PDF电子版下载\n计算机基础_操作系统_汇编语言_计算机网络-电子书PDF下载\n机器学习，人工智能经典必读电子书（PDF）下载\n设计模式经典图书电子书下载\nMYSQL、MongoDB数据库经典电子书下载\nGo语言经典电子书pdf下载\n\n","categories":["编程资料"],"tags":["电子书下载","Python图书"]},{"title":"Java电子书_文档教程_高清PDF下载","url":"https://tanqingbo.cn/CSBook002/","content":"本帖子致力于汇总Java学习过程中需要用到的图书（电子书）、教程、文档，所有相关资料均提供电子版免费下载，涵盖Java实用电子书籍、实例、入门基础教程、自学手册、软件开发、程序开发案例、编程语言设计、进阶、高级编程开发、Java虚拟机等，涉及Java Web、Spring、JDK、Servlet JSP、JavaEE、JVM等，帮助开发者全面学习了解﻿java编程知识！如果没有找到你想要的书籍也可以文末给我留言。\n目录\nJava\nJava 基础\nJava进阶\nJavaWeb\n\n\n\nJavaJava 基础\n\n\n书籍名称\n百度网盘下载地址\n提取码\n\n\n\n阿里巴巴Java开发手册\n百度云下载链接\n密码:w3r3\n\n\n码出高效\n百度云下载链接\n密码:65fy\n\n\nHead First Java\n百度云下载链接\n密码:ezr0\n\n\nJava8实战\n百度云下载链接\n密码:g577\n\n\nJava编程思想\n百度云下载链接\n密码:du2r\n\n\nJava并发编程的艺术\n百度云下载链接\n密码:dlco\n\n\nJava并发编程实践\n百度云下载链接\n密码:4dsg\n\n\nJava从小白到大牛\n百度云下载链接\n密码:b2cf\n\n\nJava核心技术卷Ⅰ基础知识\n百度云下载链接\n密码:4817\n\n\nJava核心技术卷Ⅱ高级特性\n百度云下载链接\n密码:hmru\n\n\n深入理解Java虚拟机\n百度云下载链接\n密码:ijqi\n\n\n分布式Java应用基础与实践\n百度云下载链接\n密码:705o\n\n\nJAVA核心知识点整理\n百度云下载链接\n密码:zoco\n\n\nJava进阶\n\n\n书籍名称\n百度网盘下载地址\n提取码\n\n\n\n代码大全\n百度云下载链接\n密码:9ca6\n\n\n代码整洁之道\n百度云下载链接\n密码:1ybi\n\n\n敏捷软件开发\n百度云下载链接\n密码:yum5\n\n\nEffective Java(中文)\n百度云下载链接\n密码:cz2o\n\n\nEffective Java（英文）\n百度云下载链接\n密码:7f8m\n\n\nJava性能优化权威指南\n百度云下载链接\n密码:czqw\n\n\nJavaWeb\n\n\n书籍名称\n百度网盘下载地址\n提取码\n\n\n\n轻量级JavaEE企业应用实战\n百度云下载链接\n密码:7p4u\n\n\n深入分析JavaWeb技术内幕\n百度云下载链接\n密码:8acs\n\n\n深入剖析Tomcat\n百度云下载链接\n密码:eyc8\n\n\nMaven实战\n百度云下载链接\n密码:67ot\n\n\nSpring实战\n百度云下载链接\n密码:cfgc\n\n\nCamel in Action\n百度云下载链接\n密码:aelv\n\n\n大型网站技术架构：核心原理与案例分析\n百度云下载链接\n密码:v7y3\n\n\nSpring技术内幕\n百度云下载链接\n密码:4rax\n\n\n其他电子书下载\n程序员面试相关经典书籍免费下载\nPython电子书_文档教程_高清PDF下载\nC/C++电子书_文档教程_高清PDF下载\nLinux电子书_Linux书籍_高清PDF下载\n数据结构与算法相关书籍_PDF电子版下载\n计算机基础_操作系统_汇编语言_计算机网络-电子书PDF下载\n机器学习，人工智能经典必读电子书（PDF）下载\n设计模式经典图书电子书下载\nMYSQL、MongoDB数据库经典电子书下载\nGo语言经典电子书pdf下载\n\n","categories":["编程资料"],"tags":["电子书下载","Java图书"]},{"title":"计算机专业电子书下载_程序员免费高清PDF书籍_IT类相关书籍汇总","url":"https://tanqingbo.cn/CSBook001/","content":"计算机类的书籍那么贵，作为一个几天看完一本书且书不离身的程序员，对电子书的需求量还是挺多的，所以天天买纸质书是不可能的了。为了方便广大的小伙伴也能方便找到对应的电子书，我花费洪荒之力从各个搜索网站收集了几百本常用的电子书。\n包括计算机基础、数据结构与而算法、python、Java、C/C++、Linux、GO、设计模式、人工智能、数据库以及面试相关等方面的书籍，基本上涵盖了程序员所需要的所有书籍，如果你想要的书籍没有找到，也可以在文末留言，我回头更新上~\n\n重要说明：如果目录无法跳转的话，直接拉下去就可以了，这些书籍都是在同一个页面的，我只是方便大家找到对应的，弄了一个页内目录，不过有部分读者反馈他跳转不了。\n\n\n数据结构与算法相关书籍\n计算机基础\n操作系统\n汇编语言\n计算机网络\n计算机组成原理\n正则表达式\n\n\nPython\n1、Python基础\n2、数据分析\n3、Python爬虫\n\n\nLinux\nC语言\nC++  \n人工智能\n设计模式\nJava\nJava 基础\nJava进阶\nJavaWeb\n\n\n数据库\nGo\n面试相关\n其他书籍\n\n数据结构与算法相关书籍\n\n\n书籍名称\n百度网盘下载地址\n提取码\n\n\n\n挑战程序设计竞赛\n百度云下载链接\n密码:t9a7\n\n\nJava数据结构和算法\n百度云下载链接\n密码:05ay\n\n\n算法图解\n百度云下载链接\n密码:h2ng\n\n\n算法导论\n百度云下载链接\n密码:l4lc\n\n\n算法第四版\n百度云下载链接\n密码:z7ep\n\n\n剑指offer\n百度云下载链接\n密码:ws8z\n\n\n计算机程序设计艺术1-3卷\n百度云下载链接\n密码:9smu\n\n\n大话数据结构\n百度云下载链接\n密码:ydat\n\n\n程序员代码面试指南：IT名企算法与数据结构\n百度云下载链接\n密码:nk9i\n\n\n编程珠玑\n百度云下载链接\n密码:4te7\n\n\n编程之美\n百度云下载链接\n密码:p6l4\n\n\n啊哈算法\n百度云下载链接\n密码:ew4i\n\n\n程序员的算法趣题\n百度云下载链接\n密码:52lr\n\n\n我的第一本算法书\n百度云下载链接\n密码:wbgf\n\n\ncookbook-LeetCode\n百度云下载链接\n密码:2pjc\n\n\nleetcode-solution\n百度云下载链接\n密码:nb9k\n\n\nLeetCode 101：和你一起你轻松刷题\n百度云下载链接\n密码:8h0c\n\n\nCMU硕士讲解经典101道\n百度云下载链接\n密码:6eab\n\n\nLeetCode面试常见算法整理\n百度云下载链接\n密码:pome\n\n\nLeetCode刷题手册（阿里大佬）\n百度云下载链接\n密码:4rzq\n\n\n加密与解密\n百度云下载链接\n密码:fhvu\n\n\n算法笔记\n百度云下载链接\n密码:fot4\n\n\nLeetCode刷题Java版答案\n百度云下载链接\n密码:k057\n\n\n计算机基础操作系统\n\n\n书籍名称\n百度网盘下载地址\n提取码\n\n\n\n30天填自制操作系统\n百度云下载链接\n密码:qi3i\n\n\n操作系统之哲学原理\n百度云下载链接\n密码:j06p\n\n\n程序是怎样跑起来的\n百度云下载链接\n密码:zso3\n\n\n深入理解计算机系统\n百度云下载链接\n密码:c73a\n\n\n现代操作系统\n百度云下载链接\n密码:rmce\n\n\n程序员必知操作系统\n百度云下载链接\n密码:edmk\n\n\n操作系统精髓与设计原理\n百度云下载链接\n密码:8d5v\n\n\nGoogle Android SDK开发范例大全(完整版)\n百度云下载链接\n密码:cu6y\n\n\n30天精通iPhone手机编程\n百度云下载链接\n密码:13m1\n\n\n计算机程序的构造和解释\n百度云下载链接\n密码:tsfd\n\n\n汇编语言\n\n\n书籍名称\n百度网盘下载地址\n提取码\n\n\n\n汇编语言（注：王爽写的，我觉得写的很好，适合入门）\n百度云下载链接\n密码:6set\n\n\n计算机网络\n\n\n书籍名称\n百度网盘下载地址\n提取码\n\n\n\n计算机网络：自顶向下\n百度云下载链接\n密码:i6oh\n\n\n图解HTTP\n百度云下载链接\n密码:gcrd\n\n\n图解TC/IP\n百度云下载链接\n密码:ores\n\n\n网络是怎样连接的\n百度云下载链接\n密码:fl5f\n\n\nHTTP权威指南\n百度云下载链接\n密码:vr1m\n\n\nUNIX网络编程\n百度云下载链接\n密码:bwyt\n\n\n计算机组成原理\n\n\n书籍名称\n百度网盘下载地址\n提取码\n\n\n\n计算机组成原理\n百度云下载链接\n密码:18k8\n\n\n计算机组成原理-白中英\n百度云下载链接\n密码:wtw2\n\n\n计算机编译原理\n\n\n书籍名称\n百度网盘下载地址\n提取码\n\n\n\n编译原理（高清龙书中文版）\n百度云下载链接\n密码:yocx\n\n\n编译原理及实践\n百度云下载链接\n密码:ei2d\n\n\n正则表达式\n\n\n书籍名称\n百度网盘下载地址\n提取码\n\n\n\n正则表达式必知必会\n百度云下载链接\n密码:uvsn\n\n\n正则表达式深入浅出\n百度云下载链接\n密码:rfy1\n\n\n精通正则表达式\n百度云下载链接\n密码:nmej\n\n\nPython1、Python基础\n\n\n书籍名称\n百度网盘下载地址\n提取码\n\n\n\n编程小白的第一本Python入门书\n百度云下载链接\n密码:hmtm\n\n\nHead First Python（中文版）\n百度云下载链接\n密码:ew7g\n\n\nPython编程初学者指南\n百度云下载链接\n密码:0dbk\n\n\nPython高级编程\n百度云下载链接\n密码:21od\n\n\nPython Cookbook\n百度云下载链接\n密码:mi32\n\n\nPython UNIX和Linux系统管理指南\n百度云下载链接\n密码:t8ti\n\n\nPython数据结构与算法\n百度云下载链接\n密码:fbb6\n\n\nPython网络编程基础\n百度云下载链接\n密码:s0qi\n\n\nPython学习手册\n百度云下载链接\n密码:g1u1\n\n\n《流畅的Python》高清中文版\n百度云下载链接\n密码:0z6v\n\n\n用Python进行自然语言处理\n百度云下载链接\n密码:1sm7\n\n\nPython开发实战\n百度云下载链接\n密码:tkej\n\n\nPython灰帽子\n百度云下载链接\n密码:hk9c\n\n\nPython开发技术详解\n百度云下载链接\n密码:razs\n\n\n简明Python教程\n百度云下载链接\n密码:ma5t\n\n\nPython编程：从入门到实践\n百度云下载链接\n密码:ua0w\n\n\n2、数据分析与爬虫\n\n\n书籍名称\n百度网盘下载地址\n提取码\n\n\n\n数据科学入门\n百度云下载链接\n密码:yrfr\n\n\nPython数据处理\n百度云下载链接\n密码:4gam\n\n\nPython数据分析实战\n百度云下载链接\n密码:7z61\n\n\nPython数据科学手册\n百度云下载链接\n密码:wpx3\n\n\nPython数据可视化编程实战\n百度云下载链接\n密码:vg99\n\n\n利用Python进行数据分析\n百度云下载链接\n密码:6bkh\n\n\n3、Python爬虫\n\n\n书籍名称\n百度网盘下载地址\n提取码\n\n\n\n用Python写网络爬虫\n百度云下载链接\n密码:v9rp\n\n\n精通Scrapy网络爬虫\n百度云下载链接\n密码:0qwe\n\n\nLinux\n\n\n书籍名称\n百度网盘下载地址\n提取码\n\n\n\n精通正则表达式\n百度云下载链接\n密码:shti\n\n\n鸟哥的Linux私房菜基础篇和服务器篇\n百度云下载链接\n密码:r2bk\n\n\n深入Linux内核架构\n百度云下载链接\n密码:rr81\n\n\nLinux宝典\n百度云下载链接\n密码:i0ks\n\n\nLinux常用命令大全\n百度云下载链接\n密码:lcf9\n\n\nLinux防火墙\n百度云下载链接\n密码:w63w\n\n\nLinux高级程序设计\n百度云下载链接\n密码:lg85\n\n\nLinux环境编程\n百度云下载链接\n密码:0dnz\n\n\nLinux命令详解词典\n百度云下载链接\n密码:juh4\n\n\n汇编语言基于linux环境第3版\n百度云下载链接\n密码:g8we\n\n\nVim 从入门到精通\n百度云下载链接\n密码:ni72\n\n\nlinux内核编程指南第3版\n百度云下载链接\n密码:l9jr\n\n\nlinux内核分析及编程\n百度云下载链接\n密码:zlqa\n\n\nC语言\n\n\n书籍名称\n百度网盘下载地址\n提取码\n\n\n\nC语言小白变怪兽\n百度云下载链接\n密码:w4tl\n\n\n啊哈c语言\n百度云下载链接\n密码:2bm6\n\n\n经典C程序100例\n百度云下载链接\n密码:pbyt\n\n\nC Primer Plus\n百度云下载链接\n密码:98gd\n\n\nC程序设计语言（包括课后答案等）\n百度云下载链接\n密码:5qt2\n\n\nC和指针\n百度云下载链接\n密码:3mjt\n\n\nC语言编程精粹\n百度云下载链接\n密码:979u\n\n\nC语言参考手册\n百度云下载链接\n密码:nyj7\n\n\nC语言函数大全\n百度云下载链接\n密码:rppz\n\n\nC语言解析教程\n百度云下载链接\n密码:1pih\n\n\nC语言深度剖析\n百度云下载链接\n密码:5gyc\n\n\nC专家编程\n百度云下载链接\n密码:4097\n\n\n深入探索C对象模型\n百度云下载链接\n密码:be4s\n\n\nC陷阱与缺陷\n百度云下载链接\n密码:zioq\n\n\n程序设计实践\n百度云下载链接\n密码:q1mz\n\n\nC 程序设计语言第2版\n百度云下载链接\n密码:47vs\n\n\n高质量C语言编程思想\n百度云下载链接\n密码:4umk\n\n\nC++\n\n\n书籍名称\n百度网盘下载地址\n提取码\n\n\n\n代码大全\n百度云下载链接\n密码:9ca6\n\n\nC++ Primer\n百度云下载链接\n密码:m6gx\n\n\nC++编程思想\n百度云下载链接\n密码:k9f1\n\n\nC++对象模型\n百度云下载链接\n密码:yqey\n\n\n深入探索C++对象模型\n百度云下载链接\n密码:ixog\n\n\nC++ Templates\n百度云下载链接\n密码:uwi2\n\n\nC++编程规范-101条规则准则与最佳实践\n百度云下载链接\n密码:g8ix\n\n\nC++沉思录中文第2版\n百度云下载链接\n密码:t1as\n\n\nC++设计新思维-泛型编程与设计之应用\n百度云下载链接\n密码:lwm8\n\n\nEffective STL 中文版\n百度云下载链接\n密码:734k\n\n\nMore Effective C++中文版\n百度云下载链接\n密码:4ggd\n\n\nSTL源码剖析\n百度云下载链接\n密码:hain\n\n\n泛型编程与STL中文版\n百度云下载链接\n密码:mgn4\n\n\n大规模c++程序设计\n百度云下载链接\n密码:78ud\n\n\nThinking In C++中文版\n百度云下载链接\n密码:zq6w\n\n\nMore Exceptional C++中文版\n百度云下载链接\n密码:lci3\n\n\nEffective C++中文版\n百度云下载链接\n密码:gzij\n\n\nC++语言的设计和演化\n百度云下载链接\n密码:4ltg\n\n\nC++标准程序库自修教程与参考手册\n百度云下载链接\n密码:20hu\n\n\n人工智能\n\n\n书籍名称\n百度网盘下载地址\n提取码\n\n\n\n贝叶斯思维统计建模的Python学习法\n百度云下载链接\n密码:esay\n\n\n机器学习实战\n百度云下载链接\n密码:lvsp\n\n\nPython机器学习及实践\n百度云下载链接\n密码:kqdb\n\n\nTensorflow实战Google深度学习框架\n百度云下载链接\n密码:6gf2\n\n\n深度学习_中文版\n百度云下载链接\n密码:ekx5\n\n\n机器学习笔记\n百度云下载链接\n密码:coft\n\n\nTensorFlow实践与智能系统\n百度云下载链接\n密码:r5b5\n\n\n用Python进行自然语言处理\n百度云下载链接\n密码:1sm7\n\n\nkeras中文文档\n百度云下载链接\n密码:oahz\n\n\n机器学习理论导引\n百度云下载链接\n密码:uzha\n\n\n设计模式\n\n\n书籍名称\n百度网盘下载地址\n提取码\n\n\n\n图解设计模式\n百度云下载链接\n密码:aer0\n\n\n研磨设计模式\n百度云下载链接\n密码:xth6\n\n\nHead First设计模式\n百度云下载链接\n密码:fef8\n\n\n大话设计模式\n百度云下载链接\n密码:dfyf\n\n\nJavaJava 基础\n\n\n书籍名称\n百度网盘下载地址\n提取码\n\n\n\n阿里巴巴Java开发手册\n百度云下载链接\n密码:w3r3\n\n\n码出高效\n百度云下载链接\n密码:65fy\n\n\nHead First Java\n百度云下载链接\n密码:ezr0\n\n\nJava8实战\n百度云下载链接\n密码:g577\n\n\nJava编程思想\n百度云下载链接\n密码:du2r\n\n\nJava并发编程的艺术\n百度云下载链接\n密码:dlco\n\n\nJava并发编程实践\n百度云下载链接\n密码:4dsg\n\n\nJava从小白到大牛\n百度云下载链接\n密码:b2cf\n\n\nJava核心技术卷Ⅰ基础知识\n百度云下载链接\n密码:4817\n\n\nJava核心技术卷Ⅱ高级特性\n百度云下载链接\n密码:hmru\n\n\n深入理解Java虚拟机\n百度云下载链接\n密码:ijqi\n\n\n分布式Java应用基础与实践\n百度云下载链接\n密码:705o\n\n\nJAVA核心知识点整理\n百度云下载链接\n密码:zoco\n\n\nJava高并发编程详解\n百度云下载链接\n密码:q3oz\n\n\nJava进阶\n\n\n书籍名称\n百度网盘下载地址\n提取码\n\n\n\n代码大全\n百度云下载链接\n密码:9ca6\n\n\n代码整洁之道\n百度云下载链接\n密码:1ybi\n\n\n敏捷软件开发\n百度云下载链接\n密码:yum5\n\n\nEffective Java(中文)\n百度云下载链接\n密码:cz2o\n\n\nEffective Java（英文）\n百度云下载链接\n密码:7f8m\n\n\nJava性能优化权威指南\n百度云下载链接\n密码:czqw\n\n\n阿里巴巴Java开发手册\n百度云下载链接\n密码:w3r3\n\n\n网络数据采集 Java网络爬虫实战\n百度云下载链接\n密码:zb0c\n\n\nJavaWeb\n\n\n书籍名称\n百度网盘下载地址\n提取码\n\n\n\n轻量级JavaEE企业应用实战\n百度云下载链接\n密码:7p4u\n\n\n深入分析JavaWeb技术内幕\n百度云下载链接\n密码:8acs\n\n\n深入剖析Tomcat\n百度云下载链接\n密码:eyc8\n\n\nMaven实战\n百度云下载链接\n密码:67ot\n\n\nSpring实战\n百度云下载链接\n密码:cfgc\n\n\nCamel in Action\n百度云下载链接\n密码:aelv\n\n\n大型网站技术架构：核心原理与案例分析\n百度云下载链接\n密码:v7y3\n\n\nSpring技术内幕\n百度云下载链接\n密码:4rax\n\n\nJavaScript宝典(第7版)\n百度云下载链接\n密码:4m2o\n\n\n深入浅出WPF—刘铁猛\n百度云下载链接\n密码:pfof\n\n\n数据库\n\n\n书籍名称\n百度网盘下载地址\n提取码\n\n\n\n高性能MySQL\n百度云下载链接\n密码:fy0y\n\n\n深入浅出MySQL\n百度云下载链接\n密码:1lel\n\n\nMongoDB权威指南\n百度云下载链接\n密码:vz6t\n\n\nMySQL必知必会\n百度云下载链接\n密码:42gd\n\n\nMySQL技术内幕InnoDB存储引擎\n百度云下载链接\n密码:bq4c\n\n\nSQL查询的艺术\n百度云下载链接\n密码:eubk\n\n\nSQLite 权威指南\n百度云下载链接\n密码:ea02\n\n\nGo\n\n\n书籍名称\n百度网盘下载地址\n提取码\n\n\n\n学习Go语言\n百度云下载链接\n密码:bph1\n\n\nGo语言实战\n百度云下载链接\n密码:2cqn\n\n\nGo web编程\n百度云下载链接\n密码:90wa\n\n\nGo 语言高级编程\n百度云下载链接\n密码:syl7\n\n\nGo入门指南\n百度云下载链接\n密码:cefw\n\n\nGo语言圣经\n百度云下载链接\n密码:ep0r\n\n\n面试相关\n\n\n书籍名称\n百度网盘下载地址\n提取码\n\n\n\n阿里巴巴Java面试问题大全\n百度云下载链接\n密码:oh43\n\n\n程序员面试宝典\n百度云下载链接\n密码:82tj\n\n\n大厂面试真题\n百度云下载链接\n密码:z347\n\n\nJava面试突击\n百度云下载链接\n密码:pgur\n\n\n剑指offer\n百度云下载链接\n密码:ws8z\n\n\nAndroid高薪之路：Android程序员面试宝典\n百度云下载链接\n密码:1cvo\n\n\nC和C++程序员面试秘籍\n百度云下载链接\n密码:6rbn\n\n\n程序员面试白皮书\n百度云下载链接\n密码:hurk\n\n\n软技能：代码之外的生存指南\n百度云下载链接\n密码:acch\n\n\nJava程序员面试笔试宝典\n百度云下载链接\n密码:f4iq\n\n\n其他书籍\n\n\n书籍名称\n百度网盘下载地址\n提取码\n\n\n\n电路识图从入门到精通\n百度云下载链接\n密码:oie5\n\n\n奇思妙想 15位计算机天才及其重大发现\n百度云下载链接\n密码:en48\n\n\n富爸爸穷爸爸\n百度云下载链接\n密码:ed17\n\n\n小狗钱钱\n百度云下载链接\n密码:g4nb\n\n\n见识 吴军\n百度云下载链接\n密码:rgsi\n\n\n你早该这么玩Excel\n百度云下载链接\n密码:v9ov\n\n\n\n书籍均来自网络，如有侵权，请联系我立即删除，邮箱：tqb_20134342@163.com\n\n以上书籍几乎涵盖了计算机专业学习的大部分书籍，如果没有找到你想要的书可以在留言区告诉我，由于还有其他工作，更新较慢，还请见谅~\nWindows 翻墙教程：从零开始科学上网（最稳定的科学上网方案）\n祝福希望大家都能找到心仪的工作，学习是一条时而郁郁寡欢，时而开环大笑的路，加油。\n如果你通过努力成功进入到了心仪的公司，一定不要懈怠放松，职场成长和新技术学习一样，不进则退。\n通过这些年的观察我发现身边的人真的就是实力越强的越努力，最高级的自律，享受孤独。\n随缘赞赏","categories":["编程资料"],"tags":["电子书下载"]},{"title":"Web 常见服务器错误代码","url":"https://tanqingbo.cn/javaweb-server-error-codes/","content":"1xx(临时响应)： 表示临时响应并需要请求者继续执行操作的状态码。\n100(继续)请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。\n101(切换协议)请求者已要求服务器切换协议，服务器已确认并准备切换。2xx (成功)：表示成功处理了请求的状态码。\n200(成功)服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。如果是对您的 robots.txt 文件显示此状态码，则表示 Googlebot 已成功检索到该文件。\n201(已创建)请求成功并且服务器创建了新的资源。\n201(已创建)请求成功并且服务器创建了新的资源。\n202(已接受)服务器已接受请求，但尚未处理。\n203(非授权信息)服务器已成功处理了请求，但返回的信息可能来自另一来源。\n204(无内容)服务器成功处理了请求，但没有返回任何内容。\n205(重置内容)服务器成功处理了请求，但没有返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图(例如，清除表单内容以输入新内容)。\n206(部分内容)服务器成功处理了部分 GET 请求。\n\n深入理解Java中的List、Set与Map集合\n4xx(请求错误)： 这些状态码表示请求可能出错，妨碍了服务器的处理。\n400(错误请求)服务器不理解请求的语法。\n401(未授权)请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应。\n403(禁止)服务器拒绝请求。\n404(未找到)服务器找不到请求的网页。例如，对于服务器上不存在的网页经常会返回此代码。\n405(方法禁用)禁用请求中指定的方法。\n406(不接受)无法使用请求的内容特性响应请求的网页。\n407(需要代理授权)此状态码与 401(未授权)类似，但指定请求者应当授权使用代理。如果服务器返回此响应，还表示请求者应当使用代理。\n408(请求超时)服务器等候请求时发生超时。\n409(冲突)服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，以及两个请求的差异列表。\n410(已删除)如果请求的资源已永久删除，服务器就会返回此响应。\n411(需要有效长度)服务器不接受不含有效内容长度标头字段的请求。\n412(未满足前提条件)服务器未满足请求者在请求中设置的其中一个前提条件。\n413(请求实体过大)服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。\n414(请求的 URI 过长)请求的 URI(通常为网址)过长，服务器无法处理。\n415(不支持的媒体类型)请求的格式不受请求页面的支持。\n416(请求范围不符合要求)如果页面无法提供请求的范围，则服务器会返回此状态码。 \n417(未满足期望值)服务器未满足”期望”请求标头字段的要求。\n\nJava内存模型及GC原理(Java内存分配、GC基本原理)\n5xx(服务器错误)：这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。\n500(服务器内部错误)服务器遇到错误，无法完成请求。\n501(尚未实施)服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。\n502(错误网关)服务器作为网关或代理，从上游服务器收到无效响应。\n503(服务不可用)服务器目前无法使用(由于超载或停机维护)。通常，这只是暂时状态。\n504(网关超时)服务器作为网关或代理，但是没有及时从上游服务器收到请求。\n505(HTTP 版本不受支持)服务器不支持请求中所用的 HTTP 协议版本。\n\n码字不易，求分享、转发。😄\n往期精彩文章\nJava必读电子书_文档教程_高清PDF下载\n\n深入理解Java中的List、Set与Map集合\n\n由浅入深，解析Java Servlet开发以及工作的过程\n\nJava Map使用多个映射案例\n\n推荐7款好用的终端工具 \n\n8张图 带你理解Java内存区域 \n\nJava八大基本数据类型详解\n\n如何学习Java多线程（超详细总结）\n\nJavaWeb中文编码问题\n\nJava内存模型及GC原理(Java内存分配、GC基本原理)\n\n\n","categories":["Java"],"tags":["web"]},{"title":"深入理解Java中的List、Set与Map集合","url":"https://tanqingbo.cn/java-Set-Map/","content":"List、Set与Map\nList 、Set、 Map有什么区别和联系\nlist 和set 有共同的父类 它们的用法也是一样的 唯一的不太就是set中不能有相同的元素 list中可以\nlist和set的用途非常广泛 list可以完全代替数组来使用\nmap 是独立的合集 它使用键值对的方式来储存数据 键不能有重复的 值可以用 \nmap不像上边两种集合那个用的广泛 不过在servlet 和jsp中 map可是绝对的重中之重 页面之间传值全靠map\n\n\n\n\nList 、Set、 Map都有哪些子类\n      Collection\n      ├List\n      │├LinkedList\n      │├ArrayList\n      │└Vector\n      │　└Stack\n      └Set\n       |-HashSet\n       └TreeSet        \n      Map\n      ├Hashtable\n      ├HashMap\n      └WeakHashMap\n\n注意：Map没有继承Collection接口，Map提供key到value的映射。\n\n\nList\nLinkedList类\nLinkedList实现了List接口，允许null元素。此外LinkedList提供额外的get，remove，insert方法在 LinkedList的首部或尾部。这些操作使LinkedList可被用作堆栈（stack），队列（queue）或双向队列（deque）。\n注意LinkedList没有同步方法。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List：　　    　        \n\n\n\n\t　List list = Collections.synchronizedList(new LinkedList(...));\n\n\n​    特点：寻址困难，插入和删除容易。\n\nArrayList类\n\nArrayList实现了可变大小的数组。它允许所有元素，包括null。ArrayList没有同步。\nsize，isEmpty，get，set方法运行时间为常数。但是add方法开销为分摊的常数，添加n个元素需要O(n)的时间。其他的方法运行时间为线性。\n每个ArrayList实例都有一个容量（Capacity），即用于存储元素的数组的大小。这个容量可随着不断添加新元素而自动增加，但是增长算法并 没有定义。当需要插入大量元素时，在插入前可以调用ensureCapacity方法来增加ArrayList的容量以提高插入效率。\n和LinkedList一样，ArrayList也是非同步的（unsynchronized）。\n特点是：寻址容易，插入和删除困难；\n\n\nVector类\n\nVector非常类似ArrayList，但是Vector是同步的。由Vector创建的Iterator，虽然和ArrayList创建的 Iterator是同一接口，但是，因为Vector是同步的，当一个Iterator被创建而且正在被使用，另一个线程改变了Vector的状态（例 如，添加或删除了一些元素），这时调用Iterator的方法时将抛出ConcurrentModificationException，因此必须捕获该 异常。\n\n\nStack 类\n\nStack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得 Vector得以被当作堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。\n\n\n\nSet\nHashSet类\n\n它不允许出现重复元素；\n不保证集合中元素的顺序\n允许包含值为null的元素，但最多只能有一个null元素。\nHashSet的实现是不同步的。\n\n\nTreeSet类\n\nreeSet类实现 Set 接口，该接口由 TreeMap 实例支持。此类保证排序后的 set 按照升序排列元素，根据使用的构造方法不同，可能会按照元素的自然顺序 进行排序，或按照在创建 set 时所提供的比较器进行排序。\n\nTreeSet描述的是Set的一种变体——可以实现排序等功能的集合，它在讲对象元素添加到集合中时会自动按照某种比较规则将其插入到有序的对象序列中.\n\n\nHashSet是基于Hash算法实现的,其性能通常优于TreeSet,我们通常都应该使用HashSet,在我们需要排序的功能时,我门才使用TreeSet;\n\n\n\n\nMap接口\nHashtable类\n\nHashtable继承Map接口，实现一个key-value映射的哈希表。任何非空（non-null）的对象都可作为key或者value。　　添加数据使用put(key, value)，取出数据使用get(key)，这两个基本操作的时间开销为常数。\n\nHashtable 通过initial capacity和load factor两个参数调整性能。通常缺省的load factor 0.75较好地实现了时间和空间的均衡。增大load factor可以节省空间但相应的查找时间将增大，这会影响像get和put这样的操作。\n\n作为key的对象将通过计算其散列函数来确定与之对应的value的位置，因此任何作为key的对象都必须实现hashCode和equals方法。\n\n　Hashtable是同步的。\n\n\n\nHashMap类\n\nHashMap和Hashtable类似，不同之处在于HashMap是非同步的，并且允许null，即null value和null key。其迭代子操作时间开销和HashMap 的容量成比例,因此，不要将HashMap的初始化容量设得过高，或者load factor过低。\n\n\nWeakHashMap类\n\nWeakHashMap是一种改进的HashMap，它对key实行“弱引用”，如果一个key不再被外部所引用，那么该key可以被GC回收。\n\nhashmap遍历的两种方式\n\nHashMap的遍历有两种常用的方法，那就是使用keyset及entryset来进行遍历\n\n方法一：\nMap map = new HashMap();\t　　Iterator iter = map.entrySet().iterator();\t　　while (iter.hasNext()) {\t　　Map.Entry entry = (Map.Entry) iter.next();\t　　Object key = entry.getKey();\t　　Object val = entry.getValue();\t　　}\n\n\n\n\n\n\n\n+ 效率高,以后尽量要使用此种方式！\n\n+ 方法二：\n\n           Map map = new HashMap();\n    　　Iterator iter = map.keySet().iterator();\n        　　while (iter.hasNext()) {\n        　　Object key = iter.next();\n        　　Object val = map.get(key);\n        　　}\n\n+ 效率低,以后尽量少使用！\n\nHashMap的数据结构\n\nHashMap里面实现一个静态内部类Entry，其重要的属性有 key , value, next.数据\n\nvalue的值是元素的key的哈希值对数组长度取模得到。如下面第二幅图中，12%16=12,28%16=12,108%16=12,140%16=12。所以12、28、108以及140都存储在数组下标为12的位置。\n\n结构如图所示：\n\n\n\n\nHashMap的存取实现\n     // 存储时:\tint hash = key.hashCode(); // 这个hashCode方法这里不详述,只要理解每个key的hash是一个固定的int值\tint index = hash % Entry[].length;\tEntry[index] = value;    &lt;br/&gt;\t\t\t// 取值时:\tint hash = key.hashCode();int index = hash % Entry[].length;     \t\treturn Entry[index];\n\n​     \n\n解决hash冲突的办法\n\n开放定址法（线性探测再散列，二次探测再散列，伪随机探测再散列）再哈希法链地址法建立一个公共溢出区Java中hashmap的解决办法就是采用的链地址法。\n\n\n再散列rehash过程\n\n当哈希表的容量超过默认容量时，必须调整table的大小。当容量已经达到最大可能值时，那么该方法就将容量调整到Integer.MAX_VALUE返回，这时，需要创建一张新表，将原表的映射到新表中。\n\n  码字不易，求分享、转发。😄\n往期精彩文章\nJava必读电子书_文档教程_高清PDF下载\n\n由浅入深，解析Java Servlet开发以及工作的过程\n\nJava Map使用多个映射案例\n\n推荐7款好用的终端工具 \n\n8张图 带你理解Java内存区域 \n\nJava八大基本数据类型详解\n\n如何学习Java多线程（超详细总结）\n\nJavaWeb中文编码问题\n\nJava内存模型及GC原理(Java内存分配、GC基本原理)\n\n\n\n\n","categories":["Java"],"tags":["Java","数据结构"]},{"title":"由浅入深，解析Java Servlet开发以及工作的过程","url":"https://tanqingbo.cn/Java-Servlet/","content":"Servlet简介\nServlet是sun公司提供的一门用于开发动态web资源的技术。\n\nSun公司在其API中提供了一个servlet接口，用户若想用发一个动态web资源(即开发一个Java程序向浏览器输出数据)，需要完成以下2个步骤：\n\n编写一个Java类，实现servlet接口。\n把开发好的Java类部署到web服务器中。\n\n\n\nServlet的运行过程\nServlet程序是由WEB服务器调用，web服务器收到客户端的Servlet访问请求后：\n①Web服务器首先检查是否已经装载并创建了该Servlet的实例对象。如果是，则直接执行第④步，否则，执行第②步。\n②装载并创建该Servlet的一个实例对象。 \n③调用Servlet实例对象的init()方法。\n④创建一个用于封装HTTP请求消息的HttpServletRequest对象和一个代表HTTP响应消息的HttpServletResponse对象，然后调用Servlet的service()方法并将请求和响应对象作为参数传递进去。\n⑤WEB应用程序被停止或重新启动之前，Servlet引擎将卸载Servlet，并在卸载之前调用Servlet的destroy()方法。 \n\n\n\nServlet接口实现类\nServlet接口SUN公司定义了两个默认实现类，分别为：GenericServlet、HttpServlet。\n\nHttpServlet指能够处理HTTP请求的servlet，它在原有Servlet接口上添加了一些与HTTP协议处理方法，它比Servlet接口的功能更为强大。因此开发人员在编写Servlet时，通常应继承这个类，而避免直接去实现Servlet接口。\n\nHttpServlet在实现Servlet接口时，覆写了service方法，该方法体内的代码会自动判断用户的请求方式，如为GET请求，则调用HttpServlet的doGet方法，如为Post请求，则调用doPost方法。因此，开发人员在编写Servlet时，通常只需要覆写doGet或doPost方法，而不要去覆写service方法。\n通过Eclipse创建和编写Servlet\n在编写Servlet类的时候要继承javax.servlet.http.HttpServlet类。\n\neclipse自动生成代码如下：\n       1 package gacl.servlet.study;\n       2 \n       3 import java.io.IOException;\n       4 import java.io.PrintWriter;\n       5 \n       6 import javax.servlet.ServletException;\n       7 import javax.servlet.http.HttpServlet;\n       8 import javax.servlet.http.HttpServletRequest;\n       9 import javax.servlet.http.HttpServletResponse;\n      10 \n      11 public class ServletDemo1 extends HttpServlet {\n      12 \n      13     /**\n      14      * The doGet method of the servlet. &lt;br&gt;\n      15      *\n      16      * This method is called when a form has its tag value method equals to get.\n      17      * \n      18      * @param request the request send by the client to the server\n      19      * @param response the response send by the server to the client\n      20      * @throws ServletException if an error occurred\n      21      * @throws IOException if an error occurred\n      22      */\n      23     public void doGet(HttpServletRequest request, HttpServletResponse response)\n      24             throws ServletException, IOException {\n      25 \n      26         response.setContentType(\"text/html\");\n      27         PrintWriter out = response.getWriter();\n      28         out.println(\"&lt;!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\"&gt;\");\n      29         out.println(\"&lt;HTML&gt;\");\n      30         out.println(\"  &lt;HEAD&gt;&lt;TITLE&gt;A Servlet&lt;/TITLE&gt;&lt;/HEAD&gt;\");\n      31         out.println(\"  &lt;BODY&gt;\");\n      32         out.print(\"    This is \");\n      33         out.print(this.getClass());\n      34         out.println(\", using the GET method\");\n      35         out.println(\"  &lt;/BODY&gt;\");\n      36         out.println(\"&lt;/HTML&gt;\");\n      37         out.flush();\n      38         out.close();\n      39     }\n      40 \n      41     /**\n      42      * The doPost method of the servlet. &lt;br&gt;\n      43      *\n      44      * This method is called when a form has its tag value method equals to post.\n      45      * \n      46      * @param request the request send by the client to the server\n      47      * @param response the response send by the server to the client\n      48      * @throws ServletException if an error occurred\n      49      * @throws IOException if an error occurred\n      50      */\n      51     public void doPost(HttpServletRequest request, HttpServletResponse response)\n      52             throws ServletException, IOException {\n      53 \n      54         response.setContentType(\"text/html\");\n      55         PrintWriter out = response.getWriter();\n      56         out.println(\"&lt;!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\"&gt;\");\n      57         out.println(\"&lt;HTML&gt;\");\n      58         out.println(\"  &lt;HEAD&gt;&lt;TITLE&gt;A Servlet&lt;/TITLE&gt;&lt;/HEAD&gt;\");\n      59         out.println(\"  &lt;BODY&gt;\");\n      60         out.print(\"    This is \");\n      61         out.print(this.getClass());\n      62         out.println(\", using the POST method\");\n      63         out.println(\"  &lt;/BODY&gt;\");\n      64         out.println(\"&lt;/HTML&gt;\");\n      65         out.flush();\n      66         out.close();\n      67     }\n      68 \n      69 }\n\n如果是post请求的话则编写dopost函数，是get请求的话就编写doget函数。但此时web服务器还不能调用该servlet类，还需在web.xml文件中配置。 \n\n然后我们就可以通过浏览器访问ServletDemo1这个Servlet。\n\n8张图 带你理解Java内存区域 |  IT码农 (tanqingbo.cn)\n\n\nServlet开发注意细节\nServlet访问URL映射配置\n\n由于客户端是通过URL地址访问web服务器中的资源，所以Servlet程序若想被外界访问，必须把servlet程序映射到一个URL地址上，这个工作在web.xml文件中使用&lt;servlet&gt;元素和&lt;servlet-mapping&gt;元素完成。\n\n&lt;servlet&gt;元素用于注册Servlet，它包含有两个主要的子元素：&lt;servlet-name&gt;和&lt;servlet-class&gt;，分别用于设置Servlet的注册名称和Servlet的完整类名。 \n\n一个&lt;servlet-mapping&gt;元素用于映射一个已注册的Servlet的一个对外访问路径，它包含有两个子元素：&lt;servlet-name&gt;和&lt;url-pattern&gt;，分别用于指定Servlet的注册名称和Servlet的对外访问路径。\n\n同一个Servlet可以被映射到多个URL上，即多个&lt;servlet-mapping&gt;元素的&lt;servlet-name&gt;子元素的设置值可以是同一个Servlet的注册名。 \n\nServlet访问URL使用*通配符映射　\n\n在Servlet映射到的URL中也可以使用通配符，但是只能有两种固定的格式：一种格式是”.扩展名”，另一种格式是以正斜杠（/）开头并以”/*”结尾。例如：\n       &lt;servlet&gt;\n       &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt;\n       &lt;servlet-class&gt;gacl.servlet.study.ServletDemo1&lt;/servlet-class&gt;\n     &lt;/servlet&gt;\n      &lt;servlet-mapping&gt;\n      &lt;servlet-name&gt;ServletDemo1&lt;/servlet-name&gt;\n      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n\n可以匹配任意的字符，所以此时可以用任意的URL去访问ServletDemo1这个Servlet.例如：\n     http://localhost:8080/工程名/nvlkfmndlmd\n\n\n对于如下的一些映射关系：　　Servlet1 映射到 /abc/*　　Servlet2 映射到 /*　　Servlet3 映射到 /abc　　Servlet4 映射到 .do问题：　　当请求URL为“/abc/a.html”，“/abc/*”和“/*”都匹配，哪个servlet响应    　　Servlet引擎将调用Servlet1。　　当请求URL为“/abc”时，“/abc/*”和“/abc”都匹配，哪个servlet响应    　　Servlet引擎将调用Servlet3。　　当请求URL为“/abc/a.do”时，“/abc/*”和“.do”都匹配，哪个servlet响应    　　Servlet引擎将调用Servlet1。　　当请求URL为“/a.do”时，“/”和“.do”都匹配，哪个servlet响应    　　Servlet引擎将调用Servlet2。　　当请求URL为“/xxx/yyy/a.do”时，“/”和“.do”都匹配，哪个servlet响应    　　Servlet引擎将调用Servlet2。　　匹配的原则就是”谁长得更像就找谁”\n\nServlet与普通Java类的区别　\n\nServlet是一个供其他Java程序（Servlet引擎）调用的Java类，它不能独立运行，它的运行完全由Servlet引擎来控制和调度。　　针对客户端的多次Servlet请求，通常情况下，服务器只会创建一个Servlet实例对象，也就是说Servlet实例对象一旦创建，它就会驻留在内存中，为后续的其它请求服务，直至web容器退出，servlet实例对象才会销毁。　　在Servlet的整个生命周期内，Servlet的init方法只被调用一次。而对一个Servlet的每次访问请求都导致Servlet引擎调用一次servlet的service方法。对于每次访问请求，Servlet引擎都会创建一个新的HttpServletRequest请求对象和一个新的HttpServletResponse响应对象，然后将这两个对象作为参数传递给它调用的Servlet的service()方法，service方法再根据请求方式分别调用doXXX方法。　　如果在元素中配置了一个元素，那么WEB应用程序在启动时，就会装载并创建Servlet的实例对象、以及调用Servlet实例对象的init()方法。\n\n\n举例：\n  &lt;servlet&gt;\n      &lt;servlet-name&gt;invoker&lt;/servlet-name&gt;\n      &lt;servlet-class&gt;\n          org.apache.catalina.servlets.InvokerServlet\n      &lt;/servlet-class&gt;\n      &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;\n  &lt;/servlet&gt;\n\n用途：为web应用写一个InitServlet，这个servlet配置为启动时装载，为整个web应用创建必要的数据库表和数据。\n\n缺省Servlet\n\n如果某个Servlet的映射路径仅仅为一个正斜杠（/），那么这个Servlet就成为当前Web应用程序的缺省Servlet。 \n\n\n\n\n凡是在web.xml文件中找不到匹配的元素的URL，它们的访问请求都将交给缺省Servlet处理，也就是说，缺省Servlet用于处理所有其他Servlet都不处理的访问请求。例如：\n &lt;!-- 将ServletDemo2配置成缺省Servlet --&gt;\t 8   &lt;servlet-mapping&gt;\t 9     &lt;servlet-name&gt;ServletDemo2&lt;/servlet-name&gt;\t10     &lt;url-pattern&gt;/&lt;/url-pattern&gt;\t11   &lt;/servlet-mapping&gt;\n\n\n    3.当访问不存在的Servlet时，就使用配置的默认缺省的Servlet进行处理\n\n在&lt;tomcat的安装目录&gt;\\conf\\web.xml文件中，注册了一个名称为org.apache.catalina.servlets.DefaultServlet的Servlet，并将这个Servlet设置为了缺省Servlet。\n\n当访问Tomcat服务器中的某个静态HTML文件和图片时，实际上是在访问这个缺省Servlet。\n\n\n\nServlet的线程安全问题\n\n当多个客户端并发访问同一个Servlet时，web服务器会为每一个客户端的访问请求创建一个线程，并在这个线程上调用Servlet的service方法，因此service方法内如果访问了同一个资源的话，就有可能引发线程安全问题。\n\n线程安全的例子：\n public void doGet(HttpServletRequest request,          HttpServletResponse response)            throws ServletException, IOException {        /**       * 当多线程并发访问这个方法里面的代码时，会存在线程安全问题吗？       * i变量被多个线程并发访问，但是没有线程安全问题，因为i是doGet方法里面的局部变量，       * 当有多个线程并发访问doGet方法时，每一个线程里面都有自己的i变量，       * 各个线程操作的都是自己的i变量，所以不存在线程安全问题       * 多线程并发访问某一个方法的时候，如果在方法内部定义了一些资源(变量，集合等)                * 那么每一个线程都有这些东西，所以就不存在线程安全问题了     */     int i=1;     i++; response.getWriter().write(i);  \t}  public void doPost(HttpServletRequest request, HttpServletResponse response)          throws ServletException, IOException {      doGet(request, response);  }\n\n\n\n\n\n把i定义成全局变量，当多个线程并发访问变量i时，就会存在线程安全问题了。\n\n线程安全问题只存在多个线程并发操作同一个资源的情况下，所以在编写Servlet的时候，如果并发访问某一个资源(变量，集合等)，就会存在线程安全问题。那么该如何解决这个问题呢？先看下面的代码：\n public class ServletDemo3 extends HttpServlet {  int i=1;  public void doGet(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException {     /**      * 加了synchronized后，并发访问i时就不存在线程安全问题了，      * 为什么加了synchronized后就没有线程安全问题了呢？      * 假如现在有一个线程访问Servlet对象，那么它就先拿到了Servlet对象的那把锁      * 等到它执行完之后才会把锁还给Servlet对象，由于是它先拿到了Servlet对象的那把锁，      * 所以当有别的线程来访问这个Servlet对象时，由于锁已经被之前的线程拿走了，后面的线程只能排队等候了      *       */     synchronized (this) {//在java中，每一个对象都有一把锁，这里的this指的就是Servlet对象         i++;         try {             Thread.sleep(1000*4);         } catch (InterruptedException e) {             e.printStackTrace();         }         response.getWriter().write(i+\"\");     }    }\n\n\n\n\n\n5.现在这种做法是给Servlet对象加了一把锁，保证任何时候都只有一个线程在访问该Servlet对象里面的资源，这样就不存在线程安全问题了.\n这种做法虽然解决了线程安全问题，但是编写Servlet却万万不能用这种方式处理线程安全问题，假如有9999个人同时访问这个Servlet，那么这9999个人必须按先后顺序排队轮流访问。\n8张图 带你理解Java内存区域 |  IT码农 (tanqingbo.cn)\n　　针对Servlet的线程安全问题，Sun公司是提供有解决方案的：让Servlet去实现一个SingleThreadModel接口，如果某个Servlet实现了SingleThreadModel接口，那么Servlet引擎将以单线程模式来调用其service方法。　　查看Sevlet的API可以看到，SingleThreadModel接口中没有定义任何方法和常量，在Java中，把没有定义任何方法和常量的接口称之为标记接口，经常看到的一个最典型的标记接口就是”Serializable”，这个接口也是没有定义任何方法和常量的，标记接口在Java中有什么用呢？主要作用就是给某个对象打上一个标志，告诉JVM，这个对象可以做什么，比如实现了”Serializable“接口的类的对象就可以被序列化，还有一个”Cloneable“接口，这个也是一个标记接口，在默认情况下，Java中的对象是不允许被克隆的，就像现实生活中的人一样，不允许克隆，但是只要实现了”Cloneable”接口，那么对象就可以被克隆了。\n　　让Servlet实现了SingleThreadModel接口，只要在Servlet类的定义中增加实现SingleThreadModel接口的声明即可。 **　**　对于实现了SingleThreadModel接口的Servlet，Servlet引擎仍然支持对该Servlet的多线程并发访问，其采用的方式是产生多个Servlet实例对象，并发的每个线程分别调用一个独立的Servlet实例对象。　　实现SingleThreadModel接口并不能真正解决Servlet的线程安全问题，因为Servlet引擎会创建多个Servlet实例对象，而真正意义上解决多线程安全问题是指一个Servlet实例对象被多个线程同时调用的问题。事实上，在Servlet API 2.4中，已经将SingleThreadModel标 记为Deprecated（过时的）。  \n\n一般来说，servlet是单例的，同一个实例可以同时有多个用户访问，这个没有任何问题。问题在于servlet是否有状态，对这些状态的访问是否必须是synchronized的。如果是，那么在同一个时间就只有一个用户可以访问这些状态了，这就大大降低了性能。所以一般来说servlet都是无状态的。\n\n码字不易，求分享、转发。😄\n往期精彩文章\nJava必读电子书_文档教程_高清PDF下载\n\nJava Map使用多个映射案例\n\n推荐7款好用的终端工具 \n\n8张图 带你理解Java内存区域 \n\nJava八大基本数据类型详解\n\n如何学习Java多线程（超详细总结）\n\nJavaWeb中文编码问题\n\nJava内存模型及GC原理(Java内存分配、GC基本原理)\n\nJava面试题–基础知识汇总\n\n\n","categories":["Java"],"tags":["Java","Servlet"]},{"title":"Java Map使用多个映射案例","url":"https://tanqingbo.cn/Map-uses-multiple-maps/","content":"上一篇给大家推荐了《推荐7款好用的终端工具 》,本篇给大家分享一个Java Map使用多个映射案例。\n问题描述\n许多单词和另外一些单词相似，例如，通过改变第一个字母，单词wine可以变成，dine fine line mine nine pine vine 改变第3个字母，wide wife wipe wire…….\n\n他们仅仅通过改变一个字母，可以得到很多个单词，假设有一个词典，89000个单词，将单词长度相同，且只有一个字母不同的单词放到一组。\n思路\n使用一个MAP对象，其中key是单词，value是用一个字母替换能从key变换得到的一系列单词。\n\n主要问题是如何从包含89000个单词的数组中构造MAP对象。\n方法一：暴力解决\n先判断除一个字母不同外，两个单词是否相等。代码如下：\n private static Boolean oneCharOff(String word1,String word2){\t\tif(word1.length()!=word2.length()) return false;\t\tint diffs = 0;\t\tfor(int i=0;i&lt;word1.length();i++){\t\t\tif(word1.charAt(i)!=word2.charAt(i))\t\t\t\tif(++diffs&gt;1)\t\t\t\t\treturn false;\t\t}\t\treturn true;\t}\n\n\n\n\n\n\n计算一个MAP对象，该对象以一些单词作为关键字而以只在一个字母处不同的一列单词作为关键字的值，该函数对一个89000单词的词典运行96秒。\n      public static Map&lt;String, List&lt;String&gt;&gt; computeAdjacentWord(List&lt;String&gt; theWords){\t\t\t//单词映射，单词作为关键字，而只有一个单词和该单词不同的一系列单词作为值。\t\t\tMap&lt;String, List&lt;String&gt;&gt; adjWords = new TreeMap&lt;String, List&lt;String&gt;&gt;();\t\t\tString[] words = new String[theWords.size()];\t\t\ttheWords.toArray(words);\t\t\tfor(int i=0;i&lt;words.length;i++){\t\t\t\tfor(int j = i+1;j&lt;words.length;j++){\t\t\t\t\tif(oneCharOff(words[i], words[j])){\t\t\t\t\t\tupdate(adjWords,words[i], words[j]);\t\t\t\t\t\tupdate(adjWords,words[j], words[i]);\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\treturn adjWords;\t\t}\t\n\n\n    private static &lt;KeyType&gt; void update(Map&lt;KeyType, List&lt;String&gt;&gt; adjWords, KeyType string, String string2) {\n            List&lt;String&gt; lst = adjWords.get(string);\n            if(lst == null){\n                lst = new ArrayList&lt;String&gt;();\n                adjWords.put(string, lst);\n            }\n            lst.add(string2);\n        }\n\n该算法的问题在于速度慢，一个明显的改进就是避免比较不同长度的单词。可以把单词按照长度分组，然后对各分组进行上述程序。\n方法二：避免比较单词长度\n可以把单词按照长度分组，然后对各分组进行上述程序。为此可以使用第二个映射，此时关键字是整数，代表单词长度，而值是该长度对应的单词集合。\n  public static Map&lt;String, List&lt;String&gt;&gt; computeAdjacentWord(List&lt;String&gt; theWords){\t\tMap&lt;String, List&lt;String&gt;&gt; adjWords = new TreeMap&lt;String, List&lt;String&gt;&gt;();\t\tMap&lt;Integer, List&lt;String&gt;&gt; wordsByLength = new TreeMap&lt;Integer, List&lt;String&gt;&gt;();\t\tfor(String w:theWords){\t\t\t//根据长度对单词分组\t\t\tupdate(wordsByLength,w.length(),w);\t\t}\t\tfor(List&lt;String&gt; list:wordsByLength.values()){\n\n          String[] words = new String[list.size()];\n          list.toArray(words);\n          for(int i=0;i&lt;words.length;i++){\n              for(int j = i+1;j&lt;words.length;j++){\n                  if(oneCharOff(words[i], words[j])){\n                      update(adjWords,words[i], words[j]);\n                      update(adjWords,words[j], words[i]);\n                  }\n              }\n          }\n      }\n      return adjWords;\n  }\n\n引入第二个集合后，可以使words.length的值成倍减少，也就可以使双重循环的次数减少，从而缩短运行时间。\n\n与第一个方法比较，第二个方法只是在边际上编程困难，其运行时间为51秒，大约快了一倍。\n\n方法二中的update方法和oneCharOff方法参考方法一。\n\n\n方法三：\n另外有附加了一些映射，先和方法二一样，将单词按长度分组，然后分别对每组运算。\n\n假设对长度为4的单词操作，这是首先要找出像wine和nine这样的单词，他们除第一个外单词完全相同，对于这种单词，可以删除第一个字母，留下3个单词做代表，这样就形成一个Map，其中关键字为这个代表，而其值是所有包含同一代表的单词的一个List。\n\n每一个Map中的list对象都形成单词的一个集团，其中任何一个单词均可以通过单个字母替换变成另一个单词，因此在这个最后的Map构成之后，很容易遍历它以及添加一些项到正在计算的原始Map中。\n\n然后我们使用一个新的Map再处理4个字母单词组的第二个字母。此后第三个字母，最后是第四个字母。\n  public static Map&lt;String, List&lt;String&gt;&gt; computeAdjacentWord(List&lt;String&gt; theWords){\t\t\tMap&lt;String, List&lt;String&gt;&gt; adjWords = new TreeMap&lt;String, List&lt;String&gt;&gt;();\t\t\tMap&lt;Integer, List&lt;String&gt;&gt; wordsByLength = new TreeMap&lt;Integer, List&lt;String&gt;&gt;();\t\t\tfor(String w:theWords){\t\t\t\t//根据长度对单词分组\t\t\t\tupdate(wordsByLength,w.length(),w);\t\t\t}\t\t\t//每一组单词按去掉一个字母后是否相同再次分组映射\t\t\tfor(Map.Entry&lt;Integer, List&lt;String&gt;&gt; entry : wordsByLength.entrySet()){\t\t\t\tList&lt;String&gt; groupsWords = entry.getValue();\t\t\t\tint groupNum = entry.getKey();\t\t\t\t//从第一个字母开始，依次处理每个字母，映射到Map中。\t\t\t\tfor(int i=0;i&lt;groupNum;i++){\t\t\t\t\tMap&lt;String, List&lt;String&gt;&gt; repToWord = new TreeMap&lt;String, List&lt;String&gt;&gt;();\t\t\t\t\t//从第一个字母开始，依次处理每个字母，映射到Map中。\t\t\t\t\tfor(String str:groupsWords){\t\t\t\t\t\tString rep = str.substring(0,i) + str.substring(i+1);\t\t\t\t\t\tupdate(repToWord, rep, str);\t\t\t\t\t}\t\t\t\t\t//放到最终的Map映射中。\t\t\t\t\tfor(List&lt;String&gt; wordClique : repToWord.values()){\t\t\t\t\t\tif(wordClique.size()&gt;2)\t\t\t\t\t\t\tfor(String s1 : wordClique)\t\t\t\t\t\t\t\tfor(String s2 : wordClique)\t\t\t\t\t\t\t\t\tif(s1 != s2)\t\t\t\t\t\t\t\t\t\tupdate(adjWords, s1, s2);\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\treturn adjWords;\t\t}\n\n  private static &lt;KeyType&gt; void update(Map&lt;KeyType, List&lt;String&gt;&gt; adjWords, KeyType string, String string2) {\n          List&lt;String&gt; lst = adjWords.get(string);\n          if(lst == null){\n              lst = new ArrayList&lt;String&gt;();\n              adjWords.put(string, lst);\n          }\n          lst.add(string2);\n      }\n\n该算法对89000个单词处理改进到了4秒，大大提升了效率。\n\n\n往期精彩文章\nJava必读电子书_文档教程_高清PDF下载\n\n推荐7款好用的终端工具 \n\n8张图 带你理解Java内存区域 \n\nJava八大基本数据类型详解\n\n如何学习Java多线程（超详细总结）\n\nJavaWeb中文编码问题\n\nJava内存模型及GC原理(Java内存分配、GC基本原理)\n\nJava面试题–基础知识汇总\n\nJava面试题–设计模式与继承多态\n\n\n","categories":["Java"],"tags":["数据结构","Map"]},{"title":"推荐7款好用的终端工具","url":"https://tanqingbo.cn/7-terminal-tools/","content":"上一篇分享了《8张图 带你理解Java内存区域 》,本篇给大家推荐7款好用的终端工具。\n1、Cmder下载地址：https://cmder.net/\nCmder是一个代替cmd的终端工具。只能操作Windows。\n它的好处是：\n\n支持大部分Linux命令，比如ls\n鼠标选中默认复制，鼠标右击粘贴\n美观的界面，可以自定义背景\n\n解压，双击Cmder.exe即可运行，\n\n使用tips:1、添加快捷键\n打开cmd到安装目录，输入Cmder.exe /REGISTER ALL\n你会发现鼠标右击多了一个Cmder Here 的快捷方式\n\n2、乱码问题\n打开Cmder，左上角右击，setting—&gt; environment\n\n添加两行：\nset LANG=zh_CN.UTF-8chcp 65001\n\n2、SecureCRT 和 SecureFX\n下载地址：https://www.vandyke.com/download/securecrt/6.7/index.html\nSecureFX是一款文件传输工具，SecureCRT 是一款SSH工具，两个常配合一起使用。\n\n\nSecureCRT 的优点：\n\n支持选中自动复制，右击粘贴\n有多种界面风格可以选\n支持宏脚本，支持日志打印\n\n但是这款软件是收费的。\n3、Mobaxterm下载地址：https://mobaxterm.mobatek.net/download.html\n\nMobaXterm是分免费版本和收费版本的，但是免费版本已经很强大了，足够日常的使用了。\n分为两种安装模式：\n\n便携式，适合安装在U盘，双击即可运行，这样你的服务器账号密码什么的就很方便的管理了，出门在外只需要一个U盘就可以连接你的服务器了。\n安装式，普通安装。\n\n优点：\n\n同时支持SSH和SFTP，可视化操作文件，不需要再安装ftp工具（不像SecureCRT还要安装SecureFX才能传输文件）。\n彩色日志\n免费\n\n缺点是有时候会卡死。\n4、XShell、XFTP下载地址：https://www.netsarang.com/zh/xshell/\nXShell 是最知名终端模拟软件 ，Xshell可以在Windows界面下用来访问远端不同系统下的服务器，从而比较好的达到远程控制终端的目的。除此之外，其还有丰富的外观配色方案以及样式选择。\n但是这款软件是要收费的，但是有30天试用期。\nXShell操作\n\n因为Xshell只是ssh工具，使用XShell的同时，一般搭配XFTP使用，就像SecureCRT搭配SecureFX使用。\nXFTP下载地址：https://www.netsarang.com/zh/xftp/\nXFTP通过选项卡界面和同步浏览，Xftp完美地直观地可视化了您的文件目录。Xftp支持Windows上下文菜单，以便与第三方Windows实用程序无缝集成，并支持用户定义的编辑器，以便动态编辑。\n\n5、termius下载地址：https://www.termius.com/linux\ntermius是微软的一款SSH终端工具，它支持\n\nWindows\nLinux\nOSX\nAndroid\niOS\n\n几乎所有的平台。而且termius的操作界面十分好看且简洁。\n\n6、WinSCP、FileZillaWinSCP是一个Windows环境下使用SSH的开源图形化SFTP客户端。同时支持SCP协议。它的主要功能就是在本地与远程计算机间安全的复制文件。\nFileZilla 客户端是一个快速可靠的、跨平台的FTP,FTPS和SFTP客户端。具有图形用户界面(GUI)和很多有用的特性。\n这两者都是FTP工具，不支持SSH。\n\n\n7、PuTTY下载地址：https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html\nPuTTY是一个Telnet/SSH/rlogin/纯TCP以及串行阜连线软件。较早的版本仅支援Windows平台，在最近的版本中开始支援各类Unix平台。\nPuTTY看上去有一种古老的味道，免费，比Xshell还要简洁。\n\n码字不易，求分享、转发。😄\n往期精彩文章\nJava必读电子书_文档教程_高清PDF下载\n8张图 带你理解Java内存区域 \nJava八大基本数据类型详解\n如何学习Java多线程（超详细总结）\nJavaWeb中文编码问题\nJava内存模型及GC原理(Java内存分配、GC基本原理)\nJava面试题–基础知识汇总\nJava面试题–设计模式与继承多态\nJava面试题–重点总结\n\n","categories":["工具"],"tags":["工具","Linux","编程"]},{"title":"8张图 带你理解Java内存区域","url":"https://tanqingbo.cn/Java-memory-area/","content":"很多人会误以为Java内存区域和内存模型是同一个东西，其实并不是。\nJava内存区域是指 JVM运行时将数据分区域存储 ，简单的说就是不同的数据放在不同的地方。通常又叫 运行时数据区域。\nJava内存模型（JMM）定义了程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。\n1、Java内存区域1.8 之前：JDK1.8（含）之后：区别就是 1.8有一个元数据区替代方法区了。\nJDK 1.7 其实是并没完全移除方法区，但是不会像1.6以前报 “java.lang.OutOfMemoryError: PermGen space”，而是报 java.lang.OutOfMemoryError: Java heap space\n\n1.7部分内容（比如 常量池、静态变量有方法区转移到了堆）\n\n\n那么，Java 8 中 PermGen 为什么被移出 HotSpot JVM 了？我总结了两个主要原因：\n\n由于 PermGen 内存经常会溢出，引发恼人的 java.lang.OutOfMemoryError: PermGen，因此 JVM 的开发者希望这一块内存可以更灵活地被管理，不要再经常出现这样的 OOM\n移除 PermGen 可以促进 HotSpot JVM 与 JRockit VM 的融合，因为 JRockit 没有永久代。\n\n根据上面的各种原因，PermGen 最终被移除，方法区移至 Metaspace，字符串常量移至 Java Heap。\n\n引用自https://www.sczyh30.com/posts/Java/jvm-metaspace/\n\n下面逐一介绍一下jvm管辖的这几种内存区域。\n2、程序计数器程序计数器（Program Counter Register）是一块较小的内存空间，由于JVM可以并发执行线程，因此会存在线程之间的切换，而这个时候就程序计数器会记录下当前程序执行到的位置，以便在其他线程执行完毕后，恢复现场继续执行。\nJVM会为每个线程分配一个程序计数器，与线程的生命周期相同。\n如果线程正在执行的是应该Java方法，这个计数器记录的是正在执行虚拟机字节码指令的地址。\n如果正在执行的是Native方法，计数器的值则为空（undefined）\n程序计数器是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。\n3、Java虚拟机栈虚拟机栈 描述的是 Java 方法执行的内存模型：\n每个方法在执行的同时都会创建一个栈帧（Stack Frame，是方法运行时的基础数据结构）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。\n虚拟机栈是每个线程独有的，随着线程的创建而存在，线程结束而死亡。\n在虚拟机栈内存不够的时候会OutOfMemoryError，在线程运行中需要更大的虚拟机栈时会出现StackOverFlowError。\n\n虚拟机栈包含很多栈帧，每个方法执行的同时会创建一个栈帧，栈帧又存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。\n\n在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧，与这个栈帧相关联的方法称为当前方法。\n\n1）局部变量表局部变量表是存放方法参数和局部变量的区域。\n全局变量是放在堆的，有两次赋值的阶段，一次在类加载的准备阶段，赋予系统初始值；另外一次在类加载的初始化阶段，赋予代码定义的初始值。\n而局部变量没有赋初始值是不能使用的。\n2）操作数栈一个先入后出的栈。\n当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈操作。\n3） 动态连接每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。持有这个引用是为了支持方法调用过程中的动态连接(Dynamic Linking)。\n\n常量池可以便于指令的识别\n\npublic void methodA(){}public void methodB(){    methodA();//methodB()调用methodA(),先找到调用methodA()的版本符号，再变为直接引用}\n\n方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本(即调用哪一个方法)，这也是Java强大的扩展能力，在运行期间才能确定目标方法的直接引用。\n所有方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用。\n4）方法返回地址（方法出口）返回分为 正常返回 和 异常退出。\n无论何种退出情况，都将返回至方法当前被调用的位置，这也程序才能继续执行。\n一般来说，方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中会保存这个计数器值。\n方法退出的过程相当于弹出当前栈帧。\n4、本地方法栈Java虚拟机栈是调用Java方法；本地方法栈是调用本地native方法，可以认为是通过 JNI (Java Native Interface) 直接调用本地 C/C++ 库，不受JVM控制。\n\n\n本地方法栈也会抛出 StackOverflowError 和 OutOfMemoryError 异常\n5、Java堆Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。\n堆是垃圾收集器管理的主要区域，又称为“GC堆”，可以说是Java虚拟机管理的内存中最大的一块。\n现在的虚拟机（包括HotSpot VM）都是采用分代回收算法。在分代回收的思想中， 把堆分为：新生代+老年代+永久代（1.8没有了）；新生代 又分为 Eden + From Survivor + To Survivor区。\n\n6、方法区方法区（Method Area）与 Java 堆一样，是所有线程共享的内存区域。\n方法区用于存储已经被虚拟机加载的类信息（即加载类时需要加载的信息，包括版本、field、方法、接口等信息）、final常量、静态变量、编译器即时编译的代码等。\n方法区逻辑上属于堆的一部分，但是为了与堆进行区分，通常又叫“非堆”。\n方法区比较重要的一部分是运行时常量池（Runtime Constant Pool），为什么叫运行时常量池呢？是因为运行期间可能会把新的常量放入池中，比如说常见的String的intern()方法。\nString a = \"I am HaC\";Integer b = 100;\n\n在编译阶段就把所有的字符串文字放到一个常量池中，复用同一个（比如说上述的“I am HaC”），节省空间。\n关于方法区和元空间的关系：\n\n方法区是JVM规范概念，而永久代则是Hotspot虚拟机特有的概念，简单点理解：方法区和堆内存的永久代其实一个东西，但是方法区是包含了永久代。\n只有 HotSpot 才有 “PermGen space”，而对于其他类型的虚拟机，如 JRockit（Oracle）、J9（IBM） 并没有“PermGen space”\n\n7、元空间1.8就把方法区改用元空间了。类的元信息被存储在元空间中。元空间没有使用堆内存，而是与堆不相连的本地内存区域。所以，理论上系统可以使用的内存有多大，元空间就有多大，所以不会出现永久代存在时的内存溢出问题。\n可以通过 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize 来指定元空间的大小。\n8、总结：\n码字不易，求分享、转发。😄\n往期精彩文章\nJava必读电子书_文档教程_高清PDF下载\nJava八大基本数据类型详解\n如何学习Java多线程（超详细总结）\nJavaWeb中文编码问题\nJava内存模型及GC原理(Java内存分配、GC基本原理)\nJava面试题–基础知识汇总\nJava面试题–设计模式与继承多态\nJava面试题–重点总结\n\n","categories":["Java"],"tags":["Java","JVM","JMM"]},{"title":"Java八大基本数据类型详解","url":"https://tanqingbo.cn/Java-eight-data-types/","content":"1、介绍Java语言提供了8种基本数据类型。分别是 byte、short、int、long、float、double、boolean、char。\n\nString 是对象，不属于基本数据类型\n\n8种基本数据按类型分可以分为\n\n4个 整数型：byte、short、int、long\n2个浮点型：float、double\n1个字符类型：char\n1个布尔型：boolean\n\n\n\n基本数据类型 “==” 比较都是值。\nBoolean 《Java虚拟机规范》给出了4个字节,但还要看虚拟机实现是否按照规范来，所以1个字节、4个字节都是有可能的。\n\n2、拆箱和装箱问题\n拆箱和装箱装箱就是自动将基本数据类型转换为包装器类型；使用Integer.valueOf方法。拆箱就是自动将包装器类型转换为基本数据类型；使用Integer.intValue方法。\n\n\nInteger total = 99; //执行上面那句代码的时候，系统为我们执行了，即自动装箱Integer total = Integer.valueOf(99);int totalprim = total; //执行上面那句代码的时候，系统为我们执行了，即自动拆箱int totalprim = total.intValue();\n\n\n范围问题通过一个问题去引申，面试经常被问的：\n\n\nInteger i = 400; Integer j = 400; System.out.println(i==j);  //falseInteger o = 12; Integer k = 12;System.out.println(o==12);  //true\n\n上面提到，使用 Integer去创建数据，其实是一个Integer.valueOf 过程，Integer.valueOf 源码如下：\npublic static Integer valueOf(int i) {    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)        return IntegerCache.cache[i + (-IntegerCache.low)];    return new Integer(i);}\n\n如果值的范围在-128到127之间，它就从高速缓存返回实例。否则 new 一个Integer对象。new Integer 就是一个装箱的过程了，装箱的过程会创建对应的对象，这个会消耗内存，所以装箱的过程会增加内存的消耗，影响性能。所以说最后是i 和 j 两个对象比较，内存地址不一样，结果就是false了。\n\n==的值比较问题\n\nint a =200;Integer b = new Integer(200);Integer c = 200;System.out.println(a==b); //trueSystem.out.println(a==c); //trueSystem.out.println(b==c); //false\n\n这也是面试经常问到的，在代码中我们经常也会用到这种判断。\na==b，a==c，只要和基本数据类型（即 int）比较，Integer就会调用value.intValue()拆箱成基本数据类型，你也可以理解为：当有基本数据类型，只比较值\nb==c，这两个是永远不会相等的，拆箱装箱只是针对基本数据类型的比较才有，Integer并不是基本数据类型，b、c两者存放的内存地址不一样，所以不相等。\n总结：\n\n①、无论如何，Integer与new Integer不会相等。不会经历拆箱过程，因为它们存放内存的位置不一样。\n②、两个都是非new出来的Integer，如果数在-128到127之间，则是true,否则为false。\n③、两个都是new出来的，即两个new Integer比较，则为false。\n④、int与Integer、new Integer()进行==比较时，结果永远为true，因为会把Integer自动拆箱为int，其实就是相当于两个int类型比较。\n\n3、int 和 Integer\nInteger 继承了Object类，是对象类型，有自己的属性和方法，是 int 的包装类。int是java基本数据类型。\nInteger默认值null，int默认值 0。\nint 可以直接做运算，Integer 不能直接运算，拆箱转化为int才能进行运算。\n\n4、默认值问题Java中：\n\n整数的默认类型是 int。\n浮点数默认类型是 double，否则需要 在后面加f、d\n\n\n浮点数如果不加f，默认就是double类型的，前面再用 float修饰，就会报错。可以使用两种方法解决：\n\n结尾加上 f\n使用(float) 强转\n\n5、Integer.parseInt()和Integer.valueOf()的区别parseInt() 和 valueOf() 都是Integer 对象的方法。入参都是一个String字符串。\n\nparseInt\n\npublic static int parseInt(String s) throws NumberFormatException\n\n将字符串参数作为带符号十进制整数来转换。如果无法转换，抛出 NumberFormatException。\n\nvalueOf\n\npublic static Integer valueOf(String s) throws NumberFormatException\n\n返回初始化为指定 String 值的新的 Integer 对象，如果无法转换，抛出 NumberFormatException。\nString str = \"-12\";int  num = Integer.parseInt(str);System.out.println(num); // -12Integer  num2 = Integer.valueOf(str);System.out.println(num2); // -12int num3 =Integer.parseInt(\"HaC\"); //java.lang.NumberFormatException\n\nint 与 Integer转换：\nint a=A.intValue();Integer A=Integer.valueOf(a);\n\n\nInteger派别：Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的。Double派别：Double、Float的valueOf方法的实现是类似的。每次都返回不同的对象。\n\n6、精度丢失问题byte a = 5;int b =2;float c  = 6f;double d =0.03;double d2 =300.03;System.out.println(a/b); // 2  a会转化为int 类型System.out.println(b/c); // 0.33333334 b会转化为float类型System.out.println(a+d+d2); // 301.05999999999995 a会转化为double类型,但是结果理应是  301.06\n\n不同类型的数据在运算的时候，会向高精度的数据类型转换。\n\n其实double类型数值的计算经常会出现这种精度丢失的问题，尤其是有小数点的情况下，常常会因为精度丢失而导致程序出错。因为计算机是通过二进制进行运算的，而计算机在表示小数的二进制是会有精度问题的。\n所以我们在运算高精度的数据的时候，可以使用 java.math.BigDecimal 类\n7、字符串与整数拼接问题String a = \"1\";int b = 1;int c = 2;System.out.println(a + b + c); //112System.out.println(b + c + a); //31\n\na + b + c 从左到右按顺序运算，a+b 的结果是 12 ，是一个String，然后再拼接 c，最后是 String\nb + c + a 从左到右按顺序运算，b + c 的结果是 3，是一个int ，然后拼接a，变成 String。\n8、留几个问题瞅瞅1） 设有下面两个赋值语句：a = Integer.parseInt(\"1024\");b = Integer.valueOf(\"1024\").intValue();\n\n下述说法正确的是（）\nA   a是整数类型变量，b是整数类对象。B   a是整数类对象，b是整数类型变量。C   a和b都是整数类对象并且它们的值相等。D   a和b都是整数类型变量并且它们的值相等。\n答案是 D，intValue()是把Integer对象类型变成int的基础数据类型；\n2）表达式(short)10/10.2*2运算后结果是什么类型？A   shortB   intC   doubleD   float\n答案是 C，Java中，你如果 没有在数字后面声明，浮点数默认为double。\n\n要注意是(short)10/10.2*2，而不是(short) (10/10.2 *2)，前者只是把10强转为short，又由于式子中存在浮点数，所以会对结果值进行一个自动类型的提升，浮点数默认为double，所以答案是double；后者是把计算完之后值强转short。\n\n\n以上就是Java基本数据类型的基本介绍，重温一下，避免踩坑。\n码字不易，求分享、转发。😄\n往期精彩文章\nJava必读电子书_文档教程_高清PDF下载\n如何学习Java多线程（超详细总结）\nJavaWeb中文编码问题\nJava内存模型及GC原理(Java内存分配、GC基本原理)\nJava面试题–基础知识汇总\nJava面试题–设计模式与继承多态\nJava面试题–重点总结\n\n","categories":["Java"],"tags":["Java","数据类型"]},{"title":"计算机经典书籍","url":"https://tanqingbo.cn/Computer-Classic-Books/","content":"上一篇分享了《如何学习Java多线程（超详细总结）》,本篇文章给大家推荐几本计算机领域经典的书籍，文末带下载链接。\n深入理解计算机系统 豆瓣评分：9.7分本书的最大优点是为程序员描述计算机系统的实现细节，帮助其在大脑中构造一个层次型的计算机系统，从最底层的数据在内存中的表示到流水线指令的构成，到虚拟存储器，到编译系统，到动态加载库，到最后的用户态应用。 \n\n\n现代操作系统 豆瓣评分：8.9分本书适合作为高等院校计算机专业操作系统课程教材，也是设计、开发操作系统的重要参考书。 \n\n\n计算机程序的构造和解释  豆瓣评分：9.5分 美国麻省理工学院(MIT)多年使用的教材。\n\n\n计算机网络（第4版） : 自顶向下方法 豆瓣评分：8.8分本书采用了独创的自顶向下方法，即从应用层开始沿协议栈向下讲解计算机网络的基本原理，强调应用层范例和应用编程接口，内容深入浅出，注重教学方法，理论与实践相结合。 \n\n\n数据库系统概念 : 第五版 豆瓣评分：8.2分本书是数据库系统方面的经典教材之一。国际上许多著名大学包括斯坦福大学、耶鲁大学、得克萨斯大学、康奈尔大学、伊利诺伊大学、印度理工学院等都采用本书作为教科书。 \n\n\n设计模式 : 可复用面向对象软件的基础 豆瓣评分：9.1分设计模式有多重要，等你工作的时候就明白了。 这本书结合设计实作例从面向对象的设计中精选出23个设计模式，总结了面向对象设计中最有价值的经验，并且用简洁可复用的形式表达出来。 \n\n\n以上推荐的书籍都堪称计算机领域圣经级别的书，豆瓣评分均接近9分，需要电子版的同学可以戳下面地址下载：\n链接：https://pan.baidu.com/s/14A2e2jCCJpXldcAN_ViX5w提取码：fa9r \n其他电子书下载\nJava电子书_文档教程_高清PDF下载\nPython电子书_文档教程_高清PDF下载\nC/C++电子书_文档教程_高清PDF下载\nLinux电子书_Linux书籍_高清PDF下载\n数据结构与算法相关书籍_PDF电子版下载\n计算机基础_操作系统_汇编语言_计算机网络-电子书PDF下载\n机器学习，人工智能经典必读电子书（PDF）下载\n设计模式经典图书电子书下载\nMYSQL、MongoDB数据库经典电子书下载\nGo语言经典电子书pdf下载\n程序员面试相关经典书籍免费下载\n\n","categories":["编程资料"],"tags":["操作系统"]},{"title":"eclipse使用lombok","url":"https://tanqingbo.cn/eclipse-lombok/","content":"上一篇分享了《如何学习Java多线程（超详细总结）》,本篇文章介绍eclipse如何使用lombok。\n安装lombok\n下载lombok http://projectlombok.org/download.html,下载下来的是一个lombok.jar包。放到eclipse的文件夹下。\n\n\n双击lombok.jar进行安装。\n\n如果程序还在报错，那么点击在eclipse的Project选项的clean.\nlombok使用\nLombok的特色是根据annotation创建一些代码，以减少重复代码的数量，它提供了以下几个annotation：\n     @Getter和@Setter：为属性创建getter和setter\n     @EqualsAndHashCode：实现equals()方法和hashCode()方法\n     @ToString：实现toString()方法\n     @Data：上述3个annotation的和，会创建getter setter equals hashCode和toString （最实用）\n     @Cleanup：关闭流\n     @Synchronized：对象同步\n     @SneakyThrows：抛出异常\n     @Log4j: log4j日志声明\n\n\n实例import lombok.Data;\nimport lombok.ToString;\n\n@ToString(exclude=\"color\") \npublic @Data class Person { \n          private String name; \n          private int size; \n          private String color; \n          private String style; \n          private boolean flag;\n\n          public static void main(String[] args) {\n               Person p = new Person();\n            p.setName(\"aa\");\n            System.out.println(p.getName());\n        }\n\n}\n\n@Data是实现所有的成员的Get和Set方法\n\n@ToString(exclude=”color”) 是ToString时候排除color成员变量\n\n注意调用flag成员变量时候，是isFlag方法\n\n注解加载类上，对所有的属性都有效，加在单一属性上只对该属性有效。\n\n\n码字不易，求分享、转发。😄\n推荐阅读\n计算机专业电子书下载\nJava电子书_文档教程_高清PDF下载\nPython电子书_文档教程_高清PDF下载\nC/C++电子书_文档教程_高清PDF下载\nLinux电子书_Linux书籍_高清PDF下载\n数据结构与算法相关书籍_PDF电子版下载\n计算机基础_操作系统_汇编语言_计算机网络-电子书PDF下载\n\n","categories":["Java"],"tags":["lombok"]},{"title":"如何学习Java多线程（超详细总结）","url":"https://tanqingbo.cn/Java-multithreaded-learning/","content":"上一篇分享了《JavaWeb中文编码问题》,本篇文章中详细总结了Java多线程的一些问题。\n进程和线程的区别：\n进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1–n个线程。\n线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。\n线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。\n多进程是指操作系统能同时运行多个任务（程序）。\n多线程是指在同一程序中有多个顺序流在执行。\n\n\n在java中要想实现多线程，有两种手段，一种是继续Thread类，另外一种是实现Runable接口。\n\n扩展java.lang.Thread类class Thread1 extends Thread{\t\t\t\t\tprivate String name;\t\t\t\t    public Thread1(String name) {\t\t\t\t       this.name=name;\t\t\t\t    }\t\t\t\t\tpublic void run() {\t\t\t\t        for (int i = 0; i &lt; 5; i++) {\t\t\t\t            System.out.println(name + \"运行  :  \" + i);\t\t\t\t            try {\t\t\t\t                sleep((int) Math.random() * 10);\t\t\t\t            } catch (InterruptedException e) {\t\t\t\t                e.printStackTrace();\t\t\t\t            }\t\t\t\t        }\t\t\t\t       \t\t\t\t\t}\t\t\t\t}\t\t\t\tpublic class Main {\t\t\t\t\t\t\t\t\tpublic static void main(String[] args) {\t\t\t\t\t\tThread1 mTh1=new Thread1(\"A\");\t\t\t\t\t\tThread1 mTh2=new Thread1(\"B\");\t\t\t\t\t\tmTh1.start();\t\t\t\t\t\tmTh2.start();\t\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\t}\n\n\nstart()方法的调用后并不是立即执行多线程代码，而是使得该线程变为可运行态（Runnable），什么时候运行是由操作系统决定的。\n\n从程序运行的结果可以发现，多线程程序是乱序执行。因此，只有乱序执行的代码才有必要设计为多线程。Thread.sleep()方法调用目的是不让当前线程独自霸占该进程所获取的CPU资源，以留出一定时间给其他线程执行的机会。\n\n实际上所有的多线程代码执行顺序都是不确定的，每次执行的结果都是随机的。\n\n但是start方法重复调用的话，会出现java.lang.IllegalThreadStateException异常。\n  Thread1 mTh1=new Thread1(\"A\");\tThread1 mTh2=mTh1;\tmTh1.start();\tmTh2.start();\n\n\n实现java.lang.Runnable接口class Thread2 implements Runnable{\t\tprivate String name;\t\t\tpublic Thread2(String name) {\t\t\tthis.name=name;\t\t}\t\t@Override\t\tpublic void run() {\t\t\t  for (int i = 0; i &lt; 5; i++) {\t\t            System.out.println(name + \"运行  :  \" + i);\t\t            try {\t\t            \tThread.sleep((int) Math.random() * 10);\t\t            } catch (InterruptedException e) {\t\t                e.printStackTrace();\t\t            }\t\t        }\t\t}\t}\tpublic class Main {\t\tpublic static void main(String[] args) {\t\t\tnew Thread(new Thread2(\"C\")).start();\t\t\tnew Thread(new Thread2(\"D\")).start();\t\t}\t}\n\n注：Thread类实际上也是实现了Runnable接口的类。\n在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread对象的start()方法来运行多线程代码。\n实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是扩展Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。Thread和Runnable的区别class Thread2 implements Runnable{\t    private int count=15;\t\t@Override\t\tpublic void run() {\t\t\t  for (int i = 0; i &lt; 5; i++) {\t\t\t\t  System.out.println(Thread.currentThread().getName() + \"运行  count= \" + count--);\t\t            try {\t\t            \tThread.sleep((int) Math.random() * 10);\t\t            } catch (InterruptedException e) {\t\t                e.printStackTrace();\t\t            }\t\t        }\t\t\t\t\t}\t\t\t}\tpublic class Main {\t\t\tpublic static void main(String[] args) {\t\t\t\t\t\tThread2 my = new Thread2();\t\t        new Thread(my, \"C\").start();//同一个mt，但是在Thread中就不可以，如果用同一个实例化对象mt，就会出现异常   \t\t        new Thread(my, \"D\").start();\t\t        new Thread(my, \"E\").start();\t\t}\t}\n注：这里要注意每个线程都是用同一个实例化对象，如果不是同一个，效果就和上面的Thread一样了！\n实现Runnable接口比继承Thread类所具有的优势：\n适合多个相同的程序代码的线程去处理同一个资源.\n可以避免java中的单继承的限制\n增加程序的健壮性，代码可以被多个线程共享，代码和数据独立\n\n\n\n提醒一下大家：main方法其实也是一个线程。在java中所以的线程都是同时启动的，至于什么时候，哪个先执行，完全看谁先得到CPU的资源。在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个ＪＶＭ，每一个ｊＶＭ实习在就是在操作系统中启动了一个进程。\n线程状态转换\n\n\n新建状态（New）：新创建了一个线程对象。\n就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。\n运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。\n阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：\n等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。\n同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。\n其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。\n\n\n\n5.死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。\n线程调度\n调整线程优先级：Java线程有优先级，优先级高的线程会获得较多的运行机会。\njava线程的优先级用整数表示，取值是1~10，Thread类有一下三个静态常量：static int MAX_PRIORITY 线程可以具有的最高优先级，取值为10。static int MIN_PRIORITY 线程可以具有的最高优先级，取值为1。static int NORM_PRIORITY 分配给线程的默认优先级，取值为5。\nThread类的setPriority()和getPriority()方法分别用来设置和获取线程的优先级。\n线程的优先级有继承关系，比如A线程中创建了B线程，那么B将和A具有相同的优先级。\n\n\n线程睡眠：Thread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。\n线程等待：Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。\n线程让步：Thread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。\n线程加入：join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。\n线程唤醒：Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。\n\n常用函数说明\nsleep(long millis): 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）\n\njoin():指等待t线程终止。\njoin:\n这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行。\nThread t = new AThread(); t.start(); t.join();\n\n\n\n\n\n\n在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。\n   class Thread1 extends Thread{  \t\tprivate String name;  \t    public Thread1(String name) {  \t    \tsuper(name);  \t       this.name=name;  \t    }  \t\tpublic void run() {  \t\t\tSystem.out.println(Thread.currentThread().getName() + \" 线程运行开始!\");  \t        for (int i = 0; i &lt; 5; i++) {  \t            System.out.println(\"子线程\"+name + \"运行 : \" + i);  \t            try {  \t                sleep((int) Math.random() * 10);  \t            } catch (InterruptedException e) {  \t                e.printStackTrace();  \t            }  \t        }  \t        System.out.println(Thread.currentThread().getName() + \" 线程运行结束!\");  \t\t}  \t}  \tpublic class Main {  public static void main(String[] args) {  \t\tSystem.out.println(Thread.currentThread().getName()+\"主线程运行开始!\");  \t\tThread1 mTh1=new Thread1(\"A\");  \t\tThread1 mTh2=new Thread1(\"B\");  \t\tmTh1.start();  \t\tmTh2.start();  \t\tSystem.out.println(Thread.currentThread().getName()+ \"主线程运行结束!\");    \t}    }\n\n\n\n\n\n\n运行结果：\n main主线程运行开始!\tmain主线程运行结束!\tA 线程运行开始!\tB 线程运行开始!\t子线程A运行 : 0\t子线程B运行 : 0\t子线程A运行 : 1\t子线程A运行 : 2\t子线程A运行 : 3\t子线程A运行 : 4\t子线程B运行 : 1\t子线程B运行 : 2\t子线程B运行 : 3\t子线程B运行 : 4\tB 线程运行结束!\tA 线程运行结束!\n\n\n\n\n\n\n发现主线程比子线程早结束。\n\n加join：\n\n\npublic class Main {\tpublic static void main(String[] args) {\t\t\tSystem.out.println(Thread.currentThread().getName()+\"主线程运行开始!\");\t\t\tThread1 mTh1=new Thread1(\"A\");\t\t\tThread1 mTh2=new Thread1(\"B\");\t\t\tmTh1.start();\t\t\tmTh2.start();\t\t\ttry {\t\t\t\tmTh1.join();\t\t\t} catch (InterruptedException e) {\t\t\t\te.printStackTrace();\t\t\t}\t\t\ttry {\t\t\t\tmTh2.join();\t\t\t} catch (InterruptedException e) {\t\t\t\te.printStackTrace();\t\t\t}\t\t\tSystem.out.println(Thread.currentThread().getName()+ \"主线程运行结束!\");\t}}\n\n运行结果：\n main主线程运行开始!\tA 线程运行开始!\tB 线程运行开始!\t子线程B运行 : 0\t子线程A运行 : 0\t子线程B运行 : 1\t子线程B运行 : 2\t子线程B运行 : 3\t子线程B运行 : 4\tB 线程运行结束!\t子线程A运行 : 1\t子线程A运行 : 2\t子线程A运行 : 3\t子线程A运行 : 4\tA 线程运行结束!\tmain主线程运行结束!\n\n\n\n\n\n\n主线程一定会等子线程都结束了再结束。\nyield():暂停当前正在执行的线程对象，并执行其他线程。\nyield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。\n class ThreadYield extends Thread{\t    public ThreadYield(String name) {\t        super(name);\t    }\t    @Override\t    public void run() {\t        for (int i = 1; i &lt;= 50; i++) {\t            System.out.println(\"\" + this.getName() + \"-----\" + i);\t            // 当i为30时，该线程就会把CPU时间让掉，让其他或者自己的线程执行（也就是谁先抢到谁执行）\t            if (i ==30) {\t                this.yield();\t            }\t        }\t}\t}\tpublic class Main {\t\tpublic static void main(String[] args) {\t\t\tThreadYield yt1 = new ThreadYield(\"张三\");\t    \tThreadYield yt2 = new ThreadYield(\"李四\");\t        yt1.start();\t        yt2.start();\t\t}}\n\n ​ ​        \n\n运行结果：\n\n第一种情况：李四（线程）当执行到30时会CPU时间让掉，这时张三（线程）抢到CPU时间并执行。第二种情况：李四（线程）当执行到30时会CPU时间让掉，这时李四（线程）抢到CPU时间并执行。\n\n\n\nsleep()和yield()的区别\nsleep()和yield()的区别):sleep()使当前线程进入停滞状态，所以执行sleep()的线程在指定的时间内肯定不会被执行；yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。\nyield()方法称为“退让”，它把运行机会让给了同等优先级的其他线程\nsleep 方法允许较低优先级的线程获得运行机会，但 yield()  方法执行时，当前线程仍处在可运行状态，所以，不可能让出较低优先级的线程些时获得 CPU 占有权。\n\nsetPriority(): 更改线程的优先级。\n用法：\n  Thread4 t1 = new Thread4(\"t1\");\tThread4 t2 = new Thread4(\"t2\");\tt1.setPriority(Thread.MAX_PRIORITY);\tt2.setPriority(Thread.MIN_PRIORITY);\n\n\ninterrupt():\n中断某个线程，这种结束方式比较粗暴，如果t线程打开了某个资源还没来得及关闭也就是run方法还没有执行完就强制结束线程，会导致资源无法关闭 \n要想结束进程最好的办法就是用sleep()函数的例子程序里那样，在线程类里面用以个boolean型变量来控制run()方法什么时候结束，run()方法一结束，该线程也就结束了。wait()\nObj.wait()，与Obj.notify()必须要与synchronized(Obj)一起使用，也就是wait,与notify是针对已经获取了Obj锁进行操作，从语法角度来说就是Obj.wait(),Obj.notify必须在synchronized(Obj){…}语句块内。从功能上来说wait就是说线程在获取对象锁后，主动释放对象锁，同时本线程休眠。直到有其它线程调用对象的notify()唤醒该线程，才能继续获取对象锁，并继续执行。相应的notify()就是对对象锁的唤醒操作。但有一点需要注意的是notify()调用后，并不是马上就释放对象锁的，而是在相应的synchronized(){}语句块执行结束，自动释放锁后，JVM会在wait()对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程，继续执行。这样就提供了在线程间同步、唤醒的操作。Thread.sleep()与Object.wait()二者都可以暂停当前线程，释放CPU控制权，主要的区别在于Object.wait()在释放CPU同时，释放了对象锁的控制。\n经典的面试题，题目要求如下：  建立三个线程，A线程打印10次A，B线程打印10次B,C线程打印10次C，要求线程同时运行，交替打印10次ABC。这个问题用Object的wait()，notify()就可以很方便的解决。代码如下：public class MyThreadPrinter2 implements Runnable {         private String name;       private Object prev;       private Object self;       private MyThreadPrinter2(String name, Object prev, Object self) {           this.name = name;           this.prev = prev;           this.self = self;       }       public void run() {           int count = 10;           while (count &gt; 0) {               synchronized (prev) {                   synchronized (self) {                       System.out.print(name);                       count--;                      self.notify();                   }                   try {                       prev.wait();                   } catch (InterruptedException e) {                       e.printStackTrace();                   }               }           }       }       public static void main(String[] args) throws Exception {           Object a = new Object();           Object b = new Object();           Object c = new Object();           MyThreadPrinter2 pa = new MyThreadPrinter2(\"A\", c, a);           MyThreadPrinter2 pb = new MyThreadPrinter2(\"B\", a, b);           MyThreadPrinter2 pc = new MyThreadPrinter2(\"C\", b, c);           new Thread(pa).start();        Thread.sleep(100);  //确保按顺序A、B、C执行        new Thread(pb).start();        Thread.sleep(100);          new Thread(pc).start();           Thread.sleep(100);          }   }\n输出结果：\nABCABCABCABCABCABCABCABCABCABC\n\n\n\nwait和sleep区别\n共同点：\n他们都是在多线程的环境下，都可以在程序的调用处阻塞指定的毫秒数，并返回。 \nwait()和sleep()都可以通过interrupt()方法 打断线程的暂停状态 ，从而使线程立刻抛出InterruptedException。 \n\n\n不同点：\nThread类的方法：sleep(),yield()等 \nObject的方法：wait()和notify()等 \n每个对象都有一个锁来控制同步访问。Synchronized关键字可以和对象的锁交互，来实现线程的同步。 sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。\nwait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用 \nsleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常\n\n\n\n常见线程名词解释\n主线程：JVM调用程序main()所产生的线程。\n当前线程：这个是容易混淆的概念。一般指通过Thread.currentThread()来获取的进程。\n后台线程：指为其他线程提供服务的线程，也称为守护线程。JVM的垃圾回收线程就是一个后台线程。用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束\n前台线程：是指接受后台线程服务的线程，其实前台后台线程是联系在一起，就像傀儡和幕后操纵者一样的关系。傀儡是前台线程、幕后操纵者是后台线程。由前台线程创建的线程默认也是前台线程。\n可以通过isDaemon()和setDaemon()方法来判断和设置一个线程是否为后台线程。\n\n线程同步\nsynchronized关键字的作用域有二种： \n\n是某个对象实例内，synchronized aMethod(){}可以防止多个线程同时访问这个对象的synchronized方法（如果一个对象有多个synchronized方法，只要一个线程访问了其中的一个synchronized方法，其它线程不能同时访问这个对象中任何一个synchronized方法）。这时，不同的对象实例的synchronized方法是不相干扰的。也就是说，其它线程照样可以同时访问相同类的另一个对象实例中的synchronized方法；\n是某个类的范围，synchronized static aStaticMethod{}防止多个线程同时访问这个类中的synchronized static 方法。它可以对类的所有对象实例起作用。 \n\n\n除了方法前用synchronized关键字，synchronized关键字还可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。用法是: synchronized(this){/区块/}，它的作用域是当前对象； \n\nsynchronized关键字是不能继承的，也就是说，基类的方法synchronized f(){} 在继承类中并不自动是synchronized f(){}，而是变成了f(){}。继承类需要你显式的指定它的某个方法为synchronized方法；\n\n总结：\n\nsynchronized关键字可以作为函数的修饰符，也可作为函数内的语句，也就是平时说的同步方法和同步语句块。\n无论synchronized关键字加在方法上还是对象上，它取得的锁都是对象，而不是把一段代码或函数当作锁――而且同步方法很可能还会被其他线程的对象访问。\n每个对象只有一个锁（lock）与之相关联。\n实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。  Class Foo{public synchronized static void methodAAA()   // 同步的static 函数{//….}public void methodBBB(){       synchronized(Foo.class)   //  class literal(类名称字面常量)}       }\n\n\n代码中的methodBBB()方法是把class literal作为锁的情况，它和同步的static函数产生的效果是一样的，取得的锁很特别，是当前调用这个方法的对象所属的类。\n      1. 线程同步的目的是为了保护多个线程反问一个资源时对资源的破坏。\n      2. 线程同步方法是通过锁来实现，每个对象都有切仅有一个锁，这个锁与一个特定的对象关联。\n      3. 对于静态同步方法，锁是针对这个类的，锁对象是该类的Class对象。静态和非静态方法的锁互不干预。\n      4. 对于同步，要时刻清醒在哪个对象上同步，这是关键。\n      5. 编写线程安全的类，需要时刻注意对多个线程竞争访问资源的逻辑和安全做出正确的判断\n      6. 当多个线程等待一个对象锁时，没有获取到锁的线程将发生阻塞。\n      7. 死锁是线程间相互等待锁锁造成的，在实际中发生的概率非常的小。\n\n\n线程数据传递\n在传统的同步开发模式下，当我们调用一个函数时，通过这个函数的参数将数据传入，并通过这个函数的返回值来返回最终的计算结果。但在多线程的异步开发模式下，数据的传递和返回和同步开发模式有很大的区别。由于线程的运行和结束是不可预料的，因此，在传递和返回数据时就无法象函数一样通过函数参数和return语句来返回数据。\n\n通过构造方法传递数据 \n\n在创建线程时，必须要建立一个Thread类的或其子类的实例。因此，我们不难想到在调用start方法之前通过线程类的构造方法将数据传入线程。并将传入的数据使用类变量保存起来，以便线程使用(其实就是在run方法中使用)。\n\n\n通过变量和方法传递数据 \n\n向对象中传入数据一般有两次机会，第一次机会是在建立对象时通过构造方法将数据传入，另外一次机会就是在类中定义一系列的public的方法或变量（也可称之为字段）。然后在建立完对象后，通过对象实例逐个赋值。\n\n\n\n\n通过回调函数传递数据 \n  class Data \t\t{ \t\tpublic int value = 0; \t\t} \t\tclass Work \t\t{ \t\tpublic void process(Data data, Integer numbers) \t\t{ \t\tfor (int n : numbers) \t\t{ \t\tdata.value += n; \t\t} \t\t} \t\t} \t\tpublic class MyThread3 extends Thread \t\t{ \t\tprivate Work work; \t\tpublic MyThread3(Work work) \t\t{ \t\tthis.work = work; \t\t} \t\tpublic void run() \t\t{ \t\tjava.util.Random random = new java.util.Random(); \t\tData data = new Data(); \t\tint n1 = random.nextInt(1000); \t\tint n2 = random.nextInt(2000); \t\tint n3 = random.nextInt(3000); \t\twork.process(data, n1, n2, n3); // 使用回调函数 \t\tSystem.out.println(String.valueOf(n1) + \"+\" + String.valueOf(n2) + \"+\" \t\t+ String.valueOf(n3) + \"=\" + data.value); \t\t} \t\tpublic static void main(String[] args) \t\t{ \t\tThread thread = new MyThread3(new Work()); \t\tthread.start(); \t\t} \t\t} \n\n\n\n​    \n码字不易，求分享、转发。😄\n往期精彩文章\nJava必读电子书_文档教程_高清PDF下载\n深入理解Java中的List、Set与Map集合\n由浅入深，解析Java Servlet开发以及工作的过程\nJava Map使用多个映射案例\n推荐7款好用的终端工具\n8张图 带你理解Java内存区域\nJava八大基本数据类型详解\nJavaWeb中文编码问题\nJava内存模型及GC原理(Java内存分配、GC基本原理)\n\n","categories":["Java"],"tags":["Java","线程"]},{"title":"JavaWeb中文编码问题","url":"https://tanqingbo.cn/JavaWeb-Chinese-Garbled/","content":"上一篇分享了《Java内存模型及GC原理(Java内存分配、GC基本原理)》,本篇文章中我们来聊一下JavaWeb中一些中文编码问题。\n需要编码的原因\n计算机中存储的最小单元是一个字节，即8bit，所以能表示的字符范围是0~255个。\n人类要表示的符号太多，无法用一个字节来完全表示。\n要解决这个矛盾必须要有一个新的数据结构char，从char到byte必须编码。编码格式\n\n\nASCII\n\nASCII码共有128个，用一个字节的低7位表示，031是控制字符，如换行、回车、删除等；32126是打印字符，可以通过键盘输入并能够显示出来。\n\n\nISO-8859-1\n\n128个字符显然是不够用的，ISO组织在ASCII码的基础上又制定了一系列标准用来扩展ASCII编码，他们是ISO-8859-1~ISO-8859-15，其中ISO-8859-1涵盖了大多数西欧语言字符，所以应用最广泛。ISO-8859-1任然是单字节编码，它总共能表示256个字符。\n\n\nGB2312\n\n它的全称是《信息交换用汉字编码字符集基本集》，它是双字节编码，总的编码范围是A1F7，其中从A1A9是符号区，总共包含682个字符。从B0~F7是汉字区，包含6763个汉字。\n\n\nGBK\n\n全称《汉字内码扩展规范》，为了扩展GB2312加入了更多的汉字，它的编码是和GB2312是兼容的，也就是说GB2312编码的汉字可以用GBK来解码，并且不会有乱码。\n\n\nGB18030\n\n是我国强制标准，它可能是单字节、双字节、或者四字节编码，与GB2312兼容，应用并不广泛。\n\n\nUTF-16\n\n用两个字节来表示Unicode转化格式，它是定长的表示方法，不论什么字符都可以用两个字节表示，两个字节是16bit，所以叫UTF-16。每两个字节表示一个字符，这就大大简化了字符串的操作，这也是java以UTF-16作为内存字符存储格式的一个很重要的原因。\n\n\nUTF-8\n\nUTF-16同意采用两个字符表示一个字节，但是很大一部分字符用一个字节就可以表示现在却要用两个字符表示，存储空间放大了一倍，而现在网络带宽还非常有限，这样会增大网络传输的流量，而且也没必要。而UTF-8采用了一种变长的技术，每个编码区域有不同的字码长度。不同类型的字符可以由1~6个字节组成。\n\n\n\njava中需要编码的场景I/O操作中存在的编码\n涉及编码的地方一般在字符到字节或者字节带字符的转换上，二需要这种转换的场景主要是I/O。\nReader类是java的i/o中读字符的父类，而inputstream类是读字节的父类，inputstreamreader类就是关联字节到字符的桥梁，它负责在I/O过程中处理读取字节到字符的转换，而具体字节到字符的解码又委托streamdecoder去做，在streamdecoder解码过程中必须有用户指定charset编码格式，如果没有指定charset，将使用本地环境中的默认字符集。\n写的情况也类似，字符的父类是writer，字节的父类是outputstream，通过outputstreamwriter转换字符到字节。StreamEncoder类负责将字符编码成字节，编码格式和默认编码规则与解码是一致的。\n强烈建议不要使用操作系统的默认编码，因为这样你的应用程序的编码格式就和运行环境绑定起来了，在跨环境是很可能出现乱码。\n\n内存操作中的乱码\n内存中进行字符到字节的转换也很常见。\n  String s = \"这是一段中文字符\";\t\tbyte[] b = s.getBytes(\"utf-8\");\t\tString n = new String(b,\"utf-8\");Charset charset = Charset.forName(\"utf-8\");\t\tByteBuffer byteBuffer = charset.encode(string);\t\tCharBuffer charBuffer = charset.decode(byteBuffer);\n\n\n\n\n\n\nJava中如何编解码\n以字符串“I am 君山”为例。\n\n按照ISO-8859-1编码\n\nISO-8859-1是单字节编码，中文“君山”被转化成值是3f的byte，3f也就是“?”字符。所以经常会出现中文变成“?”，很可能就是错误地使用了ISO-8859-1编码导致的。\n\n按照GB2312编码\n\nGB2312字符集有一个char到byte的码表，不同的字符编码就查这个码表找到与每个字符的对应字节，然后拼装成byte数组。\n\n按照GBK编码\n\nGBK与GB2312编码结果是一样的；\n由此可以看出来GBK编码是兼容GB2312编码的，他们的编码算法是一样的。\n不同的是它们的码表长度不一样，GBK包含的汉字字符更多，所以只要是经过GB2312编码的汉字都可以用GBK进行解码，反之则不然。\n\n\n按照utf-16编码\n\n用utf-16编码将char数组放大了一倍，单字节范围内的字符在高位补0变成两个字节，中文字符也变两个字节。\n\n编码效率非常高，规则很简单。\n\n\n按照utf-8编码\n\nUTF-16采用顺序编码，不能对单个字符的编码值进行校验，如果中间的一个字符码值损坏，后面所有的码值都将受到影响。\n\n而UTF-8不存在这些问题，UTF-8对单字节范围内字符任然用一个字节表示，对汉字采用三个字节表示。\nUTF-8编码与GBK和GB2312不同，不用查码表，所以在编码效率上UTF-8的效率会更好，所以在存储中文字符时UTF-8编码比较理想。\n\n\n几种编码格式的比较\n\nGB2312与GBK的编码规则类似，但是GBK范围更大，所以GB2312与GBK比较，应该选择GBK；\nutf-16与utf-8都是处理Unicode编码，编码规则不太相同，相对来说utf-16编码效率最高，字符到字节相互转换更简单，进行字符操作也更好，它适合本地磁盘和内存之间使用，可以进行字符和字节中间的快速切换，java内存编码就采用utf-16编码；\n但是UTF-16不适合网络之间的传输，因为网络传输容易损坏字节流，一旦字节流损坏就很难恢复，相比较而言，utf-8更适合网络传输，单个字符的损坏不会影响后面其他字符，编码效率介于GBK和UTF-16之间；\nUTF-8在编码效率上和安全性上做了平衡，是理想的中文编码方式。\n\n\n\nJava Web中涉及的编解码\nURL的编解码\n\n浏览器编码URL将非ASCII字符按照某种编码格式编码成16进制数字后在每个16进制表示的字节前加上“%”，所以就出现了如下情况：\n  http://tanqingbo.cn/%E5%93%AA%E6%9C%AC%E4%B9%A6%E9%80%82%E5%90%88%E6%8E%A8%E8%8D%90%E7%BB%99%20Java%20%E5%88%9D%E5%AD%A6%E8%80%85%EF%BC%9F/\n\n\n\nhttp Header的编码\n\nheader中传递参数，如：Cookie、redirectPath等，这些用户设置的值可能存在编码问题。\n对header进行解码实在调用request.getHeader时进行的，这个方法将byte到char的转化使用的是ISO-8859-1，不能手动设置Header的其他解码格式，如果有非ASCII字符肯定会有乱码；\n不要在header中传递非ASCII字符，如果一定要出传递，可以先将这些字符用org.apache.catalina.util.URLEncoder编码，然后再添加到header中。\n\n\n访问数据库都是通过客户端JDBC驱动来完成的，用JDBC来存取数据要和数据的内置编码保持一致，可以通过设置JDBC URL来指定，如：MySQL：\n      jdbcUrl=\"jdbc:mysql://localhost:3306/boke?characterEncoding=utf-8\"\nJS中的编码问题\n外部引入JS文件\n\n如果script没有设置charset，浏览器就会以当前这个页面的默认字符集解析这个JS文件，如果外部的JS文件的编码格式与当前页面的编码格式一致，那么可以不设置这个charset，但是如果script.js文件的编码格式与当前页面不一致，上面的那段中文输入就会变成乱码。\n\n\nJS的URL编码\n\n实际上JS中处理URL编码有三个函数，只要掌握了这三个函数，基本上就能正确处理JS的URL乱码问题了；\n\n\nescape()\n这个函数是将非ascii字符转化成Unicode编码值，并且在编码值前加上“%u”；\n\n\n解码通过unescape()函数；\n通过将特殊字符换成Unicode编码值可以避免因为编码的字符集的不兼容而出现的信息丢失问题，在服务端通过解码参数就可以避免乱码的问题。\n\n\n\n\nencodeURL()\n\n与escape()相比，encodeURL()是真正的JS用来对URL编码的函数，它可以将整个URL中的字符(除了一些特殊字符，如：符号、数字、字母)进行UTF-8编码，在每个值之前加上“%”；\n解码通过encodeURL函数。\n\n\nencodeURLComponent()\n\nencodeURLComponent()这个函数比encodeURL()编码还要彻底；\n通常用于将一个URL当做参数放在另一个URL中；\n\n\n其他需要编码的地方\n\nXML文件可以通过设置投来制定编码格式：\n  &lt;?xml version\"1.0\" encoding=\"UTF-8\"&gt;\n\nVelocity(基于Java的模板引擎)设置编码格式：\n  services.VelocityService.input.encoding=uft-8\n\nJsp设置编码格式：\n  &lt;%@page contentType=\"text/html; charset=utf-8\"&gt;\n常见问题分析\n\n\n\n\n中文变成了看不懂的字符\n\n一个汉字变成一个问号\n\n一个汉字变成两个问号\n\n一种不正常的正确编码\n\n我们通过request.getParameter获取参数值时，直接调用：\n  String value = request.getParameter(name);\n\n会出现乱码，但是用如下方式：\n  String value = new String(request.getParameter(name).getBytes(\"ISO-8859-1\"),\"GBK\");\n\n解析时取得的value会是正确的汉字字符。\n\n\n\n\n码字不易，求分享、转发。😄\n推荐阅读\n计算机专业电子书下载\nJava电子书_文档教程_高清PDF下载\nPython电子书_文档教程_高清PDF下载\nC/C++电子书_文档教程_高清PDF下载\nLinux电子书_Linux书籍_高清PDF下载\n数据结构与算法相关书籍_PDF电子版下载\n计算机基础_操作系统_汇编语言_计算机网络-电子书PDF下载\n\n","categories":["Java"],"tags":[]},{"title":"Java内存模型及GC原理(Java内存分配、GC基本原理)","url":"https://tanqingbo.cn/Java-GC/","content":"之前分享过一些经典的Java面试题，分别是《Java面试题–基础知识汇总》、《Java面试题–设计模式与继承多态》和《Java面试题–重点总结(三)》，这篇文章主要讲Java内存模型及GC原理。\nJava内存模型\n按照官方的说法：Java 虚拟机具有一个堆，堆是运行时数据区域，所有类实例和数组的内存均从此处分配。\n\nJVM主要管理两种类型内存：堆和非堆，堆内存（Heap Memory）是在 Java 虚拟机启动时创建，非堆内存(Non-heap Memory)是在JVM堆之外的内存。\n\n堆是Java代码可及的内存，留给开发人员使用的；非堆是JVM留给自己用的，包含方法区、JVM内部处理或优化所需的内存（如 JIT Compiler，Just-in-time Compiler，即时编译后的代码缓存）、每个类结构（如运行时常数池、字段和方法数据）以及方法和构造方法的代码。\n\nJVM 内存包含如下几个部分：\n\n堆内存（Heap Memory）： 存放Java对象\n非堆内存（Non-Heap Memory）： 存放类加载信息和其它meta-data\n其它（Other）： 存放JVM 自身代码等\n\n\n\n\n\n\n在JVM启动时，就已经保留了固定的内存空间给Heap内存，这部分内存并不一定都会被JVM使用，但是可以确定的是这部分保留的内存不会被其他进程使用，这部分内存大小由-Xmx 参数指定。而另一部分内存在JVM启动时就分配给JVM，作为JVM的初始Heap内存使用，这部分内存是由 -Xms 参数指定。\n详细配置文件目录：eclipse/eclipse.ini\n\nJava内存分配\nJava的内存管理实际上就是变量和对象的管理，其中包括对象的分配和释放。\n\n\nJVM内存申请过程如下：\n\nJVM 会试图为相关Java对象在Eden中初始化一块内存区域\n当Eden空间足够时，内存申请结束；否则到下一步\nJVM 试图释放在Eden中所有不活跃的对象（这属于1或更高级的垃圾回收）,释放后若Eden空间仍然不足以放入新对象，则试图将部分Eden中活跃对象放入Survivor区\nSurvivor区被用来作为Eden及OLD的中间交换区域，当OLD区空间足够时，Survivor区的对象会被移到Old区，否则会被保留在Survivor区\n当OLD区空间不够时，JVM 会在OLD区进行完全的垃圾收集（0级）\n完全垃圾收集后，若Survivor及OLD区仍然无法存放从Eden复制过来的部分对象，导致JVM无法在Eden区为新对象创建内存区域，则出现”out of memory”错误\n\n\n\nGC基本原理\nGC（Garbage Collection)，是JAVA/.NET中的垃圾收集器。\n\n编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。所以，Java的内存管理实际上就是对象的管理，其中包括对象的分配和释放。\n\n\n对于程序员来说，分配对象使用new关键字；释放对象时，只要将对象所有引用赋值为null，让程序不能够再访问到这个对象，我们称该对象为”不可达的”.GC将负责回收所有”不可达”对象的内存空间。\n\n对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆（heap）中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”.当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。\n\n为了保证 GC能够在不同平台实现的问题，Java规范对GC的很多行为都没有进行严格的规定。例如，对于采用什么类型的回收算法、什么时候进行回收等重要问题都没有明确的规定。\n\n\nGC分代划分\nJVM内存模型中Heap区分两大块，一块是 Young Generation，另一块是Old Generation\n在Young Generation中，有一个叫Eden Space的空间，主要是用来存放新生的对象，还有两个Survivor Spaces（from、to），它们的大小总是一样，它们用来存放每次垃圾回收后存活下来的对象。\n在Old Generation中，主要存放应用程序中生命周期长的内存对象。\n在Young Generation块中，垃圾回收一般用Copying的算法，速度快。每次GC的时候，存活下来的对象首先由Eden拷贝到某个SurvivorSpace，当Survivor Space空间满了后，剩下的live对象就被直接拷贝到OldGeneration中去。因此，每次GC后，Eden内存块会被清空。\n在Old Generation块中，垃圾回收一般用mark-compact的算法，速度慢些，但减少内存要求。\n垃圾回收分多级，0级为全部(Full)的垃圾回收，会回收OLD段中的垃圾；1级或以上为部分垃圾回收，只会回收Young中的垃圾，内存溢出通常发生于OLD段或Perm段垃圾回收后，仍然无内存空间容纳新的Java对象的情况。增量式GC\n增量式GC（Incremental GC），是GC在JVM中通常是由一个或一组进程来实现的，它本身也和用户程序一样占用heap空间，运行时也占用CPU。\n当GC进程运行时，应用程序停止运行。当GC运行时间较长时，用户能够感到Java程序的停顿，另外一方面，如果GC运行时间太短，则可能对象回收率太低.\n增量式GC就是通过一定的回收算法，把一个长时间的中断，划分为很多个小的中断，通过这种方式减少GC对用户程序的影响。\nSun JDK提供的HotSpot JVM就能支持增量式GC。HotSpot JVM缺省GC方式为不使用增量GC，为了启动增量GC，我们必须在运行Java程序时增加-Xincgc的参数。\nHotSpot JVM增量式GC的实现是采用Train GC算法，它的基本想法就是：将堆中的所有对象按照创建和使用情况进行分组（分层），将使用频繁高和具有相关性的对象放在一队中，随着程序的运行，不断对组进行调整。当GC运行时，它总是先回收最老的（最近很少访问的）的对象，如果整组都为可回收对象，GC将整组回收。这样，每次GC运行只回收一定比例的不可达对象，保证程序的顺畅运行。\n\n详解函数finalize\nfinalize 是位于Object类的一个方法，详见我的开源项目：src-jdk1.7.0_02\n该方法的访问修饰符为protected，由于所有类为Object的子类，因此用户类很容易访问到这个方法。\n\n\n由于，finalize函数没有自动实现链式调用，我们必须手动的实现，因此finalize函数的最后一个语句通常是 super.finalize（）。通过这种方式，我们可以实现从下到上实现finalize的调用，即先释放自己的资源，然后再释放父类的资源。根据Java语言规范，JVM保证调用finalize函数之前，这个对象是不可达的，但是JVM不保证这个函数一定会被调用。另外，规范还保证finalize函数最多运行一次。\n很多Java初学者会认为这个方法类似与C++中的析构函数，将很多对象、资源的释放都放在这一函数里面。其实，这不是一种很好的方式，原因有三：\n其一、GC为了能够支持finalize函数，要对覆盖这个函数的对象作很多附加的工作。\n其二、在finalize运行完成之后，该对象可能变成可达的，GC还要再检查一次该对象是否是可达的。因此，使用 finalize会降低GC的运行性能。\n其三、由于GC调用finalize的时间是不确定的，因此通过这种方式释放资源也是不确定的。\n\n\n通常，finalize用于一些不容易控制、并且非常重要资源的释放，例如一些I/O的操作，数据的连接。\n\nGC程序交互\n序如何与GC进行交互呢？ Java2增强了内存管理功能，增加了一个java.lang.ref包，详见我的开源项目：src-jdk1.7.0_02\n其中定义了三种引用类。这三种引用类分别为：SoftReference、 WeakReference、 PhantomReference\n通过使用这些引用类，程序员可以在一定程度与GC进行交互，以便改善GC的工作效率，这些引用类的引用强度介于可达对象和不可达对象之间。\nSoft Reference的主要特点是据有较强的引用功能。只有当内存不够的时候，才进行回收这类内存，因此在内存足够的时候，它们通常不被回收。另外，这些引用对象还能保证在Java抛出OutOfMemory 异常之前，被设置为null。它可以用于实现一些常用图片的缓存，实现Cache的功能，保证最大限度的使用内存而不引起OutOfMemory。以下给出这种引用类型的使用伪代码：\n\n// 申请一个图像对象  \t\t　Image image=new Image();       // 创建Image对象  \t\t　…  \t\t　// 使用 image  \t\t　…  \t\t　// 使用完了image，将它设置为soft 引用类型，并且释放强引用；  \t\t　SoftReference sr=new SoftReference(image);  \t\t　image=null;  \t\t　…  \t\t　// 下次使用时  \t\t　if (sr!=null)   \t\t    image=sr.get();  \t\t　else{  \t\t\t//由于GC由于低内存，已释放image，因此需要重新装载；  \t\t　       image=new Image();  //由于GC由于低内存，已释放image，因此需要重新装载；  \t\t　       sr=new SoftReference(image);  \t\t　}  \n\n\n\n\nWeak引用对象与Soft引用对象的最大不同就在于：GC在进行回收时，需要通过算法检查是否回收Soft引用对象，而对于Weak引用对象，GC总是进行回收。Weak引用对象更容易、更快被GC回收。\nPhantom引用的用途较少，主要用于辅助finalize函数的使用。\n\nJava编程建议\n最基本的建议就是尽早释放无用对象的引用。大多数程序员在使用临时变量的时候，都是让引用变量在退出活动域（scope）后，自动设置为 null.我们在使用这种方式时候，必须特别注意一些复杂的对象图，例如数组，队列，树，图等，这些对象之间有相互引用关系较为复杂。对于这类对象，GC 回收它们一般效率较低。如果程序允许，尽早将不用的引用对象赋为null，这样可以加速GC的工作。\n尽量少用finalize函数。finalize函数是Java提供给程序员一个释放对象或资源的机会。但是，它会加大GC的工作量，因此尽量少采用finalize方式回收资源。\n如果需要使用经常使用的图片，可以使用soft应用类型。它可以尽可能将图片保存在内存中，供程序调用，而不引起OutOfMemory.\n注意集合数据类型，包括数组，树，图，链表等数据结构，这些数据结构对GC来说，回收更为复杂。另外，注意一些全局的变量，以及一些静态变量。这些变量往往容易引起悬挂对象（dangling reference），造成内存浪费。\n当程序有一定的等待时间，程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。使用增量式GC可以缩短Java程序的暂停时间。\n\n码字不易，求分享、转发。😄\n推荐阅读\n计算机专业电子书下载\nJava电子书_文档教程_高清PDF下载\nPython电子书_文档教程_高清PDF下载\nC/C++电子书_文档教程_高清PDF下载\nLinux电子书_Linux书籍_高清PDF下载\n数据结构与算法相关书籍_PDF电子版下载\n计算机基础_操作系统_汇编语言_计算机网络-电子书PDF下载\n\n","categories":["Java"],"tags":["JVM"]},{"title":"Java面试题--重点总结(三)","url":"https://tanqingbo.cn/Java-interview03/","content":"前面已经分享了两章Java面试基础知识，分别是《Java面试题–基础知识汇总》和《Java面试题–设计模式与继承多态》，这篇文章接着来分享Java面试的基础知识点。\n多态\n同一个对象，在程序不同时刻的多种运行状态。举例：动物，狗是狗，狗是动物。水(气态，液态，固态)\n\n多态前提\n\n存在着继承或者实现关系\n有方法的重写\n父类(接口)引用指向子类(实现)对象\n\n\n多态的好处和弊端：\n\n\n\n好处：多态的存在提高了程序的扩展性和后期可维护性\n弊端：虽然可以预先使用，但是只能访问父类中已有的功能，运行的是后期子类的功能内容。 不能预先使用子类中定义的特有功能。\n\n\n多态中对象调用成员的特点Fu f = new Zi();\n\n\n\n成员变量编译看左边，运行看左边\n成员方法编译看左边，运行看右边\n静态方法编译看左边，运行看左边\n\n\n\n\n多态的思想指挥同一批对象做事情。举例：带兵打仗，下课等。\n\nObject类\n是所有类的根类，超类。java中提供的类以及我们自定义的类都直接或者间接的继承自Object类。\nObject类中的方法\nvoid finalize() 当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。\nClass getClass() 获取对象的字节码文件的描述类，后面再讲反射的时候还会在说这个类。 String name = s.getClass().getName();\nint hashCode() 获取对象的哈希值。其实就是对象的内存地址值十进制表示\nString toString() 返回对象的字符串表示。\n\n\n表示格式：\n\ngetClass().getName()+\"@\"+Integer.toHexString(hashCode());\n\n 一般我们输出对象名的时候，其实底层调用的就是该对象的toString()方法。 这种返回没有意义，所以，我们会重写这个方法，显示类的成员变量信息。\n\nboolean equals(Object obj) 用于比较两个对象的地址值是否相同。 我们获取对象后，比较它的地址值意义不大。所以也会对这个方法进行重写。 重写要完成什么功能，是根据需求定的。\n\n\n==和equals的用法：\n\n==怎么用？可以用于比较基本数据类型，比较的就是基本数据类型的值是否相等。可以用于比较引用数据类型，比较的是对象的地址值是否相等。\n\nequals怎么用？equals只能用于比较引用数据类型的。Object提供的equals是用于比较对象地址值是否相同。自定义类中，如果重写了equals方法，那么就是按照你自己的需求来比较的。\n一般我们输出对象名的时候，其实底层调用的就是该对象的toString()方法。这种返回没有意义，所以，我们会重写这个方法，显示类的成员变量信息。\n\nboolean equals(Object obj) 用于比较两个对象的地址值是否相同。 我们获取对象后，比较它的地址值意义不大。所以也会对这个方法进行重写。 重写要完成什么功能，是根据需求定的。\n\n\n\npackage关键字\n\n包：其实就是文件夹。用于区分不同包下相同的类名。\n好处：A：对类文件进行分类管理。B：给类提供了多层命名空间aaa.Demobbb.DemoC：写在程序文件的第一行。D：包也是一种封装形式。\n\n\nimport关键字\n\n导入包的关键字\n格式：import 包名;\n注意：A:一个程序文件中只有一个package，可以有多个import。B:用来导包中的类，不导入包中的包。C:通常写import  mypack.Demo，明确自己使用的类。 \n\n\n\n\n关键字的顺序类，包，导包这些关键的顺序。包 –   导包 –  类\n\n不同修饰符的访问权限\n     　  \n\t\t\t本类中       同一个包中       不同包中的子类中        不同包中private       OK默认          OK             Okprotected    OK             Ok                  OKpublic       OK             Ok                  OK              OK\n\n\n  ​    \n\n不同修饰符可以修饰哪些内容\n     \t\t\t   类            构造方法          成员变量              成员方法   private    (能修饰内部类)        OK              OK                   OK默认            Ok              Ok              Ok                   OKprotected  (能修饰内部类)        OK              OK                   Okpublic         Ok              Ok              OK                   OKstatic                                         OK                   Okfinal          Ok                              OK                   OKabstract       Ok                                                   OK\n\n\n\n\n\n\n一般格式：\n\n成员变量：权限修饰符+static/final+数据类型+成员变量名public static final int NUM = 10;\n成员方法：权限修饰符+static/final/abstract+返回类型+方法名\n\n\n\n内部类(次重点)把一个类定义在某个类中的，这个类就被称为内部类，内置类，嵌套类。\n\n访问特点：A:内部类可以直接访问外部类中的成员，因为内部类持有外部类的引用， 格式为：外部类名.thisB:外部类要想访问内部类的成员，必须创建对象访问。\n\n内部类的访问格式：\n\n\n\n当内部类定义在外部类的成员位置，而且非私有，则可以在其他外部类中直接建立内部类对象 格式：外部类名.内部类名  变量名 = new 外部类对象.内部类对象如：Outer.Inner in = new Outer().new Inner()\n当内部类在外部类成员位置，且被static修饰时,外部其他类可直接访问静态内部类的非静态成员 格式：new 外部类名.内部类名().内部类成员 如：new Outer.Inner().function();\n外部其他类可直接访问静态内部类的静态成员 格式：new 外部类名.内部类名.内部类成员 如：new Outer.Inner.function();\n\n\n什么使用时候内部类呢？\n假如有A类和B类，A类想直接访问B类的成员，B类访问A类成员的时候，需要创建A类对象进行访问，这个时候，就可以把A类定义为B类的内部类。\n\n内部类的位置A:成员位置可以被private修饰(Body，Heart)可以被static修饰。(它访问的外部类的成员必须是静态的)B:局部位置可以直接访问外部类中的成员，因为还持有外部类的持用也可以直接访问局部成员，但是局部成员要用final修饰。注意：局部内部类不能用private和static修饰\n\n通过class文件我们就可以区分是否带有内部类，以及内部类的位置 Outer$Inner:成员内部类 Outer$1Inner:局部内部类\n\n\n\n匿名内部类(局部内部类的简写) (重点)(1)前提：继承一个类或者实现一个接口(注意不要弄混匿名内部类的前提和多态的前提)(2)格式：      \nnew 父类名或者接口名()   {    重写父类方法或者实现接口中的方法。    也可以自定义其他方法。   };\n\n\n\n\n\n  什么时候定义匿名内部类？  匿名内部类只是为了简化书写，匿名内部类有局限，通常定义匿名内部类时，该类方法不超过3个\n  匿名内部类的好处和弊端：  好处：简化代码书写  弊端：  不能直接调用自己的特有方法  不能执行强转换动作  如果该类里面方法较多，不允许使用匿名内部类\n\n模板设计模式：在定义功能时，功能的一部分是确定的，有一部分是不确定的，而且确定的部分在使用不确定的部分，可将不确定的部分暴露出去，由该类的子类去完成。如：求一段程序的运行时间例子。\n\n异常(1)程序运行过程中的不正常现象就叫异常。(2)导致程序运行不正常的现象有很多，所以，就有很多的异常对象。而这些异常对象存在着共性的内容，所以，可以不断的进行抽取。最终形成了异常的体系结构。异常体系的根类是:Throwable\n Throwable：  |--Error:重大的问题，我们处理不了。也不需要编写代码处理。比如说内存溢出。  |--Exception:一般性的错误，是需要我们编写代码进行处理的。|--RuntimeException:运行时异常，这个我们也不需要处理。   其实就是为了让他在运行时出问题，然后我们回来修改代码。\n+ 异常的分类  异常有两种：  编译时被检测异常：  该异常在编译时，如果没有处理(没有抛也没有try)，编译失败。  该异常被标识，代表这可以被处理。  运行时异常(编译时不检测)  在编译时，不需要处理，编译器不检查。  该异常的发生，建议不处理，让程序停止。需要对代码进行修正。+ **(4)异常体系的特点：**  异常体系中的所有类及其子类对象都具备可抛性。也就是说可以被throw和throws关键字所操作。+ **(5)main方法是如何处理异常的。**  A:在main里面编写代码进行处理  B:交给jvm自己进行处理。采用的是jvm的默认处理方式。   其实就是相当于调用了异常对象的printStackTrace()方法。+ **(6)Throwable类的学习**  getMessage():获取异常信息，返回字符串。  toString():获取异常类名和异常信息，返回字符串。  printStackTrace():获取异常类名和异常信息，以及异常出现在程序中的位置。返回值void。+ **(7)异常的处理·**\n      A:try...catch...finally\n基本格式：\n    try\n    {\n    可能出现异常的代码\n    }\n    catch(异常对象)\n    {\n    异常处理代码\n    }\n    finally\n    {\n    释放资源\n    }\n变形格式：\n    try...catch\n    try...catch...catch...\n    try...catch...catch...finally\n  多个异常同时被捕获的时候，记住一个原则：  先逮小的，再逮大的。  finally:永远被执行，除非退出jvm。System.exit(0);#### 面试题2个**final,finally,finalize区别？**final是最终的意思。它可以用于修饰类，成员变量，成员方法。它修饰的类不能被继承，它修饰的变量时常量，它修饰的方法不能被重写。&lt;br/finally:是异常处理里面的关键字。它其中的代码永远被执行。特殊情况：在执行它之前jvm退出。System.exit(0);&lt;br/finalize:是Object类中的一个方法。它是于垃圾回收器调用的方式。：假如catch中有return语句， finally里中的代码会执行吗？  是在return前，还是在return后呢？  会，在return前执行finally里面的代码。(8)Exception和RuntimeException的区别A:Exception:一般性的错误，是需要我们编写代码进行处理的。B:RuntimeException:运行时异常，这个我们也不需要处理。  其实就是为了让他在运行时出问题，然后我们回来修改代码。在用throws抛出一个的时候，如果这个异常是属于RuntimeException的体系的时候，我们在调用的地方可以不用处理。(RuntimeException和RuntimeException的子类)在用throws抛出一个的时候，如果这个异常是属于Exception的体系的时候，我们在调用的地方必须进行处理或者继续抛出。+ **自定义异常**定义类继承Exception或者RuntimeException1. 为了让该自定义类具备可抛性。2. 让该类具备操作异常的共性方法。\t\t\t\n  class MyExcepiton extends Exception  {   \n           MyExcepiton(){}   \n           MyExcepiton(String message)  \n          {    super(message);    } \n      } \n      class MyException extends RuntimeException  {\n          MyExcepiton(){}  \n        MyExcepiton(String message) \n         {    super(message);    } \n       }\n\n\n\n\n​    \n\nthrows和throw的区别A：有throws的时候可以没有throw。有throw的时候，如果throw抛的异常是Exception体系，那么必须有throws在方法上声明。B：throws用于方法的声明上，其后跟的是异常类名，后面可以跟多个异常类，之间用逗号隔开throw用于方法体中，其后跟的是一个异常对象名\n\n码字不易，求分享、转发。😄\n推荐阅读\n计算机专业电子书下载\nJava电子书_文档教程_高清PDF下载\nPython电子书_文档教程_高清PDF下载\nC/C++电子书_文档教程_高清PDF下载\nLinux电子书_Linux书籍_高清PDF下载\n数据结构与算法相关书籍_PDF电子版下载\n计算机基础_操作系统_汇编语言_计算机网络-电子书PDF下载\n\n","categories":["Java"],"tags":["Java","面试"]},{"title":"提高网站搜索排名_网站博客优化_SEO学习教程（二）","url":"https://tanqingbo.cn/SEO02/","content":"1、符合SEO的网站\n结构清晰、导航明确（树状结构/次导航）\n\nF型结构、树状结构\n\n\nURL标准化、静态化（伪静态）\n\n不友好的URL：动态URL\n友好的URL：静态URL，URL目录不要做的太深，不利于搜索引擎抓取。\n\n\n页面标题、关键词清晰（SEO标签）\n\ntitle标签和h1标签要明确\n\n\n内容互联、分类聚合（锚文本/TAG）\n\n使用锚文本将站内内容串联起来\n站内锚文本：在文章内容页面添加超链接，可以跳转到你想优化的页面。\n\n通过不同纬度分类创建聚合页\n\n\n\n主次分明（301/404/Robots/Nofollow）\n\n域名301：将链接跳转到另一个链接\n404页面：错误页面可以采用404页面\nrobots文件：不重要页面拒绝收录\nnofollow标签：不重要链接拒绝跟踪\n\n\n\n2、建设网站1、传统建站如果是传统建站，你需要具备以下知识：\n\nFTP软件知识:服务端和客户\n服务器(虚拟主机/VPS/云主机) .\n程序(CMS一织梦， 帝国，zblog等)\n优点:可做多种类型，子目录灵活\n传统建站必备技能\n服务器配置:环境配置/安全配置\nPHP (或其他语言)及数据库基础\nFTP软件知识:服务端和客户端\n\n2、Saas建站只需要准备一个域名就可以了。\n自动锚文本怎么做？\n\n在文章内容页面添加超链接，可以跳转到你想优化的页面就可以了。\n\n怎么设置首页标签-TDK？\n\n在&lt;head&gt;标签中重复出现网站关键词，案例如下：\n  IT码农 - 一个专注于程序员成长的网站\n    \n\n    \n\n    \n\n  \n\n   \n\ndescription和keywords标签里面多次出现网站关键词，方便搜索引擎识别。\n\n\n还有分类页、频道页、内容页、单页面的TDK、都这样设置seo标签。\n3、 站内站为了提高本站内容在搜索引擎中的排名，还可以建一个站内站，站内站不是给用户看的，是给搜索引擎看的，在自己网站的主页没有站内站的入口，但是站内站里面同样更新大量内容，由于不是给用户看，内容可以水一点，然后插入自己想优化的锚文本链接。\n4、长尾关键词系统优化目标关键词：直接给你带来客户的关键词\n长尾关键词：间接给你带来客户的关键词\n在内容和页面中多次出现和主题相关二点关键词。\n5、让内容排名更好\n标题出现2-3次长尾关键词\n四处一词（内容中多处出现同一关键词）、图文并茂\n内容越丰富越好、加大关键词的频次、加大锚文本的频次\n\n6、增加关键词密度标签：&lt;img src=\"1.jpg\" alt=\"关键词\"&gt;&lt;a title=\"关键词\"&gt;文字&lt;/a&gt;\n\n主导航和分类导航\n各个模块标题\n文本内容\n网站页眉页脚\n上述都可以增加关键词密度\n码字不易，求分享、转发。😄\n推荐阅读\n计算机专业电子书下载\nJava电子书_文档教程_高清PDF下载\nPython电子书_文档教程_高清PDF下载\nC/C++电子书_文档教程_高清PDF下载\nLinux电子书_Linux书籍_高清PDF下载\n数据结构与算法相关书籍_PDF电子版下载\n计算机基础_操作系统_汇编语言_计算机网络-电子书PDF下载\n\n","categories":["SEO教程"],"tags":[]},{"title":"Java面试题--设计模式与继承多态(二)","url":"https://tanqingbo.cn/Java-interview02/","content":"前面已经分享了一篇Java面试基础知识，《Java面试题–基础知识汇总》，这篇文章接着来分享Java面试的基础知识点。\n1、单例设计模式(1)设计模式：解决某类问题行之有效的方法，是一种思想，是规律的总结(2)用来保证某个类在内存中只有一个对象(3)保证唯一性的思想及步骤:\n\n为了避免其他程序建立该类对象，先禁止其他程序建立该类对象，即将构造函数私有化\n为了其他程序访问到该类对象，须在本类中创建一个该类私有对象\n为了方便其他程序访问到该类对象，可对外提供一个公共访问方式。比如API中的Runtime类就是单例设计模式。\n\n\n单例设计模式的两种方式A:饿汉式 当类加载的时候，就创建对象。\n\tclass Student\t{\t\tprivate Student(){}\t\tprivate static final Student s = new Student();\t\tpublic static Student getInstance()\t{\t\treturn s;\t}}\t\t\n\nB:懒汉式 当使用的使用，才去创建对象。\n\t\tclass Student{\tprivate Student(){}\tprivate static final Student s = null;\t\tpublic static Student getInstance()\t{\t\tif(s==null) \t\t{\t\t\t//线程1就进来了，线程2就进来了。\t\t\ts = new Student();\t\t}\t\treturn s;\t}}\n\n\n\n\n\n\n饿汉式和懒汉式的区别：\n饿汉式是类一加载进内存就创建好了对象；\n懒汉式则是类才加载进内存的时候，对象还没有存在，只有调用了getInstance()方法时，对象才开始创建。\n懒汉式是延迟加载，如果多个线程同时操作懒汉式时就有可能出现线程安全问题，解决线程安全问题,可以加同步来解决。但是加了同步之后，每一次都要比较锁，效率就变慢了，所以可以加双重判断来提高程序效率。\n注：开发常用饿汉式，因为饿汉式简单安全。懒汉式多线程的时候容易发生问题\n\n\n\n2、Math类的使用(重点)\n**数学操作类:**该类没有构造函数，方法均为静态的\n\n成员变量：\n\nE：比任何其他值都更接近e（即自然对数的底数）的double值。\nPI：比任何其他值都更接近pi（即圆的周长与直径之比）的double值。\n\n\n成员方法：\n   static double abs(double a) \n\n\n返回 double 值的绝对值。返回绝对值static double ceil(double a)\n\n返回最小的（最接近负无穷大）double 值，该值大于等于参数，并等于某个整数。\n     static double floor(double a) \n\n返回最大的（最接近正无穷大）double 值，该值小于等于参数，并等于某个整数。 \n   max：返回两个值中较大的那个   min：返回两个值中较小的那个   static long round(double a) 返回最接近参数的 long。   static int round(float a) 返回最接近参数的 int。         \n  static double random() \n\n  返回带正号的 double 值，该值大于等于 0.0 且小于 1.0  static double pow(double a, double b)  返回第一个参数的第二个参数次幂的值\n  static double sqrt(double a) \n\n  返回正确舍入的 double 值的正平方根\n  返回正确舍入的 double 值的正平方根\n\n\n\nRandom类的使用(重点)\n\n产生随机数的类\n\n构造方法:\n\n        Random() 创建一个新的随机数生成器。  \n        Random(long seed) 使用单个 long 种子创建一个新的随机数生成器 \n\n成员方法:\n\n    int nextInt() 返回下一个伪随机数，它是此随机数生成器的序列中均匀分布的 int 值 \n    int nextInt(int n) 返回一个伪随机数，它是取自此随机数生成器序列的、在 0（包括）和指定值（不包括）之间均匀分布的 int 值 \n\n\n3、Scanner类的使用\n可以获取从键盘的输入数据\n\n构造方法：\n  Scanner(InputStream source) 构造一个新的 Scanner，它生成的值是从指定的输入流扫描的。\n        如：Scanner sc = new Scanner(System.in);\n  sc.nextInt();获取整型数据\n  sc.nextLine();获取字符串数据\n\n\n4、继承(重点)\n把很多类的相同特征和行为进行抽取，用一个类来描述。让多个类和这个类产生一个关系。这样的话，多个类就可以省略很多代码。这个关系就是继承。java中用extends关键字表示。\n\n继承的体系结构:\n\n多个具体的对象，不断的向上抽取共享的内容，最终形成了一个体系。这个体系叫做继承体系。\n\n\n继承的特点:\n\njava中只能单继承，没有多继承 \njava可以有多重(层)继承 \n\n\n继承的好处：\n\n继承的出现提高了代码的复用性 \n继承的出现让类与类之间产生了关系，提供了多态的前提。 \n\n\n子父类中的成员关系\n\n成员变量:在子类方法中使用一个变量时,首先，在方法的局部变量中找这个变量，有则使用。否则，在本类中找成员变量，有则使用。否则，在父类中找成员变量，有则使用。否则，报错。\n成员方法:用子类对象使用一个方法时。首先，在子类中找这个方法，有则使用。否则，在父类中找这个方法，有则使用。否则，报错。\n\n\n\n5、重写和重载的区别？\n重载：在同一类中。方法名相同，参数列表不同。重载可以改变返回类型。\n重写：在不同类中(子父类中)。方法声明相同(返回类型，方法名，参数列表均相同)。\n重写需要注意：\n子类方法的访问权限要大于等于父类方法的访问权限。 \n静态只能重写静态。但是这种情况一般不会出现。\n\n\n\n6、构造方法\n子类的实例化过程,子类创建对象时，会先去创建父类的对象。默认是去调用父类的无参构造方法。子类构造方法中，第一行默认是super()\n为什么子类中第一行会默认有super()?\n因为他继承父类的成员使用，使用前这些成员必须初始化，而他们是父类的成员，所以，必须通过父类进行初始化。所以，会先创建一个父类的对象。当父类没有无参构造方法时,必须使用this或者super调用其他的构造方法。\n\n\n\n7、this和super的区别\nthis:代表本类对象的引用。\n\nsuper:代表父类的存储空间。\n8、final关键字(重点)\n最终的意思，可以用于修饰类，方法，变量。\n\nfinal修饰的类不能被继承。\n\nfinal修饰的方法不能被重写。\n\nfinal修饰的变量是一个常量。只能被赋值一次。\n\n内部类只能访问被final修饰的局部变量。\n9、抽象类(重点)\n多个类有相同的方法声明，但是方法体不一样。这个时候，我们考虑把方法声明进行抽取。让子类继承后，自己去实现方法体。没有方法体的方法，我们需要用抽象标志下。\n\n抽象的关键字是：abstract。\n\n抽象类：该方法称为抽象方法，包含抽象方法的类就是抽象类。\n\n抽象类的特点：\n\n抽象类和抽象方法都要用abstract进行修饰\n抽象类不能被实例化\n抽象类中不一定有抽象方法，但是，有抽象方法的类一定是抽象类。\n\n\n抽象类中数据的特点\n\n抽象类中可以有变量，也可以有常量。 \n抽象类中可以有抽象方法，也可以有非抽象方法。 \n抽象类是一个类，所以，它有构造方法。 \n虽然本身不能实例化。但是可以给子类实例化使用。 \n\n\n抽象类中的问题\n\nA:抽象类中是否有构造方法？能不能被实例化？如果不能，为什么有构造方法？\n\n抽象类有构造方法。抽象类不能被实例化。抽象类中的构造方法供子类实例化调用。  \n\n\n抽象关键字abstract不可以和哪些关键字共存？ \n\nprivate:私有内容子类继承不到，所以，不能重写。但是abstract修饰的方法，要求被重写。两者冲突。 \n\nfinal:final修饰的方法不能被重写。而abstract修饰的方法，要求被重写。两者冲突。 \n\nstatic:假如一个抽象方法能通过static修饰，那么这个方法，就可以直接通过类名调用。而抽象方法是没有方法体的，这样的调用无意义。所以，不能用static修饰。 \n\n\n\n抽象类中可不可以没有抽象方法？如果可以，这样的类有什么用吗？ \n\n抽象类可以没有抽象方法。\n抽象类中没有抽象方法的作用，只是为了不让别的类建立该抽象类对象。这个在awt中有体现。\n\n\n\n10、接口interface\n当一个类中的方法都是抽象的时候，java提供了另一种表示方式，叫接口。\n\n用interface关键字表示。类与接口关系用implements表示。\n\n接口的成员特点\n      成员变量 \n      是常量，默认修饰 public static final \n      成员方法 \n      都是抽象的，默认修饰 public abstract \n\n\n    A:类与类的关系 \n    是继承关系。类与类只能单继承，可以多重继承。 \n    B:类和接口的关系\n    是实现关系。类可以多实现接口。 \n    类在继承一个类的同时，可以实现多个接口。 \n    C:接口和接口的关系 \n    是继承关系。接口可以多继承接口。 \n\n接口的特点:\n      是对外暴露的规则 \n      是功能的扩展 \n      接口的出现降低耦合性。 \n      耦合(类与类之间的关系 )\n      内聚(类完成功能的能力) \n      编程规范：低耦合，高内聚。 \n      接口可以多实现。如：CPU和主板、笔记本的USB插口、插座 \n\n接口和抽象类的区别\n\n抽象类只能被单继承接口可以多实现,接口的出现避免了多继承的局限性。 \n\n\n抽象类中的数据特点： \n\n成员变量：可以是变量，也可以是常量 \n成员方法：可以是抽象方法，也可以是非抽象方法 \n构造方法：有构造方法 \n\n\n接口中的数据特点： \n\n成员变量：是常量。默认修饰 public static final \n成员方法：都是抽象方法。都有默认修饰 public abstract \n构造方法：没有构造方法 \n抽象类中定义的是继承体系中的共性功能。接口中定义的是继承体系中的扩展功能。 \n抽象类被继承是”is a”关系:xx是yy的一种,接口被实现是”like a”关系:xx像yy的一种.\n\n\n\n码字不易，求分享、转发。😄\n推荐阅读\n计算机专业电子书下载\nJava电子书_文档教程_高清PDF下载\nPython电子书_文档教程_高清PDF下载\nC/C++电子书_文档教程_高清PDF下载\nLinux电子书_Linux书籍_高清PDF下载\n数据结构与算法相关书籍_PDF电子版下载\n计算机基础_操作系统_汇编语言_计算机网络-电子书PDF下载\n\n","categories":["Java"],"tags":["Java","面试"]},{"title":"Java面试题--基础知识汇总(一)","url":"https://tanqingbo.cn/Java-interview01/","content":"下面进入今天文章的主题。\n1、面向对象面向对象思想：面向对象是相对于面向过程而言的，面向过程强调的是功能，面向对象强调的是将功能封装进对象，强调具备功能的对象；\n\n思想特点\n是符合人们思考习惯的一种思想；\n将复杂的事情简单化了；\n将程序员从执行者变成了指挥者\n\n\n特征：\n\n\n封装：隐藏对象的属性和实现细节，仅对外提供公共访问方式\n继承: 多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义 这些属性和行为，只要继承那个类即可。\n\n多态: 一个对象在程序不同运行时刻代表的多种状态，父类或者接口的引用指向子类对象2、类和对象：\n\n类：对现实世界中某类事物的描述,是抽象的，概念上的定义。\n对象：事物具体存在的个体。\n3、成员变量和局部变量的区别(重点)\n作用域 \n\n成员变量：针对整个类有效。\n局部变量：只在某个范围内有效。(一般指的就是方法,语句体内)\n\n\n存储位置\n\n成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。\n局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中。 当方法调用完，或者语句结束后，就自动释放。\n\n\n初始值\n\n成员变量：有默认初始值。\n局部变量：没有默认初始值，使用前必须赋值。\n\n\n\n4、匿名对象匿名对象就是没有名字的对象。是对象的一种简写形式。应用场景\n\n只调用一次类中的方法。\n可以作为实际参数在方法传递中使用\n\n5、封装：指隐藏对象的属性和实现细节，仅对外提供公共访问方式；比如电脑机箱、笔记本等\n好处：\n\n将变化隔离；\n方便使用；\n提高复用性；\n提高安全性\n\n关键字private：封装在代码中的体现\n\n私有的意思，权限修饰符\n用来修饰成员变量和成员函数\n用private修饰的成员只在本类中有效\n私有是封装的一种体现\n\n6、构造方法：\n特点：方法名与类名相同没有返回类型没有返回值\n作用：构造函数是用于创建对象，并对其进行初始化赋值，对象一建立就自动调用相对应的构造函数，\n构造方法的注意事项:\n如果一个自定义类没有构造方法，系统会默认给出一个无参构造方法。\n如果一个自定义类提供了构造方法，那么，系统将不再给出无参构造方法。 这个时候，你可以不使用无参构造方法。 如果你想使用，那么，就必须手动给出无参构造方法。\n\n建议：一般情况下，我们的自定义类都要手动给出无参构造方法。 \n\n构造方法和成员方法的区别\n格式区别构造方法和类名相同，并且没有返回类型，也没有返回值。普通成员方法可以任意起名，必须有返回类型，可以没有返回值。\n作用区别构造方法用于创建对象，并进行初始化值。普通成员方法是用于完成特定功能的。\n调用区别构造方法是在创建对象时被调用的，一个对象建立，只调用一次相应构造函数,普通成员方法是由创建好的对象调用，可以调用多次\n\n\n\n7、构造代码块：作用：给对象进行初始化，对象一建立就执行，而且优先于构造函数执行\n构造代码块和构造函数的区别：\n\n构造代码块是给所有不同对象的共性进行统一初始化\n构造函数是给对应的对象进行初始化\n\n8、this关键字\nthis关键字代表本类对象的一个引用，谁调用this所在的方法，this就代表谁  \nthis的使用场景\n\n\n用于区分同名成员变量和局部变量；\n在定义函数时，该函数内部要用到调用该函数的对象时，因为此时对象还没建立，故this代表此对象\n构造函数间调用这个时候，this(参数)必须作为第一条语句存在。9、Person p = new Person();在内存中做了哪些事情。\n将Person.class文件加载进内存中。\n如果p定义在主方法中，那么，就会在栈空间开辟一个变量空间p。\n在堆内存给对象分配空间。\n对对象中的成员进行默认初始化。\n对对象中的成员进行显示初始化。\n调用构造代码块对对象进行初始化。(如果没有就不执行)\n调用构造方法对对象进行初始化。对象初始化完毕。\n将对象的内存地址赋值给p变量，让p变量指向该对象。10、static关键字：静态的意思，用来修饰成员变量和成员函数\n\n静态的特点:\n\n随着类的加载而加载、优先于对象存在、对所有对象共享、可以被类名直接调用\n\n静态的注意事项\n\n为什么静态方法只能访问静态成员：因为静态的内容是随着类的加载而加载，它是先进内存的。\n\n静态方法中不能使用this,super关键字\n\n主方法是静态的\npublic static void main(String[] args)public:公共的意思，是最大权限修饰符。static:由于jvm调用main方法的时候，没有创建对象。只能通过类名调用。所以，main必须用static修饰。void:由于main方法是被jvm调用，不需要返回值。用void修饰。main:main是主要的意思，所以jvm采用了这个名字。是程序的入口。String[]:字符串数组args:数组名在运行的时候，通过java命令给args数组赋值。格式：java MainTest hello world itcast\n\n\n\n\n\n11、静态变量和成员变量的区别调用方式\n\n静态变量也称为类变量，可以直接通过类名调用。也可以通过对象名调用。这个变量属于类。\n成员变量也称为实例变量，只能通过对象名调用。这个变量属于对象。\n\n存储位置\n\n静态变量存储在方法区中的静态区。\n成员变量存储在堆内存。\n\n生命周期\n\n静态变量随着类的加载而存在，随着类的消失而消失。生命周期长。\n成员变量随着对象的创建而存在，随着对象的消失而消失。\n\n与对象的相关性\n\n静态变量是所有对象共享的数据。\n成员变量是每个对象所特有的数据。\n\n静态的优点和弊端\n\n优点：对对象的共享数据进行单独空间的存储，节省内存，没有必要每个对象都存储一份可直接被类名调用\n弊端：生命周期过长，随着类的消失而消失访问出现权限，即静态虽好但只能访问静态\n\n什么使用使用静态呢？\n\n当所有对象共享某个数据的时候，就把这个成员变量定义为静态修饰的。\n当某个方法没有访问该类中的非静态成员，就可以把这个方法定义为静态修饰。\n静态的生命周期比较长，所以一般不推荐使用。\n\n静态代码块\n\n它只执行一次，它比main还先执行。\n执行顺序静态代码块–构造代码块–构造方法\n\n12、制作API(次重点)API(全拼):Application Program Interface 应用程序编程接口。\n\n类中的内容需要用文档注释。\n\n使用JDK\\bin目录下的javadoc工具。\n格式:javadoc -d 目录 -author -version ArrayTool.java\n\n\n\n\n码字不易，求分享、转发。😄\n推荐阅读\n计算机专业电子书下载\nJava电子书_文档教程_高清PDF下载\nPython电子书_文档教程_高清PDF下载\nC/C++电子书_文档教程_高清PDF下载\nLinux电子书_Linux书籍_高清PDF下载\n数据结构与算法相关书籍_PDF电子版下载\n计算机基础_操作系统_汇编语言_计算机网络-电子书PDF下载\n\n","categories":["Java"],"tags":["Java","面试"]},{"title":"计算机专业几本必看的书！","url":"https://tanqingbo.cn/computer-book/","content":"当今社会，要说哪个专业或者领域最火爆最受欢迎，计算机专业当之无愧可以进入Top3。日常生活中的各行各业都离不开计算机的支持，无处不在。而且，计算机行业给的薪资也是非常非常非常可观令人心动！(本人就是因为计算机赚的多才选的计算机专业，如今头发已经快掉完了，哈哈哈)。\n但是，计算机专业所涵盖知识之广，难度之大，让很多小白或者刚入门的同学望而生却，不知所措。今天，我就为大家推荐几部我在学习计算机的路上，对我帮助最大的几本书，帮助各位快速并且系统的学习计算机专业，文末附下载地址。\n1.《深入理解计算机系统》（CSAPP）\n\n无论是处于哪个阶段的同学，这部书都是必备的。正如此书开篇作者所言“如果你全心投身学习这本书中的概念，完全理解底层计算机系统以及它对应用程序的理解，你会步上成为为数不多的大牛之路”。这是一本很基础的书，涵盖了计算机组成原理，操作系统，体系结构，网络编程，并行程序设计原理等课程的基础知识。学习这本书，你就会对计算机底层世界有一个宏观的认知，搞清楚计算机底层的工作原理，为什么它可以完成如此复杂的工作？为什么一个小小的cpu却又如此强大？最简单的“hello,word”程序是怎么运行的?当然，因为这本书包含很多概念，专业术语，读起来可能比较晦涩，大家也不必一口气读完，可以在学习整个计算机过程中慢慢去读，慢慢理解。\n2.关于编程语言\n到底哪种编程语言是世界上最好的语言是程序员永远无法达成一致的世界难题。小编结合自身五年的学习经验以及针对当前社会的需求，给大家推荐三门编程语言（C++/Java/Python）以及相关的书籍。\n1）《C++ Primer》\n\n这是一本久负盛名的C++经典教程。无论是初学者入门，或是中/高级程序员提升，这本书都是不容置疑的首选！！！\n2）《Java编程思想》\n\n这本书赢得了全球程序员的广泛赞誉，即使是最晦涩的概念，在作者的文字和示例面前都迎刃而解。从Java的基础语法到最高级特性，这本书都可以指导你一步步的轻松的去理解和掌握！这本书小编我在大二学了一整年，学完之后真的完成了质的飞跃！亲身体验，非常推荐给大家！\n3）《Fluent Python》\n\n近两年小编用的编程语言就是python。现在网络上对于python的教材真的是五花八门，内容过于重复和繁琐，对我们帮助并不大。关于这本书我可以很果断的说，这是世面上关于python最好的书！并且真是书的风格特别友好，读的时候你会感觉一个博学但是温柔的大叔再跟你侃侃而谈。\n3.数据结构与算法分析掌握了最基本的编程语言，就该学习更高级的知识了，也是程序员核心知识——数据结构与算法分析。只有掌握了这些，才可能写的更好更高效的程序，才能将语言更好地用于实际问题的解决。当然，这部分知识也是比较难学的。接下来给大家推荐三本我认为非常好的三本相关书籍。\n1)《数据结构(C++语言版)》\n\n建议各位同学将这本书配合邓俊辉老师的网课一起使用，事半功倍！\n2）《算法图解》\n\n这本书的特点就是示例非常丰富，图文并茂，特别容易理解，对于初学者特别友好，概念拆分的也很清晰。非常非常适合入门！\n3）《算法导论》\n\nemmmmm这本书真的是算“圣书”了，如果把它从头到尾看完并且搞明白了，那么恭喜你，月入百万不是梦！\n4.一些建议\n1）在大家学习计算机相关知识的时候，一定要好好利用网络上的资源，好好利用百度和谷歌。有什么不会的直接上网搜，肯定会有很多优秀的博主为你排忧解惑。2）对于编程语言的学习，一定要多动手写代码，在实战中掌握。而且C++/Java/Python掌握一门就够了。大同小异，当你精通一门语言之后，如果想要学习其他语言，就会非常的快。3）学习数据结构和算法分析，一定一定要在看懂之后自己用自己喜欢的编程语言实现一遍，一定要亲自实现一遍呀！！！这一点太重要了。这样你就能很快的掌握而且再一次加强编程能力。\n5、最后\n上面推荐的基本书建议大家购买正版阅读，此外也给大家提供电子版的下载地址：链接：https://pan.baidu.com/s/1KgS7JvjrASSc3-YTet1SCw\n提取码：6m5l\n希望对大家能有帮助！\n其他电子书下载\nJava电子书_文档教程_高清PDF下载\nPython电子书_文档教程_高清PDF下载\nC/C++电子书_文档教程_高清PDF下载\nLinux电子书_Linux书籍_高清PDF下载\n数据结构与算法相关书籍_PDF电子版下载\n计算机基础_操作系统_汇编语言_计算机网络-电子书PDF下载\n机器学习，人工智能经典必读电子书（PDF）下载\n设计模式经典图书电子书下载\nMYSQL、MongoDB数据库经典电子书下载\nGo语言经典电子书pdf下载\n程序员面试相关经典书籍免费下载\n\n","categories":["编程资料"],"tags":[]},{"title":"我们都是好孩子","url":"https://tanqingbo.cn/We-are-all-good-kids/","content":"\n高中时心底曾藏有一个女神，却因为勇气不足而错失良机。上大学填志愿的时候，填了一个离家万里的学校，每年才回一次家…… 但这些都不重要，因为学生年代是青春，少不了挫折与折腾，不必遗憾，这个世界有一点好就是，就是无论离开了谁，世界都一样正常运转。时至今日，当我再次回头认真看待过去时，发觉或许正是填了一个离家万里的学校，才开启了我精彩的人生。\n\n\n大学毕业的时候，我妈打电话问我什么时候可以离校，我说20号左右。但是临离校的前两天我都还没有买回家的票，我妈大概是猜到我又想先出去玩的心思，她开始着急了，说家里的好菜都给你备好了，但我坚持要晚一段时间才回家，她也就没说什么了，只是后来有点伤感。\n\n我就像一只在天空飞翔的风筝，一方面享受着被爸妈牵挂的安全感，另一方面又想飞的再高一点，多看一眼这片蓝天，我知道迟早有一天要被收回去，但是我真的想再多飞一会儿。\n\n突然想起了初中，那时的我还只是一个乖乖的学生，没有叛逆，好像除了读书之外没有其他任何想法，只是像绝大多数普通的孩子那样消耗着普通的青春，享受着单纯的欢愉。\n\n一直到初中毕业，作为这一阶段的结束总下要留下点什么纪念一下，于是大家纷纷买了同学录，给每个同学发一张。同学录里面有一栏里面要填的是“你的梦想是什么？”，可是“梦想”到底是个什么东西，那时的自己并不知道，于是就像抄作业一样，我抄了一个“当一名科学家”，反正没有正确答案，所以也没有对错之分，写完之后也就渐渐淡忘了。直到前两天，在上课的时候老师对我们说：“你们是博士，是未来的科学家啊！”我才突然在某一瞬间挖出前面那段深埋在童年记忆里的场景，而一旦回想起来，我仿佛穿越时空站在时光那头静观自己。世界是多么的美妙啊，兜兜转转大半圈，又重新回到了最初的那个航向。\n\n\n\n再来聊聊旅行！我从来都不是一个果敢的人，但旅行除外。\n\n在某次在逛书店的过程中认识一个朋友（之前认识，但不熟），由于都喜欢看书，我们便互相推荐自己最近看的书，久而久之便熟了起来。后来经常能在朋友圈里看到她在全国各地旅游的照片，那个时候就觉得这个姑娘太帅了，一个人就敢背着包全国各地跑，生活就应该活成这个样子。\n\n大一暑假的时候，我终于鼓足勇气，把攒下来的所有钱全都拿出来买了一套户外装备，跟着一群小伙伴去甘肃省徒步了，那是我第一次徒步，也是第一旅行，300多公里路，没想到我真的一步一步走完了。而在这一惊险刺激的旅程中的所见所悟于我而言像是打开了新世界的大门。\n\n虽然这是发生在好几年前的事情，但现在看来，我依然觉得它是我人生阶段的一个重要转折，也是从那时起，我喜欢上了旅行，我努力的攒奖学金，一发钱就一个人背着包去全国各地旅行。东南西北、高原沙漠，都一一去领略过它们的风采。在路上，你不知道接下来会发生什么，又会遇到怎样有趣的人，这种新鲜感很让我着迷。\n\n旅行确实是成为了我生命中不可或缺的一部分，但严格来讲，一直但现在，我都没有它列入我的梦想，因为我想做的仅仅是一步步、慢慢地走向自己真正想去的地方。\n\n当然，这些故事中也有一些小插曲。\n\n去年夏天的时候在爬泰山的时候认识了YXE，后来又因为行程一致，一起又在北京待了几天。泰山是真的好美，YXE也是真的去过不少地方，于是我问她：“下半年有什么行程吗？”他说去德国，录取通知书已经到了，她想在出国之前多去一些地方，并且让我有时间可以去德国找她玩。去德国的念头只是在我的脑海里一闪而过，更多的则是羡慕她不到20岁的年龄却一个人去了这么多地方的旅行经历。可未曾想在去年冬天的时候，我真的收到了她在德国寄来的信，让我有时间去欧洲看看，她全程免费导游。\n\n\n\n前段时间，我的室友搬出去，就剩我一个人住了，那天晚上我发了一条朋友圈：\n\n\n曾经也幻想过要是一个人住就好了，我可以在宿舍看电影的时候把外放声音调到最大，通宵学习也不怕打扰到别人。可是终于要一个人住的时候，心里却有一种说不上来的落魄感，终于晚上回来连个说话的人都没有了～\n\n\n第二天早上醒来，收到一朋友发来的微信：还好吗？看到这三个字的时候差点就哭了出来，在一堆调侃的信息当中，我庆幸的是至少还有人关心我到底过的好不好的。\n\n前两天跟一群博士吃饭的时候，我说我买了一台相机，想要拍一些好看的照片。对方很惊讶的问我说：“博士不是应该好好做科研工作吗？为什么还买相机呢？”说实话，听了这个问题之后我思考了好久，我承认来这边这么久了，我还从来没有把自己当作一个科研工作者全身心的投入工作，但我并不觉得摄影与科研矛盾，我害怕一成不变的生活，或许在枯燥的科研生活当中加上一点不那么靠谱的爱好进去也能够取得事半功倍的效果。\n\n每个人心中都有一根弦，都有一套属于自己的衡量世界的标准，我想在我的这根弦还没有绷紧之前，再多折腾一会，毕竟每个人的20岁只有一次，毕竟吹过的牛逼还没实现呢~\n\n\n","categories":["技术以外"],"tags":[]},{"title":"提高网站搜索排名_网站博客优化_SEO学习教程（一）","url":"https://tanqingbo.cn/SEO01/","content":"1、行业分析\n聚焦，给用户提供什么，为什么要选择你。要么Java、要么Linux。\n先是顶级关键词、然后再细分。\n\n2、用户需求\n同一个产品，不同用户搜索的关键词不一样。\n关于秋天的作文\n关于秋天的句子\n\n\n学会利用百度指数的需图谱：http://index.baidu.com/v2/index.html#/\n和程序员相关的哪一类词？”编程”不错！\n\n3、网站类型\n细分，研究行业关键词，再细分。\n\n4、内容来源\n来自书籍\n内容组合\n围绕文章标题找出4个问题，把这4个问题的答案进行组合，一篇文章就搞定了。（写作技巧，牛逼！！！）\neg：去新加坡留学选哪个大学好？（围绕这个标题问4个问题）\n哪些大学？学费？适合的专业？留学条件？（去网上、书上找答案）\n\n\n\n\n微信公众号：找相关的公众号原创，搬运过来就行。\n翻译内容\n\n5、关键字确定和长尾挖掘1、目标关键词优化\n首页目标关键词的优化和排名\n\n关键词的确定：ABC拓词法\n​    eg： 办公室    鲜花    租摆     \n\n\n\n办公室\n鲜花\n租摆\n\n\n\nA\nB\nC\n\n\n会场\n绿值\n出租\n\n\n室内\n盆栽\n租赁\n\n\n​            \n\n标题可以取为：A1B1C1_A2B2C2_A3B3C3 - 公司名      （其中A1A2A3是A的近义词）\n\n办公室鲜花租摆_会场绿值出租_室内盆栽租赁——公司名\n\n\n这种做法既可以避免百度算法屏蔽、又包括了所有搜索场景\n\n\n2、长尾关键词优化\n内页，也就是产品页面、栏目页面的优化和排名\n\n普通的做网站、做内容是有什么内容发什么内容，而做seo是先围绕网站的方向，找到潜在用户会搜的词，然后围绕这些关键词去做内容。\n\n挖掘长尾：\n第一个方法就是通过百度相关搜索。\n认认真真的拿起百度，把你这个行业里面的你能想到的很多词进行搜索。搜索之后，你就会看到搜索这个相关搜索里面有很多的这个相关词，这些相关词就非常的有价值。\n而且都是有用户搜索的，你的网站上面就去做这些词的时候，对你的网站的这个价值就会大大提高。\n\n\n  第二个方法就是分析十个你同行的网站，就是你所在的这个行业一定有十个做的非常好的网站，然后呢，你通过工具把这十个网站他在搜索引擎上有排名的一些关键词，把它拿出来。然后把同行他排名比较好的那些词拿起来做同义词替换再排列组合。\n6、站内优化\n交换30个友情链接，两个月内，陆续交换友情链接\n什么是站内站？做一个站内站。\n\n码字不易，求分享、转发。😄\n推荐阅读\n计算机专业电子书下载\nJava电子书_文档教程_高清PDF下载\nPython电子书_文档教程_高清PDF下载\nC/C++电子书_文档教程_高清PDF下载\nLinux电子书_Linux书籍_高清PDF下载\n数据结构与算法相关书籍_PDF电子版下载\n计算机基础_操作系统_汇编语言_计算机网络-电子书PDF下载\n\n","categories":["SEO教程"],"tags":[]},{"title":"Java经典电子书PDF下载","url":"https://tanqingbo.cn/哪本书适合推荐给 Java 初学者？/","content":"作为一个程序员应该知道，Java常年占据编程语言的排行版第一，而且在web开发、移动互联网开发以及大数据开发三大领域常年占据霸主地位，而且由于Java的稳定性，很多大型科技公司都愿意采用Java解决方案，这就意味着每个互联网都会设置大量的Java岗，竞争压力相对较小。\n那么，有那些经典的书籍适合给Java初学者来看呢？文末附下载地址。\n一、Java基础1、《Head First Java》\n这本书适合零基础入门Java的人，插图很多，内容风趣且通俗易懂，基本上涵盖了所有Java相关的基础知识，对于基础不行的小白、又不喜欢看大段文字的人来说再适合不过了。\n2、《Java核心技术 卷Ⅰ 基础知识》\n这本书在Java领域是和Java编程思想齐名的一本书，很多知识点都讲的特别细，我初次看的时候发现课上好多没讲的基础知识这本书上都提到了，非常有助于你练好扎实的基础知识。\n二、Java中级1、《大话设计模式》\n设计模式就像是编程界的招式、套路一样，你在开发的过程中遇到的大多数问题都有对应的招式帮你解决。这样我们写起代码来就会轻松许多，将来别人来维护你的代码也会更容易一些。\n基于这个原因，学好设计模式对程序员也就非常重要了，可以说是面试官必问的知识点之一。这本书通过讲故事的方式来讲述程序设计，把不同的设计模式放到对应的场景中，特别容易理解，更重要的是书中所有的代码都是Java实现的。\n2、《分布式Java应用基础与实践》\n本书介绍分布式Java应用涉及的知识点，分为基于Java实现网络通信、RPC；基于SOA实现大型分布式Java应用；编写高性能Java应用；构建高可用、可伸缩的系统四个部分，是一本不折不扣的“理论结合实践”之作。\n3、《Java并发编程实践》\n随着多核处理器的普及，使用并发成为构建高性能应用程序的关键。Java在开发并发程序中也取得了显著的进步，提高了Java虚拟机的性能以及并发类的可伸缩性，并加入了丰富的新并发构建块。在《JAVA并发编程实践》中，作者不仅解释了并发它们究竟如何工作、如何使用，还阐释了创造它们的原因，及其背后的设计模式。\n三、Java高级1、《大型网站技术架构：核心原理与案例分析》\n该书通过梳理大型网站技术发展历程，剖析大型网站技术架构模式，深入讲述大型互联网架构设计的核心原理，并通过一组典型网站技术架构设计案例，为读者呈现一幅包括技术选型、架构设计、性能优化、Web 安全、系统发布、运维监控等在内的大型网站开发全景视图。适用于指导网站工程师、架构师进行网站技术架构设计。\n2、《代码整洁之道》\n这本书自出版以来，一直被亚马逊评为销量最高的5本技术书籍之一，作者也被亲切的成为“Bob叔”，他有句名言：任何一个傻瓜都能写出计算机可以理解的代码，惟有写出人类容易理解的代码，才是优秀的程序员。\n以上所提到的所有书籍下载地址：\n链接：https://pan.baidu.com/s/1bWbADyzCaDV5H6vGDOPPRw提取码：zdcz \n最为Java初学者该看那些书，这也是我的一家只谈，欢迎各位留言区交流讨论！\n其他电子书下载\nJava电子书_文档教程_高清PDF下载\nPython电子书_文档教程_高清PDF下载\nC/C++电子书_文档教程_高清PDF下载\nLinux电子书_Linux书籍_高清PDF下载\n数据结构与算法相关书籍_PDF电子版下载\n计算机基础_操作系统_汇编语言_计算机网络-电子书PDF下载\n机器学习，人工智能经典必读电子书（PDF）下载\n设计模式经典图书电子书下载\nMYSQL、MongoDB数据库经典电子书下载\nGo语言经典电子书pdf下载\n程序员面试相关经典书籍免费下载\n\n","categories":["编程资料"],"tags":["Java"]},{"title":"历年微软面试中出现的leetcode算法题","url":"https://tanqingbo.cn/历年微软面试中出现的leetcode算法题/","content":"应网友要求，汇总了上百道历年微软面试中出现的算法题，该帖子根据牛客网上网友们分享的微软面经汇集而成，保证整理的每一道算法题都在面试中出现过：\n\n根据这个些算法题，大家可以看到大厂算法习惯考查的方向，也可以更有针对性的准备面试，希望对大家有用。每一题目的出处与原始牛客链接对应关系见issues，以下是面试题整理的表格，分别注明了题目、出现的次数以及leetcode的链接：\n\n\n\n题目\n出现次数\n链接\n\n\n\n215. 数组中的第K个最大元素\n6\nhttps://leetcode-cn.com/problems/kth-largest-element-in-an-array\n\n\n124. 二叉树中的最大路径和\n4\nhttps://leetcode-cn.com/problems/binary-tree-maximum-path-sum\n\n\n468. 验证IP地址\n3\nhttps://leetcode-cn.com/problems/validate-ip-address\n\n\n236. 二叉树的最近公共祖先\n3\nhttps://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree\n\n\n206. 反转链表\n3\nhttps://leetcode-cn.com/problems/reverse-linked-list\n\n\n91. 解码方法\n3\nhttps://leetcode-cn.com/problems/decode-ways\n\n\n94. 二叉树的中序遍历\n3\nhttps://leetcode-cn.com/problems/binary-tree-inorder-traversal\n\n\n15. 三数之和\n3\nhttps://leetcode-cn.com/problems/3sum\n\n\n121. 买卖股票的最佳时机\n3\nhttps://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock\n\n\n48. 旋转图像\n3\nhttps://leetcode-cn.com/problems/rotate-image\n\n\n543. 二叉树的直径\n3\nhttps://leetcode-cn.com/problems/diameter-of-binary-tree\n\n\n53. 最大子序和\n3\nhttps://leetcode-cn.com/problems/maximum-subarray\n\n\n4. 寻找两个正序数组的中位数\n2\nhttps://leetcode-cn.com/problems/median-of-two-sorted-arrays\n\n\n110. 平衡二叉树\n2\nhttps://leetcode-cn.com/problems/balanced-binary-tree\n\n\n146. LRU缓存机制\n2\nhttps://leetcode-cn.com/problems/lru-cache\n\n\n103. 二叉树的锯齿形层次遍历\n2\nhttps://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal\n\n\n450. 删除二叉搜索树中的节点\n2\nhttps://leetcode-cn.com/problems/delete-node-in-a-bst\n\n\n415. 字符串相加\n2\nhttps://leetcode-cn.com/problems/add-strings\n\n\n62. 不同路径\n2\nhttps://leetcode-cn.com/problems/unique-paths\n\n\n22. 括号生成\n2\nhttps://leetcode-cn.com/problems/generate-parentheses\n\n\n1. 两数之和\n2\nhttps://leetcode-cn.com/problems/two-sum\n\n\n79. 单词搜索\n2\nhttps://leetcode-cn.com/problems/word-search\n\n\n200. 岛屿数量\n2\nhttps://leetcode-cn.com/problems/number-of-islands\n\n\n89. 格雷编码\n2\nhttps://leetcode-cn.com/problems/gray-code\n\n\n98. 验证二叉搜索树\n2\nhttps://leetcode-cn.com/problems/validate-binary-search-tree\n\n\n剑指 Offer 46. 把数字翻译成字符串\n1\nhttps://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof\n\n\n84. 柱状图中最大的矩形\n1\nhttps://leetcode-cn.com/problems/largest-rectangle-in-histogram\n\n\n120. 三角形最小路径和\n1\nhttps://leetcode-cn.com/problems/triangle\n\n\n5. 最长回文子串\n1\nhttps://leetcode-cn.com/problems/longest-palindromic-substring\n\n\n867. 转置矩阵\n1\nhttps://leetcode-cn.com/problems/transpose-matrix\n\n\n560. 和为K的子数组\n1\nhttps://leetcode-cn.com/problems/subarray-sum-equals-k\n\n\n986. 区间列表的交集\n1\nhttps://leetcode-cn.com/problems/interval-list-intersections\n\n\n78. 子集\n1\nhttps://leetcode-cn.com/problems/subsets\n\n\n907. 子数组的最小值之和\n1\nhttps://leetcode-cn.com/problems/sum-of-subarray-minimums\n\n\n162. 寻找峰值\n1\nhttps://leetcode-cn.com/problems/find-peak-element\n\n\n547. 朋友圈\n1\nhttps://leetcode-cn.com/problems/friend-circles\n\n\n1013. 将数组分成和相等的三个部分\n1\nhttps://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum\n\n\n34. 在排序数组中查找元素的第一个和最后一个位置\n1\nhttps://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array\n\n\n142. 环形链表 II\n1\nhttps://leetcode-cn.com/problems/linked-list-cycle-ii\n\n\n572. 另一个树的子树\n1\nhttps://leetcode-cn.com/problems/subtree-of-another-tree\n\n\n154. 寻找旋转排序数组中的最小值 II\n1\nhttps://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii\n\n\n704. 二分查找\n1\nhttps://leetcode-cn.com/problems/binary-search\n\n\n151. 翻转字符串里的单词\n1\nhttps://leetcode-cn.com/problems/reverse-words-in-a-string\n\n\n171. Excel表列序号\n1\nhttps://leetcode-cn.com/problems/excel-sheet-column-number\n\n\n39. 组合总和\n1\nhttps://leetcode-cn.com/problems/combination-sum\n\n\n150. 逆波兰表达式求值\n1\nhttps://leetcode-cn.com/problems/evaluate-reverse-polish-notation\n\n\n283. 移动零\n1\nhttps://leetcode-cn.com/problems/move-zeroes\n\n\n767. 重构字符串\n1\nhttps://leetcode-cn.com/problems/reorganize-string\n\n\n10. 正则表达式匹配\n1\nhttps://leetcode-cn.com/problems/regular-expression-matching\n\n\n459. 重复的子字符串\n1\nhttps://leetcode-cn.com/problems/repeated-substring-pattern\n\n\n973. 最接近原点的 K 个点\n1\nhttps://leetcode-cn.com/problems/k-closest-points-to-origin\n\n\n3. 无重复字符的最长子串\n1\nhttps://leetcode-cn.com/problems/longest-substring-without-repeating-characters\n\n\n72. 编辑距离\n1\nhttps://leetcode-cn.com/problems/edit-distance\n\n\n剑指 Offer 21. 调整数组顺序使奇数位于偶数前面\n1\nhttps://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof\n\n\n剑指 Offer 36. 二叉搜索树与双向链表\n1\nhttps://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof\n\n\n887. 鸡蛋掉落\n1\nhttps://leetcode-cn.com/problems/super-egg-drop\n\n\n剑指 Offer 26. 树的子结构\n1\nhttps://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof\n\n\n328. 奇偶链表\n1\nhttps://leetcode-cn.com/problems/odd-even-linked-list\n\n\n137. 只出现一次的数字 II\n1\nhttps://leetcode-cn.com/problems/single-number-ii\n\n\n155. 最小栈\n1\nhttps://leetcode-cn.com/problems/min-stack\n\n\n剑指 Offer 52. 两个链表的第一个公共节点\n1\nhttps://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof\n\n\n1375. 灯泡开关 III\n1\nhttps://leetcode-cn.com/problems/bulb-switcher-iii\n\n\n662. 二叉树最大宽度\n1\nhttps://leetcode-cn.com/problems/maximum-width-of-binary-tree\n\n\n76. 最小覆盖子串\n1\nhttps://leetcode-cn.com/problems/minimum-window-substring\n\n\n449. 序列化和反序列化二叉搜索树\n1\nhttps://leetcode-cn.com/problems/serialize-and-deserialize-bst\n\n\n47. 全排列 II\n1\nhttps://leetcode-cn.com/problems/permutations-ii\n\n\n300. 最长上升子序列\n1\nhttps://leetcode-cn.com/problems/longest-increasing-subsequence\n\n\n152. 乘积最大子数组\n1\nhttps://leetcode-cn.com/problems/maximum-product-subarray\n\n\n44. 通配符匹配\n1\nhttps://leetcode-cn.com/problems/wildcard-matching\n\n\n739. 每日温度\n1\nhttps://leetcode-cn.com/problems/daily-temperatures\n\n\n122. 买卖股票的最佳时机 II\n1\nhttps://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii\n\n\n20. 有效的括号\n1\nhttps://leetcode-cn.com/problems/valid-parentheses\n\n\n207. 课程表\n1\nhttps://leetcode-cn.com/problems/course-schedule\n\n\n700. 二叉搜索树中的搜索\n1\nhttps://leetcode-cn.com/problems/search-in-a-binary-search-tree\n\n\n701. 二叉搜索树中的插入操作\n1\nhttps://leetcode-cn.com/problems/insert-into-a-binary-search-tree\n\n\n1312. 让字符串成为回文串的最少插入次数\n1\nhttps://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome\n\n\n剑指 Offer 33. 二叉搜索树的后序遍历序列\n1\nhttps://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof\n\n\n139. 单词拆分\n1\nhttps://leetcode-cn.com/problems/word-break\n\n\n557. 反转字符串中的单词 III\n1\nhttps://leetcode-cn.com/problems/reverse-words-in-a-string-iii\n\n\n60. 第k个排列\n1\nhttps://leetcode-cn.com/problems/permutation-sequence\n\n\n剑指 Offer 04. 二维数组中的查找\n1\nhttps://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof\n\n\n推荐阅读\nJava电子书_文档教程_高清PDF下载\nPython电子书_文档教程_高清PDF下载\nC/C++电子书_文档教程_高清PDF下载\nLinux电子书_Linux书籍_高清PDF下载\n数据结构与算法相关书籍_PDF电子版下载\n计算机基础_操作系统_汇编语言_计算机网络-电子书PDF下载\n机器学习，人工智能经典必读电子书（PDF）下载\n设计模式经典图书电子书下载\nMYSQL、MongoDB数据库经典电子书下载\nGo语言经典电子书pdf下载\n程序员面试相关经典书籍免费下载\n\n","categories":["编程资料"],"tags":["算法","面试"]},{"title":"如何学习设计模式？","url":"https://tanqingbo.cn/How-to-learn-design-patterns/","content":"记得我第一次独立做一个项目的时候，当时没什么经验，开始之前也没有什么规划，想到需要啥功能就去实现啥功能，最后做到一半的时候发现进行不下去了。\n一会发现要给对象添加新属性，于是改对象、改构造函数、然后又发现数据库的表格设计的也不对，需要改数据库，添加新功能的时候，不仅要写新功能的代码，前面写的所有代码相应都要改一下……\n这就是吃了没有把设计模式学好的亏，其实我们把程序员分成两类，一种是懂设计模式，一种是不懂设计模式，不懂设计模式的程序员不管写了多少行代码，可能都体会不到编程真正的美。\n比如一个系统有好几种角色：老师、同学。工厂模式可以帮你实例化，就算未来可以能还有新的角色，也不用多添加或者改动原来的一行代码。\n给对象添加新功能，装饰模式帮你搞定，对象太大，想要提高响应速度，可以考虑用代理模式。\n你看设计模式就像是招式、套路一样，你在开发的过程中遇到的大多数问题都有对应的招式帮你解决，这样我们做起事情来就会轻松许多，将来别人来维护你以前写的代码也会更容易一些。\n基于这些原因，你应该知道学好设计模式对程序员有多重要了。\n那么怎么学好设计模式呢？\n之前我们学长跟我说过一句话，让我印象很深刻，他说：“看书要比自己到网上找教程要高效很多，书上的知识更成体系，作为一个初学者，把该方向的一本经典书看完，问题差不多就解决了95%。”\n所以给大家推荐一本设计模式比较经典的书，《Head First 设计模式(中文版)》，豆瓣评分9.2分，可能是这个方向评分最高的一本书。\n\n据我所知不少顶级高校，用的教材就是这本书，看完之后你的编程能力肯定会有很大的提升。推荐购买正版，PDF电子版也提供给大家。\n链接：https://pan.baidu.com/s/1Ean9-sIQcfGGFb9mTHQh1Q提取码：hpyi \n其他电子书下载\nJava电子书_文档教程_高清PDF下载\nPython电子书_文档教程_高清PDF下载\nC/C++电子书_文档教程_高清PDF下载\nLinux电子书_Linux书籍_高清PDF下载\n数据结构与算法相关书籍_PDF电子版下载\n计算机基础_操作系统_汇编语言_计算机网络-电子书PDF下载\n机器学习，人工智能经典必读电子书（PDF）下载\n设计模式经典图书电子书下载\nMYSQL、MongoDB数据库经典电子书下载\nGo语言经典电子书pdf下载\n程序员面试相关经典书籍免费下载\n\n","categories":["设计模式"],"tags":["设计模式"]},{"title":"想学Linux，这一本书就够了！","url":"https://tanqingbo.cn/程序员绕不去的槛，Linux！！！/","content":"如果你是个程序员的话，那你肯定绕不过Linux这个坎，因为你写代码的时候免不了要和服务器打交道，而服务器用的都是Linux操作系统，倒不是Windows系统不能做服务器，是Windows一旦用作商业用途就得花各种钱，而Linux系统不仅免费、开源，而且还安全稳定，所以大多数的公司都是选择的Linux服务器。\n也就是说，如果你想去一家好的公司上班，那Linux的一些常规操作是必须要会的，而且面试的时候，面试官也肯定会问。所以这里给大家推荐一本书《Linux鸟哥私房菜》，帮大家学好Linux知识。\n\n这本书想必大家都听说过，很多人奉它为Linux学习的圣经，可以说是Linux入门必读的书籍，里面的内容也确实很全面，而且非常口语化，容易理解接受，目前这本书已经更新到第四版了。\n\n建议大家学习的时候可以购买正版，此外也给大家准备了这根本书的高清PDF下载地址：\n链接：https://pan.baidu.com/s/1x-vaW1OU5SFEetbexmFArg提取码：03oz需要的朋友自行下载~\n其他电子书下载\nJava电子书_文档教程_高清PDF下载\nPython电子书_文档教程_高清PDF下载\nC/C++电子书_文档教程_高清PDF下载\nLinux电子书_Linux书籍_高清PDF下载\n数据结构与算法相关书籍_PDF电子版下载\n计算机基础_操作系统_汇编语言_计算机网络-电子书PDF下载\n机器学习，人工智能经典必读电子书（PDF）下载\n设计模式经典图书电子书下载\nMYSQL、MongoDB数据库经典电子书下载\nGo语言经典电子书pdf下载\n程序员面试相关经典书籍免费下载\n\n","categories":["编程资料"],"tags":["Linux"]},{"title":"GitHub万赞，程序员必看操作系统总结！","url":"https://tanqingbo.cn/GitHub万赞，程序员必看操作系统总结！/","content":"今天给大家推荐一本程序员必看操作系统的书，可以先看一下目录。\n\n内容涉及\n\n认识操作系统\n进程和线程\n内存管理\n文件管理\nI/O\n死锁\n操作系统面试题\n操作系统核心概念\n\n书籍不是扫描版的，里面的文字都可以直接复制，非常便于我们学习。\n\n可以看到图非常清晰，而且排版样式非常好\n\n还为你汇总了操作系统面试题\n\n还有所有操作系统名词汇总\n\n这本书一共是 306 页，17w 字，我想这应该是全网最经典的**一份**操作系统书籍了吧，现在把这本书免费分享给大家，戳下面的链接可以下载：\n链接：https://pan.baidu.com/s/1_vbUzGx0GGGLFzx84ryaUQ \n提取码：qt7p \n其他电子书下载\nJava电子书_文档教程_高清PDF下载\nPython电子书_文档教程_高清PDF下载\nC/C++电子书_文档教程_高清PDF下载\nLinux电子书_Linux书籍_高清PDF下载\n数据结构与算法相关书籍_PDF电子版下载\n计算机基础_操作系统_汇编语言_计算机网络-电子书PDF下载\n机器学习，人工智能经典必读电子书（PDF）下载\n设计模式经典图书电子书下载\nMYSQL、MongoDB数据库经典电子书下载\nGo语言经典电子书pdf下载\n程序员面试相关经典书籍免费下载\n\n","categories":["编程资料"],"tags":["操作系统"]},{"title":"Java岗，肯定有用！","url":"https://tanqingbo.cn/《Java高并发编程详解》，去大厂必看！/","content":"Java岗，肯定有用！作为一个程序员应该知道，Java常年占据编程语言的排行版第一，而且在web开发、移动互联网开发以及大数据开发三大领域常年占据霸主地位，而且由于Java的稳定性，很多大型科技公司都愿意采用Java解决方案，这就意味着每个互联网都会设置大量的Java岗，竞争压力相对较小。\n而且Java开发岗对于开发者的要求相对于C语言要低一些，毕竟Java的很多模块都封装的很好。所以如果你是一个小白或者是准备转行学计算机的话，可以考虑一下Java开发这个方向。\n另外，这里给大家推荐一本书《Java高并发编程详解》，多线程高并发问题，这是每个Java岗都会问的问题，面试官必问系列，关于这个问题，这本书里面该讲的都讲清楚了，评价很不错，给大家看一下简介和目录：\n\n\n所以大家如果想找Java相关岗位的工作的话，建议可以看一下，我也给大家准备好了高清PDF下载地址，需要的朋友自行下载：\n链接：https://pan.baidu.com/s/1m-0UIzXRbx_IxgFlaOX0Og提取码：csl4\n其他电子书下载\nJava电子书_文档教程_高清PDF下载\nPython电子书_文档教程_高清PDF下载\nC/C++电子书_文档教程_高清PDF下载\nLinux电子书_Linux书籍_高清PDF下载\n数据结构与算法相关书籍_PDF电子版下载\n计算机基础_操作系统_汇编语言_计算机网络-电子书PDF下载\n机器学习，人工智能经典必读电子书（PDF）下载\n设计模式经典图书电子书下载\nMYSQL、MongoDB数据库经典电子书下载\nGo语言经典电子书pdf下载\n程序员面试相关经典书籍免费下载\n\n","categories":["编程资料"],"tags":["Java","多线程"]},{"title":"批量规范化：加速深度网络培训减少内部协变量偏移","url":"https://tanqingbo.cn/Batch-Normalization/","content":"1、摘要\n训练深度神经网络很复杂，因为随着前一层的参数变化，每层输入的分布在训练期间发生变化。这通过要求较低的学习速率和仔细的参数初始化来减慢训练，并且使得训练具有饱和非线性的模型变得非常困难。我们将这种现象称为内部协变量偏移，并通过归一化层输入来解决问题。\n优势在于使标准化成为模型体系结构的一部分，并为每个训练小批量执行标准化。批量标准化允许我们使用更高的学习率并且不太关心初始化。应用于最先进的图像分类模型，批量标准化实现了相同的精度，培训步骤减少了14倍，并且大大超过了原始模型。\n\n2、介绍\n使用小批量的示例，而不是一次一个示例，在几个方面是有帮助的。 首先，小批量损失的梯度是对训练集的梯度的估计，其质量随批量增加而改善。 其次，由于现代计算平台提供的并行性，批量计算可以比单个示例的m计算更有效。 虽然随机梯度简单有效，但需要仔细调整模型超参数，特别是优化中使用的学习率，以及模型参数的初始值。 由于每层的输入受到所有前面层的参数的影响，因此训练变得复杂。 因此，随着网络变得更深，网络参数的微小变化会放大。\n\n考虑到每一层使用sigmoid激活函数g(x),当|x|增加时，g`趋近于零，也就是说早训练过程中除了绝对值小的x，训练会减慢，梯度会减缓或者消失。\n\n在训练期间对这些参数的改变可能将x的多维度移动到非线性的饱和状态并且减慢收敛。 随着网络深度的增加，这种效应会被放大。在实践中，饱和问题和由此产生的消失梯度通常通过使用整流线性单元（ReLU）来解决，也就是激活函数采用ReLU.\n\n如果我们能够确保非线性输入的分布在网络训练时保持更稳定，那么优化器将不太可能陷入饱和状态，并且训练将加速。\n\n我们将在训练过程中深度网络内部节点分布的变化称为内部协变量偏移。为了消除它并且提供更快的训练。我们提出了一种新的机制，我们称之为批量归一化。\n\n它在减少内部协变量偏移方面迈出了一步，并且这样做大大加速了深度神经网络的训练。它通过标准化步骤来实现这一点，该步骤修复了层输入的均值和方差。\n\n批量标准化的优点：\n\n批量标准化还通过降低梯度对参数或其初始值的比例的依赖性，对通过网络的梯度流有益。这使我们可以使用更高的学习率而不会出现分歧的风险。\n批量标准化使模型正规化并减少了对Dropout的需求。最后，批量标准化可以通过防止网络陷入饱和模式。\n\n\n\n3、减少内部协变量偏移\n我们将内部协变量偏移定义为由于训练期间网络参数的变化导致的网络激活分布的变化。 为了改善训练，我们寻求减少内部协变量的变化。\n众所周知，线性变换为具有零均值和单位方差，并且去相关，则网络训练收敛得更快（whitened）。 由于每层观察由下面的层产生的输入，因此实现每层的输入的相同whitening将是有利的。 通过增加每层的输入，我们将朝着实现固定的输入分布迈出一步，这将消除内部协变量偏移的不良影响。\n\n码字不易，求分享、转发。😄\n推荐阅读\n机器学习，人工智能经典必读电子书（PDF）下载\n计算机专业电子书下载\nJava电子书_文档教程_高清PDF下载\nPython电子书_文档教程_高清PDF下载\nC/C++电子书_文档教程_高清PDF下载\nLinux电子书_Linux书籍_高清PDF下载\n数据结构与算法相关书籍_PDF电子版下载\n计算机基础_操作系统_汇编语言_计算机网络-电子书PDF下载\n\n","categories":["图像处理与机器学习"],"tags":[]},{"title":"推荐两本经典的算法书，入门以及找工作必备！","url":"https://tanqingbo.cn/推荐两本经典算法书/","content":"记得我上本科的时候，我们老师一直跟我们强调：“算法才是编程的灵魂，一定要把算法学好。”因为不管你是Java编程爱好者、还是python的忠实粉丝，亦或觉得PHP才是这个世界最好的编程语言，都跨不过算法这个门槛。甚至可以说，懂算法的程序员才是一个合格的程序员，大部分互联网企业笔试环节必考算法，面试的时候也会让你手写算法，所以给大家推荐两本书，帮大家搞定算法这个难题。一本适合新手入门，一本适合找工作进阶。\n1、《我的第一本算法书》这本书是京都大学一个计算机教授和朋友联合出品的动画讲解算法的App 所衍生出来的书籍，非常适合新手朋友们。里面有枯燥的理论和复杂的公式，而是通过大量的步骤图帮助读者加深对数据结构原理和算法执行过程的理解，便于学习和记忆。将本书作为算法入门的第一步，是非常不错的选择。\n\n下载地址：\n链接：https://pan.baidu.com/s/1r_lxqzfg7YTHvAEQhNJwnQ提取码：en9j\n2、《剑指offer》这本书大家一定如雷贯耳吧，基本上只要你是程序员就一定会用到这本书，书里面剖析了50个典型的程序员面试题，从基础知识、代码质量、解题思路、优化效率和综合能力五个方面系统整理了影响面试的5个要点。\n\n下载地址：\n链接：https://pan.baidu.com/s/1GD9yTglFZkn5n__965dKjA提取码：mas8\n其他电子书下载\nJava电子书_文档教程_高清PDF下载\nPython电子书_文档教程_高清PDF下载\nC/C++电子书_文档教程_高清PDF下载\nLinux电子书_Linux书籍_高清PDF下载\n数据结构与算法相关书籍_PDF电子版下载\n计算机基础_操作系统_汇编语言_计算机网络-电子书PDF下载\n机器学习，人工智能经典必读电子书（PDF）下载\n设计模式经典图书电子书下载\nMYSQL、MongoDB数据库经典电子书下载\nGo语言经典电子书pdf下载\n程序员面试相关经典书籍免费下载\n\n","categories":["编程资料"],"tags":["算法","数据结构"]},{"title":"百度搜索技巧","url":"https://tanqingbo.cn/baidu-search/","content":"为什么程序员大佬用百度搜出来的都是精准答案，而你搜出来的却是广告？\n教你几个搜索小技巧，帮你快速找到想要的信息：\n1、关键词后输入（空格）+确定词\n搜索结果里必然包含确定词\n2、给关键词带上引号，\n帮你屏蔽广告，搜索结果中只出现包含关键词内容。\n3、关键词前加site: 网址  \n可以单独查询某个网站里面的内容\n4、关键词前加intitle：\n文章的标题中必然出现关键词\n5、关键词后加filetype:文档格式\n精准搜索某一格式的文档。\n你学会了吗？\n","categories":["工具"],"tags":["网站","工具"]}]